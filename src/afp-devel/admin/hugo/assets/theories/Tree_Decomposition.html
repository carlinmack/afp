<div id="Graph">
<div class="head">
<h1>Theory Graph</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Graphs›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Graph
<span class="keyword2"><span class="keyword">imports</span></span> <a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL/Main.html">Main</a> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is the vertex type.›</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'a</span> Edge <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span>"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'a</span> Walk <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list"</span></span>

<span class="keyword1"><span class="command">record</span></span> <span class="tfree">'a</span> Graph <span class="main">=</span>
  verts <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">V</span>ı"</span><span class="main">)</span>
  arcs <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> Edge set"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">E</span>ı"</span><span class="main">)</span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">is_arc</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> Graph_scheme <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">→</span>ı"</span> 60<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main"><span class="free">→</span></span><span class="hidden">⇘</span><sub><span class="free"><span class="bound"><span class="entity">G</span></span></span></sub><span class="hidden">⇙</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">w</span></span></span><span class="main">)</span> <span class="main">∈</span> <span class="keyword1">E</span><span class="hidden">⇘</span><sub><span class="free"><span class="bound"><span class="entity">G</span></span></span></sub><span class="hidden">⇙</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We only consider undirected finite simple graphs, that is, graphs without multi-edges and without
  loops.
›</span></span>
<span class="keyword1"><span class="command">locale</span></span> Graph <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> Graph_scheme"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">structure</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> finite_vertex_set<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="keyword1">V</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> valid_edge_set<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">E</span> <span class="main">⊆</span> <span class="keyword1">V</span> <span class="main">×</span> <span class="keyword1">V</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> undirected<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">→</span><span class="free">w</span> <span class="main">=</span> <span class="free">w</span><span class="main">→</span><span class="free">v</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> no_loops<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="free">v</span><span class="main">→</span><span class="free">v</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1" id="Graph-finite_edge_set"><span class="command">lemma</span></span> finite_edge_set <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="keyword1">E</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> finite_vertex_set valid_edge_set
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finite_subset<span class="main">)</span>
<span class="keyword1" id="Graph-edges_are_in_V"><span class="command">lemma</span></span> edges_are_in_V<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">→</span><span class="free">w</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms valid_edge_set <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Walks›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A walk is sequence of vertices connected by edges.›</span></span>
<span class="keyword1"><span class="command">inductive</span></span> <span class="entity">walk</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> Walk <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
Nil <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">walk</span> <span class="main">[]</span>"</span></span>
<span class="main">|</span> Singleton <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">∈</span> <span class="keyword1">V</span> <span class="main">⟹</span> <span class="free">walk</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">]</span>"</span></span>
<span class="main">|</span> Cons<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">→</span><span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">⟹</span> <span class="free">walk</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span> <span class="main">⟹</span> <span class="free">walk</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Show a few composition/decomposition lemmas for walks.  These will greatly simplify the proofs
  that follow.›</span></span>
<span class="keyword1" id="Graph-walk_2"><span class="command">lemma</span></span> walk_2 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">→</span><span class="free">w</span> <span class="main">⟹</span> walk <span class="main">[</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> edges_are_in_V<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> walk.intros<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1" id="Graph-walk_comp"><span class="command">lemma</span></span> walk_comp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> walk <span class="free">xs</span><span class="main">;</span> walk <span class="free">ys</span><span class="main">;</span> <span class="free">xs</span> <span class="main">=</span> Nil <span class="main">∨</span> <span class="free">ys</span> <span class="main">=</span> Nil <span class="main">∨</span> last <span class="free">xs</span><span class="main">→</span>hd <span class="free">ys</span> <span class="main">⟧</span> <span class="main">⟹</span> walk <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> walk.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> walk.intros<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">metis</span> list.exhaust_sel walk.intros<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> walk.intros<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1" id="Graph-walk_tl"><span class="command">lemma</span></span> walk_tl<span class="main">:</span> <span class="quoted"><span class="quoted">"walk <span class="free">xs</span> <span class="main">⟹</span> walk <span class="main">(</span>tl <span class="free">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> walk.induct<span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1" id="Graph-walk_drop"><span class="command">lemma</span></span> walk_drop<span class="main">:</span> <span class="quoted"><span class="quoted">"walk <span class="free">xs</span> <span class="main">⟹</span> walk <span class="main">(</span>drop <span class="free">n</span> <span class="free">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> drop_Suc tl_drop walk_tl<span class="main">)</span>
<span class="keyword1" id="Graph-walk_take"><span class="command">lemma</span></span> walk_take<span class="main">:</span> <span class="quoted"><span class="quoted">"walk <span class="free">xs</span> <span class="main">⟹</span> walk <span class="main">(</span>take <span class="free">n</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> walk.induct<span class="main">)</span>
     <span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">metis</span> Graph.walk.simps Graph_axioms take_Cons' take_eq_Nil<span class="main"><span class="keyword3">,</span></span>
      <span class="operator">metis</span> Graph.walk.simps Graph_axioms edges_are_in_V<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> take_Cons'<span class="main">)</span>
<span class="keyword1" id="Graph-walk_rev"><span class="command">lemma</span></span> walk_rev<span class="main">:</span> <span class="quoted"><span class="quoted">"walk <span class="free">xs</span> <span class="main">⟹</span> walk <span class="main">(</span>rev <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> walk.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
     <span class="main">(</span><span class="operator">metis</span> Singleton edges_are_in_V<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> last_ConsL last_appendR list.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span>
      not_Cons_self2 rev.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> undirected walk_comp<span class="main">)</span>
<span class="keyword1" id="Graph-walk_decomp"><span class="command">lemma</span></span> walk_decomp<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"walk <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"walk <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"walk <span class="free">ys</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms append_eq_conv_conj<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span>"</span></span><span class="main">]</span> walk_take walk_drop <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1" id="Graph-walk_dropWhile"><span class="command">lemma</span></span> walk_dropWhile<span class="main">:</span> <span class="quoted"><span class="quoted">"walk <span class="free">xs</span> <span class="main">⟹</span> walk <span class="main">(</span>dropWhile <span class="free">f</span> <span class="free">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> walk_drop dropWhile_eq_drop<span class="main">)</span>
<span class="keyword1" id="Graph-walk_takeWhile"><span class="command">lemma</span></span> walk_takeWhile<span class="main">:</span> <span class="quoted"><span class="quoted">"walk <span class="free">xs</span> <span class="main">⟹</span> walk <span class="main">(</span>takeWhile <span class="free">f</span> <span class="free">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> walk_take takeWhile_eq_take <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>

<span class="keyword1" id="Graph-walk_in_V"><span class="command">lemma</span></span> walk_in_V<span class="main">:</span> <span class="quoted"><span class="quoted">"walk <span class="free">xs</span> <span class="main">⟹</span> set <span class="free">xs</span> <span class="main">⊆</span> <span class="keyword1">V</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> walk.induct<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> edges_are_in_V<span class="main">)</span>

<span class="keyword1" id="Graph-walk_first_edge"><span class="command">lemma</span></span> walk_first_edge<span class="main">:</span> <span class="quoted"><span class="quoted">"walk <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="free">w</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">v</span><span class="main">→</span><span class="free">w</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> walk.cases <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
<span class="keyword1" id="Graph-walk_first_edge'"><span class="command">lemma</span></span> walk_first_edge'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> walk <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span><span class="main">;</span> <span class="free">xs</span> <span class="main">≠</span> Nil <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">v</span><span class="main">→</span>hd <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> walk_first_edge <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> list.exhaust_sel<span class="main">)</span>
<span class="keyword1" id="Graph-walk_middle_edge"><span class="command">lemma</span></span> walk_middle_edge<span class="main">:</span> <span class="quoted"><span class="quoted">"walk <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">v</span> <span class="main">#</span> <span class="free">w</span> <span class="main">#</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">v</span><span class="main">→</span><span class="free">w</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">@</span> <span class="free">v</span> <span class="main">#</span> <span class="free">w</span> <span class="main">#</span> <span class="free">ys</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> walk.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
     <span class="main">(</span><span class="operator">metis</span> list.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>3<span class="main"><span class="main">)</span></span> self_append_conv2 tl_append2<span class="main">)</span>
<span class="keyword1" id="Graph-walk_last_edge"><span class="command">lemma</span></span> walk_last_edge<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> walk <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span><span class="main">;</span> <span class="free">xs</span> <span class="main">≠</span> Nil<span class="main">;</span> <span class="free">ys</span> <span class="main">≠</span> Nil <span class="main">⟧</span> <span class="main">⟹</span> last <span class="free">xs</span><span class="main">→</span>hd <span class="free">ys</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> walk_middle_edge<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"butlast <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"last <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"hd <span class="free">ys</span>"</span></span> <span class="quoted"><span class="quoted">"tl <span class="free">ys</span>"</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Cons_eq_appendI append_butlast_last_id append_eq_append_conv2 list.exhaust_sel self_append_conv<span class="main">)</span>

<span class="keyword1" id="Graph-walk_takeWhile_edge"><span class="command">lemma</span></span> walk_takeWhile_edge<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"walk <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">v</span><span class="main">]</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> Nil"</span></span> <span class="quoted"><span class="quoted">"hd <span class="free">xs</span> <span class="main">≠</span> <span class="free">v</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"last <span class="main">(</span>takeWhile <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≠</span> <span class="free">v</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span><span class="main">→</span><span class="free">v</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"last <span class="var">?xs</span><span class="main">→</span><span class="free">v</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xs'</span></span> <span class="keyword2"><span class="keyword">where</span></span> xs'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="var">?xs</span> <span class="main">@</span> <span class="skolem">xs'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> takeWhile_dropWhile_id<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span><span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs'</span> <span class="main">=</span> Nil"</span></span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> xs' assms<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span> walk_last_edge <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs'</span> <span class="main">≠</span> Nil"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"hd <span class="skolem">xs'</span> <span class="main">=</span> <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>full_types<span class="main"><span class="main">)</span></span> hd_dropWhile same_append_eq takeWhile_dropWhile_id xs'<span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="quoted"><span class="quoted">‹<span class="skolem">xs'</span> <span class="main">≠</span> <span class="main">[]</span>›</span></span> append_Nil assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>3<span class="main"><span class="main">)</span></span> walk_decomp<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> walk_last_edge xs'<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Connectivity›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">connected</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">→<span class="hidden">⇧</span><sup>*</sup></span>"</span> 60<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">connected</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">≡</span> <span class="main">∃</span><span class="bound">xs</span><span class="main">.</span> walk <span class="bound">xs</span> <span class="main">∧</span> <span class="bound">xs</span> <span class="main">≠</span> Nil <span class="main">∧</span> hd <span class="bound">xs</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">∧</span> last <span class="bound">xs</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span>"</span></span>
<span class="keyword1" id="Graph-connectedI"><span class="command">lemma</span></span> connectedI <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> walk <span class="free">xs</span><span class="main">;</span> <span class="free">xs</span> <span class="main">≠</span> Nil<span class="main">;</span> hd <span class="free">xs</span> <span class="main">=</span> <span class="free">v</span><span class="main">;</span> last <span class="free">xs</span> <span class="main">=</span> <span class="free">w</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">v</span> <span class="main">→<span class="hidden">⇧</span><sup>*</sup></span> <span class="free">w</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> connected_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1" id="Graph-connectedE"><span class="command">lemma</span></span> connectedE<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">→<span class="hidden">⇧</span><sup>*</sup></span> <span class="free">w</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">xs</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"walk <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> Nil"</span></span> <span class="quoted"><span class="quoted">"hd <span class="free">xs</span> <span class="main">=</span> <span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"last <span class="free">xs</span> <span class="main">=</span> <span class="free">w</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms that <span class="keyword1"><span class="command">unfolding</span></span> connected_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="Graph-connected_in_V"><span class="command">lemma</span></span> connected_in_V<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">→<span class="hidden">⇧</span><sup>*</sup></span> <span class="free">w</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> connected_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> hd_in_set last_in_set subsetCE walk_in_V<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1" id="Graph-connected_refl"><span class="command">lemma</span></span> connected_refl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="keyword1">V</span> <span class="main">⟹</span> <span class="free">v</span> <span class="main">→<span class="hidden">⇧</span><sup>*</sup></span> <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> connectedI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">[</span></span></span><span class="free"><span class="free"><span class="free">v</span></span></span><span class="main"><span class="main"><span class="main">]</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1" id="Graph-connected_edge"><span class="command">lemma</span></span> connected_edge<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">→</span><span class="free">w</span> <span class="main">⟹</span> <span class="free">v</span> <span class="main">→<span class="hidden">⇧</span><sup>*</sup></span> <span class="free">w</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> connectedI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">[</span></span></span><span class="free"><span class="free"><span class="free">v</span></span></span><span class="main"><span class="main"><span class="main">,</span></span></span><span class="free"><span class="free"><span class="free">w</span></span></span><span class="main"><span class="main"><span class="main">]</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1" id="Graph-connected_trans"><span class="command">lemma</span></span> connected_trans<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> u_v<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span> <span class="main">→<span class="hidden">⇧</span><sup>*</sup></span> <span class="free">v</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> v_w<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">→<span class="hidden">⇧</span><sup>*</sup></span> <span class="free">w</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span> <span class="main">→<span class="hidden">⇧</span><sup>*</sup></span> <span class="free">w</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xs</span></span> <span class="keyword2"><span class="keyword">where</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"walk <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">≠</span> Nil"</span></span> <span class="quoted"><span class="quoted">"hd <span class="skolem">xs</span> <span class="main">=</span> <span class="free">u</span>"</span></span> <span class="quoted"><span class="quoted">"last <span class="skolem">xs</span> <span class="main">=</span> <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> u_v connectedE <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">ys</span></span> <span class="keyword2"><span class="keyword">where</span></span> ys<span class="main">:</span> <span class="quoted"><span class="quoted">"walk <span class="skolem">ys</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ys</span> <span class="main">≠</span> Nil"</span></span> <span class="quoted"><span class="quoted">"hd <span class="skolem">ys</span> <span class="main">=</span> <span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"last <span class="skolem">ys</span> <span class="main">=</span> <span class="free">w</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> v_w connectedE <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?R</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">@</span> tl <span class="skolem">ys</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"walk <span class="var">?R</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> walk_comp<span class="main">[</span><span class="operator">OF</span> xs<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> xs<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span> ys<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>2<span class="main"><span class="main">,</span></span>3<span class="main"><span class="main">)</span></span> list.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>3<span class="main"><span class="main">)</span></span> walk.simps<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?R</span> <span class="main">≠</span> Nil"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> xs<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"hd <span class="var">?R</span> <span class="main">=</span> <span class="free">u</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> xs<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">,</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"last <span class="var">?R</span> <span class="main">=</span> <span class="free">w</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> xs<span class="main">(</span>2<span class="main">,</span>4<span class="main">)</span> ys<span class="main">(</span>2<span class="main">,</span>3<span class="main">,</span>4<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> append_butlast_last_id last_append last_tl list.exhaust_sel<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Paths›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A path is a walk without repeated vertices.  This is simple enough, so most of the above
  lemmas transfer directly to paths.›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">path</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> Walk <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">path</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≡</span> walk <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">∧</span> distinct <span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>

<span class="keyword1" id="Graph-path_singleton"><span class="command">lemma</span></span> path_singleton <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="keyword1">V</span> <span class="main">⟹</span> path <span class="main">[</span><span class="free">v</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1" id="Graph-path_2"><span class="command">lemma</span></span> path_2 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">v</span><span class="main">→</span><span class="free">w</span><span class="main">;</span> <span class="free">v</span> <span class="main">≠</span> <span class="free">w</span> <span class="main">⟧</span> <span class="main">⟹</span> path <span class="main">[</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1" id="Graph-path_cons"><span class="command">lemma</span></span> path_cons<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> path <span class="free">xs</span><span class="main">;</span> <span class="free">xs</span> <span class="main">≠</span> Nil<span class="main">;</span> <span class="free">v</span><span class="main">→</span>hd <span class="free">xs</span><span class="main">;</span> <span class="free">v</span> <span class="main">∉</span> set <span class="free">xs</span> <span class="main">⟧</span> <span class="main">⟹</span> path <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> distinct.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> list.exhaust_sel walk.Cons<span class="main">)</span>
<span class="keyword1" id="Graph-path_comp"><span class="command">lemma</span></span> path_comp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> walk <span class="free">xs</span><span class="main">;</span> walk <span class="free">ys</span><span class="main">;</span> <span class="free">xs</span> <span class="main">=</span> Nil <span class="main">∨</span> <span class="free">ys</span> <span class="main">=</span> Nil <span class="main">∨</span> last <span class="free">xs</span><span class="main">→</span>hd <span class="free">ys</span><span class="main">;</span> distinct <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟧</span>
  <span class="main">⟹</span> path <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> walk_comp <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1" id="Graph-path_tl"><span class="command">lemma</span></span> path_tl<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="free">xs</span> <span class="main">⟹</span> path <span class="main">(</span>tl <span class="free">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> distinct_tl walk_tl<span class="main">)</span>
<span class="keyword1" id="Graph-path_drop"><span class="command">lemma</span></span> path_drop<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="free">xs</span> <span class="main">⟹</span> path <span class="main">(</span>drop <span class="free">n</span> <span class="free">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> walk_drop<span class="main">)</span>
<span class="keyword1" id="Graph-path_take"><span class="command">lemma</span></span> path_take<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="free">xs</span> <span class="main">⟹</span> path <span class="main">(</span>take <span class="free">n</span> <span class="free">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> walk_take<span class="main">)</span>
<span class="keyword1" id="Graph-path_rev"><span class="command">lemma</span></span> path_rev<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="free">xs</span> <span class="main">⟹</span> path <span class="main">(</span>rev <span class="free">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> walk_rev<span class="main">)</span>
<span class="keyword1" id="Graph-path_decomp"><span class="command">lemma</span></span> path_decomp<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"path <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"path <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"path <span class="free">ys</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> walk_decomp assms distinct_append <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1" id="Graph-path_dropWhile"><span class="command">lemma</span></span> path_dropWhile<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="free">xs</span> <span class="main">⟹</span> path <span class="main">(</span>dropWhile <span class="free">f</span> <span class="free">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> walk_dropWhile<span class="main">)</span>
<span class="keyword1" id="Graph-path_takeWhile"><span class="command">lemma</span></span> path_takeWhile<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="free">xs</span> <span class="main">⟹</span> path <span class="main">(</span>takeWhile <span class="free">f</span> <span class="free">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> walk_takeWhile<span class="main">)</span>
<span class="keyword1" id="Graph-path_in_V"><span class="command">lemma</span></span> path_in_V<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="free">xs</span> <span class="main">⟹</span> set <span class="free">xs</span> <span class="main">⊆</span> <span class="keyword1">V</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> walk_in_V<span class="main">)</span>
<span class="keyword1" id="Graph-path_first_edge"><span class="command">lemma</span></span> path_first_edge<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="free">w</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">v</span><span class="main">→</span><span class="free">w</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> walk_first_edge <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1" id="Graph-path_first_edge'"><span class="command">lemma</span></span> path_first_edge'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> path <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span><span class="main">;</span> <span class="free">xs</span> <span class="main">≠</span> Nil <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">v</span><span class="main">→</span>hd <span class="free">xs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> walk_first_edge' <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1" id="Graph-path_middle_edge"><span class="command">lemma</span></span> path_middle_edge<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">v</span> <span class="main">#</span> <span class="free">w</span> <span class="main">#</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">v</span> <span class="main">→</span> <span class="free">w</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> walk_middle_edge <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1" id="Graph-path_takeWhile_edge"><span class="command">lemma</span></span> path_takeWhile_edge<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> path <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">v</span><span class="main">]</span><span class="main">)</span><span class="main">;</span> <span class="free">xs</span> <span class="main">≠</span> Nil<span class="main">;</span> hd <span class="free">xs</span> <span class="main">≠</span> <span class="free">v</span> <span class="main">⟧</span>
  <span class="main">⟹</span> last <span class="main">(</span>takeWhile <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≠</span> <span class="free">v</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span><span class="main">→</span><span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> walk_takeWhile_edge <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We introduce shorthand notation for a path connecting two vertices.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">path_from_to</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> Graph_scheme <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> Walk <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span>
  <span class="main">(</span><span class="quoted">"_ <span class="keyword1">↝</span>_<span class="keyword1">↝</span>ı _"</span> <span class="main">[</span>71<span class="main">,</span> 71<span class="main">,</span> 71<span class="main">]</span> 70<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">path_from_to</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">≡</span> Graph.path <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≠</span> Nil <span class="main">∧</span> hd <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">∧</span> last <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span>"</span></span>
<span class="keyword1"><span class="command">context</span></span> Graph <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1" id="Graph-path_from_toI"><span class="command">lemma</span></span> path_from_toI <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> path <span class="free">xs</span><span class="main">;</span> <span class="free">xs</span> <span class="main">≠</span> Nil<span class="main">;</span> hd <span class="free">xs</span> <span class="main">=</span> <span class="free">v</span><span class="main">;</span> last <span class="free">xs</span> <span class="main">=</span> <span class="free">w</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">v</span> <span class="main">↝</span><span class="free">xs</span><span class="main">↝</span> <span class="free">w</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> path_from_toE <span class="main">[</span><span class="operator">dest</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">↝</span><span class="free">xs</span><span class="main">↝</span> <span class="free">w</span> <span class="main">⟹</span> path <span class="free">xs</span> <span class="main">∧</span> <span class="free">xs</span> <span class="main">≠</span> Nil <span class="main">∧</span> hd <span class="free">xs</span> <span class="main">=</span> <span class="free">v</span> <span class="main">∧</span> last <span class="free">xs</span> <span class="main">=</span> <span class="free">w</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> path_from_to_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Every walk contains a path connecting the same vertices.›</span></span>
<span class="keyword1" id="Graph-walk_to_path"><span class="command">lemma</span></span> walk_to_path<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"walk <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> Nil"</span></span> <span class="quoted"><span class="quoted">"hd <span class="free">xs</span> <span class="main">=</span> <span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"last <span class="free">xs</span> <span class="main">=</span> <span class="free">w</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">ys</span><span class="main">.</span> <span class="free">v</span> <span class="main">↝</span><span class="bound">ys</span><span class="main">↝</span> <span class="free">w</span> <span class="main">∧</span> set <span class="bound">ys</span> <span class="main">⊆</span> set <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We prove this by removing loops from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">xs</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> until <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">xs</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is a path.
    We want to perform induction over <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"length <span class="free"><span class="free">xs</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, but <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">xs</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in
    <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"set <span class="free"><span class="free">ys</span></span> <span class="main"><span class="main">⊆</span></span> set <span class="free"><span class="free">xs</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> should not be part of the induction hypothesis. To accomplish this,
    we hide <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"set <span class="free"><span class="free">xs</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> behind a definition for this specific part of the goal.›</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">target_set</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">target_set</span> <span class="main">=</span> set <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"set <span class="free">xs</span> <span class="main">⊆</span> <span class="skolem">target_set</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">ys</span><span class="main">.</span> <span class="free">v</span> <span class="main">↝</span><span class="bound">ys</span><span class="main">↝</span> <span class="free">w</span> <span class="main">∧</span> set <span class="bound">ys</span> <span class="main">⊆</span> <span class="skolem">target_set</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"length <span class="free">xs</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> infinite_descent0<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>smaller <span class="skolem">n</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xs</span></span> <span class="keyword2"><span class="keyword">where</span></span>
      xs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">=</span> length <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="quoted">"walk <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">≠</span> Nil"</span></span> <span class="quoted"><span class="quoted">"hd <span class="skolem">xs</span> <span class="main">=</span> <span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"last <span class="skolem">xs</span> <span class="main">=</span> <span class="free">w</span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">xs</span> <span class="main">⊆</span> <span class="skolem">target_set</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
      hyp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="main">(</span><span class="main">∃</span><span class="bound">ys</span><span class="main">.</span> <span class="free">v</span> <span class="main">↝</span><span class="bound">ys</span><span class="main">↝</span> <span class="free">w</span> <span class="main">∧</span> set <span class="bound">ys</span> <span class="main">⊆</span> <span class="skolem">target_set</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹If <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">xs</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is not a path, then <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">xs</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is not distinct and we can decompose it.›</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">ys</span></span> <span class="skolem"><span class="skolem">zs</span></span> <span class="skolem"><span class="skolem">u</span></span>
      <span class="keyword2"><span class="keyword">where</span></span> xs_decomp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> set <span class="skolem">ys</span>"</span></span> <span class="quoted"><span class="quoted">"distinct <span class="skolem">ys</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="skolem">u</span> <span class="main">#</span> <span class="skolem">zs</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> not_distinct_conv_prefix <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> path_from_toI<span class="main">)</span>
    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">u</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> appears in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">xs</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, so we have a loop in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">xs</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> starting from an
      occurrence of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">u</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">xs</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> ending in the vertex <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">u</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="skolem"><span class="skolem">u</span></span> <span class="main"><span class="main">#</span></span> <span class="skolem"><span class="skolem">ys</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
      We define <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">zs</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> as <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">xs</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> without this loop.›</span></span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">ys'</span></span> <span class="skolem"><span class="skolem">ys_suffix</span></span> <span class="keyword2"><span class="keyword">where</span></span>
      ys_decomp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">ys</span> <span class="main">=</span> <span class="skolem">ys'</span> <span class="main">@</span> <span class="skolem">u</span> <span class="main">#</span> <span class="skolem">ys_suffix</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> split_list xs_decomp<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">zs'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">zs'</span> <span class="main">=</span> <span class="skolem">ys'</span> <span class="main">@</span> <span class="skolem">u</span> <span class="main">#</span> <span class="skolem">zs</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"walk <span class="skolem">zs'</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> zs'_def <span class="keyword1"><span class="command">using</span></span> xs<span class="main">(</span>2<span class="main">)</span> xs_decomp<span class="main">(</span>3<span class="main">)</span> ys_decomp
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> walk_decomp list.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> list.simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> walk_comp walk_last_edge<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="skolem">zs'</span> <span class="main">&lt;</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> zs'_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> xs<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> xs_decomp<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> ys_decomp<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"hd <span class="skolem">zs'</span> <span class="main">=</span> <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> zs'_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> append_is_Nil_conv hd_append list.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> xs<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span> xs_decomp<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> ys_decomp<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"last <span class="skolem">zs'</span> <span class="main">=</span> <span class="free">w</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> zs'_def <span class="keyword1"><span class="command">using</span></span> xs<span class="main">(</span>5<span class="main">)</span> xs_decomp<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">zs'</span> <span class="main">⊆</span> <span class="skolem">target_set</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> zs'_def <span class="keyword1"><span class="command">using</span></span> xs<span class="main">(</span>6<span class="main">)</span> xs_decomp<span class="main">(</span>3<span class="main">)</span> ys_decomp <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> zs'_def hyp <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">corollary</span></span> connected_by_path<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">→<span class="hidden">⇧</span><sup>*</sup></span> <span class="free">w</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">xs</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">↝</span><span class="free">xs</span><span class="main">↝</span> <span class="free">w</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms connected_def walk_to_path <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Cycles›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A cycle in an undirected graph is a closed path with at least 3 different vertices.
  Closed paths with 0 or 1 vertex do not exist (graphs are loop-free), and paths with 2 vertices
  are not considered loops in undirected graphs.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">cycle</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> Walk <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">cycle</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≡</span> path <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">∧</span> length <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">&gt;</span> <span class="numeral">2</span> <span class="main">∧</span> last <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">→</span> hd <span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>

<span class="keyword1" id="Graph-cycleI"><span class="command">lemma</span></span> cycleI <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> path <span class="free">xs</span><span class="main">;</span> length <span class="free">xs</span> <span class="main">&gt;</span> <span class="numeral">2</span><span class="main">;</span> last <span class="free">xs</span><span class="main">→</span>hd <span class="free">xs</span> <span class="main">⟧</span> <span class="main">⟹</span> cycle <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> cycle_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1" id="Graph-cycleE"><span class="command">lemma</span></span> cycleE<span class="main">:</span> <span class="quoted"><span class="quoted">"cycle <span class="free">xs</span> <span class="main">⟹</span> path <span class="free">xs</span> <span class="main">∧</span> <span class="free">xs</span> <span class="main">≠</span> Nil <span class="main">∧</span> length <span class="free">xs</span> <span class="main">&gt;</span> <span class="numeral">2</span> <span class="main">∧</span> last <span class="free">xs</span><span class="main">→</span>hd <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> cycle_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We can now show a lemma that explains how to construct cycles from certain paths.
  If two paths both starting from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">v</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> diverge immediately and meet again on their
  last vertices, then the graph contains a cycle with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">v</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> on it.

  Note that if two paths do not diverge immediately but only eventually, then
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">prop</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">maximal_common_prefix</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> can be used to remove the common prefix.›</span></span>
<span class="keyword1" id="Graph-meeting_paths_produce_cycle"><span class="command">lemma</span></span> meeting_paths_produce_cycle<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> Nil"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> ys<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="free">ys</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">≠</span> Nil"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> meet<span class="main">:</span> <span class="quoted"><span class="quoted">"last <span class="free">xs</span> <span class="main">=</span> last <span class="free">ys</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> diverge<span class="main">:</span> <span class="quoted"><span class="quoted">"hd <span class="free">xs</span> <span class="main">≠</span> hd <span class="free">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">zs</span><span class="main">.</span> cycle <span class="bound">zs</span> <span class="main">∧</span> hd <span class="bound">zs</span> <span class="main">=</span> <span class="free">v</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="free">xs</span> <span class="main">∩</span> set <span class="free">ys</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> meet xs<span class="main">(</span>2<span class="main">)</span> ys<span class="main">(</span>2<span class="main">)</span> last_in_set <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xs'</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="skolem"><span class="skolem">xs''</span></span> <span class="keyword2"><span class="keyword">where</span></span> xs'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="skolem">xs'</span> <span class="main">@</span> <span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs''</span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">xs'</span> <span class="main">∩</span> set <span class="free">ys</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> set <span class="free">ys</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> split_list_first_prop<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> set <span class="free">ys</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> disjoint_iff_not_equal<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">ys'</span></span> <span class="skolem"><span class="skolem">ys''</span></span> <span class="keyword2"><span class="keyword">where</span></span> ys'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">=</span> <span class="skolem">ys'</span> <span class="main">@</span> <span class="skolem">x</span> <span class="main">#</span> <span class="skolem">ys''</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∉</span> set <span class="skolem">ys'</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> split_list_first_prop<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">ys</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?zs</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">#</span> <span class="skolem">xs'</span> <span class="main">@</span> <span class="skolem">x</span> <span class="main">#</span> <span class="main">(</span>rev <span class="skolem">ys'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"last <span class="var">?zs</span><span class="main">→</span>hd <span class="var">?zs</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> undirected walk_first_edge walk_first_edge' ys'<span class="main">(</span>1<span class="main">)</span> ys<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> last_rev<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path <span class="var">?zs</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"walk <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> rev <span class="skolem">ys'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span><span class="main">)</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ys'</span> <span class="main">=</span> Nil"</span></span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹last <span class="var">?zs</span><span class="main">→</span>hd <span class="var">?zs</span>›</span></span> edges_are_in_V<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ys'</span> <span class="main">≠</span> Nil"</span></span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">hence</span></span></span> <span class="quoted"><span class="quoted">"last <span class="skolem">ys'</span><span class="main">→</span><span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> walk_last_edge walk_tl ys'<span class="main">(</span>1<span class="main">)</span> ys<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"hd <span class="main">(</span>rev <span class="skolem">ys'</span><span class="main">)</span> <span class="main">=</span> last <span class="skolem">ys'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">ys'</span> <span class="main">≠</span> <span class="main">[]</span>›</span></span> hd_rev<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"walk <span class="main">(</span>rev <span class="skolem">ys'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> list.sel<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> walk_decomp<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> walk_rev walk_tl ys'<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> ys<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"walk <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> rev <span class="skolem">ys'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> path_cons undirected ys'<span class="main">(</span>1<span class="main">)</span> ys<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"walk <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="skolem">xs'</span> <span class="main">@</span> <span class="skolem">x</span> <span class="main">#</span> rev <span class="skolem">ys'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> xs'<span class="main">(</span>1<span class="main">)</span> xs<span class="main">(</span>1<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> append_Cons list.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> list.simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> walk_comp walk_decomp<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> walk_last_edge<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="skolem">xs'</span> <span class="main">@</span> <span class="skolem">x</span> <span class="main">#</span> rev <span class="skolem">ys'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> distinct_append distinct.simps<span class="main">(</span>2<span class="main">)</span> set_append
      <span class="keyword1"><span class="command">using</span></span> xs'<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span> xs<span class="main">(</span>1<span class="main">)</span> ys'<span class="main">(</span>1<span class="main">)</span> ys<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="var">?zs</span> <span class="main">≠</span> <span class="numeral">2</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> diverge xs'<span class="main">(</span>1<span class="main">)</span> ys'<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> cycleI<span class="main">[</span><span class="operator">of</span> <span class="var"><span class="quoted"><span class="var">?zs</span></span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A graph with unique paths between every pair of connected vertices has no cycles.›</span></span>
<span class="keyword1" id="Graph-unique_paths_implies_no_cycles"><span class="command">lemma</span></span> unique_paths_implies_no_cycles<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> unique_paths<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">v</span> <span class="bound">w</span><span class="main">.</span> <span class="bound">v</span> <span class="main">→<span class="hidden">⇧</span><sup>*</sup></span> <span class="bound">w</span> <span class="main">⟹</span> <span class="main">∃!</span><span class="bound">xs</span><span class="main">.</span> <span class="bound">v</span> <span class="main">↝</span><span class="bound">xs</span><span class="main">↝</span> <span class="bound">w</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span>cycle <span class="bound">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"cycle <span class="skolem">xs</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?v</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"hd <span class="skolem">xs</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?w</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"last <span class="skolem">xs</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?ys</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="var">?v</span><span class="main">,</span><span class="var">?w</span><span class="main">]</span>"</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">good</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">good</span> <span class="skolem">xs</span> <span class="main">⟷</span> <span class="var">?v</span> <span class="main">↝</span><span class="skolem">xs</span><span class="main">↝</span> <span class="var">?w</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">xs</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path <span class="var">?ys</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹cycle <span class="skolem">xs</span>›</span></span> cycle_def no_loops undirected <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">good</span> <span class="var">?ys</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> good_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> path_from_toI<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">good</span> <span class="skolem">xs</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> good_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> path_from_toI <span class="quoted"><span class="quoted">‹cycle <span class="skolem">xs</span>›</span></span> cycleE<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?ys</span> <span class="main">≠</span> <span class="skolem">xs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹cycle <span class="skolem">xs</span>›</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> One_nat_def Suc_1 cycleE length_Cons less_not_refl list.size<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="main">(</span><span class="main">∃!</span><span class="bound">xs</span><span class="main">.</span> <span class="skolem">good</span> <span class="bound">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"connected <span class="var">?v</span> <span class="var">?w</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹cycle <span class="skolem">xs</span>›</span></span> cycleE <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">unfolding</span></span> good_def <span class="keyword1"><span class="command">using</span></span> unique_paths <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  A graph without cycles (also called a forest) has a unique path between every pair of connected
  vertices.
›</span></span>
<span class="keyword1" id="Graph-no_cycles_implies_unique_paths"><span class="command">lemma</span></span> no_cycles_implies_unique_paths<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> no_cycles<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span>cycle <span class="bound">xs</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> connected<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">→<span class="hidden">⇧</span><sup>*</sup></span> <span class="free">w</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃!</span><span class="bound">xs</span><span class="main">.</span> <span class="free">v</span> <span class="main">↝</span><span class="bound">xs</span><span class="main">↝</span> <span class="free">w</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ex_ex1I<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">xs</span><span class="main">.</span> <span class="free">v</span> <span class="main">↝</span><span class="bound">xs</span><span class="main">↝</span> <span class="free">w</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> connected connected_by_path <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="skolem">ys</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">↝</span><span class="skolem">xs</span><span class="main">↝</span> <span class="free">w</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">↝</span><span class="skolem">ys</span><span class="main">↝</span> <span class="free">w</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> xs_valid<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">≠</span> Nil"</span></span> <span class="quoted"><span class="quoted">"hd <span class="skolem">xs</span> <span class="main">=</span> <span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"last <span class="skolem">xs</span> <span class="main">=</span> <span class="free">w</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> ys_valid<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="skolem">ys</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ys</span> <span class="main">≠</span> Nil"</span></span> <span class="quoted"><span class="quoted">"hd <span class="skolem">ys</span> <span class="main">=</span> <span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"last <span class="skolem">ys</span> <span class="main">=</span> <span class="free">w</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> <span class="skolem">ys</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">≠</span> <span class="skolem">ys</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">ps</span> <span class="bound">xs'</span> <span class="bound">ys'</span><span class="main">.</span> <span class="skolem">xs</span> <span class="main">=</span> <span class="bound">ps</span> <span class="main">@</span> <span class="bound">xs'</span> <span class="main">∧</span> <span class="skolem">ys</span> <span class="main">=</span> <span class="bound">ps</span> <span class="main">@</span> <span class="bound">ys'</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">xs'</span> <span class="main">=</span> Nil <span class="main">∨</span> <span class="bound">ys'</span> <span class="main">=</span> Nil <span class="main">∨</span> hd <span class="bound">xs'</span> <span class="main">≠</span> hd <span class="bound">ys'</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quoted"><span class="skolem">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> list_induct2'<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>
         <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> append_Cons append_Nil list.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">ps</span></span> <span class="skolem"><span class="skolem">xs'</span></span> <span class="skolem"><span class="skolem">ys'</span></span> <span class="keyword2"><span class="keyword">where</span></span>
      ps<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> <span class="skolem">ps</span> <span class="main">@</span> <span class="skolem">xs'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ys</span> <span class="main">=</span> <span class="skolem">ps</span> <span class="main">@</span> <span class="skolem">ys'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs'</span> <span class="main">=</span> Nil <span class="main">∨</span> <span class="skolem">ys'</span> <span class="main">=</span> Nil <span class="main">∨</span> hd <span class="skolem">xs'</span> <span class="main">≠</span> hd <span class="skolem">ys'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"last <span class="skolem">xs</span> <span class="main">∈</span> set <span class="skolem">ps</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs'</span> <span class="main">=</span> Nil"</span></span> <span class="keyword1"><span class="command">using</span></span> xs_valid<span class="main">(</span>2<span class="main">)</span> ps<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> that<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> xs_not_nil<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xs'</span> <span class="main">≠</span> Nil"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">xs</span> <span class="main">≠</span> <span class="skolem">ys</span>›</span></span> ys_valid<span class="main">(</span>1<span class="main">,</span>4<span class="main">)</span> ps<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span> xs_valid<span class="main">(</span>4<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"last <span class="skolem">ys</span> <span class="main">∈</span> set <span class="skolem">ps</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ys'</span> <span class="main">=</span> Nil"</span></span> <span class="keyword1"><span class="command">using</span></span> ys_valid<span class="main">(</span>2<span class="main">)</span> ps<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> that<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> ys_not_nil<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">ys'</span> <span class="main">≠</span> Nil"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">xs</span> <span class="main">≠</span> <span class="skolem">ys</span>›</span></span> xs_valid<span class="main">(</span>1<span class="main">,</span>4<span class="main">)</span> ps<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span> ys_valid<span class="main">(</span>4<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">zs</span><span class="main">.</span> cycle <span class="bound">zs</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?v</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"last <span class="skolem">ps</span>"</span></span>
      <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">ps</span> <span class="main">≠</span> Nil"</span></span> <span class="keyword1"><span class="command">using</span></span> xs_valid<span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span> ys_valid<span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span> ps<span class="main">(</span>1<span class="main">,</span>2<span class="main">,</span>3<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path <span class="main">(</span><span class="var">?v</span> <span class="main">#</span> <span class="skolem">xs'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> xs_valid<span class="main">(</span>1<span class="main">)</span> ps<span class="main">(</span>1<span class="main">)</span> * walk_decomp<span class="main">(</span>2<span class="main">)</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> append_Cons append_assoc append_butlast_last_id distinct_append self_append_conv2<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path <span class="main">(</span><span class="var">?v</span> <span class="main">#</span> <span class="skolem">ys'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> ys_valid<span class="main">(</span>1<span class="main">)</span> ps<span class="main">(</span>2<span class="main">)</span> * walk_decomp<span class="main">(</span>2<span class="main">)</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> append_Cons append_assoc append_butlast_last_id distinct_append self_append_conv2<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"last <span class="skolem">xs'</span> <span class="main">=</span> last <span class="skolem">ys'</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> xs_valid<span class="main">(</span>4<span class="main">)</span> ys_valid<span class="main">(</span>4<span class="main">)</span> xs_not_nil ys_not_nil ps<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> ps<span class="main">(</span>3<span class="main">)</span> meeting_paths_produce_cycle xs_not_nil ys_not_nil <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> no_cycles <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹locale Graph›</span>
<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Tree">
<div class="head">
<h1>Theory Tree</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Trees›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Tree
<span class="keyword2"><span class="keyword">imports</span></span> <a href="#Graph">Graph</a> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A tree is a connected graph without cycles.›</span></span>
<span class="keyword1"><span class="command">locale</span></span> Tree <span class="main">=</span> Graph <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> connected<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">v</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="main">;</span> <span class="free">w</span> <span class="main">∈</span> <span class="keyword1">V</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">v</span> <span class="main">→<span class="hidden">⇧</span><sup>*</sup></span> <span class="free">w</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> no_cycles<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>cycle <span class="free">xs</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Unique Connecting Path›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹For every pair of vertices in a tree, there exists a unique path connecting these two
  vertices.
›</span></span>
<span class="keyword1" id="Tree-unique_connecting_path"><span class="command">lemma</span></span> unique_connecting_path<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">v</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="main">;</span> <span class="free">w</span> <span class="main">∈</span> <span class="keyword1">V</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">∃!</span><span class="bound">xs</span><span class="main">.</span> <span class="free">v</span> <span class="main">↝</span><span class="bound">xs</span><span class="main">↝</span> <span class="free">w</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> connected no_cycles no_cycles_implies_unique_paths <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Let us define a function mapping pair of vertices to their unique connecting path.›</span></span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹locale Tree›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">unique_connecting_path</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> Graph_scheme <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> Walk"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">↝</span>ı"</span> 71<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">unique_connecting_path</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">≡</span> <span class="keyword1">THE</span> <span class="bound">xs</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">↝</span><span class="bound">xs</span><span class="main">↝</span><span class="hidden">⇘</span><sub><span class="free"><span class="bound"><span class="entity">G</span></span></span></sub><span class="hidden">⇙</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span>"</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We defined this outside the locale in order to be able to use the index in the shorthand
  syntax <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">v</span></span> <span class="main"><span class="main">↝</span></span><span class="main"><span class="main">ı</span></span> <span class="free"><span class="free">w</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">context</span></span> Tree <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Tree-unique_connecting_path_set"><span class="command">lemma</span></span> unique_connecting_path_set<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> set <span class="main">(</span><span class="free">v</span> <span class="main">↝</span> <span class="free">w</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> set <span class="main">(</span><span class="free">v</span> <span class="main">↝</span> <span class="free">w</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> theI'<span class="main">[</span><span class="operator">OF</span> unique_connecting_path<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">folded</span> unique_connecting_path_def<span class="main">]</span>
    hd_in_set last_in_set <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Tree-unique_connecting_path_properties"><span class="command">lemma</span></span> unique_connecting_path_properties<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"path <span class="main">(</span><span class="free">v</span> <span class="main">↝</span> <span class="free">w</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">↝</span> <span class="free">w</span> <span class="main">≠</span> Nil"</span></span> <span class="quoted"><span class="quoted">"hd <span class="main">(</span><span class="free">v</span> <span class="main">↝</span> <span class="free">w</span><span class="main">)</span> <span class="main">=</span> <span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"last <span class="main">(</span><span class="free">v</span> <span class="main">↝</span> <span class="free">w</span><span class="main">)</span> <span class="main">=</span> <span class="free">w</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> theI'<span class="main">[</span><span class="operator">OF</span> unique_connecting_path<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">folded</span> unique_connecting_path_def<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Tree-unique_connecting_path_unique"><span class="command">lemma</span></span> unique_connecting_path_unique<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">↝</span><span class="free">xs</span><span class="main">↝</span> <span class="free">w</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="free">v</span> <span class="main">↝</span> <span class="free">w</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms connected_in_V <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">with</span></span> unique_connecting_path_properties<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> assms unique_connecting_path <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">corollary</span></span> unique_connecting_path_connects<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">v</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="main">;</span> <span class="free">w</span> <span class="main">∈</span> <span class="keyword1">V</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">v</span> <span class="main">↝</span><span class="main">(</span><span class="free">v</span><span class="main">↝</span><span class="free">w</span><span class="main">)</span> <span class="main">↝</span> <span class="free">w</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> unique_connecting_path unique_connecting_path_unique <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="Tree-unique_connecting_path_rev"><span class="command">lemma</span></span> unique_connecting_path_rev<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">↝</span> <span class="free">w</span> <span class="main">=</span> rev <span class="main">(</span><span class="free">w</span> <span class="main">↝</span> <span class="free">v</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">↝</span><span class="main">(</span>rev <span class="main">(</span><span class="free">w</span> <span class="main">↝</span> <span class="free">v</span><span class="main">)</span><span class="main">)</span><span class="main">↝</span> <span class="free">w</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> unique_connecting_path_properties walk_rev hd_rev last_rev path_from_toI<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> unique_connecting_path_unique <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Tree-unique_connecting_path_decomp"><span class="command">lemma</span></span> unique_connecting_path_decomp<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">↝</span> <span class="free">w</span> <span class="main">=</span> <span class="free">ps</span> <span class="main">@</span> <span class="free">u</span> <span class="main">#</span> <span class="free">ps'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">ps</span> <span class="main">@</span> <span class="main">[</span><span class="free">u</span><span class="main">]</span> <span class="main">=</span> <span class="free">v</span> <span class="main">↝</span> <span class="free">u</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span> <span class="main">#</span> <span class="free">ps'</span> <span class="main">=</span> <span class="free">u</span> <span class="main">↝</span> <span class="free">w</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"hd <span class="main">(</span><span class="free">ps</span> <span class="main">@</span> <span class="main">[</span><span class="free">u</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> <span class="free">v</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> append_Nil assms hd_append2 list.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> unique_connecting_path_properties<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path <span class="main">(</span><span class="free">ps</span> <span class="main">@</span> <span class="main">[</span><span class="free">u</span><span class="main">]</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> unique_connecting_path_properties<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">unfolding</span></span> assms<span class="main">(</span>3<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> distinct.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> distinct1_rotate list.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> list.simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> not_distinct_conv_prefix
        path_decomp<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> rev.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> rotate1.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> walk_comp walk_decomp<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> walk_last_edge walk_rev<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"last <span class="main">(</span><span class="free">ps</span> <span class="main">@</span> <span class="main">[</span><span class="free">u</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> <span class="free">u</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">ps</span> <span class="main">@</span> <span class="main">[</span><span class="free">u</span><span class="main">]</span> <span class="main">≠</span> Nil"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">ps</span> <span class="main">@</span> <span class="main">[</span><span class="free">u</span><span class="main">]</span> <span class="main">=</span> <span class="free">v</span> <span class="main">↝</span> <span class="free">u</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> unique_connecting_path_unique <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"last <span class="main">(</span><span class="free">u</span> <span class="main">#</span> <span class="free">ps'</span><span class="main">)</span> <span class="main">=</span> <span class="free">w</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms unique_connecting_path_properties<span class="main">(</span>4<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path <span class="main">(</span><span class="free">u</span> <span class="main">#</span> <span class="free">ps'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> unique_connecting_path_properties<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">unfolding</span></span> assms<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> path_decomp<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"hd <span class="main">(</span><span class="free">u</span> <span class="main">#</span> <span class="free">ps'</span><span class="main">)</span> <span class="main">=</span> <span class="free">u</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span> <span class="main">#</span> <span class="free">ps'</span> <span class="main">≠</span> Nil"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span> <span class="main">#</span> <span class="free">ps'</span> <span class="main">=</span> <span class="free">u</span> <span class="main">↝</span> <span class="free">w</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> unique_connecting_path_unique <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Tree-unique_connecting_path_tl"><span class="command">lemma</span></span> unique_connecting_path_tl<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span> <span class="main">∈</span> set <span class="main">(</span><span class="free">w</span> <span class="main">↝</span> <span class="free">v</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">→</span><span class="free">w</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"tl <span class="main">(</span><span class="free">w</span> <span class="main">↝</span> <span class="free">v</span><span class="main">)</span> <span class="main">=</span> <span class="free">u</span> <span class="main">↝</span> <span class="free">v</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> contra<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="var">?thesis</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>2<span class="main">)</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">ps</span></span> <span class="skolem"><span class="skolem">ps'</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    ps<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">↝</span> <span class="free">v</span> <span class="main">=</span> <span class="skolem">ps</span> <span class="main">@</span> <span class="free">u</span> <span class="main">#</span> <span class="skolem">ps'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> split_list<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"cycle <span class="main">(</span><span class="skolem">ps</span> <span class="main">@</span> <span class="main">[</span><span class="free">u</span><span class="main">]</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"path <span class="main">(</span><span class="skolem">ps</span> <span class="main">@</span> <span class="main">[</span><span class="free">u</span><span class="main">]</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> unique_connecting_path_decomp assms<span class="main">(</span>1<span class="main">,</span>3<span class="main">)</span> ps
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> edges_are_in_V unique_connecting_path_properties<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span><span class="skolem">ps</span> <span class="main">@</span> <span class="main">[</span><span class="free">u</span><span class="main">]</span><span class="main">)</span> <span class="main">&gt;</span> <span class="numeral">2</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="var">?thesis</span>"</span></span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span> <span class="main">≠</span> <span class="free">w</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>3<span class="main">)</span> no_loops <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span><span class="skolem">ps</span> <span class="main">@</span> <span class="main">[</span><span class="free">u</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> <span class="numeral">2</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> edges_are_in_V<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>3<span class="main"><span class="main">)</span></span> hd_append length_0_conv length_append_singleton
            less_2_cases linorder_neqE_nat list.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> nat.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> ps snoc_eq_iff_butlast
            unique_connecting_path_properties<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"tl <span class="main">(</span><span class="free">w</span> <span class="main">↝</span> <span class="free">v</span><span class="main">)</span> <span class="main">=</span> <span class="free">u</span> <span class="main">#</span> <span class="skolem">ps'</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> One_nat_def Suc_1 append_Nil diff_Suc_1 length_0_conv length_Cons
            length_append_singleton list.collapse nat.simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> ps tl_append2<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span> <span class="main">#</span> <span class="skolem">ps'</span> <span class="main">=</span> <span class="free">u</span> <span class="main">↝</span> <span class="free">v</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> unique_connecting_path_decomp assms<span class="main">(</span>1<span class="main">,</span>3<span class="main">)</span> edges_are_in_V<span class="main">(</span>2<span class="main">)</span> ps <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> contra <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"last <span class="main">(</span><span class="skolem">ps</span> <span class="main">@</span> <span class="main">[</span><span class="free">u</span><span class="main">]</span><span class="main">)</span> <span class="main">→</span> hd <span class="main">(</span><span class="skolem">ps</span> <span class="main">@</span> <span class="main">[</span><span class="free">u</span><span class="main">]</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>3<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> edges_are_in_V<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> unique_connecting_path_properties<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span>
          assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> hd_append list.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> ps snoc_eq_iff_butlast<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> no_cycles <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Every tree with at least two vertices contains an edge.›</span></span>
<span class="keyword1" id="Tree-tree_has_edge"><span class="command">lemma</span></span> tree_has_edge<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"card <span class="keyword1">V</span> <span class="main">&gt;</span> <span class="main">1</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">v</span> <span class="bound">w</span><span class="main">.</span> <span class="bound">v</span><span class="main">→</span><span class="bound">w</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="keyword2"><span class="keyword">where</span></span> v<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> List.finite_set One_nat_def card.empty card_mono empty_set less_le_trans linear
        not_less subsetI zero_less_Suc<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">w</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">≠</span> <span class="skolem">w</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> One_nat_def card.empty card.insert distinct.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> empty_set
      finite.intros<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> finite_distinct_list finite_vertex_set hd_in_set last.simps last_in_set
      less_or_eq_imp_le list.exhaust_sel list.simps<span class="main"><span class="main">(</span></span>15<span class="main"><span class="main">)</span></span> not_less path_singleton<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">→</span> hd <span class="main">(</span>tl <span class="main">(</span><span class="skolem">v</span><span class="main">↝</span><span class="skolem">w</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> v
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> unique_connecting_path_properties last.simps list.exhaust_sel walk_first_edge'<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Separations›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Removing a single edge always splits a tree into two subtrees.  Here we define the set of vertices
  of the left subtree.  The definition may not be obvious at first glance, but we will soon prove
  that it behaves as expected.  We say that a vertex <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">u</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is in the left subtree if and only
  if the unique path from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">u</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">t</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> visits <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">s</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">left_tree</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">left_tree</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">≡</span> <span class="main">{</span> <span class="bound"><span class="bound">u</span></span> <span class="main">∈</span> <span class="keyword1">V</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">∈</span> set <span class="main">(</span><span class="bound">u</span> <span class="main">↝</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span> <span class="main">}</span>"</span></span>
<span class="keyword1" id="Tree-left_treeI"><span class="command">lemma</span></span> left_treeI <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">u</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="main">;</span> <span class="free">s</span> <span class="main">∈</span> set <span class="main">(</span><span class="free">u</span> <span class="main">↝</span> <span class="free">t</span><span class="main">)</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">u</span> <span class="main">∈</span> left_tree <span class="free">s</span> <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> left_tree_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1" id="Tree-left_treeE"><span class="command">lemma</span></span> left_treeE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span> <span class="main">∈</span> left_tree <span class="free">s</span> <span class="free">t</span> <span class="main">⟹</span> <span class="free">u</span> <span class="main">∈</span> <span class="keyword1">V</span> <span class="main">∧</span> <span class="free">s</span> <span class="main">∈</span> set <span class="main">(</span><span class="free">u</span> <span class="main">↝</span> <span class="free">t</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> left_tree_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="Tree-left_tree_in_V"><span class="command">lemma</span></span> left_tree_in_V<span class="main">:</span> <span class="quoted"><span class="quoted">"left_tree <span class="free">s</span> <span class="free">t</span> <span class="main">⊆</span> <span class="keyword1">V</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> left_tree_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1" id="Tree-left_tree_initial"><span class="command">lemma</span></span> left_tree_initial<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">s</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="main">;</span> <span class="free">t</span> <span class="main">∈</span> <span class="keyword1">V</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">s</span> <span class="main">∈</span> left_tree <span class="free">s</span> <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> left_tree_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> unique_connecting_path_set<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1" id="Tree-left_tree_initial'"><span class="command">lemma</span></span> left_tree_initial'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">s</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="main">;</span> <span class="free">t</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="main">;</span> <span class="free">s</span> <span class="main">≠</span> <span class="free">t</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">t</span> <span class="main">∉</span> left_tree <span class="free">s</span> <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> distinct.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> last.simps left_treeE list.discI list.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> path_from_toI
      path_singleton set_ConsD unique_connecting_path_unique<span class="main">)</span>
<span class="keyword1" id="Tree-left_tree_initial_edge"><span class="command">lemma</span></span> left_tree_initial_edge<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">→</span><span class="free">t</span> <span class="main">⟹</span> <span class="free">t</span> <span class="main">∉</span> left_tree <span class="free">s</span> <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> edges_are_in_V<span class="main">(</span>1<span class="main">)</span> left_tree_initial' no_loops undirected <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The union of the left and right subtree is <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="keyword1"><span class="quoted"><span class="keyword1">V</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>
<span class="keyword1" id="Tree-left_tree_union_V"><span class="command">lemma</span></span> left_tree_union_V<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">→</span><span class="free">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"left_tree <span class="free">s</span> <span class="free">t</span> <span class="main">∪</span> left_tree <span class="free">t</span> <span class="free">s</span> <span class="main">=</span> <span class="keyword1">V</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"left_tree <span class="free">s</span> <span class="free">t</span> <span class="main">∪</span> left_tree <span class="free">t</span> <span class="free">s</span> <span class="main">⊆</span> <span class="keyword1">V</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> left_tree_in_V <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword1"><span class="command">have</span></span> s<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> t<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">using</span></span> edges_are_in_V <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Assume to the contrary that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">u</span></span> <span class="main"><span class="main">∈</span></span> <span class="keyword1"><span class="keyword1">V</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is in neither part.›</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u</span> <span class="keyword3"><span class="command">assume</span></span> u<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∉</span> left_tree <span class="free">s</span> <span class="free">t</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∉</span> left_tree <span class="free">t</span> <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Then we can construct two different paths from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">s</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">u</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, which, in a
      tree, is a contradiction.  First, we get paths from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">s</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">u</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and from
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">t</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">u</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?xs</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">↝</span> <span class="skolem">u</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?ys</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">↝</span> <span class="skolem">u</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">∉</span> set <span class="var">?xs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> u<span class="main">(</span>1<span class="main">,</span>3<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> left_tree_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> unique_connecting_path_rev mem_Collect_eq s set_rev<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">∉</span> set <span class="var">?ys</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> u<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> left_tree_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> unique_connecting_path_rev mem_Collect_eq set_rev t<span class="main">)</span>

    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Now we can define two different paths from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">s</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">u</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">xs'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xs'</span> <span class="main">=</span> <span class="var">?xs</span>"</span></span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">ys'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">ys'</span> <span class="main">=</span> <span class="free">s</span> <span class="main">#</span> <span class="var">?ys</span>"</span></span>

    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path <span class="skolem">ys'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> path_cons <span class="quoted"><span class="quoted">‹<span class="free">s</span> <span class="main">∉</span> set <span class="var">?ys</span>›</span></span> assms
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> unique_connecting_path_properties<span class="main"><span class="main">(</span></span>1-3<span class="main"><span class="main">)</span></span> t u<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path <span class="skolem">xs'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs'</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ys'</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>  <span class="quoted"><span class="quoted">"hd <span class="skolem">xs'</span> <span class="main">=</span> <span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"last <span class="skolem">xs'</span> <span class="main">=</span> <span class="skolem">u</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> unique_connecting_path_properties s u<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"hd <span class="skolem">ys'</span> <span class="main">=</span> <span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"last <span class="skolem">ys'</span> <span class="main">=</span> <span class="skolem">u</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> unique_connecting_path_properties<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">,</span></span>4<span class="main"><span class="main">)</span></span> t u<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs'</span> <span class="main">≠</span> <span class="skolem">ys'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> unique_connecting_path_set<span class="main">(</span>1<span class="main">)</span> <span class="quoted"><span class="quoted">‹<span class="free">t</span> <span class="main">∉</span> set <span class="var">?xs</span>›</span></span> t u<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The existence of two different paths is a contradiction.›</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> unique_connecting_path_unique <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">V</span> <span class="main">⊆</span> left_tree <span class="free">s</span> <span class="free">t</span> <span class="main">∪</span> left_tree <span class="free">t</span> <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The left and right subtrees are disjoint.›</span></span>
<span class="keyword1" id="Tree-left_tree_disjoint"><span class="command">lemma</span></span> left_tree_disjoint<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">→</span><span class="free">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"left_tree <span class="free">s</span> <span class="free">t</span> <span class="main">∩</span> left_tree <span class="free">t</span> <span class="free">s</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="var">?thesis</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u</span></span> <span class="keyword2"><span class="keyword">where</span></span> u<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">u</span> <span class="main">↝</span> <span class="free">t</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">u</span> <span class="main">↝</span> <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> left_treeE <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

  <span class="keyword1"><span class="command">have</span></span> s<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> t<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms edges_are_in_V <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">ps</span></span> <span class="skolem"><span class="skolem">ps'</span></span> <span class="keyword2"><span class="keyword">where</span></span> ps<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">↝</span> <span class="free">t</span> <span class="main">=</span> <span class="skolem">ps</span> <span class="main">@</span> <span class="free">s</span> <span class="main">#</span> <span class="skolem">ps'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> split_list u<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ps'</span> <span class="main">≠</span> Nil"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms last_snoc no_loops unique_connecting_path_properties<span class="main">(</span>4<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> u<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> t<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="main">(</span><span class="skolem">ps</span> <span class="main">@</span> <span class="main">[</span><span class="free">s</span><span class="main">]</span><span class="main">)</span> <span class="main">&lt;</span> length <span class="main">(</span><span class="skolem">u</span> <span class="main">↝</span> <span class="free">t</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ps<span class="main">)</span>

  <span class="keyword1"><span class="command">have</span></span> ps'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">ps</span> <span class="main">@</span> <span class="main">[</span><span class="free">s</span><span class="main">]</span> <span class="main">=</span> <span class="skolem">u</span> <span class="main">↝</span> <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> ps unique_connecting_path_decomp t u<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">qs</span></span> <span class="skolem"><span class="skolem">qs'</span></span> <span class="keyword2"><span class="keyword">where</span></span> qs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">ps</span> <span class="main">@</span> <span class="main">[</span><span class="free">s</span><span class="main">]</span> <span class="main">=</span> <span class="skolem">qs</span> <span class="main">@</span> <span class="free">t</span> <span class="main">#</span> <span class="skolem">qs'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> split_list<span class="main">[</span><span class="operator">OF</span> u<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">qs'</span> <span class="main">≠</span> Nil"</span></span> <span class="keyword1"><span class="command">using</span></span> assms last_snoc no_loops <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> **<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="main">(</span><span class="skolem">qs</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span> <span class="main">&lt;</span> length <span class="main">(</span><span class="skolem">ps</span> <span class="main">@</span> <span class="main">[</span><span class="free">s</span><span class="main">]</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> qs<span class="main">)</span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">qs</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span> <span class="main">=</span> <span class="skolem">u</span> <span class="main">↝</span> <span class="free">t</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> qs ps' unique_connecting_path_decomp s u<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> less_trans<span class="main">[</span><span class="operator">OF</span> ** *<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The path from a vertex in the left subtree to a vertex in the right subtree goes through <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">s</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  In other words, an edge <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">s</span></span><span class="main"><span class="main">→</span></span><span class="free"><span class="free">t</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is a separator in a tree.
›</span></span>
<span class="keyword1"><span class="command">theorem</span></span> left_tree_separates<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> st<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">→</span><span class="free">t</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> u<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span> <span class="main">∈</span> left_tree <span class="free">s</span> <span class="free">t</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> u'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u'</span> <span class="main">∈</span> left_tree <span class="free">t</span> <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">∈</span> set <span class="main">(</span><span class="free">u</span> <span class="main">↝</span> <span class="free">u'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="var">?thesis</span>"</span></span>
  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="free">u</span> <span class="main">↝</span> <span class="free">u'</span><span class="main">)</span> <span class="main">⊆</span> left_tree <span class="free">s</span> <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"<span class="free">u</span> <span class="main">↝</span> <span class="free">u'</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">u</span></span> <span class="quoted"><span class="free">u'</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> unique_connecting_path_properties<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x</span> <span class="skolem">xs</span> <span class="skolem">u</span> <span class="skolem">u'</span><span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">u</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Cons.hyps<span class="main">(</span>2<span class="main">)</span> Cons.prems<span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> left_treeE list.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> unique_connecting_path_properties<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">→</span>hd <span class="skolem">xs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Cons.hyps<span class="main">(</span>2<span class="main">)</span> Cons.prems<span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span> st
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> IntI left_tree_disjoint distinct.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> last.simps left_treeE list.set<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span>
          unique_connecting_path_properties<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>4<span class="main"><span class="main">)</span></span> walk_first_edge'<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span> <span class="quoted"><span class="quoted">"hd <span class="skolem">xs</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> edges_are_in_V <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> hd <span class="skolem">xs</span> <span class="main">↝</span> <span class="skolem">u'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Cons.hyps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> Cons.prems<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">,</span></span>3<span class="main"><span class="main">)</span></span> IntI left_tree_disjoint distinct.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> last.simps
          left_treeE list.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>3<span class="main"><span class="main">)</span></span> list.set<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> path_from_toI st
          unique_connecting_path_properties<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>3<span class="main"><span class="main">,</span></span>4<span class="main"><span class="main">)</span></span> unique_connecting_path_unique walk_tl<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">hence</span></span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">∉</span> set <span class="main">(</span>hd <span class="skolem">xs</span> <span class="main">↝</span> <span class="skolem">u'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Cons.hyps<span class="main">(</span>2<span class="main">)</span> Cons.prems<span class="main">(</span>4<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> list.set_intros<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"hd <span class="skolem">xs</span> <span class="main">∈</span> left_tree <span class="free">s</span> <span class="free">t</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="var">?thesis</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"hd <span class="skolem">xs</span> <span class="main">∈</span> left_tree <span class="free">t</span> <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹hd <span class="skolem">xs</span> <span class="main">∈</span> <span class="keyword1">V</span>›</span></span> st left_tree_union_V <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">∈</span> set <span class="main">(</span>hd <span class="skolem">xs</span> <span class="main">↝</span> <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> left_treeE <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?ys'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"hd <span class="skolem">xs</span> <span class="main">↝</span> <span class="free">s</span>"</span></span>
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?ys</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">#</span> <span class="var">?ys'</span>"</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∉</span> set <span class="var">?ys'</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> set <span class="var">?ys'</span>"</span></span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"tl <span class="var">?ys'</span> <span class="main">=</span> <span class="skolem">u</span> <span class="main">↝</span> <span class="free">s</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> unique_connecting_path_tl <span class="quoted"><span class="quoted">‹<span class="skolem">u</span><span class="main">→</span>hd <span class="skolem">xs</span>›</span></span> edges_are_in_V<span class="main">(</span>1<span class="main">)</span> st <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">≠</span> hd <span class="skolem">xs</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span>
          <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?ys</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="skolem">u</span><span class="main">,</span> hd <span class="skolem">xs</span><span class="main">]</span>"</span></span>
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">≠</span> <span class="skolem">u</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Cons.prems<span class="main">(</span>2<span class="main">)</span> left_tree_initial_edge st <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">=</span> hd <span class="skolem">xs</span>"</span></span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="var">?ys</span> <span class="main">=</span> <span class="skolem">u</span> <span class="main">↝</span> <span class="free">t</span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> unique_connecting_path_unique<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">u</span></span> <span class="var"><span class="quoted"><span class="var">?ys</span></span></span> <span class="quoted"><span class="quoted">"hd <span class="skolem">xs</span>"</span></span><span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="skolem">u</span><span class="main">→</span>hd <span class="skolem">xs</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">t</span> <span class="main">≠</span> <span class="skolem">u</span>›</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> path_from_toI<span class="main">)</span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">∉</span> set <span class="main">(</span><span class="skolem">u</span> <span class="main">↝</span> <span class="free">t</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Cons.hyps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> Cons.prems<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span> <span class="quoted"><span class="quoted">‹<span class="free">t</span> <span class="main">=</span> hd <span class="skolem">xs</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">u</span>›</span></span> distinct.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span>
                distinct_singleton list.set_intros<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> no_loops set_ConsD st<span class="main">)</span>
          <span class="keyword3"><span class="command">thus</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> Cons.prems<span class="main">(</span>2<span class="main">)</span> left_treeE <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">u</span> <span class="main">↝</span> <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">t</span> <span class="main">∈</span> set <span class="var">?ys'</span>›</span></span> <span class="quoted"><span class="quoted">‹hd <span class="skolem">xs</span> <span class="main">∈</span> <span class="keyword1">V</span>›</span></span> st
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> edges_are_in_V<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> unique_connecting_path_properties<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">,</span></span>3<span class="main"><span class="main">)</span></span> list.collapse set_ConsD<span class="main">)</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> Cons.prems<span class="main">(</span>2<span class="main">)</span> st <span class="quoted"><span class="quoted">‹<span class="skolem">u</span> <span class="main">∈</span> <span class="keyword1">V</span>›</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> left_tree_disjoint disjoint_iff_not_equal left_treeI<span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"path <span class="var">?ys</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> path_cons <span class="quoted"><span class="quoted">‹<span class="skolem">u</span><span class="main">→</span>hd <span class="skolem">xs</span>›</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> unique_connecting_path_properties<span class="main"><span class="main">(</span></span>1-3<span class="main"><span class="main">)</span></span> edges_are_in_V st<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?ys</span> <span class="main">≠</span> Nil"</span></span> <span class="quoted"><span class="quoted">"hd <span class="var">?ys</span> <span class="main">=</span> <span class="skolem">u</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"last <span class="var">?ys</span> <span class="main">=</span> <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> st unique_connecting_path_properties<span class="main">(</span>2<span class="main">,</span>4<span class="main">)</span> <span class="quoted"><span class="quoted">‹hd <span class="skolem">xs</span> <span class="main">∈</span> <span class="keyword1">V</span>›</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> edges_are_in_V<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?ys</span> <span class="main">=</span> <span class="skolem">u</span> <span class="main">↝</span> <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> unique_connecting_path_unique <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">u</span> <span class="main">↝</span> <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="quoted"><span class="quoted">‹<span class="free">t</span> <span class="main">∈</span> set <span class="var">?ys'</span>›</span></span> list.set_intros<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> Cons.prems<span class="main">(</span>2<span class="main">)</span> <span class="quoted"><span class="quoted">‹<span class="skolem">u</span> <span class="main">∈</span> <span class="keyword1">V</span>›</span></span> st
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> left_tree_disjoint disjoint_iff_not_equal left_treeI<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>hd <span class="skolem">xs</span> <span class="main">↝</span> <span class="skolem">u'</span><span class="main">)</span> <span class="main">⊆</span> left_tree <span class="free">s</span> <span class="free">t</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> Cons.hyps<span class="main">(</span>1<span class="main">)</span> st Cons.prems<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">xs</span> <span class="main">⊆</span> left_tree <span class="free">s</span> <span class="free">t</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> * <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> Cons.hyps<span class="main">(</span>2<span class="main">)</span> Cons.prems<span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> insert_subset left_treeE list.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> list.set<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> unique_connecting_path_properties<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">u'</span> <span class="main">∈</span> left_tree <span class="free">s</span> <span class="free">t</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> left_treeE u u' unique_connecting_path_set<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> left_tree_disjoint disjoint_iff_not_equal st u'<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹By symmetry, the path also visits <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">t</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>
<span class="keyword1"><span class="command">corollary</span></span> left_tree_separates'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">→</span><span class="free">t</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span> <span class="main">∈</span> left_tree <span class="free">s</span> <span class="free">t</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">u'</span> <span class="main">∈</span> left_tree <span class="free">t</span> <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">∈</span> set <span class="main">(</span><span class="free">u</span> <span class="main">↝</span> <span class="free">u'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms left_tree_separates <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> left_treeE set_rev undirected unique_connecting_path_rev<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹locale Tree›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Rooted Trees›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A rooted tree is a tree with a distinguished vertex called root.›</span></span>

<span class="keyword1"><span class="command">locale</span></span> RootedTree <span class="main">=</span> Tree <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">root</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> root_in_V<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">root</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In a rooted tree, we can define the parent relation.›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">parent</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">parent</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span> hd <span class="main">(</span>tl <span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">↝</span> <span class="free">root</span><span class="main">)</span><span class="main">)</span>"</span></span>

  <span class="keyword1" id="Tree-parent_edge"><span class="command">lemma</span></span> parent_edge<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">v</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="main">;</span> <span class="free">v</span> <span class="main">≠</span> <span class="free">root</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">v</span><span class="main">→</span>parent <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> parent_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> last.simps list.exhaust_sel root_in_V unique_connecting_path_properties walk_first_edge'<span class="main">)</span>
  <span class="keyword1" id="Tree-parent_edge_root"><span class="command">lemma</span></span> parent_edge_root<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">→</span><span class="free">root</span> <span class="main">⟹</span> parent <span class="free">v</span> <span class="main">=</span> <span class="free">root</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> parent_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> edges_are_in_V<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> path_from_toE undirected unique_connecting_path
        unique_connecting_path_set<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> unique_connecting_path_tl unique_connecting_path_unique<span class="main">)</span>
  <span class="keyword1" id="Tree-parent_in_V"><span class="command">lemma</span></span> parent_in_V<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">v</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="main">;</span> <span class="free">v</span> <span class="main">≠</span> <span class="free">root</span> <span class="main">⟧</span> <span class="main">⟹</span> parent <span class="free">v</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> parent_edge edges_are_in_V<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1" id="Tree-parent_edge_cases"><span class="command">lemma</span></span> parent_edge_cases<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">→</span><span class="free">w</span> <span class="main">⟹</span> <span class="free">w</span> <span class="main">=</span> parent <span class="free">v</span> <span class="main">∨</span> <span class="free">v</span> <span class="main">=</span> parent <span class="free">w</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> parent_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Un_iff edges_are_in_V<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> left_tree_initial left_tree_separates' left_tree_union_V
        root_in_V undirected unique_connecting_path_properties<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> unique_connecting_path_tl<span class="main">)</span>

  <span class="keyword1" id="Tree-sibling_path"><span class="command">lemma</span></span> sibling_path<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> v<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">≠</span> <span class="free">root</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> w<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">≠</span> <span class="free">root</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> vw<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">≠</span> <span class="free">w</span>"</span></span> <span class="quoted"><span class="quoted">"parent <span class="free">v</span> <span class="main">=</span> parent <span class="free">w</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">↝</span><span class="free">w</span> <span class="main">=</span> <span class="main">[</span><span class="free">v</span><span class="main">,</span>parent <span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">]</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=</span> <span class="var">?xs</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path <span class="var">?xs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> v w vw
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> distinct_length_2_or_more distinct_singleton no_loops parent_edge undirected
          walk.Cons walk_2<span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> unique_connecting_path_unique <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹locale RootedTree›</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="TreeDecomposition">
<div class="head">
<h1>Theory TreeDecomposition</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Tree Decompositions›</span></span>

<span class="keyword1"><span class="command">theory</span></span> TreeDecomposition
<span class="keyword2"><span class="keyword">imports</span></span> <a href="#Tree">Tree</a> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A tree decomposition of a graph.›</span></span>

<span class="keyword1"><span class="command">locale</span></span> TreeDecomposition <span class="main">=</span> Graph <span class="quoted"><span class="free">G</span></span> <span class="main">+</span> T<span class="main">:</span> Tree <span class="quoted"><span class="free">T</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> Graph_scheme"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">structure</span></span><span class="main">)</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">T</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c</span><span class="main">,</span><span class="tfree">'d</span><span class="main">)</span> Graph_scheme"</span></span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">bag</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span>
    <span class="comment1">― ‹Every vertex appears somewhere›</span>
    bags_union<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋃</span> <span class="main">{</span> <span class="free">bag</span> <span class="bound">t</span> <span class="main">|</span> <span class="bound">t</span><span class="main">.</span> <span class="bound">t</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="hidden">⇘</span><sub><span class="free">T</span></sub><span class="hidden">⇙</span> <span class="main">}</span> <span class="main">=</span> <span class="keyword1">V</span>"</span></span>
     <span class="comment1">― ‹Every edge is covered›</span>
    <span class="keyword2"><span class="keyword">and</span></span> bags_edges<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">→</span><span class="free">w</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">t</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="hidden">⇘</span><sub><span class="free">T</span></sub><span class="hidden">⇙</span><span class="main">.</span> <span class="free">v</span> <span class="main">∈</span> <span class="free">bag</span> <span class="bound">t</span> <span class="main">∧</span> <span class="free">w</span> <span class="main">∈</span> <span class="free">bag</span> <span class="bound">t</span>"</span></span>
    <span class="comment1">― ‹Every vertex appearing in <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted"><span class="free">s</span></span><span class="antiquote">}</span></span> and <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted"><span class="free">u</span></span><span class="antiquote">}</span></span> also appears in every bag on the path
        connecting <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted"><span class="free">s</span></span><span class="antiquote">}</span></span> and <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted"><span class="free">u</span></span><span class="antiquote">}</span></span>›</span>
    <span class="keyword2"><span class="keyword">and</span></span> bags_continuous<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">s</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="hidden">⇘</span><sub><span class="free">T</span></sub><span class="hidden">⇙</span><span class="main">;</span> <span class="free">u</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="hidden">⇘</span><sub><span class="free">T</span></sub><span class="hidden">⇙</span><span class="main">;</span> <span class="free">t</span> <span class="main">∈</span> set <span class="main">(</span><span class="free">s</span> <span class="main">↝</span><span class="hidden">⇘</span><sub><span class="free">T</span></sub><span class="hidden">⇙</span> <span class="free">u</span><span class="main">)</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">bag</span> <span class="free">s</span> <span class="main">∩</span> <span class="free">bag</span> <span class="free">u</span> <span class="main">⊆</span> <span class="free">bag</span> <span class="free">t</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Following the usual literature, we will call elements of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="keyword1"><span class="quoted"><span class="keyword1">V</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> vertices and
  elements of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">V</span></span><span class="hidden">⇘</span><sub><span class="free"><span class="free">T</span></span></sub><span class="hidden">⇙</span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> bags (or nodes) from now on.›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Width of a Tree Decomposition›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We define the width of this tree decomposition as the size of the largest bag minus 1.›</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">bag_cards</span> <span class="main">≡</span> <span class="main">{</span> card <span class="main">(</span><span class="free">bag</span> <span class="bound">t</span><span class="main">)</span> <span class="main">|</span> <span class="bound">t</span><span class="main">.</span> <span class="bound">t</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="hidden">⇘</span><sub><span class="free">T</span></sub><span class="hidden">⇙</span> <span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">max_bag_card</span> <span class="main">≡</span> Max bag_cards"</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We need a special case for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">V</span></span><span class="hidden">⇘</span><sub><span class="free"><span class="free">T</span></span></sub><span class="hidden">⇙</span> <span class="main"><span class="main">=</span></span> <span class="main"><span class="main">{}</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> because in this case <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> max_bag_card<span class="antiquote"><span class="antiquote">}</span></span></span></span>
  is not well-defined.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">width</span> <span class="main">≡</span> <span class="keyword1">if</span> <span class="keyword1">V</span><span class="hidden">⇘</span><sub><span class="free">T</span></sub><span class="hidden">⇙</span> <span class="main">=</span> <span class="main">{}</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> max_bag_card <span class="main">-</span> <span class="main">1</span>"</span></span>

<span class="keyword1" id="TreeDecomposition-bags_in_V"><span class="command">lemma</span></span> bags_in_V<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="hidden">⇘</span><sub><span class="free">T</span></sub><span class="hidden">⇙</span> <span class="main">⟹</span> <span class="free">bag</span> <span class="free">t</span> <span class="main">⊆</span> <span class="keyword1">V</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> bags_union Sup_upper mem_Collect_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1" id="TreeDecomposition-bag_finite"><span class="command">lemma</span></span> bag_finite<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="hidden">⇘</span><sub><span class="free">T</span></sub><span class="hidden">⇙</span> <span class="main">⟹</span> finite <span class="main">(</span><span class="free">bag</span> <span class="free">t</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> bags_in_V finite_subset finite_vertex_set <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1" id="TreeDecomposition-bag_bound_V"><span class="command">lemma</span></span> bag_bound_V<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="hidden">⇘</span><sub><span class="free">T</span></sub><span class="hidden">⇙</span> <span class="main">⟹</span> card <span class="main">(</span><span class="free">bag</span> <span class="free">t</span><span class="main">)</span> <span class="main">≤</span> card <span class="keyword1">V</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bags_in_V card_mono finite_vertex_set<span class="main">)</span>
<span class="keyword1" id="TreeDecomposition-bag_bound_V_empty"><span class="command">lemma</span></span> bag_bound_V_empty<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="keyword1">V</span> <span class="main">=</span> <span class="main">{}</span><span class="main">;</span> <span class="free">t</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="hidden">⇘</span><sub><span class="free">T</span></sub><span class="hidden">⇙</span> <span class="main">⟧</span> <span class="main">⟹</span> card <span class="main">(</span><span class="free">bag</span> <span class="free">t</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> bag_bound_V <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1" id="TreeDecomposition-empty_tree_empty_V"><span class="command">lemma</span></span> empty_tree_empty_V<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">V</span><span class="hidden">⇘</span><sub><span class="free">T</span></sub><span class="hidden">⇙</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">⟹</span> <span class="keyword1">V</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> bags_union <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1" id="TreeDecomposition-bags_exist"><span class="command">lemma</span></span> bags_exist<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="keyword1">V</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">t</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="hidden">⇘</span><sub><span class="free">T</span></sub><span class="hidden">⇙</span><span class="main">.</span> <span class="free">v</span> <span class="main">∈</span> <span class="free">bag</span> <span class="bound">t</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> bags_union <span class="keyword1"><span class="command">using</span></span> UnionE mem_Collect_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The width is never larger than the number of vertices, and if there is at least one vertex
  in the graph, then it is always smaller.  This is trivially true because a bag contains at most
  all of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="keyword1"><span class="quoted"><span class="keyword1">V</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.  However, the proof is not fully trivial because we also need to show that
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> width<span class="antiquote"><span class="antiquote">}</span></span></span></span> is well-defined.›</span></span>
<span class="keyword1" id="TreeDecomposition-bag_cards_finite"><span class="command">lemma</span></span> bag_cards_finite<span class="main">:</span> <span class="quoted"><span class="quoted">"finite bag_cards"</span></span> <span class="keyword1"><span class="command">using</span></span> T.finite_vertex_set <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1" id="TreeDecomposition-bag_cards_nonempty"><span class="command">lemma</span></span> bag_cards_nonempty<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">V</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">⟹</span> bag_cards <span class="main">≠</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> bag_cards_finite empty_tree_empty_V empty_Collect_eq ex_in_conv <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1" id="TreeDecomposition-max_bag_card_in_bag_cards"><span class="command">lemma</span></span> max_bag_card_in_bag_cards<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">V</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">⟹</span> max_bag_card <span class="main">∈</span> bag_cards"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> max_bag_card_def
  <span class="keyword1"><span class="command">using</span></span> Max_in bag_cards_finite bag_cards_nonempty <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1" id="TreeDecomposition-max_bag_card_lower_bound_bag"><span class="command">lemma</span></span> max_bag_card_lower_bound_bag<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="hidden">⇘</span><sub><span class="free">T</span></sub><span class="hidden">⇙</span> <span class="main">⟹</span> max_bag_card <span class="main">≥</span> card <span class="main">(</span><span class="free">bag</span> <span class="free">t</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> Max_ge bag_cards_finite max_bag_card_def mem_Collect_eq<span class="main">)</span>
<span class="keyword1" id="TreeDecomposition-max_bag_card_lower_bound_1"><span class="command">lemma</span></span> max_bag_card_lower_bound_1<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">V</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"max_bag_card <span class="main">&gt;</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">v</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="main">.</span> <span class="main">∃</span><span class="bound">t</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="hidden">⇘</span><sub><span class="free">T</span></sub><span class="hidden">⇙</span><span class="main">.</span> <span class="bound">v</span> <span class="main">∈</span> <span class="free">bag</span> <span class="bound">t</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="keyword1">V</span> <span class="main">≠</span> <span class="main">{}</span>›</span></span> bags_union <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"max_bag_card <span class="main">&gt;</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> max_bag_card_def <span class="keyword1"><span class="command">using</span></span> bag_finite
    card_gt_0_iff emptyE Max_gr_iff<span class="main">[</span><span class="operator">OF</span> bag_cards_finite bag_cards_nonempty<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1" id="TreeDecomposition-max_bag_card_upper_bound_V"><span class="command">lemma</span></span> max_bag_card_upper_bound_V<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">V</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">⟹</span> max_bag_card <span class="main">≤</span> card <span class="keyword1">V</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> max_bag_card_def
  <span class="keyword1"><span class="command">using</span></span> Max_le_iff<span class="main">[</span><span class="operator">OF</span> bag_cards_finite bag_cards_nonempty<span class="main">]</span> bag_bound_V <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="TreeDecomposition-width_upper_bound_V"><span class="command">lemma</span></span> width_upper_bound_V<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">V</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">⟹</span> width <span class="main">&lt;</span> card <span class="keyword1">V</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> width_def
  <span class="keyword1"><span class="command">using</span></span> max_bag_card_upper_bound_V max_bag_card_lower_bound_1
    diff_less empty_tree_empty_V le_neq_implies_less less_imp_diff_less zero_less_one <span class="keyword1"><span class="command">by</span></span> <span class="operator">presburger</span>
<span class="keyword1" id="TreeDecomposition-width_V_empty"><span class="command">lemma</span></span> width_V_empty<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">V</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">⟹</span> width <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> width_def max_bag_card_def
  <span class="keyword1"><span class="command">using</span></span> bag_bound_V_empty T.finite_vertex_set <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="keyword1">V</span><span class="hidden">⇘</span><sub><span class="free">T</span></sub><span class="hidden">⇙</span> <span class="main">=</span> <span class="main">{}</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1" id="TreeDecomposition-width_bound_V_le"><span class="command">lemma</span></span> width_bound_V_le<span class="main">:</span> <span class="quoted"><span class="quoted">"width <span class="main">≤</span> card <span class="keyword1">V</span> <span class="main">-</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> width_upper_bound_V width_V_empty <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="keyword1">V</span> <span class="main">=</span> <span class="main">{}</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1" id="TreeDecomposition-width_lower_bound_1"><span class="command">lemma</span></span> width_lower_bound_1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">→</span><span class="free">w</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"width <span class="main">≥</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">t</span></span> <span class="keyword2"><span class="keyword">where</span></span> t<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">t</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="hidden">⇘</span><sub><span class="free">T</span></sub><span class="hidden">⇙</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="free">bag</span> <span class="skolem">t</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> <span class="free">bag</span> <span class="skolem">t</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> bags_edges assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span><span class="free">bag</span> <span class="skolem">t</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> t<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span> bag_finite card_0_eq empty_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span><span class="free">bag</span> <span class="skolem">t</span><span class="main">)</span> <span class="main">≠</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> t<span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span> assms no_loops
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> One_nat_def card_Suc_eq empty_iff insertE<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span><span class="free">bag</span> <span class="skolem">t</span><span class="main">)</span> <span class="main">≥</span> <span class="numeral">2</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"max_bag_card <span class="main">&gt;</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> t<span class="main">(</span>1<span class="main">)</span> max_bag_card_lower_bound_bag <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> width_def <span class="keyword1"><span class="command">using</span></span> t<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹locale TreeDecomposition›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Treewidth of a Graph›</span></span>

<span class="keyword1"><span class="command">context</span></span> Graph <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The treewidth of a graph is the minimum treewidth over all its tree decompositions.
  Here we assume without loss of generality that the universe of the vertices of the tree
  is <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> nat<span class="antiquote"><span class="antiquote">}</span></span></span></span>.  Because trees are finite, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> nat<span class="antiquote"><span class="antiquote">}</span></span></span></span> always contains enough elements.›</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">treewidth_cards</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat set"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">treewidth_cards</span> <span class="main">≡</span>
  <span class="main">{</span> TreeDecomposition.width <span class="bound">T</span> <span class="bound">bag</span> <span class="main">|</span> <span class="main">(</span><span class="bound">T</span> <span class="main">::</span> nat Graph<span class="main">)</span> <span class="bound">bag</span><span class="main">.</span> TreeDecomposition <span class="free">G</span> <span class="bound">T</span> <span class="bound">bag</span> <span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">treewidth</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">treewidth</span> <span class="main">≡</span> Min treewidth_cards"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Every graph has a trivial tree decomposition consisting of a single bag containing all of
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="keyword1"><span class="quoted"><span class="keyword1">V</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>
<span class="keyword1"><span class="command">proposition</span></span> tree_decomposition_exists<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="main">(</span><span class="bound">T</span> <span class="main">::</span> <span class="tfree">'c</span> Graph<span class="main">)</span> <span class="bound">bag</span><span class="main">.</span> TreeDecomposition <span class="free">G</span> <span class="bound">T</span> <span class="bound">bag</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'c</span> set<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">T</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">T</span> <span class="main">=</span> <span class="main">⦇</span> verts <span class="main">=</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span><span class="main">,</span> arcs <span class="main">=</span> <span class="main">{}</span> <span class="main">⦈</span>"</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">bag</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">bag</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main">::</span> <span class="tfree">'c</span><span class="main">.</span> <span class="keyword1">V</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Graph <span class="skolem">T</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> T<span class="main">:</span> Graph <span class="quoted"><span class="skolem">T</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span>T.cycle <span class="bound">xs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> T.cycleE <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">v</span> <span class="bound">w</span><span class="main">.</span> <span class="bound">v</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="hidden">⇘</span><sub><span class="skolem">T</span></sub><span class="hidden">⇙</span> <span class="main">⟹</span> <span class="bound">w</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="hidden">⇘</span><sub><span class="skolem">T</span></sub><span class="hidden">⇙</span> <span class="main">⟹</span> T.connected <span class="bound">v</span> <span class="bound">w</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> T.connected_refl <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Tree <span class="skolem">T</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> T<span class="main">:</span> Tree <span class="quoted"><span class="skolem">T</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"TreeDecomposition <span class="free">G</span> <span class="skolem">T</span> <span class="skolem">bag</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> edges_are_in_V<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">corollary</span></span> treewidth_cards_upper_bound_V<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">∈</span> treewidth_cards <span class="main">⟹</span> <span class="free">n</span> <span class="main">≤</span> card <span class="keyword1">V</span> <span class="main">-</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> TreeDecomposition.width_bound_V_le <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">corollary</span></span> treewidth_cards_finite<span class="main">:</span> <span class="quoted"><span class="quoted">"finite treewidth_cards"</span></span>
  <span class="keyword1"><span class="command">using</span></span> treewidth_cards_upper_bound_V finite_nat_set_iff_bounded_le <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">corollary</span></span> treewidth_cards_nonempty<span class="main">:</span> <span class="quoted"><span class="quoted">"treewidth_cards <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tree_decomposition_exists<span class="main">)</span>

<span class="keyword1" id="TreeDecomposition-treewidth_cards_treewidth"><span class="command">lemma</span></span> treewidth_cards_treewidth<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="main">(</span><span class="bound">T</span> <span class="main">::</span> nat Graph<span class="main">)</span> <span class="bound">bag</span><span class="main">.</span> TreeDecomposition <span class="free">G</span> <span class="bound">T</span> <span class="bound">bag</span> <span class="main">∧</span> treewidth <span class="main">=</span> TreeDecomposition.width <span class="bound">T</span> <span class="bound">bag</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> Min_in treewidth_cards_finite treewidth_cards_nonempty treewidth_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1"><span class="command">corollary</span></span> treewidth_upper_bound_V<span class="main">:</span> <span class="quoted"><span class="quoted">"treewidth <span class="main">≤</span> card <span class="keyword1">V</span> <span class="main">-</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> treewidth_def
  <span class="keyword1"><span class="command">using</span></span> treewidth_cards_nonempty Min_in treewidth_cards_finite treewidth_cards_upper_bound_V <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">corollary</span></span> treewidth_upper_bound_0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">V</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">⟹</span> treewidth <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> treewidth_upper_bound_V <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">corollary</span></span> treewidth_upper_bound_1<span class="main">:</span> <span class="quoted"><span class="quoted">"card <span class="keyword1">V</span> <span class="main">=</span> <span class="main">1</span> <span class="main">⟹</span> treewidth <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> treewidth_upper_bound_V <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">corollary</span></span> treewidth_lower_bound_1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">→</span><span class="free">w</span> <span class="main">⟹</span> treewidth <span class="main">≥</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> TreeDecomposition.width_lower_bound_1 treewidth_cards_treewidth <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="TreeDecomposition-treewidth_upper_bound_ex"><span class="command">lemma</span></span> treewidth_upper_bound_ex<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> TreeDecomposition <span class="free">G</span> <span class="main">(</span><span class="free">T</span> <span class="main">::</span> nat Graph<span class="main">)</span> <span class="free">bag</span><span class="main">;</span> TreeDecomposition.width <span class="free">T</span> <span class="free">bag</span> <span class="main">≤</span> <span class="free">n</span> <span class="main">⟧</span> <span class="main">⟹</span> treewidth <span class="main">≤</span> <span class="free">n</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> treewidth_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> Min_le dual_order.trans mem_Collect_eq treewidth_cards_finite<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹locale Graph›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Separations›</span></span>

<span class="keyword1"><span class="command">context</span></span> TreeDecomposition <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Every edge <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">s</span></span><span class="main"><span class="main">→</span></span><span class="hidden">⇘</span><sub><span class="free"><span class="free">T</span></span></sub><span class="hidden">⇙</span> <span class="free"><span class="free">t</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">T</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> separates <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">T</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.  In a tree decomposition,
  this edge also separates <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">G</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.  Proving this is our goal.  First, let us define the set of
  vertices appearing in the left subtree when separating the tree at <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">s</span></span> <span class="main"><span class="main">→</span></span><span class="hidden">⇘</span><sub><span class="free"><span class="free">T</span></span></sub><span class="hidden">⇙</span> <span class="free"><span class="free">t</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">left_part</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">⇒</span> <span class="tfree">'c</span> <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">left_part</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">≡</span> <span class="main">⋃</span><span class="main">{</span> <span class="free">bag</span> <span class="bound">u</span> <span class="main">|</span> <span class="bound">u</span><span class="main">.</span> <span class="bound">u</span> <span class="main">∈</span> T.left_tree <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">}</span>"</span></span>
<span class="keyword1" id="TreeDecomposition-left_partI"><span class="command">lemma</span></span> left_partI <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">v</span> <span class="main">∈</span> <span class="free">bag</span> <span class="free">u</span><span class="main">;</span> <span class="free">u</span> <span class="main">∈</span> T.left_tree <span class="free">s</span> <span class="free">t</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">v</span> <span class="main">∈</span> left_part <span class="free">s</span> <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> left_part_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="TreeDecomposition-left_part_in_V"><span class="command">lemma</span></span> left_part_in_V<span class="main">:</span> <span class="quoted"><span class="quoted">"left_part <span class="free">s</span> <span class="free">t</span> <span class="main">⊆</span> <span class="keyword1">V</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> left_part_def
  <span class="keyword1"><span class="command">using</span></span> T.left_tree_in_V bags_in_V <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Let us define the subgraph of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">T</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> induced by a vertex of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">G</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">vertex_subtree</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'c</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">vertex_subtree</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span> <span class="main">{</span> <span class="bound"><span class="bound">t</span></span> <span class="main">∈</span> <span class="keyword1">V</span><span class="hidden">⇘</span><sub><span class="free">T</span></sub><span class="hidden">⇙</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">∈</span> <span class="free">bag</span> <span class="bound">t</span> <span class="main">}</span>"</span></span>
<span class="keyword1" id="TreeDecomposition-vertex_subtreeI"><span class="command">lemma</span></span> vertex_subtreeI <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">t</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="hidden">⇘</span><sub><span class="free">T</span></sub><span class="hidden">⇙</span><span class="main">;</span> <span class="free">v</span> <span class="main">∈</span> <span class="free">bag</span> <span class="free">t</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">t</span> <span class="main">∈</span> vertex_subtree <span class="free">v</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> vertex_subtree_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The suggestive name <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> vertex_subtree<span class="antiquote"><span class="antiquote">}</span></span></span></span> is correct: Because <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">T</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is a tree
  decomposition, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"vertex_subtree <span class="free"><span class="free">v</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is a subtree (it is connected).›</span></span>
<span class="keyword1" id="TreeDecomposition-vertex_subtree_connected"><span class="command">lemma</span></span> vertex_subtree_connected<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> v<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> s<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">∈</span> vertex_subtree <span class="free">v</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> t<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">∈</span> vertex_subtree <span class="free">v</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">↝</span><span class="free">xs</span><span class="main">↝</span><span class="hidden">⇘</span><sub><span class="free">T</span></sub><span class="hidden">⇙</span> <span class="free">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"set <span class="free">xs</span> <span class="main">⊆</span> vertex_subtree <span class="free">v</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">s</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span><span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> <span class="main">[]</span>"</span></span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> Cons.prems<span class="main">(</span>3<span class="main">,</span>4<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">hence</span></span></span> <span class="quoted"><span class="quoted">"last <span class="skolem">xs</span> <span class="main">=</span> <span class="free">t</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Cons.prems<span class="main">(</span>4<span class="main">)</span> last.simps <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"T.path <span class="skolem">xs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Cons.prems<span class="main">(</span>4<span class="main">)</span> T.walk_tl <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"hd <span class="skolem">xs</span> <span class="main">∈</span> vertex_subtree <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"hd <span class="skolem">xs</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">s</span> <span class="main">↝</span><span class="hidden">⇘</span><sub><span class="free">T</span></sub><span class="hidden">⇙</span> <span class="free">t</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> T.unique_connecting_path_unique
        <span class="keyword1"><span class="command">using</span></span> Cons.prems<span class="main">(</span>4<span class="main">)</span> <span class="quoted"><span class="quoted">‹<span class="skolem">xs</span> <span class="main">≠</span> <span class="main">[]</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">bag</span> <span class="skolem">s</span> <span class="main">∩</span> <span class="free">bag</span> <span class="free">t</span> <span class="main">⊆</span> <span class="free">bag</span> <span class="main">(</span>hd <span class="skolem">xs</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> bags_continuous Cons.prems<span class="main">(</span>4<span class="main">)</span> T.connected_in_V <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="free">bag</span> <span class="main">(</span>hd <span class="skolem">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Cons.prems<span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> vertex_subtree_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"hd <span class="skolem">xs</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="hidden">⇘</span><sub><span class="free">T</span></sub><span class="hidden">⇙</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> T.connected_in_V<span class="main">(</span>1<span class="main">)</span> <span class="quoted"><span class="quoted">‹<span class="skolem">xs</span> <span class="main">≠</span> <span class="main">[]</span>›</span></span> <span class="quoted"><span class="quoted">‹T.path <span class="skolem">xs</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">xs</span> <span class="main">⊆</span> vertex_subtree <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Cons.hyps Cons.prems<span class="main">(</span>1<span class="main">,</span>3<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> Cons.prems<span class="main">(</span>2<span class="main">,</span>4<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">corollary</span></span> vertex_subtree_unique_path_connected<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">∈</span> vertex_subtree <span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">∈</span> vertex_subtree <span class="free">v</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="free">s</span> <span class="main">↝</span><span class="hidden">⇘</span><sub><span class="free">T</span></sub><span class="hidden">⇙</span> <span class="free">t</span><span class="main">)</span> <span class="main">⊆</span> vertex_subtree <span class="free">v</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms vertex_subtree_connected T.unique_connecting_path_properties
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> T.unique_connecting_path T.unique_connecting_path_unique
      mem_Collect_eq vertex_subtree_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  In order to prove that edges in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">T</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> are separations in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">G</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, we need one key lemma.
  If a vertex appears on both sides of a separation, then it also appears in the separation.
›</span></span>
<span class="keyword1" id="TreeDecomposition-vertex_in_separator"><span class="command">lemma</span></span> vertex_in_separator<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> st<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">→</span><span class="hidden">⇘</span><sub><span class="free">T</span></sub><span class="hidden">⇙</span> <span class="free">t</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> v<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> left_part <span class="free">s</span> <span class="free">t</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> left_part <span class="free">t</span> <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="free">bag</span> <span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="free">bag</span> <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u</span></span> <span class="skolem"><span class="skolem">u'</span></span> <span class="keyword2"><span class="keyword">where</span></span> u<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="free">bag</span> <span class="skolem">u</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> T.left_tree <span class="free">s</span> <span class="free">t</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="free">bag</span> <span class="skolem">u'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u'</span> <span class="main">∈</span> T.left_tree <span class="free">t</span> <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> v <span class="keyword1"><span class="command">unfolding</span></span> left_part_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">u</span> <span class="main">↝</span><span class="hidden">⇘</span><sub><span class="free">T</span></sub><span class="hidden">⇙</span> <span class="skolem">u'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> T.left_tree_separates st u <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="free">bag</span> <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> bags_continuous u <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> IntI T.left_treeE subsetCE<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">u</span> <span class="main">↝</span><span class="hidden">⇘</span><sub><span class="free">T</span></sub><span class="hidden">⇙</span> <span class="skolem">u'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> T.left_tree_separates' st u <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="free">bag</span> <span class="free">t</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> bags_continuous u <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> IntI T.left_treeE subsetCE<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Now we can show the main theorem: For every edge <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">s</span></span> <span class="main"><span class="main">→</span></span><span class="hidden">⇘</span><sub><span class="free"><span class="free">T</span></span></sub><span class="hidden">⇙</span> <span class="free"><span class="free">t</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">T</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, the
  set <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">bag</span></span> <span class="free"><span class="free">s</span></span> <span class="main"><span class="main">∩</span></span> <span class="free"><span class="free">bag</span></span> <span class="free"><span class="free">t</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is a separator of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">G</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.  That is, every path from the left part
  to the right part goes through <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">bag</span></span> <span class="free"><span class="free">s</span></span> <span class="main"><span class="main">∩</span></span> <span class="free"><span class="free">bag</span></span> <span class="free"><span class="free">t</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>
<span class="keyword1"><span class="command">theorem</span></span> bags_separate<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> st<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">→</span><span class="hidden">⇘</span><sub><span class="free">T</span></sub><span class="hidden">⇙</span> <span class="free">t</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> v<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> left_part <span class="free">s</span> <span class="free">t</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> w<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> left_part <span class="free">t</span> <span class="free">s</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">↝</span><span class="free">xs</span><span class="main">↝</span> <span class="free">w</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"set <span class="free">xs</span> <span class="main">∩</span> <span class="free">bag</span> <span class="free">s</span> <span class="main">∩</span> <span class="free">bag</span> <span class="free">t</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="var">?thesis</span>"</span></span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> set <span class="free">xs</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> xs v <span class="quoted"><span class="quoted">‹<span class="main">¬</span><span class="var">?thesis</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"vertex_subtree <span class="skolem">u</span> <span class="main">⊆</span> T.left_tree <span class="free">s</span> <span class="free">t</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">v</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x</span> <span class="skolem">xs</span> <span class="skolem">v</span><span class="main">)</span>
      <span class="keyword1"><span class="command">hence</span></span> contra<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∉</span> <span class="free">bag</span> <span class="free">s</span> <span class="main">∨</span> <span class="skolem">v</span> <span class="main">∉</span> <span class="free">bag</span> <span class="free">t</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> path_from_toE IntI empty_iff hd_in_set<span class="main">)</span>
      <span class="keyword1"><span class="command">{</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">u</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>vertex_subtree <span class="skolem">u</span> <span class="main">⊆</span> T.left_tree <span class="free">s</span> <span class="free">t</span>"</span></span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">z</span></span> <span class="keyword2"><span class="keyword">where</span></span> z<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> vertex_subtree <span class="skolem">u</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∉</span> T.left_tree <span class="free">s</span> <span class="free">t</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> vertex_subtree <span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Cons.prems<span class="main">(</span>1<span class="main">,</span>3<span class="main">)</span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">u</span>›</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> list.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> path_from_to_def<span class="main">)</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> left_part <span class="free">t</span> <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> vertex_subtree_def
          <span class="keyword1"><span class="command">using</span></span> T.left_tree_union_V z st <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> vertex_in_separator contra st Cons.prems<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">}</span></span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≠</span> <span class="skolem">u</span>"</span></span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> set <span class="skolem">xs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Cons.prems<span class="main">(</span>4<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">hence</span></span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">≠</span> Nil"</span></span> <span class="keyword1"><span class="command">using</span></span> empty_iff list.set<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">hence</span></span></span> <span class="quoted"><span class="quoted">"last <span class="skolem">xs</span> <span class="main">=</span> <span class="free">w</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Cons.prems<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path <span class="skolem">xs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Cons.prems<span class="main">(</span>1<span class="main">)</span> walk_tl <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"hd <span class="skolem">xs</span> <span class="main">∈</span> left_part <span class="free">s</span> <span class="free">t</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">→</span>hd <span class="skolem">xs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Cons.prems<span class="main">(</span>1<span class="main">,</span>3<span class="main">)</span> <span class="quoted"><span class="quoted">‹<span class="skolem">xs</span> <span class="main">≠</span> Nil›</span></span> walk_first_edge' <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u'</span></span> <span class="keyword2"><span class="keyword">where</span></span> u'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">u'</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="hidden">⇘</span><sub><span class="free">T</span></sub><span class="hidden">⇙</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> <span class="free">bag</span> <span class="skolem">u'</span>"</span></span> <span class="quoted"><span class="quoted">"hd <span class="skolem">xs</span> <span class="main">∈</span> <span class="free">bag</span> <span class="skolem">u'</span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> bags_edges <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u'</span> <span class="main">∈</span> T.left_tree <span class="free">s</span> <span class="free">t</span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> contra vertex_in_separator st T.left_tree_union_V Cons.prems<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
          <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> u'<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> left_part_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>set <span class="skolem">xs</span> <span class="main">∩</span> <span class="free">bag</span> <span class="free">s</span> <span class="main">∩</span> <span class="free">bag</span> <span class="free">t</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Cons.prems<span class="main">(</span>3<span class="main">)</span>
          IntI disjoint_iff_not_equal inf_le1 inf_le2 set_subset_Cons subsetCE <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"vertex_subtree <span class="skolem">u</span> <span class="main">⊆</span> T.left_tree <span class="free">s</span> <span class="free">t</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Cons.hyps <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">}</span></span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"vertex_subtree <span class="free">w</span> <span class="main">⊆</span> T.left_tree <span class="free">s</span> <span class="free">t</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> xs last_in_set <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"vertex_subtree <span class="free">w</span> <span class="main">∩</span> T.left_tree <span class="free">t</span> <span class="free">s</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> w
    <span class="keyword1"><span class="command">unfolding</span></span> left_part_def T.left_tree_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> T.left_tree_disjoint st <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹It follows that vertices cannot be dropped from a bag if they have a neighbor that has
  not been visited yet (that is, a neighbor that is strictly in the right part of the separation).›</span></span>
<span class="keyword1"><span class="command">corollary</span></span> bag_no_drop<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> st<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">→</span><span class="hidden">⇘</span><sub><span class="free">T</span></sub><span class="hidden">⇙</span> <span class="free">t</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> vw<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">→</span><span class="free">w</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> v<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="free">bag</span> <span class="free">s</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> w<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∉</span> <span class="free">bag</span> <span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> left_part <span class="free">t</span> <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="free">bag</span> <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">↝</span><span class="main">[</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">]</span><span class="main">↝</span> <span class="free">w</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> v vw w<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"set <span class="main">[</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">]</span> <span class="main">∩</span> <span class="free">bag</span> <span class="free">s</span> <span class="main">∩</span> <span class="free">bag</span> <span class="free">t</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> st v w<span class="main">(</span>2<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> T.edges_are_in_V T.left_tree_initial bags_separate left_partI<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> w<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹locale TreeDecomposition›</span>
<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="TreewidthTree">
<div class="head">
<h1>Theory TreewidthTree</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Treewidth of Trees›</span></span>

<span class="keyword1"><span class="command">theory</span></span> TreewidthTree
<span class="keyword2"><span class="keyword">imports</span></span> <a href="#TreeDecomposition">TreeDecomposition</a> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The treewidth of a tree is 1 if the tree has at least one edge, otherwise it is 0.

  For simplicity and without loss of generality, we assume that the vertex set of the tree is a
  subset of the natural numbers because this is what we use in the definition of
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> Graph.treewidth<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

  While it would be nice to lift this restriction, removing it would entail defining isomorphisms
  between graphs in order to map the tree decomposition to a tree decomposition over the natural
  numbers.  This is outside the scope of this theory and probably not terribly interesting by
  itself.›</span></span>
<span class="keyword1"><span class="command">theorem</span></span> treewidth_tree<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat Graph"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">structure</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Tree <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Graph.treewidth <span class="free">G</span> <span class="main">≤</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> Tree <span class="quoted"><span class="free">G</span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">V</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">root</span></span> <span class="keyword2"><span class="keyword">where</span></span> root<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">root</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> RootedTree <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="skolem">root</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">bag</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">bag</span> <span class="skolem">v</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="skolem">v</span> <span class="main">=</span> <span class="skolem">root</span> <span class="keyword1">then</span> <span class="main">{</span><span class="skolem">v</span><span class="main">}</span> <span class="keyword1">else</span> <span class="main">{</span><span class="skolem">v</span><span class="main">,</span> parent <span class="skolem">v</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">v</span>
    <span class="keyword1"><span class="command">have</span></span> v_in_bag<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">v</span><span class="main">.</span> <span class="bound">v</span> <span class="main">∈</span> <span class="skolem">bag</span> <span class="bound">v</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> bag_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">have</span></span> bag_in_V<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">v</span><span class="main">.</span> <span class="bound">v</span> <span class="main">∈</span> <span class="keyword1">V</span> <span class="main">⟹</span> <span class="skolem">bag</span> <span class="bound">v</span> <span class="main">⊆</span> <span class="keyword1">V</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> bag_def
      <span class="keyword1"><span class="command">using</span></span> parent_in_V empty_subsetI insert_subset <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"TreeDecomposition <span class="free">G</span> <span class="free">G</span> <span class="skolem">bag</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋃</span><span class="main">{</span><span class="skolem">bag</span> <span class="bound">t</span> <span class="main">|</span> <span class="bound">t</span><span class="main">.</span> <span class="bound">t</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="main">}</span> <span class="main">=</span> <span class="keyword1">V</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> bag_in_V v_in_bag <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v</span> <span class="skolem">w</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">→</span><span class="skolem">w</span>"</span></span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">v'</span> <span class="bound">w'</span><span class="main">.</span> <span class="main">⟦</span> <span class="bound">v'</span><span class="main">→</span><span class="bound">w'</span><span class="main">;</span> <span class="bound">v'</span> <span class="main">≠</span> <span class="skolem">root</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="bound">w'</span> <span class="main">∈</span> <span class="skolem">bag</span> <span class="bound">v'</span> <span class="main">∨</span> <span class="bound">v'</span> <span class="main">∈</span> <span class="skolem">bag</span> <span class="bound">w'</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> bag_def
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> insertI2 parent_edge_cases parent_edge_root singletonI<span class="main">)</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> <span class="skolem">bag</span> <span class="skolem">w</span> <span class="main">∨</span> <span class="skolem">w</span> <span class="main">∈</span> <span class="skolem">bag</span> <span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> no_loops undirected <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">t</span><span class="main">∈</span><span class="keyword1">V</span><span class="main">.</span> <span class="skolem">v</span> <span class="main">∈</span> <span class="skolem">bag</span> <span class="bound">t</span> <span class="main">∧</span> <span class="skolem">w</span> <span class="main">∈</span> <span class="skolem">bag</span> <span class="bound">t</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">v</span><span class="main">→</span><span class="skolem">w</span>›</span></span> edges_are_in_V v_in_bag <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">s</span> <span class="skolem">u</span> <span class="skolem">t</span> <span class="keyword3"><span class="command">assume</span></span> s<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> u<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> t<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">t</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">s</span><span class="main">↝</span><span class="skolem">u</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">t</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> t <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> s subsetCE u unique_connecting_path_properties<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> walk_in_V<span class="main">)</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span> <span class="main">=</span> <span class="skolem">u</span> <span class="main">⟹</span> <span class="skolem">t</span> <span class="main">=</span> <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> left_tree_initial' s t <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span><span class="main">→</span><span class="skolem">u</span> <span class="main">⟹</span> <span class="skolem">t</span> <span class="main">=</span> <span class="skolem">s</span> <span class="main">∨</span> <span class="skolem">t</span> <span class="main">=</span> <span class="skolem">u</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> s t u <span class="quoted"><span class="quoted">‹<span class="skolem">t</span> <span class="main">∈</span> <span class="keyword1">V</span>›</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> insertE left_treeI left_tree_initial' list.exhaust_sel list.simps<span class="main"><span class="main">(</span></span>15<span class="main"><span class="main">)</span></span>
            undirected unique_connecting_path_properties<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">,</span></span>3<span class="main"><span class="main">)</span></span> unique_connecting_path_set<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span>
            unique_connecting_path_tl<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
        <span class="keyword3"><span class="command">assume</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span> <span class="main">≠</span> <span class="skolem">u</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="skolem">s</span><span class="main">→</span><span class="skolem">u</span>"</span></span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span> <span class="main">=</span> <span class="skolem">root</span> <span class="main">⟹</span> <span class="skolem">bag</span> <span class="skolem">s</span> <span class="main">∩</span> <span class="skolem">bag</span> <span class="skolem">u</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> bag_def
          <span class="keyword1"><span class="command">using</span></span> *<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span> parent_edge u undirected <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">=</span> <span class="skolem">root</span> <span class="main">⟹</span> <span class="skolem">bag</span> <span class="skolem">s</span> <span class="main">∩</span> <span class="skolem">bag</span> <span class="skolem">u</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> bag_def
          <span class="keyword1"><span class="command">using</span></span> *<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span> parent_edge s <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="skolem">s</span> <span class="main">≠</span> <span class="skolem">root</span><span class="main">;</span> <span class="skolem">u</span> <span class="main">≠</span> <span class="skolem">root</span><span class="main">;</span> parent <span class="skolem">s</span> <span class="main">≠</span> parent <span class="skolem">u</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="skolem">bag</span> <span class="skolem">s</span> <span class="main">∩</span> <span class="skolem">bag</span> <span class="skolem">u</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
          <span class="keyword1"><span class="command">unfolding</span></span> bag_def <span class="keyword1"><span class="command">using</span></span> *<span class="main">(</span>2<span class="main">)</span> parent_edge s u undirected <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
          <span class="keyword3"><span class="command">assume</span></span> **<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span> <span class="main">≠</span> <span class="skolem">root</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">≠</span> <span class="skolem">root</span>"</span></span> <span class="quoted"><span class="quoted">"parent <span class="skolem">s</span> <span class="main">=</span> parent <span class="skolem">u</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">t</span> <span class="main">≠</span> <span class="skolem">s</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">t</span> <span class="main">≠</span> <span class="skolem">u</span>"</span></span>
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">bag</span> <span class="skolem">s</span> <span class="main">∩</span> <span class="skolem">bag</span> <span class="skolem">u</span> <span class="main">=</span> <span class="main">{</span> parent <span class="skolem">s</span> <span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> bag_def <span class="keyword1"><span class="command">using</span></span> *<span class="main">(</span>1<span class="main">)</span> **<span class="main">(</span>1-3<span class="main">)</span>
            Int_insert_left inf.orderE insertE insert_absorb subset_insertI <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">t</span> <span class="main">=</span> parent <span class="skolem">s</span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> sibling_path<span class="main">[</span><span class="operator">OF</span> s **<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> u **<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> *<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> **<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">]</span> t **<span class="main">(</span>4<span class="main">,</span>5<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">bag</span> <span class="skolem">s</span> <span class="main">∩</span> <span class="skolem">bag</span> <span class="skolem">u</span> <span class="main">⊆</span> <span class="skolem">bag</span> <span class="skolem">t</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> v_in_bag<span class="main">)</span>
        <span class="keyword1"><span class="command">}</span></span>
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">bag</span> <span class="skolem">s</span> <span class="main">∩</span> <span class="skolem">bag</span> <span class="skolem">u</span> <span class="main">⊆</span> <span class="skolem">bag</span> <span class="skolem">t</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">}</span></span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">bag</span> <span class="skolem">s</span> <span class="main">∩</span> <span class="skolem">bag</span> <span class="skolem">u</span> <span class="main">⊆</span> <span class="skolem">bag</span> <span class="skolem">t</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> TreeDecomposition <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="skolem">bag</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="main">{</span> <span class="skolem">v</span><span class="main">,</span> parent <span class="skolem">v</span> <span class="main">}</span> <span class="main">≤</span> <span class="numeral">2</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> card.insert card.empty finite.emptyI finite_insert insert_absorb insert_not_empty
            lessI less_or_eq_imp_le numerals<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span><span class="skolem">bag</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">≤</span> <span class="numeral">2</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> bag_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"max_bag_card <span class="main">≤</span> <span class="numeral">2</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="keyword1">V</span> <span class="main">≠</span> <span class="main">{}</span>›</span></span> max_bag_card_in_bag_cards <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"width <span class="main">≤</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> width_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">‹<span class="keyword1">V</span> <span class="main">≠</span> <span class="main">{}</span>›</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">bag</span><span class="main">.</span> TreeDecomposition <span class="free">G</span> <span class="free">G</span> <span class="bound">bag</span> <span class="main">∧</span> TreeDecomposition.width <span class="free">G</span> <span class="bound">bag</span> <span class="main">≤</span> <span class="main">1</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> TreeDecomposition_axioms <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> TreeDecomposition.width_V_empty le_0_eq linear
    treewidth_cards_treewidth treewidth_upper_bound_ex<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹If the tree is non-trivial, that is, if it contains more than one vertex, then its
  treewidth is exactly 1.›</span></span>
<span class="keyword1"><span class="command">corollary</span></span> treewidth_tree_exact<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat Graph"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">structure</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Tree <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"card <span class="keyword1">V</span><span class="hidden">⇘</span><sub><span class="free">G</span></sub><span class="hidden">⇙</span> <span class="main">&gt;</span> <span class="main">1</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Graph.treewidth <span class="free">G</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms Graph.treewidth_lower_bound_1 Tree.tree_has_edge Tree_def treewidth_tree
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="TreewidthCompleteGraph">
<div class="head">
<h1>Theory TreewidthCompleteGraph</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Treewidth of Complete Graphs›</span></span>

<span class="keyword1"><span class="command">theory</span></span> TreewidthCompleteGraph
<span class="keyword2"><span class="keyword">imports</span></span> <a href="#TreeDecomposition">TreeDecomposition</a> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹As an application of the separator theorem <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>bags_separate›</span></span></span></span>, or more precisely its
  corollary <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>bag_no_drop›</span></span></span></span>, we show that a complete graph of size <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">n</span></span> <span class="main"><span class="main">::</span></span> nat"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
  (a clique) has treewidth <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="free"><span class="free">n</span></span><span class="main"><span class="main">::</span></span>nat<span class="main"><span class="main">)</span></span><span class="main"><span class="main">-</span></span><span class="main"><span class="main">1</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>
<span class="keyword1"><span class="command">theorem</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Graph<span class="main">)</span> treewidth_complete_graph<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">v</span> <span class="bound">w</span><span class="main">.</span> <span class="main">⟦</span> <span class="bound">v</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="main">;</span> <span class="bound">w</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="main">;</span> <span class="bound">v</span> <span class="main">≠</span> <span class="bound">w</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="bound">v</span><span class="main">→</span><span class="bound">w</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"treewidth <span class="main">=</span> card <span class="keyword1">V</span> <span class="main">-</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">V</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">T</span></span> <span class="skolem"><span class="skolem">bag</span></span> <span class="keyword2"><span class="keyword">where</span></span>
      T<span class="main">:</span> <span class="quoted"><span class="quoted">"TreeDecomposition <span class="free">G</span> <span class="main">(</span><span class="skolem">T</span> <span class="main">::</span> nat Graph<span class="main">)</span> <span class="skolem">bag</span>"</span></span> <span class="quoted"><span class="quoted">"treewidth <span class="main">=</span> TreeDecomposition.width <span class="skolem">T</span> <span class="skolem">bag</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> treewidth_cards_treewidth <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">interpret</span></span> TreeDecomposition <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="skolem">T</span></span> <span class="quoted"><span class="skolem">bag</span></span> <span class="keyword1"><span class="command">using</span></span> T<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">.</span></span>

    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="var">?thesis</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"width <span class="main">≠</span> card <span class="keyword1">V</span> <span class="main">-</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> T<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Let <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">s</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> be a bag of maximal size.›</span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">s</span></span> <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="hidden">⇘</span><sub><span class="skolem">T</span></sub><span class="hidden">⇙</span>"</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span><span class="skolem">bag</span> <span class="skolem">s</span><span class="main">)</span> <span class="main">=</span> max_bag_card"</span></span>
      <span class="keyword1"><span class="command">using</span></span> max_bag_card_in_bag_cards <span class="quoted"><span class="quoted">‹<span class="keyword1">V</span> <span class="main">≠</span> <span class="main">{}</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The treewidth cannot be larger than <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"card <span class="keyword1"><span class="keyword1">V</span></span> <span class="main"><span class="main">-</span></span> <span class="main"><span class="main">1</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, so due to our assumption
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"width <span class="main"><span class="main">≠</span></span> card <span class="keyword1"><span class="keyword1">V</span></span> <span class="main"><span class="main">-</span></span> <span class="main"><span class="main">1</span></span>"</span></span> <span class="antiquote"><span class="antiquote">}</span></span></span></span> it must be smaller, hence <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"card <span class="main"><span class="main">(</span></span><span class="skolem"><span class="skolem">bag</span></span> <span class="skolem"><span class="skolem">s</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">&lt;</span></span> card <span class="keyword1"><span class="keyword1">V</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span><span class="skolem">bag</span> <span class="skolem">s</span><span class="main">)</span> <span class="main">&lt;</span> card <span class="keyword1">V</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> width_def
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="keyword1">V</span> <span class="main">≠</span> <span class="main">{}</span>›</span></span> empty_tree_empty_V le_eq_less_or_eq max_bag_card_upper_bound_V <span class="keyword1"><span class="command">by</span></span> <span class="operator">presburger</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="keyword2"><span class="keyword">where</span></span> v<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> <span class="keyword1">V</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∉</span> <span class="skolem">bag</span> <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> bag_finite card_mono not_less s<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> subsetI<span class="main">)</span>

    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹There exists a bag containing <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">v</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.  We consider the path from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">s</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">t</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and find that somewhere along this path there exists a bag containing
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"insert <span class="skolem"><span class="skolem">v</span></span> <span class="main"><span class="main">(</span></span><span class="skolem"><span class="skolem">bag</span></span> <span class="skolem"><span class="skolem">s</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, which is a contradiction because such a bag would be too big.›</span></span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">t</span></span> <span class="keyword2"><span class="keyword">where</span></span> t<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">t</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="hidden">⇘</span><sub><span class="skolem">T</span></sub><span class="hidden">⇙</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> <span class="skolem">bag</span> <span class="skolem">t</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> bags_exist v<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">with</span></span> s <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">t</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="hidden">⇘</span><sub><span class="skolem">T</span></sub><span class="hidden">⇙</span><span class="main">.</span> insert <span class="skolem">v</span> <span class="main">(</span><span class="skolem">bag</span> <span class="skolem">s</span><span class="main">)</span> <span class="main">⊆</span> <span class="skolem">bag</span> <span class="bound">t</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span> <span class="main">↝</span><span class="hidden">⇘</span><sub><span class="skolem">T</span></sub><span class="hidden">⇙</span> <span class="skolem">t</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">s</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> T.unique_connecting_path_properties<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x</span> <span class="skolem">xs</span> <span class="skolem">s</span><span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span><span class="main">)</span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> <span class="skolem">bag</span> <span class="skolem">s</span>"</span></span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> t Cons.prems<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∉</span> <span class="skolem">bag</span> <span class="skolem">s</span>"</span></span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span> <span class="main">≠</span> <span class="skolem">t</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> t<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">≠</span> Nil"</span></span> <span class="keyword1"><span class="command">using</span></span> Cons.hyps<span class="main">(</span>2<span class="main">)</span> Cons.prems<span class="main">(</span>1<span class="main">,</span>3<span class="main">)</span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> T.unique_connecting_path_properties<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">,</span></span>4<span class="main"><span class="main">)</span></span> last_ConsL list.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Cons.hyps<span class="main">(</span>2<span class="main">)</span> Cons.prems<span class="main">(</span>1<span class="main">)</span> t<span class="main">(</span>1<span class="main">)</span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> T.unique_connecting_path_properties<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> list.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">s'</span></span> <span class="skolem"><span class="skolem">xs'</span></span> <span class="keyword2"><span class="keyword">where</span></span> s'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span> <span class="main">#</span> <span class="skolem">s'</span> <span class="main">#</span> <span class="skolem">xs'</span> <span class="main">=</span> <span class="skolem">s</span> <span class="main">↝</span><span class="hidden">⇘</span><sub><span class="skolem">T</span></sub><span class="hidden">⇙</span> <span class="skolem">t</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> Cons.hyps<span class="main">(</span>2<span class="main">)</span> list.exhaust <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> st_path<span class="main">:</span> <span class="quoted"><span class="quoted">"T.path <span class="main">(</span><span class="skolem">s</span> <span class="main">↝</span><span class="hidden">⇘</span><sub><span class="skolem">T</span></sub><span class="hidden">⇙</span> <span class="skolem">t</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Cons.prems<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> T.unique_connecting_path_properties<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> t<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s'</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="hidden">⇘</span><sub><span class="skolem">T</span></sub><span class="hidden">⇙</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> T.edges_are_in_V<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> T.path_first_edge<span class="main">)</span>
        <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Bags can never drop vertices because every vertex has a neighbor in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">G</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> which
          has not yet been visited.›</span></span>
        <span class="keyword1"><span class="command">have</span></span> s_in_s'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">bag</span> <span class="skolem">s</span> <span class="main">⊆</span> <span class="skolem">bag</span> <span class="skolem">s'</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span>
          <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">w</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">∈</span> <span class="skolem">bag</span> <span class="skolem">s</span>"</span></span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span> <span class="main">→</span><span class="hidden">⇘</span><sub><span class="skolem">T</span></sub><span class="hidden">⇙</span> <span class="skolem">s'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> s' st_path <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> T.walk_first_edge<span class="main">)</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> left_part <span class="skolem">s'</span> <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Cons.prems<span class="main">(</span>1<span class="main">,</span>4<span class="main">)</span> s' t<span class="main">(</span>1<span class="main">)</span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> T.left_treeI T.unique_connecting_path_rev insert_subset left_partI
                list.simps<span class="main"><span class="main">(</span></span>15<span class="main"><span class="main">)</span></span> set_rev subsetI<span class="main">)</span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">∈</span> <span class="skolem">bag</span> <span class="skolem">s'</span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> bag_no_drop Cons.prems<span class="main">(</span>1<span class="main">,</span>4<span class="main">)</span> <span class="quoted"><span class="quoted">‹<span class="skolem">v</span> <span class="main">∉</span> <span class="skolem">bag</span> <span class="skolem">s</span>›</span></span> assms bags_in_V v<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Bags can never gain vertices because we started with a bag of maximal size.›</span></span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span><span class="skolem">bag</span> <span class="skolem">s'</span><span class="main">)</span> <span class="main">≤</span> card <span class="main">(</span><span class="skolem">bag</span> <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span><span class="skolem">bag</span> <span class="skolem">s'</span><span class="main">)</span> <span class="main">≤</span> max_bag_card"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> max_bag_card_def
            <span class="keyword1"><span class="command">using</span></span> Max_ge <span class="quoted"><span class="quoted">‹<span class="skolem">s'</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="hidden">⇘</span><sub><span class="skolem">T</span></sub><span class="hidden">⇙</span>›</span></span> bag_cards_finite <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
          <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> Cons.prems<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">bag</span> <span class="skolem">s'</span> <span class="main">=</span> <span class="skolem">bag</span> <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">s'</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="hidden">⇘</span><sub><span class="skolem">T</span></sub><span class="hidden">⇙</span>›</span></span> bag_finite card_seteq <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command">using</span></span> Cons.hyps Cons.prems<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span> <span class="quoted"><span class="quoted">‹<span class="skolem">s'</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="hidden">⇘</span><sub><span class="skolem">T</span></sub><span class="hidden">⇙</span>›</span></span> t s' st_path <span class="quoted"><span class="quoted">‹<span class="skolem">xs</span> <span class="main">≠</span> <span class="main">[]</span>›</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> T.path_from_toI T.path_tl T.unique_connecting_path_properties<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span>
              T.unique_connecting_path_unique last.simps list.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">t</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="hidden">⇘</span><sub><span class="skolem">T</span></sub><span class="hidden">⇙</span><span class="main">.</span> card <span class="main">(</span><span class="skolem">bag</span> <span class="skolem">s</span><span class="main">)</span> <span class="main">&lt;</span> card <span class="main">(</span><span class="skolem">bag</span> <span class="bound">t</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> v<span class="main">(</span>2<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> bag_finite card_seteq insert_subset not_le<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> s Max.coboundedI bag_cards_finite not_le <span class="keyword1"><span class="command">unfolding</span></span> max_bag_card_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> treewidth_upper_bound_V card.empty diff_diff_cancel zero_diff <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="ExampleInstantiations">
<div class="head">
<h1>Theory ExampleInstantiations</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Example Instantiations›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  This section provides a few example instantiations for the locales to show that they are not empty.
›</span></span>

<span class="keyword1"><span class="command">theory</span></span> ExampleInstantiations
<span class="keyword2"><span class="keyword">imports</span></span> <a href="#TreewidthCompleteGraph">TreewidthCompleteGraph</a> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">datatype</span></span> Vertices <span class="main">=</span> u0 <span class="main">|</span> v0 <span class="main">|</span> w0

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The empty graph is a tree.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">T1</span> <span class="main">≡</span> <span class="main">⦇</span> verts <span class="main">=</span> <span class="main">{}</span><span class="main">,</span> arcs <span class="main">=</span> <span class="main">{}</span> <span class="main">⦈</span>"</span></span>
<span class="keyword1"><span class="command">interpretation</span></span> Graph_T1<span class="main">:</span> Graph <span class="quoted">T1</span> <span class="keyword1"><span class="command">unfolding</span></span> T1_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">interpretation</span></span> Tree_T1<span class="main">:</span> Tree <span class="quoted">T1</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Tree.intro<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Graph_T1.Graph_axioms<span class="main"><span class="keyword3">,</span></span> <span class="operator">standard</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">unfold</span> T1_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
     <span class="main">(</span><span class="operator">metis</span> T1_def Graph_T1.cycle_def equals0D simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The complete graph with 2 vertices.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">T2</span> <span class="main">≡</span> <span class="main">⦇</span> verts <span class="main">=</span> <span class="main">{</span>u0<span class="main">,</span> v0<span class="main">}</span><span class="main">,</span> arcs <span class="main">=</span> <span class="main">{</span><span class="main">(</span>u0<span class="main">,</span>v0<span class="main">)</span><span class="main">,</span><span class="main">(</span>v0<span class="main">,</span>u0<span class="main">)</span><span class="main">}</span> <span class="main">⦈</span>"</span></span>
<span class="keyword1" id="ExampleInstantiations-Graph_T2"><span class="command">lemma</span></span> Graph_T2<span class="main">:</span> <span class="quoted"><span class="quoted">"Graph T2"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> T2_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="operator">auto</span>
<span class="keyword1" id="ExampleInstantiations-Tree_T2"><span class="command">lemma</span></span> Tree_T2<span class="main">:</span> <span class="quoted"><span class="quoted">"Tree T2"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> Graph <span class="quoted">T2</span> <span class="keyword1"><span class="command">using</span></span> Graph_T2 <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v</span> <span class="skolem">w</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="hidden">⇘</span><sub>T2</sub><span class="hidden">⇙</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="hidden">⇘</span><sub>T2</sub><span class="hidden">⇙</span>"</span></span> <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"connected <span class="skolem">v</span> <span class="skolem">w</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> T2_def connected_def connected_edge empty_iff insert_iff last.simps list.discI
          list.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> path_singleton simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Vertices list"</span></span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"cycle <span class="skolem">xs</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> xy<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span> <span class="main">=</span> v0 <span class="main">∧</span> <span class="skolem">y</span> <span class="main">=</span> u0<span class="main">)</span> <span class="main">∨</span> <span class="main">(</span><span class="skolem">x</span> <span class="main">=</span> u0 <span class="main">∧</span> <span class="skolem">y</span> <span class="main">=</span> v0<span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"hd <span class="skolem">xs</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"last <span class="skolem">xs</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> T2_def cycleE distinct.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> distinct_singleton insert_iff list.set<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span>
            prod.inject simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">v</span><span class="main">.</span> <span class="bound">v</span> <span class="main">∈</span> set <span class="skolem">xs</span> <span class="main">⟹</span> <span class="bound">v</span> <span class="main">=</span> <span class="skolem">x</span> <span class="main">∨</span> <span class="bound">v</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹cycle <span class="skolem">xs</span>›</span></span> xy
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> cycle_def walk_in_V T2_def empty_iff insertE insert_absorb insert_subset
            select_convs<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> <span class="main">[</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹cycle <span class="skolem">xs</span>›</span></span> xy
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> cycleE distinct_length_2_or_more last.simps list.exhaust_sel list.set_sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span>
            list.set_sel<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> no_loops<span class="main">)</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹cycle <span class="skolem">xs</span>›</span></span> <span class="keyword1"><span class="command">unfolding</span></span> cycle_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>cycle <span class="skolem">xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> T2_def cycleE empty_iff insertE prod.inject simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹As expected, the treewidth of the complete graph with 2 vertices is 1.

  Note that we use <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Graph.treewidth_complete_graph›</span></span></span></span> here and not <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>treewidth_tree›</span></span></span></span>.
  This is because <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>treewidth_tree›</span></span></span></span> requires the vertex set of the graph to be a set of
  natural numbers, which is not the case here.›</span></span>
<span class="keyword1" id="ExampleInstantiations-T2_complete"><span class="command">lemma</span></span> T2_complete<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">v</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="hidden">⇘</span><sub>T2</sub><span class="hidden">⇙</span><span class="main">;</span> <span class="free">w</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="hidden">⇘</span><sub>T2</sub><span class="hidden">⇙</span><span class="main">;</span> <span class="free">v</span> <span class="main">≠</span> <span class="free">w</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">v</span> <span class="main">→</span><span class="hidden">⇘</span><sub>T2</sub><span class="hidden">⇙</span> <span class="free">w</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> T2_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1" id="ExampleInstantiations-treewidth_T2"><span class="command">lemma</span></span> treewidth_T2<span class="main">:</span> <span class="quoted"><span class="quoted">"Graph.treewidth T2 <span class="main">=</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> Graph.treewidth_complete_graph<span class="main">[</span><span class="operator">OF</span> Graph_T2<span class="main">]</span> T2_complete <span class="keyword1"><span class="command">unfolding</span></span> T2_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The complete graph with 3 vertices.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">T3</span> <span class="main">≡</span> <span class="main">⦇</span> verts <span class="main">=</span> <span class="main">{</span>u0<span class="main">,</span> v0<span class="main">,</span> w0<span class="main">}</span><span class="main">,</span> arcs <span class="main">=</span> <span class="main">{</span><span class="main">(</span>u0<span class="main">,</span>v0<span class="main">)</span><span class="main">,</span><span class="main">(</span>v0<span class="main">,</span>u0<span class="main">)</span><span class="main">,</span><span class="main">(</span>v0<span class="main">,</span>w0<span class="main">)</span><span class="main">,</span><span class="main">(</span>w0<span class="main">,</span>v0<span class="main">)</span><span class="main">,</span><span class="main">(</span>w0<span class="main">,</span>u0<span class="main">)</span><span class="main">,</span><span class="main">(</span>u0<span class="main">,</span>w0<span class="main">)</span><span class="main">}</span> <span class="main">⦈</span>"</span></span>
<span class="keyword1" id="ExampleInstantiations-Graph_T3"><span class="command">lemma</span></span> Graph_T3<span class="main">:</span> <span class="quoted"><span class="quoted">"Graph T3"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> T3_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">[</span></span>u0<span class="main"><span class="main">,</span></span> v0<span class="main"><span class="main">,</span></span> w0<span class="main"><span class="main">]</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is a cycle in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "T3"<span class="antiquote"><span class="antiquote">}</span></span></span></span>, so <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "T3"<span class="antiquote"><span class="antiquote">}</span></span></span></span> is not a tree.›</span></span>
<span class="keyword1" id="ExampleInstantiations-Not_Tree_T3"><span class="command">lemma</span></span> Not_Tree_T3<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>Tree T3"</span></span> <span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"Tree T3"</span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> Tree <span class="quoted">T3</span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?xs</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">[</span>u0<span class="main">,</span> v0<span class="main">,</span> w0<span class="main">]</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path <span class="var">?xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> T3_def Vertices.distinct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>3<span class="main"><span class="main">,</span></span>5<span class="main"><span class="main">)</span></span>
    distinct_length_2_or_more distinct_singleton insert_iff simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> walk.Cons walk_2<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>hd <span class="var">?xs</span><span class="main">,</span> last <span class="var">?xs</span><span class="main">)</span> <span class="main">∈</span> arcs T3"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> T3_def<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> meeting_paths_produce_cycle no_cycles walk_2
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> distinct_length_2_or_more last_ConsL last_ConsR list.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="ExampleInstantiations-T3_complete"><span class="command">lemma</span></span> T3_complete<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">v</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="hidden">⇘</span><sub>T3</sub><span class="hidden">⇙</span><span class="main">;</span> <span class="free">w</span> <span class="main">∈</span> <span class="keyword1">V</span><span class="hidden">⇘</span><sub>T3</sub><span class="hidden">⇙</span><span class="main">;</span> <span class="free">v</span> <span class="main">≠</span> <span class="free">w</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">v</span> <span class="main">→</span><span class="hidden">⇘</span><sub>T3</sub><span class="hidden">⇙</span> <span class="free">w</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> T3_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1" id="ExampleInstantiations-treewidth_T3"><span class="command">lemma</span></span> treewidth_T3<span class="main">:</span> <span class="quoted"><span class="quoted">"Graph.treewidth T3 <span class="main">=</span> <span class="numeral">2</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> Graph.treewidth_complete_graph<span class="main">[</span><span class="operator">OF</span> Graph_T3<span class="main">]</span> T3_complete <span class="keyword1"><span class="command">unfolding</span></span> T3_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We omit a concrete example for the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>TreeDecomposition›</span></span></span></span> locale because
  <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>tree_decomposition_exists›</span></span></span></span> already shows that it is non-empty.›</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div>