<div id="State_Monad_Ext">
<div class="head">
<h1>Theory State_Monad_Ext</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹State Monad›</span></span>

<span class="keyword1"><span class="command">theory</span></span> State_Monad_Ext
  <span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/State_Monad.html">HOL-Library.State_Monad</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fun_app_lifted</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'M</span><span class="main">,</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'M</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> state<span class="main">)</span> state <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'M</span><span class="main">,</span><span class="tfree">'a</span><span class="main">)</span> state <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'M</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> state"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">fun_app_lifted</span> <span class="free"><span class="bound"><span class="entity">f<span class="hidden">⇩</span><sub>T</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">x<span class="hidden">⇩</span><sub>T</sub></span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span> <span class="bound">f</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">f<span class="hidden">⇩</span><sub>T</sub></span></span></span><span class="main">;</span> <span class="bound">x</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">x<span class="hidden">⇩</span><sub>T</sub></span></span></span><span class="main">;</span> <span class="bound">f</span> <span class="bound">x</span> <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">bundle</span></span> state_monad_syntax <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">notation</span></span> fun_app_lifted <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">.</span>"</span> 999<span class="main">)</span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'M</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> fun_lifted <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'M</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> state"</span></span> <span class="main">(</span><span class="quoted">"_ <span class="keyword1">==</span>_<span class="keyword1">⟹</span> _"</span> <span class="main">[</span>3<span class="main">,</span>1000<span class="main">,</span>2<span class="main">]</span> 2<span class="main">)</span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> dpfun <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">==</span><span class="main">(</span><span class="tfree">'a</span><span class="main">⇀</span><span class="tfree">'b</span><span class="main">)</span><span class="main">⟹</span> <span class="tfree">'b</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixr</span></span> <span class="quoted">"<span class="keyword1">⇒<span class="hidden">⇩</span><sub>T</sub></span>"</span> 2<span class="main">)</span>
<span class="keyword1"><span class="command">type_notation</span></span> state <span class="main">(</span><span class="quoted">"<span class="keyword1">[</span>_<span class="keyword1">|</span> _<span class="keyword1">]</span>"</span><span class="main">)</span>

<span class="keyword1"><span class="command">notation</span></span> State_Monad.return <span class="main">(</span><span class="quoted">"<span class="keyword1">⟨</span>_<span class="keyword1">⟩</span>"</span><span class="main">)</span>
<span class="keyword1"><span class="command">notation</span></span> <span class="main">(</span>ASCII<span class="main">)</span> State_Monad.return <span class="main">(</span><span class="quoted">"<span class="keyword3">(</span><span class="keyword1">#</span>_<span class="keyword1">#</span><span class="keyword3">)</span>"</span><span class="main">)</span>
<span class="keyword1"><span class="command">notation</span></span> Transfer.Rel <span class="main">(</span><span class="quoted">"<span class="keyword1">Rel</span>"</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> state_monad_syntax <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1" id="State_Monad_Ext-return_app_return"><span class="command">lemma</span></span> return_app_return<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟨</span><span class="free">f</span><span class="main">⟩</span> <span class="main">.</span> <span class="main">⟨</span><span class="free">x</span><span class="main">⟩</span> <span class="main">=</span> <span class="free">f</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fun_app_lifted_def bind_left_identity <span class="keyword1"><span class="command">..</span></span>

<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1" id="State_Monad_Ext-return_app_return_meta"><span class="command">lemma</span></span> return_app_return_meta<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟨</span><span class="free">f</span><span class="main">⟩</span> <span class="main">.</span> <span class="main">⟨</span><span class="free">x</span><span class="main">⟩</span> <span class="main">≡</span> <span class="free">f</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> return_app_return <span class="keyword1"><span class="command">.</span></span>

<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">if<span class="hidden">⇩</span><sub>T</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'M</span><span class="main">,</span> bool<span class="main">)</span> state <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'M</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> state <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'M</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> state <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'M</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> state"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">if<span class="hidden">⇩</span><sub>T</sub></span> <span class="free"><span class="bound"><span class="entity">b<span class="hidden">⇩</span><sub>T</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">x<span class="hidden">⇩</span><sub>T</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">y<span class="hidden">⇩</span><sub>T</sub></span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span><span class="bound">b</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">b<span class="hidden">⇩</span><sub>T</sub></span></span></span><span class="main">;</span> <span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">x<span class="hidden">⇩</span><sub>T</sub></span></span></span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">y<span class="hidden">⇩</span><sub>T</sub></span></span></span><span class="main">}</span>"</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Pure_Monad">
<div class="head">
<h1>Theory Pure_Monad</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Monadification›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Monads›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Pure_Monad
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Wrap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Wrap</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">App</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">App</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span>"</span></span>

<span class="keyword1" id="Pure_Monad-Wrap_App_Wrap"><span class="command">lemma</span></span> Wrap_App_Wrap<span class="main">:</span>
  <span class="quoted"><span class="quoted">"App <span class="main">(</span>Wrap <span class="free">f</span><span class="main">)</span> <span class="main">(</span>Wrap <span class="free">x</span><span class="main">)</span> <span class="main">≡</span> <span class="free">f</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> App_def Wrap_def <span class="keyword1"><span class="command">.</span></span>


<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="DP_CRelVS">
<div class="head">
<h1>Theory DP_CRelVS</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Parametricity of the State Monad›</span></span>

<span class="keyword1"><span class="command">theory</span></span> DP_CRelVS
  <span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="#State_Monad_Ext">./State_Monad_Ext</a>"</span> <span class="quoted">"<a href="#Pure_Monad">../Pure_Monad</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">lift_p</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> state <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lift_p</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span>
    <span class="main">(</span><span class="main">∀</span> <span class="bound">heap</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="bound">heap</span> <span class="main">⟶</span> <span class="main">(</span><span class="keyword1">case</span> State_Monad.run_state <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">heap</span> <span class="keyword1">of</span> <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">heap</span><span class="main">)</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="bound">heap</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">P</span> <span class="free">f</span> <span class="free">heap</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> lift<span class="main">:</span> <span class="quoted"><span class="quoted">"lift_p <span class="free">P</span> <span class="free">f</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> P<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">heap</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="DP_CRelVS-run_state_cases"><span class="command">lemma</span></span> run_state_cases<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">case</span> State_Monad.run_state <span class="free">f</span> <span class="free">heap</span> <span class="keyword1">of</span> <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">heap</span><span class="main">)</span> <span class="main">⇒</span> <span class="free">P</span> <span class="bound">heap</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> lift P <span class="keyword1"><span class="command">unfolding</span></span> lift_p_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="DP_CRelVS-lift_p_P"><span class="command">lemma</span></span> lift_p_P<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">heap'</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"State_Monad.run_state <span class="free">f</span> <span class="free">heap</span> <span class="main">=</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="free">heap'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that run_state_cases <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> state_mem_defs <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">lookup</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'param</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'mem</span><span class="main">,</span> <span class="tfree">'result</span> option<span class="main">)</span> state"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">update</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'param</span> <span class="main">⇒</span> <span class="tfree">'result</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'mem</span><span class="main">,</span> unit<span class="main">)</span> state"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">checkmem</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'param</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'mem</span><span class="main">,</span> <span class="tfree">'result</span><span class="main">)</span> state <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'mem</span><span class="main">,</span> <span class="tfree">'result</span><span class="main">)</span> state"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">checkmem</span> <span class="free"><span class="bound"><span class="entity">param</span></span></span> <span class="free"><span class="bound"><span class="entity">calc</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">x</span> <span class="main">←</span> <span class="free">lookup</span> <span class="free"><span class="bound"><span class="entity">param</span></span></span><span class="main">;</span>
    <span class="keyword1">case</span> <span class="bound">x</span> <span class="keyword1">of</span>
      Some <span class="bound">x</span> <span class="main">⇒</span> State_Monad.return <span class="bound">x</span>
    <span class="main">|</span> None <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">x</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">calc</span></span></span><span class="main">;</span>
        <span class="free">update</span> <span class="free"><span class="bound"><span class="entity">param</span></span></span> <span class="bound">x</span><span class="main">;</span>
        State_Monad.return <span class="bound">x</span>
      <span class="main">}</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">checkmem_eq</span> <span class="main">::</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'param</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'mem</span><span class="main">,</span> <span class="tfree">'result</span><span class="main">)</span> state<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'param</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'mem</span><span class="main">,</span> <span class="tfree">'result</span><span class="main">)</span> state <span class="main">⇒</span> bool"</span></span>
  <span class="main">(</span><span class="quoted">"_<span class="keyword1">$</span> _ <span class="keyword1">=CHECKMEM=</span> _"</span> <span class="main">[</span>1000<span class="main">,</span>51<span class="main">]</span> 51<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free"><span class="bound"><span class="entity">dp<span class="hidden">⇩</span><sub>T</sub></span></span></span><span class="main"><span class="free">$</span></span> <span class="free"><span class="bound"><span class="entity">param</span></span></span> <span class="keyword1"><span class="free">=CHECKMEM=</span></span> <span class="free"><span class="bound"><span class="entity">calc</span></span></span><span class="main">)</span> <span class="main">≡</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">dp<span class="hidden">⇩</span><sub>T</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">param</span></span></span> <span class="main">=</span> checkmem <span class="free"><span class="bound"><span class="entity">param</span></span></span> <span class="free"><span class="bound"><span class="entity">calc</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">term</span></span> <span class="quoted"><span class="main">0</span></span> <span class="comment1">(**)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">map_of</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">map_of</span> <span class="free"><span class="bound"><span class="entity">heap</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">=</span> fst <span class="main">(</span>run_state <span class="main">(</span><span class="free">lookup</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">heap</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">checkmem'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'param</span> <span class="main">⇒</span> <span class="main">(</span>unit <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'mem</span><span class="main">,</span> <span class="tfree">'result</span><span class="main">)</span> state<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'mem</span><span class="main">,</span> <span class="tfree">'result</span><span class="main">)</span> state"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">checkmem'</span> <span class="free"><span class="bound"><span class="entity">param</span></span></span> <span class="free"><span class="bound"><span class="entity">calc</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">x</span> <span class="main">←</span> <span class="free">lookup</span> <span class="free"><span class="bound"><span class="entity">param</span></span></span><span class="main">;</span>
    <span class="keyword1">case</span> <span class="bound">x</span> <span class="keyword1">of</span>
      Some <span class="bound">x</span> <span class="main">⇒</span> State_Monad.return <span class="bound">x</span>
    <span class="main">|</span> None <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">x</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">calc</span></span></span> <span class="main">()</span><span class="main">;</span>
        <span class="free">update</span> <span class="free"><span class="bound"><span class="entity">param</span></span></span> <span class="bound">x</span><span class="main">;</span>
        State_Monad.return <span class="bound">x</span>
      <span class="main">}</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1" id="DP_CRelVS-checkmem_checkmem'"><span class="command">lemma</span></span> checkmem_checkmem'<span class="main">:</span>
  <span class="quoted"><span class="quoted">"checkmem' <span class="free">param</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">calc</span><span class="main">)</span> <span class="main">=</span> checkmem <span class="free">param</span> <span class="free">calc</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> checkmem'_def checkmem_def <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1" id="DP_CRelVS-checkmem_eq_alt"><span class="command">lemma</span></span> checkmem_eq_alt<span class="main">:</span>
  <span class="quoted"><span class="quoted">"checkmem_eq <span class="free">dp</span> <span class="free">param</span> <span class="free">calc</span> <span class="main">=</span> <span class="main">(</span><span class="free">dp</span> <span class="free">param</span> <span class="main">=</span> checkmem' <span class="free">param</span> <span class="main">(</span><span class="main">λ</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">calc</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> checkmem_checkmem' <span class="keyword1"><span class="command">..</span></span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Mem Defs *)</span>


<span class="keyword1"><span class="command">locale</span></span> mem_correct <span class="main">=</span> state_mem_defs <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">P</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> lookup_inv<span class="main">:</span> <span class="quoted"><span class="quoted">"lift_p <span class="free">P</span> <span class="main">(</span><span class="free">lookup</span> <span class="free">k</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> update_inv<span class="main">:</span> <span class="quoted"><span class="quoted">"lift_p <span class="free">P</span> <span class="main">(</span><span class="free">update</span> <span class="free">k</span> <span class="free">v</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span>
    lookup_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">m</span> <span class="main">⟹</span> map_of <span class="main">(</span>snd <span class="main">(</span>State_Monad.run_state <span class="main">(</span><span class="free">lookup</span> <span class="free">k</span><span class="main">)</span> <span class="free">m</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> <span class="main">(</span>map_of <span class="free">m</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span>
    update_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">m</span> <span class="main">⟹</span> map_of <span class="main">(</span>snd <span class="main">(</span>State_Monad.run_state <span class="main">(</span><span class="free">update</span> <span class="free">k</span> <span class="free">v</span><span class="main">)</span> <span class="free">m</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> <span class="main">(</span>map_of <span class="free">m</span><span class="main">)</span><span class="main">(</span><span class="free">k</span> <span class="main">↦</span> <span class="free">v</span><span class="main">)</span>"</span></span>
  <span class="comment1">(* assumes correct: "lookup (update m k v) ⊆<span class="hidden">⇩</span><sub>m</sub> (lookup m)(k ↦ v)" *)</span>

<span class="keyword1"><span class="command">locale</span></span> dp_consistency <span class="main">=</span>
  mem_correct <span class="quoted"><span class="free">lookup</span></span> <span class="quoted"><span class="free">update</span></span> <span class="quoted"><span class="free">P</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">lookup</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'param</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'mem</span><span class="main">,</span> <span class="tfree">'result</span> option<span class="main">)</span> state"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">update</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">P</span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">dp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'param</span> <span class="main">⇒</span> <span class="tfree">'result</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax state_monad_syntax
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">cmem</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'mem</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">cmem</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="main">≡</span> <span class="main">∀</span><span class="bound">param</span><span class="main">∈</span>dom <span class="main">(</span>map_of <span class="free"><span class="bound"><span class="entity">M</span></span></span><span class="main">)</span><span class="main">.</span> map_of <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="bound">param</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">dp</span> <span class="bound">param</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">crel_vs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'mem</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> state <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">crel_vs</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="main">∀</span><span class="bound">M</span><span class="main">.</span> cmem <span class="bound">M</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">M</span> <span class="main">⟶</span> <span class="main">(</span><span class="keyword1">case</span> State_Monad.run_state <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="bound">M</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">v'</span><span class="main">,</span> <span class="bound">M'</span><span class="main">)</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="bound">v'</span> <span class="main">∧</span> cmem <span class="bound">M'</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">M'</span><span class="main">)</span>"</span></span>
  
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">rel_fun_lifted</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'c</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'d</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'c</span> <span class="main">==</span><span class="main">_</span><span class="main">⟹</span> <span class="tfree">'d</span><span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixr</span></span> <span class="quoted">"<span class="keyword1">===&gt;<span class="hidden">⇩</span><sub>T</sub></span>"</span> 55<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">rel_fun_lifted</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">R'</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">===&gt;</span> crel_vs <span class="free"><span class="bound"><span class="entity">R'</span></span></span>"</span></span>
<span class="keyword1"><span class="command">term</span></span> <span class="quoted"><span class="main">0</span></span> <span class="comment1">(**)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">consistentDP</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'param</span> <span class="main">==</span> <span class="tfree">'mem</span> <span class="main">⟹</span> <span class="tfree">'result</span><span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">consistentDP</span> <span class="main">≡</span> <span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> crel_vs <span class="main">(=)</span><span class="main">)</span> <span class="free">dp</span>"</span></span>
<span class="keyword1"><span class="command">term</span></span> <span class="quoted"><span class="main">0</span></span> <span class="comment1">(**)</span>
  
  <span class="comment1">(* cmem *)</span>
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="DP_CRelVS-cmem_intro"><span class="command">lemma</span></span> cmem_intro<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">param</span> <span class="bound">v</span> <span class="bound">M'</span><span class="main">.</span> State_Monad.run_state <span class="main">(</span><span class="free">lookup</span> <span class="bound">param</span><span class="main">)</span> <span class="free">M</span> <span class="main">=</span> <span class="main">(</span>Some <span class="bound">v</span><span class="main">,</span> <span class="bound">M'</span><span class="main">)</span> <span class="main">⟹</span> <span class="bound">v</span> <span class="main">=</span> <span class="free">dp</span> <span class="bound">param</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cmem <span class="free">M</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> cmem_def map_of_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> param y
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"State_Monad.run_state <span class="main">(</span><span class="free">lookup</span> <span class="skolem">param</span><span class="main">)</span> <span class="free">M</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> assms<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="DP_CRelVS-cmem_elim"><span class="command">lemma</span></span> cmem_elim<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"cmem <span class="free">M</span>"</span></span> <span class="quoted"><span class="quoted">"State_Monad.run_state <span class="main">(</span><span class="free">lookup</span> <span class="free">param</span><span class="main">)</span> <span class="free">M</span> <span class="main">=</span> <span class="main">(</span>Some <span class="free">v</span><span class="main">,</span> <span class="free">M'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="quoted"><span class="quoted">"<span class="free">dp</span> <span class="free">param</span> <span class="main">=</span> <span class="free">v</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> cmem_def dom_def map_of_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> <span class="main">(</span><span class="operator">metis</span> fst_conv option.inject<span class="main">)</span>
<span class="keyword1"><span class="command">term</span></span> <span class="quoted"><span class="main">0</span></span> <span class="comment1">(**)</span>
  
  <span class="comment1">(* crel_vs *)</span>
<span class="keyword1" id="DP_CRelVS-crel_vs_intro"><span class="command">lemma</span></span> crel_vs_intro<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">M</span> <span class="bound">v'</span> <span class="bound">M'</span><span class="main">.</span> <span class="main">⟦</span>cmem <span class="bound">M</span><span class="main">;</span> <span class="free">P</span> <span class="bound">M</span><span class="main">;</span> State_Monad.run_state <span class="free">v<span class="hidden">⇩</span><sub>T</sub></span> <span class="bound">M</span> <span class="main">=</span> <span class="main">(</span><span class="bound">v'</span><span class="main">,</span> <span class="bound">M'</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">R</span> <span class="free">v</span> <span class="bound">v'</span> <span class="main">∧</span> cmem <span class="bound">M'</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">M'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"crel_vs <span class="free">R</span> <span class="free">v</span> <span class="free">v<span class="hidden">⇩</span><sub>T</sub></span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> crel_vs_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">term</span></span> <span class="quoted"><span class="main">0</span></span> <span class="comment1">(**)</span>
  
<span class="keyword1" id="DP_CRelVS-crel_vs_elim"><span class="command">lemma</span></span> crel_vs_elim<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"crel_vs <span class="free">R</span> <span class="free">v</span> <span class="free">v<span class="hidden">⇩</span><sub>T</sub></span>"</span></span> <span class="quoted"><span class="quoted">"cmem <span class="free">M</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">M</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">v'</span> <span class="free">M'</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"State_Monad.run_state <span class="free">v<span class="hidden">⇩</span><sub>T</sub></span> <span class="free">M</span> <span class="main">=</span> <span class="main">(</span><span class="free">v'</span><span class="main">,</span> <span class="free">M'</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="free">v</span> <span class="free">v'</span>"</span></span> <span class="quoted"><span class="quoted">"cmem <span class="free">M'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">M'</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> crel_vs_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">term</span></span> <span class="quoted"><span class="main">0</span></span> <span class="comment1">(**)</span>
  
  <span class="comment1">(* consistentDP *)</span>
<span class="keyword1" id="DP_CRelVS-consistentDP_intro"><span class="command">lemma</span></span> consistentDP_intro<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">param</span><span class="main">.</span> Transfer.Rel <span class="main">(</span>crel_vs <span class="main">(=)</span><span class="main">)</span> <span class="main">(</span><span class="free">dp</span> <span class="bound">param</span><span class="main">)</span> <span class="main">(</span><span class="free">dp<span class="hidden">⇩</span><sub>T</sub></span> <span class="bound">param</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"consistentDP <span class="free">dp<span class="hidden">⇩</span><sub>T</sub></span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> consistentDP_def Rel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  
<span class="keyword1" id="DP_CRelVS-crel_vs_return"><span class="command">lemma</span></span> crel_vs_return<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>Transfer.Rel <span class="free">R</span> <span class="free">x</span> <span class="free">y</span><span class="main">⟧</span> <span class="main">⟹</span> Transfer.Rel <span class="main">(</span>crel_vs <span class="free">R</span><span class="main">)</span> <span class="main">(</span>Wrap <span class="free">x</span><span class="main">)</span> <span class="main">(</span>State_Monad.return <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> State_Monad.return_def Wrap_def Rel_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> crel_vs_intro<span class="main">)</span>
<span class="keyword1"><span class="command">term</span></span> <span class="quoted"><span class="main">0</span></span> <span class="comment1">(**)</span>
  
<span class="keyword1" id="DP_CRelVS-crel_vs_return_ext"><span class="command">lemma</span></span> crel_vs_return_ext<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>Transfer.Rel <span class="free">R</span> <span class="free">x</span> <span class="free">y</span><span class="main">⟧</span> <span class="main">⟹</span> Transfer.Rel <span class="main">(</span>crel_vs <span class="free">R</span><span class="main">)</span> <span class="free">x</span> <span class="main">(</span>State_Monad.return <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fact</span> crel_vs_return<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> Wrap_def<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">term</span></span> <span class="quoted"><span class="main">0</span></span> <span class="comment1">(**)</span>

  <span class="comment1">(* Low level operators *)</span>
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="DP_CRelVS-cmem_upd"><span class="command">lemma</span></span> cmem_upd<span class="main">:</span>
  <span class="quoted"><span class="quoted">"cmem <span class="free">M'</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"cmem <span class="free">M</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">M</span>"</span></span> <span class="quoted"><span class="quoted">"State_Monad.run_state <span class="main">(</span><span class="free">update</span> <span class="free">param</span> <span class="main">(</span><span class="free">dp</span> <span class="free">param</span><span class="main">)</span><span class="main">)</span> <span class="free">M</span> <span class="main">=</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="free">M'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> update_correct<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">M</span></span> <span class="quoted"><span class="free">param</span></span> <span class="quoted"><span class="quoted">"<span class="free">dp</span> <span class="free">param</span>"</span></span><span class="main">]</span> that <span class="keyword1"><span class="command">unfolding</span></span> cmem_def map_le_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="operator">force</span>

<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="DP_CRelVS-P_upd"><span class="command">lemma</span></span> P_upd<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">M'</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">M</span>"</span></span> <span class="quoted"><span class="quoted">"State_Monad.run_state <span class="main">(</span><span class="free">update</span> <span class="free">param</span> <span class="main">(</span><span class="free">dp</span> <span class="free">param</span><span class="main">)</span><span class="main">)</span> <span class="free">M</span> <span class="main">=</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="free">M'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> lift_p_P that update_inv<span class="main">)</span>

<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="DP_CRelVS-crel_vs_get"><span class="command">lemma</span></span> crel_vs_get<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">⋀</span><span class="bound">M</span><span class="main">.</span> cmem <span class="bound">M</span> <span class="main">⟹</span> crel_vs <span class="free">R</span> <span class="free">v</span> <span class="main">(</span><span class="free">sf</span> <span class="bound">M</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> crel_vs <span class="free">R</span> <span class="free">v</span> <span class="main">(</span>State_Monad.get <span class="main">⤜</span> <span class="free">sf</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> State_Monad.get_def State_Monad.bind_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> crel_vs_intro <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> crel_vs_elim <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>
<span class="keyword1"><span class="command">term</span></span> <span class="quoted"><span class="main">0</span></span> <span class="comment1">(**)</span>
  
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="DP_CRelVS-crel_vs_set"><span class="command">lemma</span></span> crel_vs_set<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>crel_vs <span class="free">R</span> <span class="free">v</span> <span class="free">sf</span><span class="main">;</span> cmem <span class="free">M</span><span class="main">;</span> <span class="free">P</span> <span class="free">M</span><span class="main">⟧</span> <span class="main">⟹</span> crel_vs <span class="free">R</span> <span class="free">v</span> <span class="main">(</span>State_Monad.set <span class="free">M</span> <span class="main">⪢</span> <span class="free">sf</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> State_Monad.set_def State_Monad.bind_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> crel_vs_intro <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> crel_vs_elim <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>
<span class="keyword1"><span class="command">term</span></span> <span class="quoted"><span class="main">0</span></span> <span class="comment1">(**)</span>
  
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="DP_CRelVS-crel_vs_bind_eq"><span class="command">lemma</span></span> crel_vs_bind_eq<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>crel_vs <span class="main">(=)</span> <span class="free">v</span> <span class="free">s</span><span class="main">;</span> crel_vs <span class="free">R</span> <span class="main">(</span><span class="free">f</span> <span class="free">v</span><span class="main">)</span> <span class="main">(</span><span class="free">sf</span> <span class="free">v</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> crel_vs <span class="free">R</span> <span class="main">(</span><span class="free">f</span> <span class="free">v</span><span class="main">)</span> <span class="main">(</span><span class="free">s</span> <span class="main">⤜</span> <span class="free">sf</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> State_Monad.bind_def rel_fun_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> crel_vs_intro <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> crel_vs_elim <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>
<span class="keyword1"><span class="command">term</span></span> <span class="quoted"><span class="main">0</span></span> <span class="comment1">(**)</span>

<span class="keyword1" id="DP_CRelVS-bind_transfer"><span class="command">lemma</span></span> bind_transfer<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>crel_vs <span class="free">R0</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">R0</span> <span class="keyword1">===&gt;<span class="hidden">⇩</span><sub>T</sub></span> <span class="free">R1</span><span class="main">)</span> <span class="main">===&gt;</span> crel_vs <span class="free">R1</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">v</span> <span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">v</span><span class="main">)</span> <span class="main">(⤜)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> State_Monad.bind_def rel_fun_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> crel_vs_intro <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> crel_vs_elim <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>

<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="DP_CRelVS-cmem_lookup"><span class="command">lemma</span></span> cmem_lookup<span class="main">:</span>
  <span class="quoted"><span class="quoted">"cmem <span class="free">M'</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"cmem <span class="free">M</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">M</span>"</span></span> <span class="quoted"><span class="quoted">"State_Monad.run_state <span class="main">(</span><span class="free">lookup</span> <span class="free">param</span><span class="main">)</span> <span class="free">M</span> <span class="main">=</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="free">M'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> lookup_correct<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">M</span></span> <span class="quoted"><span class="free">param</span></span><span class="main">]</span> that <span class="keyword1"><span class="command">unfolding</span></span> cmem_def map_le_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>

<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="DP_CRelVS-P_lookup"><span class="command">lemma</span></span> P_lookup<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">M'</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">M</span>"</span></span> <span class="quoted"><span class="quoted">"State_Monad.run_state <span class="main">(</span><span class="free">lookup</span> <span class="free">param</span><span class="main">)</span> <span class="free">M</span> <span class="main">=</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="free">M'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> lift_p_P that lookup_inv<span class="main">)</span>

<span class="keyword1" id="DP_CRelVS-crel_vs_lookup"><span class="command">lemma</span></span> crel_vs_lookup<span class="main">:</span>
  <span class="quoted"><span class="quoted">"crel_vs <span class="main">(</span><span class="main">λ</span> <span class="bound">v</span> <span class="bound">v'</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">v'</span> <span class="keyword1">of</span> None <span class="main">⇒</span> True <span class="main">|</span> Some <span class="bound">v'</span> <span class="main">⇒</span> <span class="bound">v</span> <span class="main">=</span> <span class="bound">v'</span> <span class="main">∧</span> <span class="bound">v</span> <span class="main">=</span> <span class="free">dp</span> <span class="free">param</span><span class="main">)</span> <span class="main">(</span><span class="free">dp</span> <span class="free">param</span><span class="main">)</span> <span class="main">(</span><span class="free">lookup</span> <span class="free">param</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> cmem_elim <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> cmem_lookup crel_vs_intro P_lookup <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1" id="DP_CRelVS-crel_vs_update"><span class="command">lemma</span></span> crel_vs_update<span class="main">:</span>
  <span class="quoted"><span class="quoted">"crel_vs <span class="main">(=)</span> <span class="main">()</span> <span class="main">(</span><span class="free">update</span> <span class="free">param</span> <span class="main">(</span><span class="free">dp</span> <span class="free">param</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> cmem_upd crel_vs_intro P_upd<span class="main">)</span>

<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="DP_CRelVS-crel_vs_checkmem"><span class="command">lemma</span></span> crel_vs_checkmem<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>is_equality <span class="free">R</span><span class="main">;</span> Transfer.Rel <span class="main">(</span>crel_vs <span class="free">R</span><span class="main">)</span> <span class="main">(</span><span class="free">dp</span> <span class="free">param</span><span class="main">)</span> <span class="free">s</span><span class="main">⟧</span>
  <span class="main">⟹</span> Transfer.Rel <span class="main">(</span>crel_vs <span class="free">R</span><span class="main">)</span> <span class="main">(</span><span class="free">dp</span> <span class="free">param</span><span class="main">)</span> <span class="main">(</span>checkmem <span class="free">param</span> <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> checkmem_def Rel_def is_equality_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> bind_transfer<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> rel_fun_def<span class="main"><span class="main">,</span></span> <span class="operator">rule_format</span><span class="main"><span class="main">,</span></span> <span class="operator">OF</span> crel_vs_lookup<span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> crel_vs_lookup crel_vs_update crel_vs_return<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> Rel_def Wrap_def<span class="main"><span class="main">]</span></span> crel_vs_bind_eq
               <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm
     <span class="main">)</span>

<span class="keyword1" id="DP_CRelVS-crel_vs_checkmem_tupled"><span class="command">lemma</span></span> crel_vs_checkmem_tupled<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">=</span> <span class="free">dp</span> <span class="free">param</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>is_equality <span class="free">R</span><span class="main">;</span> Transfer.Rel <span class="main">(</span>crel_vs <span class="free">R</span><span class="main">)</span> <span class="free">v</span> <span class="free">s</span><span class="main">⟧</span>
        <span class="main">⟹</span> Transfer.Rel <span class="main">(</span>crel_vs <span class="free">R</span><span class="main">)</span> <span class="free">v</span> <span class="main">(</span>checkmem <span class="free">param</span> <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fact</span> crel_vs_checkmem<span class="main">)</span>

  <span class="comment1">(** Transfer rules **)</span>
  <span class="comment1">(* Basics *)</span>
<span class="keyword1" id="DP_CRelVS-return_transfer"><span class="command">lemma</span></span> return_transfer<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">R</span> <span class="keyword1">===&gt;<span class="hidden">⇩</span><sub>T</sub></span> <span class="free">R</span><span class="main">)</span> Wrap State_Monad.return"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> rel_fun_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> crel_vs_return Rel_def<span class="main">)</span>

<span class="keyword1" id="DP_CRelVS-fun_app_lifted_transfer"><span class="command">lemma</span></span> fun_app_lifted_transfer<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>crel_vs <span class="main">(</span><span class="free">R0</span> <span class="keyword1">===&gt;<span class="hidden">⇩</span><sub>T</sub></span> <span class="free">R1</span><span class="main">)</span> <span class="main">===&gt;</span> crel_vs <span class="free">R0</span> <span class="main">===&gt;</span> crel_vs <span class="free">R1</span><span class="main">)</span> App <span class="main">(.)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> App_def fun_app_lifted_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
    
<span class="keyword1" id="DP_CRelVS-crel_vs_fun_app"><span class="command">lemma</span></span> crel_vs_fun_app<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>Transfer.Rel <span class="main">(</span>crel_vs <span class="free">R0</span><span class="main">)</span> <span class="free">x</span> <span class="free">x<span class="hidden">⇩</span><sub>T</sub></span><span class="main">;</span> Transfer.Rel <span class="main">(</span>crel_vs <span class="main">(</span><span class="free">R0</span> <span class="keyword1">===&gt;<span class="hidden">⇩</span><sub>T</sub></span> <span class="free">R1</span><span class="main">)</span><span class="main">)</span> <span class="free">f</span> <span class="free">f<span class="hidden">⇩</span><sub>T</sub></span><span class="main">⟧</span> <span class="main">⟹</span> Transfer.Rel <span class="main">(</span>crel_vs <span class="free">R1</span><span class="main">)</span> <span class="main">(</span>App <span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span><span class="free">f<span class="hidden">⇩</span><sub>T</sub></span> <span class="main">.</span> <span class="free">x<span class="hidden">⇩</span><sub>T</sub></span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Rel_def <span class="keyword1"><span class="command">using</span></span> fun_app_lifted_transfer<span class="main">[</span><span class="operator">THEN</span> rel_funD<span class="main">,</span> <span class="operator">THEN</span> rel_funD<span class="main">]</span> <span class="keyword1"><span class="command">.</span></span>

  <span class="comment1">(* HOL *)</span>
<span class="keyword1" id="DP_CRelVS-if"><span class="command">lemma</span></span> if<span class="hidden">⇩</span><sub>T</sub>_transfer<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>crel_vs <span class="main">(=)</span> <span class="main">===&gt;</span> crel_vs <span class="free">R</span> <span class="main">===&gt;</span> crel_vs <span class="free">R</span> <span class="main">===&gt;</span> crel_vs <span class="free">R</span><span class="main">)</span> If State_Monad_Ext.if<span class="hidden">⇩</span><sub>T</sub>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> State_Monad_Ext.if<span class="hidden">⇩</span><sub>T</sub>_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Lifting Syntax *)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Consistency *)</span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Theory *)</span>
</pre>
</div><div id="State_Heap_Misc">
<div class="head">
<h1>Theory State_Heap_Misc</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Miscellaneous Parametricity Theorems›</span></span>

<span class="keyword1"><span class="command">theory</span></span> State_Heap_Misc
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">context</span></span>  <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1" id="State_Heap_Misc-rel_fun_comp"><span class="command">lemma</span></span> rel_fun_comp<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">R1</span> <span class="main">===&gt;</span> <span class="free">S1</span><span class="main">)</span> <span class="free">f</span> <span class="free">g</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">R2</span> <span class="main">===&gt;</span> <span class="free">S2</span><span class="main">)</span> <span class="free">g</span> <span class="free">h</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">R1</span> <span class="keyword1">OO</span> <span class="free">R2</span> <span class="main">===&gt;</span> <span class="free">S1</span> <span class="keyword1">OO</span> <span class="free">S2</span><span class="main">)</span> <span class="free">f</span> <span class="free">h</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_funI <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_funD<span class="main">)</span>

<span class="keyword1" id="State_Heap_Misc-rel_fun_comp1"><span class="command">lemma</span></span> rel_fun_comp1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">R1</span> <span class="main">===&gt;</span> <span class="free">S1</span><span class="main">)</span> <span class="free">f</span> <span class="free">g</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">R2</span> <span class="main">===&gt;</span> <span class="free">S2</span><span class="main">)</span> <span class="free">g</span> <span class="free">h</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">R'</span> <span class="main">=</span> <span class="free">R1</span> <span class="keyword1">OO</span> <span class="free">R2</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">R'</span> <span class="main">===&gt;</span> <span class="free">S1</span> <span class="keyword1">OO</span> <span class="free">S2</span><span class="main">)</span> <span class="free">f</span> <span class="free">h</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms rel_fun_comp <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>

<span class="keyword1" id="State_Heap_Misc-rel_fun_comp2"><span class="command">lemma</span></span> rel_fun_comp2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">R1</span> <span class="main">===&gt;</span> <span class="free">S1</span><span class="main">)</span> <span class="free">f</span> <span class="free">g</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">R2</span> <span class="main">===&gt;</span> <span class="free">S2</span><span class="main">)</span> <span class="free">g</span> <span class="free">h</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">S'</span> <span class="main">=</span> <span class="free">S1</span> <span class="keyword1">OO</span> <span class="free">S2</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">R1</span> <span class="keyword1">OO</span> <span class="free">R2</span> <span class="main">===&gt;</span> <span class="free">S'</span><span class="main">)</span> <span class="free">f</span> <span class="free">h</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms rel_fun_comp <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>

<span class="keyword1" id="State_Heap_Misc-rel_fun_relcompp"><span class="command">lemma</span></span> rel_fun_relcompp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">R1</span> <span class="main">===&gt;</span> <span class="free">S1</span><span class="main">)</span> <span class="keyword1">OO</span> <span class="main">(</span><span class="free">R2</span> <span class="main">===&gt;</span> <span class="free">S2</span><span class="main">)</span><span class="main">)</span> <span class="free">a</span> <span class="free">b</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">(</span><span class="free">R1</span> <span class="keyword1">OO</span> <span class="free">R2</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">S1</span> <span class="keyword1">OO</span> <span class="free">S2</span><span class="main">)</span><span class="main">)</span> <span class="free">a</span> <span class="free">b</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> OO_def rel_fun_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="State_Heap_Misc-rel_fun_comp1'"><span class="command">lemma</span></span> rel_fun_comp1'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">R1</span> <span class="main">===&gt;</span> <span class="free">S1</span><span class="main">)</span> <span class="free">f</span> <span class="free">g</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">R2</span> <span class="main">===&gt;</span> <span class="free">S2</span><span class="main">)</span> <span class="free">g</span> <span class="free">h</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> <span class="free">R'</span> <span class="bound">a</span> <span class="bound">b</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">R1</span> <span class="keyword1">OO</span> <span class="free">R2</span><span class="main">)</span> <span class="bound">a</span> <span class="bound">b</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">R'</span> <span class="main">===&gt;</span> <span class="free">S1</span> <span class="keyword1">OO</span> <span class="free">S2</span><span class="main">)</span> <span class="free">f</span> <span class="free">h</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> assms rel_fun_mono<span class="main"><span class="main">[</span></span><span class="operator">OF</span> rel_fun_comp1<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="State_Heap_Misc-rel_fun_comp2'"><span class="command">lemma</span></span> rel_fun_comp2'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">R1</span> <span class="main">===&gt;</span> <span class="free">S1</span><span class="main">)</span> <span class="free">f</span> <span class="free">g</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">R2</span> <span class="main">===&gt;</span> <span class="free">S2</span><span class="main">)</span> <span class="free">g</span> <span class="free">h</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> <span class="main">(</span><span class="free">S1</span> <span class="keyword1">OO</span> <span class="free">S2</span><span class="main">)</span> <span class="bound">a</span> <span class="bound">b</span> <span class="main">⟹</span> <span class="free">S'</span> <span class="bound">a</span> <span class="bound">b</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">R1</span> <span class="keyword1">OO</span> <span class="free">R2</span> <span class="main">===&gt;</span> <span class="free">S'</span><span class="main">)</span> <span class="free">f</span> <span class="free">h</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> assms rel_fun_mono<span class="main"><span class="main">[</span></span><span class="operator">OF</span> rel_fun_comp1<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Heap_Monad_Ext">
<div class="head">
<h1>Theory Heap_Monad_Ext</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Heap Monad›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Heap_Monad_Ext
  <span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Imperative_HOL/Imperative_HOL.html">HOL-Imperative_HOL.Imperative_HOL</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fun_app_lifted</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> Heap<span class="main">)</span> Heap <span class="main">⇒</span> <span class="tfree">'a</span> Heap <span class="main">⇒</span> <span class="tfree">'b</span> Heap"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">fun_app_lifted</span> <span class="free"><span class="bound"><span class="entity">f<span class="hidden">⇩</span><sub>T</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">x<span class="hidden">⇩</span><sub>T</sub></span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span> <span class="bound">f</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">f<span class="hidden">⇩</span><sub>T</sub></span></span></span><span class="main">;</span> <span class="bound">x</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">x<span class="hidden">⇩</span><sub>T</sub></span></span></span><span class="main">;</span> <span class="bound">f</span> <span class="bound">x</span> <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">bundle</span></span> heap_monad_syntax <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">notation</span></span> fun_app_lifted <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">.</span>"</span> 999<span class="main">)</span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> fun_lifted <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> Heap"</span></span> <span class="main">(</span><span class="quoted">"_ <span class="keyword1">==H⟹</span> _"</span> <span class="main">[</span>3<span class="main">,</span>2<span class="main">]</span> 2<span class="main">)</span>
<span class="keyword1"><span class="command">type_notation</span></span> Heap <span class="main">(</span><span class="quoted">"<span class="keyword1">[</span>_<span class="keyword1">]</span>"</span><span class="main">)</span>

<span class="keyword1"><span class="command">notation</span></span> Heap_Monad.return <span class="main">(</span><span class="quoted">"<span class="keyword1">⟨</span>_<span class="keyword1">⟩</span>"</span><span class="main">)</span>
<span class="keyword1"><span class="command">notation</span></span> <span class="main">(</span>ASCII<span class="main">)</span> Heap_Monad.return <span class="main">(</span><span class="quoted">"<span class="keyword3">(</span><span class="keyword1">#</span>_<span class="keyword1">#</span><span class="keyword3">)</span>"</span><span class="main">)</span>
<span class="keyword1"><span class="command">notation</span></span> Transfer.Rel <span class="main">(</span><span class="quoted">"<span class="keyword1">Rel</span>"</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> heap_monad_syntax <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1" id="Heap_Monad_Ext-return_app_return"><span class="command">lemma</span></span> return_app_return<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟨</span><span class="free">f</span><span class="main">⟩</span> <span class="main">.</span> <span class="main">⟨</span><span class="free">x</span><span class="main">⟩</span> <span class="main">=</span> <span class="free">f</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fun_app_lifted_def return_bind <span class="keyword1"><span class="command">..</span></span>

<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1" id="Heap_Monad_Ext-return_app_return_meta"><span class="command">lemma</span></span> return_app_return_meta<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟨</span><span class="free">f</span><span class="main">⟩</span> <span class="main">.</span> <span class="main">⟨</span><span class="free">x</span><span class="main">⟩</span> <span class="main">≡</span> <span class="free">f</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> return_app_return <span class="keyword1"><span class="command">.</span></span>

<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">if<span class="hidden">⇩</span><sub>T</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"bool Heap <span class="main">⇒</span> <span class="tfree">'a</span> Heap <span class="main">⇒</span> <span class="tfree">'a</span> Heap <span class="main">⇒</span> <span class="tfree">'a</span> Heap"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">if<span class="hidden">⇩</span><sub>T</sub></span> <span class="free"><span class="bound"><span class="entity">b<span class="hidden">⇩</span><sub>T</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">x<span class="hidden">⇩</span><sub>T</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">y<span class="hidden">⇩</span><sub>T</sub></span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span><span class="bound">b</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">b<span class="hidden">⇩</span><sub>T</sub></span></span></span><span class="main">;</span> <span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">x<span class="hidden">⇩</span><sub>T</sub></span></span></span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">y<span class="hidden">⇩</span><sub>T</sub></span></span></span><span class="main">}</span>"</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="State_Heap">
<div class="head">
<h1>Theory State_Heap</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Relation Between the State and the Heap Monad›</span></span>

<span class="keyword1"><span class="command">theory</span></span> State_Heap
  <span class="keyword2"><span class="keyword">imports</span></span>
    <span class="quoted">"<a href="#DP_CRelVS">../state_monad/DP_CRelVS</a>"</span>
    <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Imperative_HOL/Imperative_HOL.html">HOL-Imperative_HOL.Imperative_HOL</a>"</span>
    <a href="#State_Heap_Misc">State_Heap_Misc</a>
    <a href="#Heap_Monad_Ext">Heap_Monad_Ext</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">lift_p</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>heap <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> Heap <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lift_p</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span>
    <span class="main">(</span><span class="main">∀</span> <span class="bound">heap</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="bound">heap</span> <span class="main">⟶</span> <span class="main">(</span><span class="keyword1">case</span> execute <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">heap</span> <span class="keyword1">of</span> None <span class="main">⇒</span> False <span class="main">|</span> Some <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">heap</span><span class="main">)</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="bound">heap</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">P</span> <span class="free">f</span> <span class="free">heap</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> lift<span class="main">:</span> <span class="quoted"><span class="quoted">"lift_p <span class="free">P</span> <span class="free">f</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> P<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">heap</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="State_Heap-execute_cases"><span class="command">lemma</span></span> execute_cases<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">case</span> execute <span class="free">f</span> <span class="free">heap</span> <span class="keyword1">of</span> None <span class="main">⇒</span> False <span class="main">|</span> Some <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">heap</span><span class="main">)</span> <span class="main">⇒</span> <span class="free">P</span> <span class="bound">heap</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> lift P <span class="keyword1"><span class="command">unfolding</span></span> lift_p_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="State_Heap-execute_cases'"><span class="command">lemma</span></span> execute_cases'<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">case</span> execute <span class="free">f</span> <span class="free">heap</span> <span class="keyword1">of</span> Some <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">heap</span><span class="main">)</span> <span class="main">⇒</span> <span class="free">P</span> <span class="bound">heap</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> execute_cases <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1" id="State_Heap-lift_p_None"><span class="command">lemma</span></span> lift_p_None<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">dest</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted">False</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"execute <span class="free">f</span> <span class="free">heap</span> <span class="main">=</span> None"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that execute_cases <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="State_Heap-lift_p_P"><span class="command">lemma</span></span> lift_p_P<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">case</span> the <span class="main">(</span>execute <span class="free">f</span> <span class="free">heap</span><span class="main">)</span> <span class="keyword1">of</span> <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">heap</span><span class="main">)</span> <span class="main">⇒</span> <span class="free">P</span> <span class="bound">heap</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> execute_cases <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span>

<span class="keyword1" id="State_Heap-lift_p_P'"><span class="command">lemma</span></span> lift_p_P'<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">heap'</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"the <span class="main">(</span>execute <span class="free">f</span> <span class="free">heap</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="free">heap'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that lift_p_P <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="State_Heap-lift_p_P''"><span class="command">lemma</span></span> lift_p_P''<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">heap'</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"execute <span class="free">f</span> <span class="free">heap</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="free">heap'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that lift_p_P <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="State_Heap-lift_p_the_Some"><span class="command">lemma</span></span> lift_p_the_Some<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"execute <span class="free">f</span> <span class="free">heap</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="free">heap'</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"the <span class="main">(</span>execute <span class="free">f</span> <span class="free">heap</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="free">heap'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that execute_cases <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span>

<span class="keyword1" id="State_Heap-lift_p_E"><span class="command">lemma</span></span> lift_p_E<span class="main">:</span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">v</span> <span class="free">heap'</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"execute <span class="free">f</span> <span class="free">heap</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="free">heap'</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">heap'</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> execute_cases <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"execute <span class="free">f</span> <span class="free">heap</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">state_of</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> State <span class="main">(</span><span class="main">λ</span> <span class="bound">heap</span><span class="main">.</span> the <span class="main">(</span>execute <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="bound">heap</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> heap_mem_defs <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">P</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"heap <span class="main">⇒</span> bool"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">lookup</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'v</span> option Heap"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">update</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> unit Heap"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">rel_state</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span>heap<span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> state <span class="main">⇒</span> <span class="tfree">'b</span> Heap <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">rel_state</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">≡</span>
    <span class="main">∀</span> <span class="bound">heap</span><span class="main">.</span> <span class="free">P</span> <span class="bound">heap</span> <span class="main">⟶</span>
      <span class="main">(</span><span class="keyword1">case</span> State_Monad.run_state <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">heap</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">v1</span><span class="main">,</span> <span class="bound">heap1</span><span class="main">)</span> <span class="main">⇒</span> <span class="keyword1">case</span> execute <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="bound">heap</span> <span class="keyword1">of</span>
        Some <span class="main">(</span><span class="bound">v2</span><span class="main">,</span> <span class="bound">heap2</span><span class="main">)</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="bound">v1</span> <span class="bound">v2</span> <span class="main">∧</span> <span class="bound">heap1</span> <span class="main">=</span> <span class="bound">heap2</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">heap2</span> <span class="main">|</span> None <span class="main">⇒</span> False<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">lookup'</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">≡</span> State <span class="main">(</span><span class="main">λ</span> <span class="bound">heap</span><span class="main">.</span> the <span class="main">(</span>execute <span class="main">(</span><span class="free">lookup</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">)</span> <span class="bound">heap</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">update'</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span> State <span class="main">(</span><span class="main">λ</span> <span class="bound">heap</span><span class="main">.</span> the <span class="main">(</span>execute <span class="main">(</span><span class="free">update</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="bound">heap</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">heap_get</span> <span class="main">=</span> Heap_Monad.Heap <span class="main">(</span><span class="main">λ</span> <span class="bound">heap</span><span class="main">.</span> Some <span class="main">(</span><span class="bound">heap</span><span class="main">,</span> <span class="bound">heap</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">checkmem</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'v</span> Heap <span class="main">⇒</span> <span class="tfree">'v</span> Heap"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">checkmem</span> <span class="free"><span class="bound"><span class="entity">param</span></span></span> <span class="free"><span class="bound"><span class="entity">calc</span></span></span> <span class="main">≡</span>
    Heap_Monad.bind <span class="main">(</span><span class="free">lookup</span> <span class="free"><span class="bound"><span class="entity">param</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">x</span><span class="main">.</span>
    <span class="keyword1">case</span> <span class="bound">x</span> <span class="keyword1">of</span>
      Some <span class="bound">x</span> <span class="main">⇒</span> return <span class="bound">x</span>
    <span class="main">|</span> None <span class="main">⇒</span> Heap_Monad.bind <span class="free"><span class="bound"><span class="entity">calc</span></span></span> <span class="main">(</span><span class="main">λ</span> <span class="bound">x</span><span class="main">.</span>
        Heap_Monad.bind <span class="main">(</span><span class="free">update</span> <span class="free"><span class="bound"><span class="entity">param</span></span></span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span>
        return <span class="bound">x</span>
      <span class="main">)</span>
    <span class="main">)</span>
  <span class="main">)</span>
  "</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">checkmem'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span> <span class="main">⇒</span> <span class="main">(</span>unit <span class="main">⇒</span> <span class="tfree">'v</span> Heap<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'v</span> Heap"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">checkmem'</span> <span class="free"><span class="bound"><span class="entity">param</span></span></span> <span class="free"><span class="bound"><span class="entity">calc</span></span></span> <span class="main">≡</span>
    Heap_Monad.bind <span class="main">(</span><span class="free">lookup</span> <span class="free"><span class="bound"><span class="entity">param</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">x</span><span class="main">.</span>
    <span class="keyword1">case</span> <span class="bound">x</span> <span class="keyword1">of</span>
      Some <span class="bound">x</span> <span class="main">⇒</span> return <span class="bound">x</span>
    <span class="main">|</span> None <span class="main">⇒</span> Heap_Monad.bind <span class="main">(</span><span class="free"><span class="bound"><span class="entity">calc</span></span></span> <span class="main">()</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">x</span><span class="main">.</span>
        Heap_Monad.bind <span class="main">(</span><span class="free">update</span> <span class="free"><span class="bound"><span class="entity">param</span></span></span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span>
        return <span class="bound">x</span>
      <span class="main">)</span>
    <span class="main">)</span>
  <span class="main">)</span>
  "</span></span>

<span class="keyword1" id="State_Heap-checkmem_checkmem'"><span class="command">lemma</span></span> checkmem_checkmem'<span class="main">:</span>
  <span class="quoted"><span class="quoted">"checkmem' <span class="free">param</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">calc</span><span class="main">)</span> <span class="main">=</span> checkmem <span class="free">param</span> <span class="free">calc</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> checkmem'_def checkmem_def <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">map_of_heap</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">map_of_heap</span> <span class="free"><span class="bound"><span class="entity">heap</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">=</span> fst <span class="main">(</span>the <span class="main">(</span>execute <span class="main">(</span><span class="free">lookup</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">heap</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="State_Heap-rel_state_elim"><span class="command">lemma</span></span> rel_state_elim<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"rel_state <span class="free">R</span> <span class="free">f</span> <span class="free">g</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">heap</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">heap'</span> <span class="free">v</span> <span class="free">v'</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"State_Monad.run_state <span class="free">f</span> <span class="free">heap</span> <span class="main">=</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="free">heap'</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"execute <span class="free">g</span> <span class="free">heap</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">v'</span><span class="main">,</span> <span class="free">heap'</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="free">v</span> <span class="free">v'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">heap'</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">atomize_elim</span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> rel_state_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"State_Monad.run_state <span class="free">f</span> <span class="free">heap</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="State_Heap-rel_state_intro"><span class="command">lemma</span></span> rel_state_intro<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">heap</span> <span class="bound">v</span> <span class="bound">heap'</span><span class="main">.</span> <span class="free">P</span> <span class="bound">heap</span> <span class="main">⟹</span> State_Monad.run_state <span class="free">f</span> <span class="bound">heap</span> <span class="main">=</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">heap'</span><span class="main">)</span>
      <span class="main">⟹</span> <span class="main">∃</span> <span class="bound">v'</span><span class="main">.</span> <span class="free">R</span> <span class="bound">v</span> <span class="bound">v'</span> <span class="main">∧</span> execute <span class="free">g</span> <span class="bound">heap</span> <span class="main">=</span> Some <span class="main">(</span><span class="bound">v'</span><span class="main">,</span> <span class="bound">heap'</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">heap</span> <span class="bound">v</span> <span class="bound">heap'</span><span class="main">.</span> <span class="free">P</span> <span class="bound">heap</span> <span class="main">⟹</span> State_Monad.run_state <span class="free">f</span> <span class="bound">heap</span> <span class="main">=</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">heap'</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">heap'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"rel_state <span class="free">R</span> <span class="free">f</span> <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> rel_state_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax state_monad_syntax
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="State_Heap-transfer_bind"><span class="command">lemma</span></span> transfer_bind<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_state <span class="free">R</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">R</span> <span class="main">===&gt;</span> rel_state <span class="free">Q</span><span class="main">)</span> <span class="main">===&gt;</span> rel_state <span class="free">Q</span><span class="main">)</span> State_Monad.bind Heap_Monad.bind"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> rel_fun_def State_Monad.bind_def Heap_Monad.bind_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_state_elim <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_state_intro<span class="main">)</span>

<span class="keyword1" id="State_Heap-transfer_return"><span class="command">lemma</span></span> transfer_return<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">R</span> <span class="main">===&gt;</span> rel_state <span class="free">R</span><span class="main">)</span> State_Monad.return Heap_Monad.return"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> rel_fun_def State_Monad.return_def Heap_Monad.return_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rel_state_intro <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> rel_state_elim <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> execute_heap<span class="main">)</span>

<span class="keyword1" id="State_Heap-fun_app_lifted_transfer"><span class="command">lemma</span></span> fun_app_lifted_transfer<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_state <span class="main">(</span><span class="free">R</span> <span class="main">===&gt;</span> rel_state <span class="free">Q</span><span class="main">)</span> <span class="main">===&gt;</span> rel_state <span class="free">R</span> <span class="main">===&gt;</span> rel_state <span class="free">Q</span><span class="main">)</span>
      State_Monad_Ext.fun_app_lifted Heap_Monad_Ext.fun_app_lifted"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> State_Monad_Ext.fun_app_lifted_def Heap_Monad_Ext.fun_app_lifted_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="State_Heap-transfer_get"><span class="command">lemma</span></span> transfer_get<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"rel_state <span class="main">(=)</span> State_Monad.get heap_get"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> State_Monad.get_def heap_get_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rel_state_intro<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Lifting Syntax *)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Heap Mem Defs *)</span>

<span class="keyword1"><span class="command">locale</span></span> heap_inv <span class="main">=</span> heap_mem_defs _ <span class="quoted"><span class="free">lookup</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">lookup</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'v</span> option Heap"</span></span>  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> lookup_inv<span class="main">:</span> <span class="quoted"><span class="quoted">"lift_p <span class="free">P</span> <span class="main">(</span><span class="free">lookup</span> <span class="free">k</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> update_inv<span class="main">:</span> <span class="quoted"><span class="quoted">"lift_p <span class="free">P</span> <span class="main">(</span><span class="free">update</span> <span class="free">k</span> <span class="free">v</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="State_Heap-rel_state_lookup"><span class="command">lemma</span></span> rel_state_lookup<span class="main">:</span>
  <span class="quoted"><span class="quoted">"rel_state <span class="main">(=)</span> <span class="main">(</span>lookup' <span class="free">k</span><span class="main">)</span> <span class="main">(</span><span class="free">lookup</span> <span class="free">k</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> rel_state_def lookup'_def <span class="keyword1"><span class="command">using</span></span> lookup_inv<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">k</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> lift_p_P'<span class="main">)</span>

<span class="keyword1" id="State_Heap-rel_state_update"><span class="command">lemma</span></span> rel_state_update<span class="main">:</span>
  <span class="quoted"><span class="quoted">"rel_state <span class="main">(=)</span> <span class="main">(</span>update' <span class="free">k</span> <span class="free">v</span><span class="main">)</span> <span class="main">(</span><span class="free">update</span> <span class="free">k</span> <span class="free">v</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> rel_state_def update'_def <span class="keyword1"><span class="command">using</span></span> update_inv<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">k</span></span> <span class="quoted"><span class="free">v</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> lift_p_P'<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="State_Heap-transfer_lookup"><span class="command">lemma</span></span> transfer_lookup<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> rel_state <span class="main">(=)</span><span class="main">)</span> lookup' <span class="free">lookup</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> rel_fun_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rel_state_lookup<span class="main">)</span>

<span class="keyword1" id="State_Heap-transfer_update"><span class="command">lemma</span></span> transfer_update<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> rel_state <span class="main">(=)</span><span class="main">)</span> update' <span class="free">update</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> rel_fun_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rel_state_update<span class="main">)</span>

<span class="keyword1" id="State_Heap-transfer_checkmem"><span class="command">lemma</span></span> transfer_checkmem<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> rel_state <span class="main">(=)</span> <span class="main">===&gt;</span> rel_state <span class="main">(=)</span><span class="main">)</span>
    <span class="main">(</span>state_mem_defs.checkmem lookup' update'<span class="main">)</span> checkmem"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span> <span class="main">=</span> transfer_lookup transfer_update
  <span class="keyword1"><span class="command">unfolding</span></span> state_mem_defs.checkmem_def checkmem_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Lifting Syntax *)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Heap Invariant *)</span>

<span class="keyword1"><span class="command">locale</span></span> heap_correct <span class="main">=</span>
  heap_inv <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> lookup_correct<span class="main">:</span>
      <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">m</span> <span class="main">⟹</span> map_of_heap <span class="main">(</span>snd <span class="main">(</span>the <span class="main">(</span>execute <span class="main">(</span><span class="free">lookup</span> <span class="free">k</span><span class="main">)</span> <span class="free">m</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> <span class="main">(</span>map_of_heap <span class="free">m</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> update_correct<span class="main">:</span>
      <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">m</span> <span class="main">⟹</span> map_of_heap <span class="main">(</span>snd <span class="main">(</span>the <span class="main">(</span>execute <span class="main">(</span><span class="free">update</span> <span class="free">k</span> <span class="free">v</span><span class="main">)</span> <span class="free">m</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> <span class="main">(</span>map_of_heap <span class="free">m</span><span class="main">)</span><span class="main">(</span><span class="free">k</span> <span class="main">↦</span> <span class="free">v</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="State_Heap-lookup'_correct"><span class="command">lemma</span></span> lookup'_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"state_mem_defs.map_of lookup' <span class="main">(</span>snd <span class="main">(</span>State_Monad.run_state <span class="main">(</span>lookup' <span class="free">k</span><span class="main">)</span> <span class="free">m</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> <span class="main">(</span>state_mem_defs.map_of lookup' <span class="free">m</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">P</span> <span class="free">m</span>›</span></span> <span class="keyword1"><span class="command">unfolding</span></span> state_mem_defs.map_of_def map_le_def lookup'_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> domIff lookup_correct map_le_def map_of_heap_def<span class="main">)</span>

<span class="keyword1" id="State_Heap-update'_correct"><span class="command">lemma</span></span> update'_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"state_mem_defs.map_of lookup' <span class="main">(</span>snd <span class="main">(</span>State_Monad.run_state <span class="main">(</span>update' <span class="free">k</span> <span class="free">v</span><span class="main">)</span> <span class="free">m</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> state_mem_defs.map_of lookup' <span class="free">m</span><span class="main">(</span><span class="free">k</span> <span class="main">↦</span> <span class="free">v</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> state_mem_defs.map_of_def map_le_def lookup'_def update'_def
  <span class="keyword1"><span class="command">using</span></span> update_correct<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">m</span></span> <span class="quoted"><span class="free">k</span></span> <span class="quoted"><span class="free">v</span></span><span class="main">]</span> that <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> map_le_def map_of_heap_def<span class="main">)</span>

<span class="keyword1" id="State_Heap-lookup'_inv"><span class="command">lemma</span></span> lookup'_inv<span class="main">:</span>
  <span class="quoted"><span class="quoted">"DP_CRelVS.lift_p <span class="free">P</span> <span class="main">(</span>lookup' <span class="free">k</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> DP_CRelVS.lift_p_def lookup'_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> lift_p_P'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lookup_inv<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="State_Heap-update'_inv"><span class="command">lemma</span></span> update'_inv<span class="main">:</span>
  <span class="quoted"><span class="quoted">"DP_CRelVS.lift_p <span class="free">P</span> <span class="main">(</span>update' <span class="free">k</span> <span class="free">v</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> DP_CRelVS.lift_p_def update'_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> lift_p_P'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> update_inv<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="State_Heap-mem_correct_heap"><span class="command">lemma</span></span> mem_correct_heap<span class="main">:</span> <span class="quoted"><span class="quoted">"mem_correct lookup' update' <span class="free">P</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> mem_correct.intro lookup'_correct update'_correct lookup'_inv update'_inv<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Heap correct *)</span>

<span class="keyword1"><span class="command">context</span></span> heap_mem_defs
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="State_Heap-mem_correct_heap_correct"><span class="command">lemma</span></span> mem_correct_heap_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> correct<span class="main">:</span> <span class="quoted"><span class="quoted">"mem_correct <span class="free">lookup<span class="hidden">⇩</span><sub>s</sub></span> <span class="free">update<span class="hidden">⇩</span><sub>s</sub></span> <span class="free">P</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> lookup<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> rel_state <span class="main">(=)</span><span class="main">)</span> <span class="free">lookup<span class="hidden">⇩</span><sub>s</sub></span> <span class="free">lookup</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> update<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> rel_state <span class="main">(=)</span><span class="main">)</span> <span class="free">update<span class="hidden">⇩</span><sub>s</sub></span> <span class="free">update</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"heap_correct <span class="free">P</span> <span class="free">update</span> <span class="free">lookup</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> mem<span class="main">:</span> mem_correct <span class="quoted"><span class="free">lookup<span class="hidden">⇩</span><sub>s</sub></span></span> <span class="quoted"><span class="free">update<span class="hidden">⇩</span><sub>s</sub></span></span> <span class="quoted"><span class="free">P</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> correct<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"the <span class="main">(</span>execute <span class="main">(</span><span class="free">lookup</span> <span class="skolem">k</span><span class="main">)</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">=</span> run_state <span class="main">(</span><span class="free">lookup<span class="hidden">⇩</span><sub>s</sub></span> <span class="skolem">k</span><span class="main">)</span> <span class="skolem">m</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="skolem">m</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">k</span> <span class="skolem">m</span>
    <span class="keyword1"><span class="command">using</span></span> lookup<span class="main">[</span><span class="operator">THEN</span> rel_funD<span class="main">,</span> <span class="operator">OF</span> HOL.refl<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">k</span></span><span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="free">P</span> <span class="skolem">m</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> rel_state_elim<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"the <span class="main">(</span>execute <span class="main">(</span><span class="free">update</span> <span class="skolem">k</span> <span class="skolem">v</span><span class="main">)</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">=</span> run_state <span class="main">(</span><span class="free">update<span class="hidden">⇩</span><sub>s</sub></span> <span class="skolem">k</span> <span class="skolem">v</span><span class="main">)</span> <span class="skolem">m</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="skolem">m</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">k</span> <span class="skolem">v</span> <span class="skolem">m</span>
    <span class="keyword1"><span class="command">using</span></span> update<span class="main">[</span><span class="operator">THEN</span> rel_funD<span class="main">,</span> <span class="operator">THEN</span> rel_funD<span class="main">,</span> <span class="operator">OF</span> HOL.refl HOL.refl<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">k</span></span> <span class="quoted"><span class="skolem">v</span></span><span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="free">P</span> <span class="skolem">m</span>›</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> rel_state_elim<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"map_of_heap <span class="skolem">m</span> <span class="main">=</span> mem.map_of <span class="skolem">m</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="skolem">m</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span>
    <span class="keyword1"><span class="command">unfolding</span></span> map_of_heap_def mem.map_of_def <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">P</span> <span class="skolem">m</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> k
      <span class="keyword1"><span class="command">using</span></span> mem.lookup_inv<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">k</span></span><span class="main">]</span> lookup<span class="main">[</span><span class="operator">THEN</span> rel_funD<span class="main">,</span> <span class="operator">OF</span> HOL.refl<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">k</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">unfolding</span></span> lift_p_def DP_CRelVS.lift_p_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> rel_state_elim<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> k v
      <span class="keyword1"><span class="command">using</span></span> mem.update_inv<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">k</span></span><span class="main">]</span> update<span class="main">[</span><span class="operator">THEN</span> rel_funD<span class="main">,</span> <span class="operator">THEN</span> rel_funD<span class="main">,</span> <span class="operator">OF</span> HOL.refl HOL.refl<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">k</span></span> <span class="quoted"><span class="skolem">v</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">unfolding</span></span> lift_p_def DP_CRelVS.lift_p_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> rel_state_elim<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> prems <span class="keyword2"><span class="keyword">for</span></span> m k
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span>snd <span class="main">(</span>run_state <span class="main">(</span><span class="free">lookup<span class="hidden">⇩</span><sub>s</sub></span> <span class="skolem">k</span><span class="main">)</span> <span class="skolem">m</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> DP_CRelVS.lift_p_P mem.lookup_inv prems prod.exhaust_sel<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> mem.lookup_correct<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="free">P</span> <span class="skolem">m</span>›</span></span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">k</span></span><span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="free">P</span> <span class="skolem">m</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> prems<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> prems <span class="keyword2"><span class="keyword">for</span></span> m k v
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span>snd <span class="main">(</span>run_state <span class="main">(</span><span class="free">update<span class="hidden">⇩</span><sub>s</sub></span> <span class="skolem">k</span> <span class="skolem">v</span><span class="main">)</span> <span class="skolem">m</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> DP_CRelVS.lift_p_P mem.update_inv prems prod.exhaust_sel<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> mem.update_correct<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="free">P</span> <span class="skolem">m</span>›</span></span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">k</span></span><span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="free">P</span> <span class="skolem">m</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> prems<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Theory *)</span>
</pre>
</div><div id="DP_CRelVH">
<div class="head">
<h1>Theory DP_CRelVH</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Parametricity of the Heap Monad›</span></span>

<span class="keyword1"><span class="command">theory</span></span> DP_CRelVH
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="#State_Heap">State_Heap</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">locale</span></span> dp_heap <span class="main">=</span>
  state_dp_consistency<span class="main">:</span> dp_consistency <span class="quoted"><span class="free">lookup_st</span></span> <span class="quoted"><span class="free">update_st</span></span> <span class="quoted"><span class="free">P</span></span> <span class="quoted"><span class="free">dp</span></span> <span class="main">+</span> heap_mem_defs <span class="quoted"><span class="free">Q</span></span> <span class="quoted"><span class="free">lookup</span></span> <span class="quoted"><span class="free">update</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">P</span> <span class="free">Q</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"heap <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">dp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'v</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">lookup</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'v</span> option Heap"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">lookup_st</span> <span class="free">update</span> <span class="free">update_st</span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span>
    rel_state_lookup<span class="main">:</span> <span class="quoted"><span class="quoted">"rel_fun <span class="main">(=)</span> <span class="main">(</span>rel_state <span class="main">(=)</span><span class="main">)</span> <span class="free">lookup_st</span> <span class="free">lookup</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span>
    rel_state_update<span class="main">:</span> <span class="quoted"><span class="quoted">"rel_fun <span class="main">(=)</span> <span class="main">(</span>rel_fun <span class="main">(=)</span> <span class="main">(</span>rel_state <span class="main">(=)</span><span class="main">)</span><span class="main">)</span> <span class="free">update_st</span> <span class="free">update</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax heap_monad_syntax
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">crel_vs</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span>
  <span class="main">∀</span><span class="bound">heap</span><span class="main">.</span> <span class="free">P</span> <span class="bound">heap</span> <span class="main">∧</span> <span class="free">Q</span> <span class="bound">heap</span> <span class="main">∧</span> state_dp_consistency.cmem <span class="bound">heap</span> <span class="main">⟶</span>
    <span class="main">(</span><span class="keyword1">case</span> execute <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">heap</span> <span class="keyword1">of</span>
      None <span class="main">⇒</span> False <span class="main">|</span>
      Some <span class="main">(</span><span class="bound">v'</span><span class="main">,</span> <span class="bound">heap'</span><span class="main">)</span> <span class="main">⇒</span> <span class="free">P</span> <span class="bound">heap'</span> <span class="main">∧</span> <span class="free">Q</span> <span class="bound">heap'</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="bound">v'</span> <span class="main">∧</span> state_dp_consistency.cmem <span class="bound">heap'</span>
    <span class="main">)</span>
"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">rel_fun_lifted</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'c</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'d</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'c</span> <span class="keyword1">==H⟹</span> <span class="tfree">'d</span><span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixr</span></span> <span class="quoted">"<span class="keyword1">===&gt;<span class="hidden">⇩</span><sub>T</sub></span>"</span> 55<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">rel_fun_lifted</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">R'</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">===&gt;</span> crel_vs <span class="free"><span class="bound"><span class="entity">R'</span></span></span>"</span></span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">consistentDP</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'v</span> Heap<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">consistentDP</span> <span class="main">≡</span> <span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> crel_vs <span class="main">(=)</span><span class="main">)</span> <span class="free">dp</span>"</span></span>

<span class="keyword1" id="DP_CRelVH-consistentDP_intro"><span class="command">lemma</span></span> consistentDP_intro<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">param</span><span class="main">.</span> Transfer.Rel <span class="main">(</span>crel_vs <span class="main">(=)</span><span class="main">)</span> <span class="main">(</span><span class="free">dp</span> <span class="bound">param</span><span class="main">)</span> <span class="main">(</span><span class="free">dp<span class="hidden">⇩</span><sub>T</sub></span> <span class="bound">param</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"consistentDP <span class="free">dp<span class="hidden">⇩</span><sub>T</sub></span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> consistentDP_def Rel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="DP_CRelVH-crel_vs_execute_None"><span class="command">lemma</span></span> crel_vs_execute_None<span class="main">:</span>
  <span class="quoted">False</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"crel_vs <span class="free">R</span> <span class="free">a</span> <span class="free">b</span>"</span></span> <span class="quoted"><span class="quoted">"execute <span class="free">b</span> <span class="free">heap</span> <span class="main">=</span> None"</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">heap</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="free">heap</span>"</span></span> <span class="quoted"><span class="quoted">"state_dp_consistency.cmem <span class="free">heap</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> crel_vs_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="DP_CRelVH-crel_vs_execute_Some"><span class="command">lemma</span></span> crel_vs_execute_Some<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"crel_vs <span class="free">R</span> <span class="free">a</span> <span class="free">b</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">heap</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="free">heap</span>"</span></span> <span class="quoted"><span class="quoted">"state_dp_consistency.cmem <span class="free">heap</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">x</span> <span class="free">heap'</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"execute <span class="free">b</span> <span class="free">heap</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">heap'</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">heap'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="free">heap'</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> crel_vs_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"execute <span class="free">b</span> <span class="free">heap</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="DP_CRelVH-crel_vs_executeD"><span class="command">lemma</span></span> crel_vs_executeD<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"crel_vs <span class="free">R</span> <span class="free">a</span> <span class="free">b</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">heap</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="free">heap</span>"</span></span> <span class="quoted"><span class="quoted">"state_dp_consistency.cmem <span class="free">heap</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">x</span> <span class="free">heap'</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"execute <span class="free">b</span> <span class="free">heap</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">heap'</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">heap'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="free">heap'</span>"</span></span> <span class="quoted"><span class="quoted">"state_dp_consistency.cmem <span class="free">heap'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="free">a</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> crel_vs_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"execute <span class="free">b</span> <span class="free">heap</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="DP_CRelVH-crel_vs_success"><span class="command">lemma</span></span> crel_vs_success<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"crel_vs <span class="free">R</span> <span class="free">a</span> <span class="free">b</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">heap</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="free">heap</span>"</span></span> <span class="quoted"><span class="quoted">"state_dp_consistency.cmem <span class="free">heap</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"success <span class="free">b</span> <span class="free">heap</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> success_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> crel_vs_executeD<span class="main">)</span>

<span class="keyword1" id="DP_CRelVH-crel_vsI"><span class="command">lemma</span></span> crel_vsI<span class="main">:</span> <span class="quoted"><span class="quoted">"crel_vs <span class="free">R</span> <span class="free">a</span> <span class="free">b</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>state_dp_consistency.crel_vs <span class="free">R</span> <span class="keyword1">OO</span> rel_state <span class="main">(=)</span><span class="main">)</span> <span class="free">a</span> <span class="free">b</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> state_dp_consistency.crel_vs_elim rel_state_elim <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> crel_vs_def<span class="main">)</span>

<span class="keyword1" id="DP_CRelVH-transfer'_return"><span class="command">lemma</span></span> transfer'_return<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">R</span> <span class="main">===&gt;</span> crel_vs <span class="free">R</span><span class="main">)</span> Wrap return"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">R</span> <span class="main">===&gt;</span> <span class="main">(</span>state_dp_consistency.crel_vs <span class="free">R</span> <span class="keyword1">OO</span> rel_state <span class="main">(=)</span><span class="main">)</span><span class="main">)</span> Wrap return"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> rel_fun_comp1 state_dp_consistency.return_transfer transfer_return<span class="main">)</span><span class="main"><span class="keyword3">+</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rel_fun_mono crel_vsI<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="DP_CRelVH-crel_vs_return"><span class="command">lemma</span></span> crel_vs_return<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Transfer.Rel <span class="main">(</span>crel_vs <span class="free">R</span><span class="main">)</span> <span class="main">(</span>Wrap <span class="free">x</span><span class="main">)</span> <span class="main">(</span>return <span class="free">y</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"Transfer.Rel <span class="free">R</span> <span class="free">x</span> <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> Rel_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> transfer'_return<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> rel_fun_def<span class="main"><span class="main">,</span></span> <span class="operator">rule_format</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="DP_CRelVH-crel_vs_return_ext"><span class="command">lemma</span></span> crel_vs_return_ext<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>Transfer.Rel <span class="free">R</span> <span class="free">x</span> <span class="free">y</span><span class="main">⟧</span> <span class="main">⟹</span> Transfer.Rel <span class="main">(</span>crel_vs <span class="free">R</span><span class="main">)</span> <span class="free">x</span> <span class="main">(</span>Heap_Monad.return <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fact</span> crel_vs_return<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> Wrap_def<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">term</span></span> <span class="quoted"><span class="main">0</span></span> <span class="comment1">(**)</span>

<span class="keyword1" id="DP_CRelVH-bind_transfer"><span class="command">lemma</span></span> bind_transfer<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>crel_vs <span class="free">R0</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">R0</span> <span class="main">===&gt;</span> crel_vs <span class="free">R1</span><span class="main">)</span> <span class="main">===&gt;</span> crel_vs <span class="free">R1</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">v</span> <span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">v</span><span class="main">)</span> <span class="main">(⤜)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> rel_fun_def bind_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">safe</span> <span class="main">(</span><span class="operator">subst</span> crel_vs_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> 4 4 <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> crel_vs_execute_Some <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> crel_vs_executeD<span class="main">)</span>


<span class="keyword1" id="DP_CRelVH-crel_vs_update"><span class="command">lemma</span></span> crel_vs_update<span class="main">:</span>
  <span class="quoted"><span class="quoted">"crel_vs <span class="main">(=)</span> <span class="main">()</span> <span class="main">(</span><span class="free">update</span> <span class="free">param</span> <span class="main">(</span><span class="free">dp</span> <span class="free">param</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span>
      crel_vsI relcomppI state_dp_consistency.crel_vs_update
      rel_state_update<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> rel_fun_def<span class="main"><span class="main">,</span></span> <span class="operator">rule_format</span><span class="main"><span class="main">]</span></span> HOL.refl
     <span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="DP_CRelVH-crel_vs_lookup"><span class="command">lemma</span></span> crel_vs_lookup<span class="main">:</span>
  <span class="quoted"><span class="quoted">"crel_vs
    <span class="main">(</span><span class="main">λ</span> <span class="bound">v</span> <span class="bound">v'</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">v'</span> <span class="keyword1">of</span> None <span class="main">⇒</span> True <span class="main">|</span> Some <span class="bound">v'</span> <span class="main">⇒</span> <span class="bound">v</span> <span class="main">=</span> <span class="bound">v'</span> <span class="main">∧</span> <span class="bound">v</span> <span class="main">=</span> <span class="free">dp</span> <span class="free">param</span><span class="main">)</span> <span class="main">(</span><span class="free">dp</span> <span class="free">param</span><span class="main">)</span> <span class="main">(</span><span class="free">lookup</span> <span class="free">param</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span>
      crel_vsI relcomppI state_dp_consistency.crel_vs_lookup
      rel_state_lookup<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> rel_fun_def<span class="main"><span class="main">,</span></span> <span class="operator">rule_format</span><span class="main"><span class="main">]</span></span> HOL.refl
     <span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="DP_CRelVH-crel_vs_eq_eq_onp"><span class="command">lemma</span></span> crel_vs_eq_eq_onp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"crel_vs <span class="main">(</span>eq_onp <span class="main">(</span><span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">v</span><span class="main">)</span><span class="main">)</span> <span class="free">v</span> <span class="free">s</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"crel_vs <span class="main">(=)</span> <span class="free">v</span> <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> crel_vs_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> eq_onp_def<span class="main">)</span>

<span class="keyword1" id="DP_CRelVH-crel_vs_bind_eq"><span class="command">lemma</span></span> crel_vs_bind_eq<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>crel_vs <span class="main">(=)</span> <span class="free">v</span> <span class="free">s</span><span class="main">;</span> crel_vs <span class="free">R</span> <span class="main">(</span><span class="free">f</span> <span class="free">v</span><span class="main">)</span> <span class="main">(</span><span class="free">sf</span> <span class="free">v</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> crel_vs <span class="free">R</span> <span class="main">(</span><span class="free">f</span> <span class="free">v</span><span class="main">)</span> <span class="main">(</span><span class="free">s</span> <span class="main">⤜</span> <span class="free">sf</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">erule</span> bind_transfer<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> rel_fun_def<span class="main"><span class="main">,</span></span> <span class="operator">rule_format</span><span class="main"><span class="main">,</span></span> <span class="operator">OF</span> crel_vs_eq_eq_onp<span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> eq_onp_def<span class="main">)</span>

<span class="keyword1" id="DP_CRelVH-crel_vs_checkmem"><span class="command">lemma</span></span> crel_vs_checkmem<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Transfer.Rel <span class="main">(</span>crel_vs <span class="free">R</span><span class="main">)</span> <span class="main">(</span><span class="free">dp</span> <span class="free">param</span><span class="main">)</span> <span class="main">(</span>checkmem <span class="free">param</span> <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"is_equality <span class="free">R</span>"</span></span> <span class="quoted"><span class="quoted">"Transfer.Rel <span class="main">(</span>crel_vs <span class="free">R</span><span class="main">)</span> <span class="main">(</span><span class="free">dp</span> <span class="free">param</span><span class="main">)</span> <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> checkmem_def Rel_def that<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> is_equality_def<span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> bind_transfer<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> rel_fun_def<span class="main"><span class="main">,</span></span> <span class="operator">rule_format</span><span class="main"><span class="main">,</span></span> <span class="operator">OF</span> crel_vs_lookup<span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> crel_vs_bind_eq crel_vs_update crel_vs_return<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> Wrap_def Rel_def<span class="main"><span class="main">]</span></span> that<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> Rel_def that<span class="main"><span class="main"><span class="main">(</span></span></span>1<span class="main"><span class="main"><span class="main">)</span></span></span><span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">unfolded</span> is_equality_def<span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="DP_CRelVH-crel_vs_checkmem_tupled"><span class="command">lemma</span></span> crel_vs_checkmem_tupled<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">=</span> <span class="free">dp</span> <span class="free">param</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>is_equality <span class="free">R</span><span class="main">;</span> Transfer.Rel <span class="main">(</span>crel_vs <span class="free">R</span><span class="main">)</span> <span class="free">v</span> <span class="free">s</span><span class="main">⟧</span>
        <span class="main">⟹</span> Transfer.Rel <span class="main">(</span>crel_vs <span class="free">R</span><span class="main">)</span> <span class="free">v</span> <span class="main">(</span>checkmem <span class="free">param</span> <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fact</span> crel_vs_checkmem<span class="main">)</span>

<span class="keyword1" id="DP_CRelVH-transfer_fun_app_lifted"><span class="command">lemma</span></span> transfer_fun_app_lifted<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>crel_vs <span class="main">(</span><span class="free">R0</span> <span class="main">===&gt;</span> crel_vs <span class="free">R1</span><span class="main">)</span> <span class="main">===&gt;</span> crel_vs <span class="free">R0</span> <span class="main">===&gt;</span> crel_vs <span class="free">R1</span><span class="main">)</span>
    App Heap_Monad_Ext.fun_app_lifted"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Heap_Monad_Ext.fun_app_lifted_def App_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="DP_CRelVH-crel_vs_fun_app"><span class="command">lemma</span></span> crel_vs_fun_app<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>Transfer.Rel <span class="main">(</span>crel_vs <span class="free">R0</span><span class="main">)</span> <span class="free">x</span> <span class="free">x<span class="hidden">⇩</span><sub>T</sub></span><span class="main">;</span> Transfer.Rel <span class="main">(</span>crel_vs <span class="main">(</span><span class="free">R0</span> <span class="keyword1">===&gt;<span class="hidden">⇩</span><sub>T</sub></span> <span class="free">R1</span><span class="main">)</span><span class="main">)</span> <span class="free">f</span> <span class="free">f<span class="hidden">⇩</span><sub>T</sub></span><span class="main">⟧</span> <span class="main">⟹</span> Transfer.Rel <span class="main">(</span>crel_vs <span class="free">R1</span><span class="main">)</span> <span class="main">(</span>App <span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span><span class="free">f<span class="hidden">⇩</span><sub>T</sub></span> <span class="main">.</span> <span class="free">x<span class="hidden">⇩</span><sub>T</sub></span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Rel_def <span class="keyword1"><span class="command">using</span></span> transfer_fun_app_lifted<span class="main">[</span><span class="operator">THEN</span> rel_funD<span class="main">,</span> <span class="operator">THEN</span> rel_funD<span class="main">]</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Lifting Syntax *)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Dynamic Programming Problem *)</span>

<span class="keyword1"><span class="command">locale</span></span> dp_consistency_heap <span class="main">=</span> heap_correct <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">dp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> state_mem_correct<span class="main">:</span> mem_correct <span class="quoted">lookup'</span> <span class="quoted">update'</span> <span class="quoted"><span class="free">P</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> mem_correct_heap<span class="main">)</span>

<span class="keyword1"><span class="command">interpretation</span></span> state_dp_consistency<span class="main">:</span> dp_consistency <span class="quoted">lookup'</span> <span class="quoted">update'</span> <span class="quoted"><span class="free">P</span></span> <span class="quoted"><span class="free">dp</span></span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1" id="DP_CRelVH-dp_heap"><span class="command">lemma</span></span> dp_heap<span class="main">:</span> <span class="quoted"><span class="quoted">"dp_heap <span class="free">P</span> <span class="free">P</span> <span class="free">lookup</span> lookup' <span class="free">update</span> update'"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">rule</span> transfer_lookup transfer_update<span class="main">)</span>

<span class="keyword1"><span class="command">sublocale</span></span> dp_heap <span class="quoted"><span class="free">P</span></span> <span class="quoted"><span class="free">P</span></span> <span class="quoted"><span class="free">dp</span></span> <span class="quoted"><span class="free">lookup</span></span> <span class="quoted">lookup'</span> <span class="quoted"><span class="free">update</span></span> <span class="quoted">update'</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> dp_heap<span class="main">)</span>

<span class="keyword1"><span class="command">notation</span></span> rel_fun_lifted <span class="main">(</span><span class="keyword2"><span class="keyword">infixr</span></span> <span class="quoted">"<span class="keyword1">===&gt;<span class="hidden">⇩</span><sub>T</sub></span>"</span> 55<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> heap_correct_empty <span class="main">=</span> heap_correct <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">empty</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> empty_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"map_of_heap <span class="free">empty</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> Map.empty"</span></span> <span class="keyword2"><span class="keyword">and</span></span> P_empty<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">empty</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> dp_consistency_heap_empty <span class="main">=</span>
  dp_consistency_heap <span class="main">+</span> heap_correct_empty
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="DP_CRelVH-cmem_empty"><span class="command">lemma</span></span> cmem_empty<span class="main">:</span>
  <span class="quoted"><span class="quoted">"state_dp_consistency.cmem <span class="free">empty</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> empty_correct
  <span class="keyword1"><span class="command">unfolding</span></span> state_dp_consistency.cmem_def
  <span class="keyword1"><span class="command">unfolding</span></span> map_of_heap_def
  <span class="keyword1"><span class="command">unfolding</span></span> state_dp_consistency.map_of_def
  <span class="keyword1"><span class="command">unfolding</span></span> lookup'_def
  <span class="keyword1"><span class="command">unfolding</span></span> map_le_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">corollary</span></span> memoization_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">dp</span> <span class="free">x</span> <span class="main">=</span> <span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"state_dp_consistency.cmem <span class="free">m</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span>
  <span class="quoted"><span class="quoted">"consistentDP <span class="free">dp<span class="hidden">⇩</span><sub>T</sub></span>"</span></span> <span class="quoted"><span class="quoted">"Heap_Monad.execute <span class="main">(</span><span class="free">dp<span class="hidden">⇩</span><sub>T</sub></span> <span class="free">x</span><span class="main">)</span> <span class="free">empty</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="free">m</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> consistentDP_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_funD<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="free">x</span></span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> crel_vs_executeD <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> P_empty cmem_empty<span class="main">)</span>

<span class="keyword1" id="DP_CRelVH-memoized_success"><span class="command">lemma</span></span> memoized_success<span class="main">:</span>
  <span class="quoted"><span class="quoted">"success <span class="main">(</span><span class="free">dp<span class="hidden">⇩</span><sub>T</sub></span> <span class="free">x</span><span class="main">)</span> <span class="free">empty</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"consistentDP <span class="free">dp<span class="hidden">⇩</span><sub>T</sub></span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that cmem_empty P_empty
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_funD <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> crel_vs_success <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> consistentDP_def<span class="main">)</span>

<span class="keyword1" id="DP_CRelVH-memoized"><span class="command">lemma</span></span> memoized<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">dp</span> <span class="free">x</span> <span class="main">=</span> fst <span class="main">(</span>the <span class="main">(</span>Heap_Monad.execute <span class="main">(</span><span class="free">dp<span class="hidden">⇩</span><sub>T</sub></span> <span class="free">x</span><span class="main">)</span> <span class="free">empty</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"consistentDP <span class="free">dp<span class="hidden">⇩</span><sub>T</sub></span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> surjective_pairing memoization_correct<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> that<span class="main">]</span>
    memoized_success<span class="main">[</span><span class="operator">OF</span> that<span class="main">,</span> <span class="operator">unfolded</span> success_def<span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"execute <span class="main">(</span><span class="free">dp<span class="hidden">⇩</span><sub>T</sub></span> <span class="free">x</span><span class="main">)</span> <span class="free">empty</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="DP_CRelVH-cmem_result"><span class="command">lemma</span></span> cmem_result<span class="main">:</span>
  <span class="quoted"><span class="quoted">"state_dp_consistency.cmem <span class="main">(</span>snd <span class="main">(</span>the <span class="main">(</span>Heap_Monad.execute <span class="main">(</span><span class="free">dp<span class="hidden">⇩</span><sub>T</sub></span> <span class="free">x</span><span class="main">)</span> <span class="free">empty</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"consistentDP <span class="free">dp<span class="hidden">⇩</span><sub>T</sub></span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> surjective_pairing memoization_correct<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> that<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span>
    memoized_success<span class="main">[</span><span class="operator">OF</span> that<span class="main">,</span> <span class="operator">unfolded</span> success_def<span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"execute <span class="main">(</span><span class="free">dp<span class="hidden">⇩</span><sub>T</sub></span> <span class="free">x</span><span class="main">)</span> <span class="free">empty</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Theory *)</span>
</pre>
</div><div id="Memory">
<div class="head">
<h1>Theory Memory</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Memoization›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Memory Implementations for the State Monad›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Memory
  <span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="#DP_CRelVS">DP_CRelVS</a>"</span> <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/Mapping.html">HOL-Library.Mapping</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Memory-lift_pI"><span class="command">lemma</span></span> lift_pI<span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">?</span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lift_p <span class="free">P</span> <span class="free">f</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">heap</span> <span class="bound">x</span> <span class="bound">heap'</span><span class="main">.</span> <span class="free">P</span> <span class="bound">heap</span> <span class="main">⟹</span> run_state <span class="free">f</span> <span class="bound">heap</span> <span class="main">=</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">heap'</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">heap'</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> lift_p_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> that<span class="main">)</span>

<span class="keyword1" id="Memory-mem_correct_default"><span class="command">lemma</span></span> mem_correct_default<span class="main">:</span>
  <span class="quoted"><span class="quoted">"mem_correct
    <span class="main">(</span><span class="main">λ</span> <span class="bound">k</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span><span class="bound">m</span> <span class="main">←</span> State_Monad.get<span class="main">;</span> State_Monad.return <span class="main">(</span><span class="bound">m</span> <span class="bound">k</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>
    <span class="main">(</span><span class="main">λ</span> <span class="bound">k</span> <span class="bound">v</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span><span class="bound">m</span> <span class="main">←</span> State_Monad.get<span class="main">;</span> State_Monad.set <span class="main">(</span><span class="bound">m</span><span class="main">(</span><span class="bound">k</span><span class="main">↦</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>
    <span class="main">(</span><span class="main">λ</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span>
    <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> map_le_def state_mem_defs.map_of_def State_Monad.bind_def State_Monad.get_def State_Monad.return_def State_Monad.set_def lift_p_def<span class="main">)</span>


<span class="keyword1" id="Memory-mem_correct_rbt_mapping"><span class="command">lemma</span></span> mem_correct_rbt_mapping<span class="main">:</span>
  <span class="quoted"><span class="quoted">"mem_correct
    <span class="main">(</span><span class="main">λ</span> <span class="bound">k</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span><span class="bound">m</span> <span class="main">←</span> State_Monad.get<span class="main">;</span> State_Monad.return <span class="main">(</span>Mapping.lookup <span class="bound">m</span> <span class="bound">k</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>
    <span class="main">(</span><span class="main">λ</span> <span class="bound">k</span> <span class="bound">v</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span><span class="bound">m</span> <span class="main">←</span> State_Monad.get<span class="main">;</span> State_Monad.set <span class="main">(</span>Mapping.update <span class="bound">k</span> <span class="bound">v</span> <span class="bound">m</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>
    <span class="main">(</span><span class="main">λ</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span>
     <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>
        map_le_def state_mem_defs.map_of_def State_Monad.bind_def State_Monad.get_def State_Monad.return_def State_Monad.set_def lookup_update' lift_p_def
     <span class="main">)</span>



<span class="keyword1"><span class="command">locale</span></span> mem_correct_empty <span class="main">=</span> mem_correct <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">empty</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> empty_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"map_of <span class="free">empty</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> Map.empty"</span></span> <span class="keyword2"><span class="keyword">and</span></span> P_empty<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">empty</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> mem_correct_empty<span class="main">)</span> dom_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"dom <span class="main">(</span>map_of <span class="free">empty</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> empty_correct <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> map_le_implies_dom_le<span class="main">)</span>

<span class="keyword1" id="Memory-mem_correct_empty_default"><span class="command">lemma</span></span> mem_correct_empty_default<span class="main">:</span>
  <span class="quoted"><span class="quoted">"mem_correct_empty
    <span class="main">(</span><span class="main">λ</span> <span class="bound">k</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span><span class="bound">m</span> <span class="main">←</span> State_Monad.get<span class="main">;</span> State_Monad.return <span class="main">(</span><span class="bound">m</span> <span class="bound">k</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>
    <span class="main">(</span><span class="main">λ</span> <span class="bound">k</span> <span class="bound">v</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span><span class="bound">m</span> <span class="main">←</span> State_Monad.get<span class="main">;</span> State_Monad.set <span class="main">(</span><span class="bound">m</span><span class="main">(</span><span class="bound">k</span><span class="main">↦</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>
    <span class="main">(</span><span class="main">λ</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span>
    Map.empty"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> mem_correct_empty.intro<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mem_correct_default<span class="main"><span class="main">]</span></span> mem_correct_empty_axioms.intro<span class="main">)</span>
     <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> state_mem_defs.map_of_def map_le_def State_Monad.bind_def State_Monad.get_def State_Monad.return_def<span class="main">)</span>

<span class="keyword1" id="Memory-mem_correct_rbt_empty_mapping"><span class="command">lemma</span></span> mem_correct_rbt_empty_mapping<span class="main">:</span>
  <span class="quoted"><span class="quoted">"mem_correct_empty
    <span class="main">(</span><span class="main">λ</span> <span class="bound">k</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span><span class="bound">m</span> <span class="main">←</span> State_Monad.get<span class="main">;</span> State_Monad.return <span class="main">(</span>Mapping.lookup <span class="bound">m</span> <span class="bound">k</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>
    <span class="main">(</span><span class="main">λ</span> <span class="bound">k</span> <span class="bound">v</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span><span class="bound">m</span> <span class="main">←</span> State_Monad.get<span class="main">;</span> State_Monad.set <span class="main">(</span>Mapping.update <span class="bound">k</span> <span class="bound">v</span> <span class="bound">m</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>
    <span class="main">(</span><span class="main">λ</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span>
    Mapping.empty"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> mem_correct_empty.intro<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mem_correct_rbt_mapping<span class="main"><span class="main">]</span></span> mem_correct_empty_axioms.intro<span class="main">)</span>
     <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> state_mem_defs.map_of_def map_le_def State_Monad.bind_def State_Monad.get_def State_Monad.return_def lookup_empty<span class="main">)</span>

<span class="keyword1"><span class="command">locale</span></span> dp_consistency_empty <span class="main">=</span>
  dp_consistency <span class="main">+</span> mem_correct_empty
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Memory-cmem_empty"><span class="command">lemma</span></span> cmem_empty<span class="main">:</span>
  <span class="quoted"><span class="quoted">"cmem <span class="free">empty</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> empty_correct <span class="keyword1"><span class="command">unfolding</span></span> cmem_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">corollary</span></span> memoization_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">dp</span> <span class="free">x</span> <span class="main">=</span> <span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"cmem <span class="free">m</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"consistentDP <span class="free">dp<span class="hidden">⇩</span><sub>T</sub></span>"</span></span> <span class="quoted"><span class="quoted">"State_Monad.run_state <span class="main">(</span><span class="free">dp<span class="hidden">⇩</span><sub>T</sub></span> <span class="free">x</span><span class="main">)</span> <span class="free">empty</span> <span class="main">=</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="free">m</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> consistentDP_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_funD<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="free">x</span></span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> crel_vs_elim <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> P_empty cmem_empty<span class="main">)</span>

<span class="keyword1" id="Memory-memoized"><span class="command">lemma</span></span> memoized<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">dp</span> <span class="free">x</span> <span class="main">=</span> fst <span class="main">(</span>State_Monad.run_state <span class="main">(</span><span class="free">dp<span class="hidden">⇩</span><sub>T</sub></span> <span class="free">x</span><span class="main">)</span> <span class="free">empty</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"consistentDP <span class="free">dp<span class="hidden">⇩</span><sub>T</sub></span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> surjective_pairing memoization_correct<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> that<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="Memory-cmem_result"><span class="command">lemma</span></span> cmem_result<span class="main">:</span>
  <span class="quoted"><span class="quoted">"cmem <span class="main">(</span>snd <span class="main">(</span>State_Monad.run_state <span class="main">(</span><span class="free">dp<span class="hidden">⇩</span><sub>T</sub></span> <span class="free">x</span><span class="main">)</span> <span class="free">empty</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"consistentDP <span class="free">dp<span class="hidden">⇩</span><sub>T</sub></span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> surjective_pairing memoization_correct<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> that<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* DP Consistency Empty *)</span>

<span class="keyword1"><span class="command">locale</span></span> dp_consistency_default <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">dp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'param</span> <span class="main">⇒</span> <span class="tfree">'result</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> dp_consistency_empty
  <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">k</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span><span class="main">(</span><span class="bound">m</span><span class="main">::</span><span class="tfree">'param</span> <span class="main">⇀</span> <span class="tfree">'result</span><span class="main">)</span> <span class="main">←</span> State_Monad.get<span class="main">;</span> State_Monad.return <span class="main">(</span><span class="bound">m</span> <span class="bound">k</span><span class="main">)</span><span class="main">}</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">k</span> <span class="bound">v</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span><span class="bound">m</span> <span class="main">←</span> State_Monad.get<span class="main">;</span> State_Monad.set <span class="main">(</span><span class="bound">m</span><span class="main">(</span><span class="bound">k</span><span class="main">↦</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">::</span><span class="tfree">'param</span> <span class="main">⇀</span> <span class="tfree">'result</span><span class="main">)</span><span class="main">.</span> True"</span></span>
  <span class="quoted"><span class="free">dp</span></span>
  <span class="quoted">Map.empty</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span>
      dp_consistency_empty.intro dp_consistency.intro mem_correct_default mem_correct_empty_default
     <span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* DP Consistency Default *)</span>

<span class="keyword1"><span class="command">locale</span></span> dp_consistency_mapping <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">dp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'param</span> <span class="main">⇒</span> <span class="tfree">'result</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> dp_consistency_empty
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span> <span class="bound">k</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span><span class="main">(</span><span class="bound">m</span><span class="main">::</span><span class="main">(</span><span class="tfree">'param</span><span class="main">,</span><span class="tfree">'result</span><span class="main">)</span> mapping<span class="main">)</span> <span class="main">←</span> State_Monad.get<span class="main">;</span> State_Monad.return <span class="main">(</span>Mapping.lookup <span class="bound">m</span> <span class="bound">k</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span> <span class="bound">k</span> <span class="bound">v</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span><span class="bound">m</span> <span class="main">←</span> State_Monad.get<span class="main">;</span> State_Monad.set <span class="main">(</span>Mapping.update <span class="bound">k</span> <span class="bound">v</span> <span class="bound">m</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span> <span class="main"><span class="bound">_</span></span><span class="main">::</span><span class="main">(</span><span class="tfree">'param</span><span class="main">,</span><span class="tfree">'result</span><span class="main">)</span> mapping<span class="main">.</span> True<span class="main">)</span>"</span></span> <span class="quoted"><span class="free">dp</span></span> <span class="quoted">Mapping.empty</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span>
      dp_consistency_empty.intro dp_consistency.intro mem_correct_rbt_mapping
      mem_correct_rbt_empty_mapping
     <span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* DP Consistency RBT *)</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Tracing Memory›</span></span>
<span class="keyword1"><span class="command">context</span></span> state_mem_defs
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lookup_trace</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">=</span>
  State <span class="main">(</span><span class="main">λ</span> <span class="main">(</span><span class="bound">log</span><span class="main">,</span> <span class="bound">m</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">case</span> State_Monad.run_state <span class="main">(</span><span class="free">lookup</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">)</span> <span class="bound">m</span> <span class="keyword1">of</span>
    <span class="main">(</span>None<span class="main">,</span> <span class="bound">m</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span>None<span class="main">,</span> <span class="main">(</span><span class="main">(</span><span class="inner_quoted">''Missed''</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">)</span> <span class="main">#</span> <span class="bound">log</span><span class="main">,</span> <span class="bound">m</span><span class="main">)</span><span class="main">)</span> <span class="main">|</span>
    <span class="main">(</span>Some <span class="bound">v</span><span class="main">,</span> <span class="bound">m</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span>Some <span class="bound">v</span><span class="main">,</span> <span class="main">(</span><span class="main">(</span><span class="inner_quoted">''Found''</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">)</span> <span class="main">#</span> <span class="bound">log</span><span class="main">,</span> <span class="bound">m</span><span class="main">)</span><span class="main">)</span>
  <span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">update_trace</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span>
  State <span class="main">(</span><span class="main">λ</span> <span class="main">(</span><span class="bound">log</span><span class="main">,</span> <span class="bound">m</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">case</span> State_Monad.run_state <span class="main">(</span><span class="free">update</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="bound">m</span> <span class="keyword1">of</span>
    <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">m</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">()</span><span class="main">,</span> <span class="main">(</span><span class="main">(</span><span class="inner_quoted">''Stored''</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">)</span> <span class="main">#</span> <span class="bound">log</span><span class="main">,</span> <span class="bound">m</span><span class="main">)</span><span class="main">)</span>
  <span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> mem_correct
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Memory-map_of_simp"><span class="command">lemma</span></span> map_of_simp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"state_mem_defs.map_of lookup_trace <span class="main">=</span> map_of <span class="keyword1">o</span> snd"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> state_mem_defs.map_of_def lookup_trace_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split option.split<span class="main">)</span>

<span class="keyword1" id="Memory-mem_correct_tracing"><span class="command">lemma</span></span> mem_correct_tracing<span class="main">:</span> <span class="quoted"><span class="quoted">"mem_correct lookup_trace update_trace <span class="main">(</span><span class="free">P</span> <span class="keyword1">o</span> snd<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span>
    <span class="main">(</span><span class="operator">auto</span>
      <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> lift_pI
      <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> lift_p_P<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lookup_inv<span class="main"><span class="main">]</span></span>
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> lookup_trace_def update_trace_def state_mem_defs.map_of_def map_of_simp
      <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits option.splits<span class="main"><span class="keyword3">;</span></span>
      <span class="operator">metis</span> snd_conv lookup_correct update_correct lift_p_P update_inv lookup_inv lift_p_P
   <span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> mem_correct_empty
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Memory-mem_correct_tracing_empty"><span class="command">lemma</span></span> mem_correct_tracing_empty<span class="main">:</span>
  <span class="quoted"><span class="quoted">"mem_correct_empty lookup_trace update_trace <span class="main">(</span><span class="free">P</span> <span class="keyword1">o</span> snd<span class="main">)</span> <span class="main">(</span><span class="main">[]</span><span class="main">,</span> <span class="free">empty</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> mem_correct_empty.intro mem_correct_tracing mem_correct_empty_axioms.intro<span class="main">)</span>
     <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_of_simp empty_correct P_empty<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> dp_consistency_mapping_tracing <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">dp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'param</span> <span class="main">⇒</span> <span class="tfree">'result</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> mapping<span class="main">:</span> dp_consistency_mapping <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> dp_consistency_empty
  <span class="quoted">mapping.lookup_trace</span> <span class="quoted">mapping.update_trace</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> <span class="keyword1">o</span> snd"</span></span> <span class="quoted"><span class="free">dp</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">[]</span><span class="main">,</span> Mapping.empty<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span>
      dp_consistency_empty.intro dp_consistency.intro
      mapping.mem_correct_tracing_empty mem_correct_empty.axioms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span>
     <span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* DP Consistency RBT *)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Theory *)</span>
</pre>
</div><div id="Pair_Memory">
<div class="head">
<h1>Theory Pair_Memory</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Pair Memory›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Pair_Memory
  <span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="#Memory">../state_monad/Memory</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(* XXX Move *)</span>
<span class="keyword1" id="Pair_Memory-map_add_mono"><span class="command">lemma</span></span> map_add_mono<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">m1</span> <span class="main">++</span> <span class="free">m2</span><span class="main">)</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> <span class="main">(</span><span class="free">m1'</span> <span class="main">++</span> <span class="free">m2'</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">m1</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> <span class="free">m1'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">m2</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> <span class="free">m2'</span>"</span></span> <span class="quoted"><span class="quoted">"dom <span class="free">m1</span> <span class="main">∩</span> dom <span class="free">m2'</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> map_le_def map_add_def dom_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword1" id="Pair_Memory-map_add_upd2"><span class="command">lemma</span></span> map_add_upd2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">f</span><span class="main">(</span><span class="free">x</span> <span class="main">↦</span> <span class="free">y</span><span class="main">)</span> <span class="main">++</span> <span class="free">g</span> <span class="main">=</span> <span class="main">(</span><span class="free">f</span> <span class="main">++</span> <span class="free">g</span><span class="main">)</span><span class="main">(</span><span class="free">x</span> <span class="main">↦</span> <span class="free">y</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"dom <span class="free">f</span> <span class="main">∩</span> dom <span class="free">g</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∉</span> dom <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> map_add_comm<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> map_add_comm<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> that
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">locale</span></span> pair_mem_defs <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">lookup1</span> <span class="free">lookup2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'mem</span><span class="main">,</span> <span class="tfree">'v</span> option<span class="main">)</span> state"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">update1</span> <span class="free">update2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'mem</span><span class="main">,</span> unit<span class="main">)</span> state"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">move12</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k1</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'mem</span><span class="main">,</span> unit<span class="main">)</span> state"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">get_k1</span> <span class="free">get_k2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'mem</span><span class="main">,</span> <span class="tfree">'k1</span><span class="main">)</span> state"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">P</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'mem</span> <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">key1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'k1</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">key2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We assume that look-ups happen on the older row, so it is biased towards the second entry.›</span></span>
<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lookup_pair</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
     <span class="keyword1">let</span> <span class="bound">k'</span> <span class="main">=</span> <span class="free">key1</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">;</span>
     <span class="bound">k2</span> <span class="main">←</span> <span class="free">get_k2</span><span class="main">;</span>
     <span class="keyword1">if</span> <span class="bound">k'</span> <span class="main">=</span> <span class="bound">k2</span>
     <span class="keyword1">then</span> <span class="free">lookup2</span> <span class="main">(</span><span class="free">key2</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">)</span>
     <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
       <span class="bound">k1</span> <span class="main">←</span> <span class="free">get_k1</span><span class="main">;</span>
       <span class="keyword1">if</span> <span class="bound">k'</span> <span class="main">=</span> <span class="bound">k1</span>
       <span class="keyword1">then</span> <span class="free">lookup1</span> <span class="main">(</span><span class="free">key2</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">)</span>
       <span class="keyword1">else</span> State_Monad.return None
     <span class="main">}</span>
   <span class="main">}</span>
   "</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We assume that updates happen on the newer row, so it is biased towards the first entry.›</span></span>
<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">update_pair</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">let</span> <span class="bound">k'</span> <span class="main">=</span> <span class="free">key1</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">;</span>
    <span class="bound">k1</span> <span class="main">←</span> <span class="free">get_k1</span><span class="main">;</span>
    <span class="keyword1">if</span> <span class="bound">k'</span> <span class="main">=</span> <span class="bound">k1</span>
    <span class="keyword1">then</span> <span class="free">update1</span> <span class="main">(</span><span class="free">key2</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span>
    <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">k2</span> <span class="main">←</span> <span class="free">get_k2</span><span class="main">;</span>
      <span class="keyword1">if</span> <span class="bound">k'</span> <span class="main">=</span> <span class="bound">k2</span>
      <span class="keyword1">then</span> <span class="free">update2</span> <span class="main">(</span><span class="free">key2</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span>
      <span class="keyword1">else</span> <span class="main">(</span><span class="free">move12</span> <span class="bound">k'</span> <span class="main">⪢</span> <span class="free">update1</span> <span class="main">(</span><span class="free">key2</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span>
    <span class="main">}</span>
  <span class="main">}</span>
  "</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> pair<span class="main">:</span> state_mem_defs <span class="quoted">lookup_pair</span> <span class="quoted">update_pair</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> mem1<span class="main">:</span> state_mem_defs <span class="quoted"><span class="free">lookup1</span></span> <span class="quoted"><span class="free">update1</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> mem2<span class="main">:</span> state_mem_defs <span class="quoted"><span class="free">lookup2</span></span> <span class="quoted"><span class="free">update2</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">inv_pair</span> <span class="free"><span class="bound"><span class="entity">heap</span></span></span> <span class="main">≡</span>
    <span class="keyword1">let</span>
      <span class="bound">k1</span> <span class="main">=</span> fst <span class="main">(</span>State_Monad.run_state <span class="free">get_k1</span> <span class="free"><span class="bound"><span class="entity">heap</span></span></span><span class="main">)</span><span class="main">;</span>
      <span class="bound">k2</span> <span class="main">=</span> fst <span class="main">(</span>State_Monad.run_state <span class="free">get_k2</span> <span class="free"><span class="bound"><span class="entity">heap</span></span></span><span class="main">)</span>
    <span class="keyword1">in</span>
    <span class="main">(</span><span class="main">∀</span> <span class="bound">k</span> <span class="main">∈</span> dom <span class="main">(</span>mem1.map_of <span class="free"><span class="bound"><span class="entity">heap</span></span></span><span class="main">)</span><span class="main">.</span> <span class="main">∃</span> <span class="bound">k'</span><span class="main">.</span> <span class="free">key1</span> <span class="bound">k'</span> <span class="main">=</span> <span class="bound">k1</span> <span class="main">∧</span> <span class="free">key2</span> <span class="bound">k'</span> <span class="main">=</span> <span class="bound">k</span><span class="main">)</span> <span class="main">∧</span>
    <span class="main">(</span><span class="main">∀</span> <span class="bound">k</span> <span class="main">∈</span> dom <span class="main">(</span>mem2.map_of <span class="free"><span class="bound"><span class="entity">heap</span></span></span><span class="main">)</span><span class="main">.</span> <span class="main">∃</span> <span class="bound">k'</span><span class="main">.</span> <span class="free">key1</span> <span class="bound">k'</span> <span class="main">=</span> <span class="bound">k2</span> <span class="main">∧</span> <span class="free">key2</span> <span class="bound">k'</span> <span class="main">=</span> <span class="bound">k</span><span class="main">)</span> <span class="main">∧</span>
    <span class="bound">k1</span> <span class="main">≠</span> <span class="bound">k2</span> <span class="main">∧</span> <span class="free">P</span> <span class="free"><span class="bound"><span class="entity">heap</span></span></span>
  "</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">map_of1</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">key1</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">=</span> fst <span class="main">(</span>State_Monad.run_state <span class="free">get_k1</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="keyword1">then</span> mem1.map_of <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">(</span><span class="free">key2</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">)</span> <span class="keyword1">else</span> None<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">map_of2</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">key1</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">=</span> fst <span class="main">(</span>State_Monad.run_state <span class="free">get_k2</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="keyword1">then</span> mem2.map_of <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">(</span><span class="free">key2</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">)</span> <span class="keyword1">else</span> None<span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Pair Mem Defs *)</span>

<span class="keyword1"><span class="command">locale</span></span> pair_mem <span class="main">=</span> pair_mem_defs <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> get_state<span class="main">:</span>
    <span class="quoted"><span class="quoted">"State_Monad.run_state <span class="free">get_k1</span> <span class="free">m</span> <span class="main">=</span> <span class="main">(</span><span class="free">k</span><span class="main">,</span> <span class="free">m'</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">m'</span> <span class="main">=</span> <span class="free">m</span>"</span></span>
    <span class="quoted"><span class="quoted">"State_Monad.run_state <span class="free">get_k2</span> <span class="free">m</span> <span class="main">=</span> <span class="main">(</span><span class="free">k</span><span class="main">,</span> <span class="free">m'</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">m'</span> <span class="main">=</span> <span class="free">m</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> move12_correct<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">m</span> <span class="main">⟹</span> State_Monad.run_state <span class="main">(</span><span class="free">move12</span> <span class="free">k1</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">m'</span><span class="main">)</span> <span class="main">⟹</span> mem1.map_of <span class="free">m'</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> Map.empty"</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">m</span> <span class="main">⟹</span> State_Monad.run_state <span class="main">(</span><span class="free">move12</span> <span class="free">k1</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">m'</span><span class="main">)</span> <span class="main">⟹</span> mem2.map_of <span class="free">m'</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> mem1.map_of <span class="free">m</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> move12_keys<span class="main">:</span>
    <span class="quoted"><span class="quoted">"State_Monad.run_state <span class="main">(</span><span class="free">move12</span> <span class="free">k1</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">m'</span><span class="main">)</span> <span class="main">⟹</span> fst <span class="main">(</span>State_Monad.run_state <span class="free">get_k1</span> <span class="free">m'</span><span class="main">)</span> <span class="main">=</span> <span class="free">k1</span>"</span></span>
    <span class="quoted"><span class="quoted">"State_Monad.run_state <span class="main">(</span><span class="free">move12</span> <span class="free">k1</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">m'</span><span class="main">)</span> <span class="main">⟹</span> fst <span class="main">(</span>State_Monad.run_state <span class="free">get_k2</span> <span class="free">m'</span><span class="main">)</span> <span class="main">=</span> fst <span class="main">(</span>State_Monad.run_state <span class="free">get_k1</span> <span class="free">m</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> move12_inv<span class="main">:</span>
    <span class="quoted"><span class="quoted">"lift_p <span class="free">P</span> <span class="main">(</span><span class="free">move12</span> <span class="free">k1</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> lookup_inv<span class="main">:</span>
    <span class="quoted"><span class="quoted">"lift_p <span class="free">P</span> <span class="main">(</span><span class="free">lookup1</span> <span class="free">k'</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"lift_p <span class="free">P</span> <span class="main">(</span><span class="free">lookup2</span> <span class="free">k'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> update_inv<span class="main">:</span>
    <span class="quoted"><span class="quoted">"lift_p <span class="free">P</span> <span class="main">(</span><span class="free">update1</span> <span class="free">k'</span> <span class="free">v</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"lift_p <span class="free">P</span> <span class="main">(</span><span class="free">update2</span> <span class="free">k'</span> <span class="free">v</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> lookup_keys<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">m</span> <span class="main">⟹</span> State_Monad.run_state <span class="main">(</span><span class="free">lookup1</span> <span class="free">k'</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span> <span class="main">(</span><span class="free">v'</span><span class="main">,</span> <span class="free">m'</span><span class="main">)</span> <span class="main">⟹</span>
     fst <span class="main">(</span>State_Monad.run_state <span class="free">get_k1</span> <span class="free">m'</span><span class="main">)</span> <span class="main">=</span> fst <span class="main">(</span>State_Monad.run_state <span class="free">get_k1</span> <span class="free">m</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">m</span> <span class="main">⟹</span> State_Monad.run_state <span class="main">(</span><span class="free">lookup1</span> <span class="free">k'</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span> <span class="main">(</span><span class="free">v'</span><span class="main">,</span> <span class="free">m'</span><span class="main">)</span> <span class="main">⟹</span>
     fst <span class="main">(</span>State_Monad.run_state <span class="free">get_k2</span> <span class="free">m'</span><span class="main">)</span> <span class="main">=</span> fst <span class="main">(</span>State_Monad.run_state <span class="free">get_k2</span> <span class="free">m</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">m</span> <span class="main">⟹</span> State_Monad.run_state <span class="main">(</span><span class="free">lookup2</span> <span class="free">k'</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span> <span class="main">(</span><span class="free">v'</span><span class="main">,</span> <span class="free">m'</span><span class="main">)</span> <span class="main">⟹</span>
     fst <span class="main">(</span>State_Monad.run_state <span class="free">get_k1</span> <span class="free">m'</span><span class="main">)</span> <span class="main">=</span> fst <span class="main">(</span>State_Monad.run_state <span class="free">get_k1</span> <span class="free">m</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">m</span> <span class="main">⟹</span> State_Monad.run_state <span class="main">(</span><span class="free">lookup2</span> <span class="free">k'</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span> <span class="main">(</span><span class="free">v'</span><span class="main">,</span> <span class="free">m'</span><span class="main">)</span> <span class="main">⟹</span>
     fst <span class="main">(</span>State_Monad.run_state <span class="free">get_k2</span> <span class="free">m'</span><span class="main">)</span> <span class="main">=</span> fst <span class="main">(</span>State_Monad.run_state <span class="free">get_k2</span> <span class="free">m</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> update_keys<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">m</span> <span class="main">⟹</span> State_Monad.run_state <span class="main">(</span><span class="free">update1</span> <span class="free">k'</span> <span class="free">v</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">m'</span><span class="main">)</span> <span class="main">⟹</span>
     fst <span class="main">(</span>State_Monad.run_state <span class="free">get_k1</span> <span class="free">m'</span><span class="main">)</span> <span class="main">=</span> fst <span class="main">(</span>State_Monad.run_state <span class="free">get_k1</span> <span class="free">m</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">m</span> <span class="main">⟹</span> State_Monad.run_state <span class="main">(</span><span class="free">update1</span> <span class="free">k'</span> <span class="free">v</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">m'</span><span class="main">)</span> <span class="main">⟹</span>
     fst <span class="main">(</span>State_Monad.run_state <span class="free">get_k2</span> <span class="free">m'</span><span class="main">)</span> <span class="main">=</span> fst <span class="main">(</span>State_Monad.run_state <span class="free">get_k2</span> <span class="free">m</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">m</span> <span class="main">⟹</span> State_Monad.run_state <span class="main">(</span><span class="free">update2</span> <span class="free">k'</span> <span class="free">v</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">m'</span><span class="main">)</span> <span class="main">⟹</span>
     fst <span class="main">(</span>State_Monad.run_state <span class="free">get_k1</span> <span class="free">m'</span><span class="main">)</span> <span class="main">=</span> fst <span class="main">(</span>State_Monad.run_state <span class="free">get_k1</span> <span class="free">m</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">m</span> <span class="main">⟹</span> State_Monad.run_state <span class="main">(</span><span class="free">update2</span> <span class="free">k'</span> <span class="free">v</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">m'</span><span class="main">)</span> <span class="main">⟹</span>
     fst <span class="main">(</span>State_Monad.run_state <span class="free">get_k2</span> <span class="free">m'</span><span class="main">)</span> <span class="main">=</span> fst <span class="main">(</span>State_Monad.run_state <span class="free">get_k2</span> <span class="free">m</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span>
    lookup_correct<span class="main">:</span>
      <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">m</span> <span class="main">⟹</span> mem1.map_of <span class="main">(</span>snd <span class="main">(</span>State_Monad.run_state <span class="main">(</span><span class="free">lookup1</span> <span class="free">k'</span><span class="main">)</span> <span class="free">m</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> <span class="main">(</span>mem1.map_of <span class="free">m</span><span class="main">)</span>"</span></span>
      <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">m</span> <span class="main">⟹</span> mem2.map_of <span class="main">(</span>snd <span class="main">(</span>State_Monad.run_state <span class="main">(</span><span class="free">lookup1</span> <span class="free">k'</span><span class="main">)</span> <span class="free">m</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> <span class="main">(</span>mem2.map_of <span class="free">m</span><span class="main">)</span>"</span></span>
      <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">m</span> <span class="main">⟹</span> mem1.map_of <span class="main">(</span>snd <span class="main">(</span>State_Monad.run_state <span class="main">(</span><span class="free">lookup2</span> <span class="free">k'</span><span class="main">)</span> <span class="free">m</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> <span class="main">(</span>mem1.map_of <span class="free">m</span><span class="main">)</span>"</span></span>
      <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">m</span> <span class="main">⟹</span> mem2.map_of <span class="main">(</span>snd <span class="main">(</span>State_Monad.run_state <span class="main">(</span><span class="free">lookup2</span> <span class="free">k'</span><span class="main">)</span> <span class="free">m</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> <span class="main">(</span>mem2.map_of <span class="free">m</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span>
    update_correct<span class="main">:</span>
      <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">m</span> <span class="main">⟹</span> mem1.map_of <span class="main">(</span>snd <span class="main">(</span>State_Monad.run_state <span class="main">(</span><span class="free">update1</span> <span class="free">k'</span> <span class="free">v</span><span class="main">)</span> <span class="free">m</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> <span class="main">(</span>mem1.map_of <span class="free">m</span><span class="main">)</span><span class="main">(</span><span class="free">k'</span> <span class="main">↦</span> <span class="free">v</span><span class="main">)</span>"</span></span>
      <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">m</span> <span class="main">⟹</span> mem2.map_of <span class="main">(</span>snd <span class="main">(</span>State_Monad.run_state <span class="main">(</span><span class="free">update2</span> <span class="free">k'</span> <span class="free">v</span><span class="main">)</span> <span class="free">m</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> <span class="main">(</span>mem2.map_of <span class="free">m</span><span class="main">)</span><span class="main">(</span><span class="free">k'</span> <span class="main">↦</span> <span class="free">v</span><span class="main">)</span>"</span></span>
      <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">m</span> <span class="main">⟹</span> mem2.map_of <span class="main">(</span>snd <span class="main">(</span>State_Monad.run_state <span class="main">(</span><span class="free">update1</span> <span class="free">k'</span> <span class="free">v</span><span class="main">)</span> <span class="free">m</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> mem2.map_of <span class="free">m</span>"</span></span>
      <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">m</span> <span class="main">⟹</span> mem1.map_of <span class="main">(</span>snd <span class="main">(</span>State_Monad.run_state <span class="main">(</span><span class="free">update2</span> <span class="free">k'</span> <span class="free">v</span><span class="main">)</span> <span class="free">m</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> mem1.map_of <span class="free">m</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Pair_Memory-map_of_le_pair"><span class="command">lemma</span></span> map_of_le_pair<span class="main">:</span>
  <span class="quoted"><span class="quoted">"pair.map_of <span class="free">m</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> map_of1 <span class="free">m</span> <span class="main">++</span> map_of2 <span class="free">m</span>"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"inv_pair <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that
  <span class="keyword1"><span class="command">unfolding</span></span> pair.map_of_def map_of1_def map_of2_def
  <span class="keyword1"><span class="command">unfolding</span></span> lookup_pair_def inv_pair_def map_of_def map_le_def dom_def map_add_def
  <span class="keyword1"><span class="command">unfolding</span></span> State_Monad.bind_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 4 4
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mem2.map_of_def mem1.map_of_def Let_def
        <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> get_state <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split_asm if_split_asm
     <span class="main">)</span>

<span class="keyword1" id="Pair_Memory-pair_le_map_of"><span class="command">lemma</span></span> pair_le_map_of<span class="main">:</span>
  <span class="quoted"><span class="quoted">"map_of1 <span class="free">m</span> <span class="main">++</span> map_of2 <span class="free">m</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> pair.map_of <span class="free">m</span>"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"inv_pair <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that
  <span class="keyword1"><span class="command">unfolding</span></span> pair.map_of_def map_of1_def map_of2_def
  <span class="keyword1"><span class="command">unfolding</span></span> lookup_pair_def inv_pair_def map_of_def map_le_def dom_def map_add_def
  <span class="keyword1"><span class="command">unfolding</span></span> State_Monad.bind_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span>
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mem2.map_of_def mem1.map_of_def State_Monad.run_state_return Let_def
        <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> get_state <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits if_split_asm option.split
     <span class="main">)</span>

<span class="keyword1" id="Pair_Memory-map_of_eq_pair"><span class="command">lemma</span></span> map_of_eq_pair<span class="main">:</span>
  <span class="quoted"><span class="quoted">"map_of1 <span class="free">m</span> <span class="main">++</span> map_of2 <span class="free">m</span> <span class="main">=</span> pair.map_of <span class="free">m</span>"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"inv_pair <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that
  <span class="keyword1"><span class="command">unfolding</span></span> pair.map_of_def map_of1_def map_of2_def
  <span class="keyword1"><span class="command">unfolding</span></span> lookup_pair_def inv_pair_def map_of_def map_le_def dom_def map_add_def
  <span class="keyword1"><span class="command">unfolding</span></span> State_Monad.bind_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 4 4
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mem2.map_of_def mem1.map_of_def State_Monad.run_state_return Let_def
        <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> get_state <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits option.split
     <span class="main">)</span>

<span class="keyword1" id="Pair_Memory-inv_pair_neq"><span class="command">lemma</span></span> inv_pair_neq<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted">False</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"inv_pair <span class="free">m</span>"</span></span> <span class="quoted"><span class="quoted">"fst <span class="main">(</span>State_Monad.run_state <span class="free">get_k1</span> <span class="free">m</span><span class="main">)</span> <span class="main">=</span> fst <span class="main">(</span>State_Monad.run_state <span class="free">get_k2</span> <span class="free">m</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> inv_pair_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Pair_Memory-inv_pair_P_D"><span class="command">lemma</span></span> inv_pair_P_D<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">m</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"inv_pair <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> inv_pair_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>

<span class="keyword1" id="Pair_Memory-inv_pair_domD"><span class="command">lemma</span></span> inv_pair_domD<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"dom <span class="main">(</span>map_of1 <span class="free">m</span><span class="main">)</span> <span class="main">∩</span> dom <span class="main">(</span>map_of2 <span class="free">m</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"inv_pair <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> inv_pair_def map_of1_def map_of2_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>

<span class="keyword1" id="Pair_Memory-move12_correct1"><span class="command">lemma</span></span> move12_correct1<span class="main">:</span>
  <span class="quoted"><span class="quoted">"map_of1 <span class="free">heap'</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> Map.empty"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"State_Monad.run_state <span class="main">(</span><span class="free">move12</span> <span class="free">k1</span><span class="main">)</span> <span class="free">heap</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">heap'</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">heap</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> move12_correct<span class="main">[</span><span class="operator">OF</span> that<span class="main"><span class="main"><span class="main">(</span></span></span>2<span class="main"><span class="main"><span class="main">,</span></span></span>1<span class="main"><span class="main"><span class="main">)</span></span></span><span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> map_of1_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> move12_keys map_le_def<span class="main">)</span>

<span class="keyword1" id="Pair_Memory-move12_correct2"><span class="command">lemma</span></span> move12_correct2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"map_of2 <span class="free">heap'</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> map_of1 <span class="free">heap</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"State_Monad.run_state <span class="main">(</span><span class="free">move12</span> <span class="free">k1</span><span class="main">)</span> <span class="free">heap</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">heap'</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">heap</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> move12_correct<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> that<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">,</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> that <span class="keyword1"><span class="command">unfolding</span></span> map_of1_def map_of2_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> move12_keys map_le_def<span class="main">)</span>

<span class="keyword1" id="Pair_Memory-dom_empty"><span class="command">lemma</span></span> dom_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"dom <span class="main">(</span>map_of1 <span class="free">heap'</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"State_Monad.run_state <span class="main">(</span><span class="free">move12</span> <span class="free">k1</span><span class="main">)</span> <span class="free">heap</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">heap'</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">heap</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> move12_correct1<span class="main">[</span><span class="operator">OF</span> that<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> map_le_implies_dom_le<span class="main">)</span>

<span class="keyword1" id="Pair_Memory-inv_pair_lookup1"><span class="command">lemma</span></span> inv_pair_lookup1<span class="main">:</span>
  <span class="quoted"><span class="quoted">"inv_pair <span class="free">m'</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"State_Monad.run_state <span class="main">(</span><span class="free">lookup1</span> <span class="free">k</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="free">m'</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"inv_pair <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that lookup_inv<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">k</span></span></span></span><span class="main">]</span> inv_pair_P_D<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹inv_pair <span class="free">m</span>›</span></span><span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> inv_pair_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 4 4
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def lookup_keys
        <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lift_p_P lookup_correct<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main"><span class="main"><span class="main"><span class="main">_</span></span></span></span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">k</span></span></span></span></span></span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> map_le_implies_dom_le<span class="main"><span class="main">]</span></span>
     <span class="main">)</span>

<span class="keyword1" id="Pair_Memory-inv_pair_lookup2"><span class="command">lemma</span></span> inv_pair_lookup2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"inv_pair <span class="free">m'</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"State_Monad.run_state <span class="main">(</span><span class="free">lookup2</span> <span class="free">k</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="free">m'</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"inv_pair <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that lookup_inv<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">k</span></span></span></span><span class="main">]</span> inv_pair_P_D<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹inv_pair <span class="free">m</span>›</span></span><span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> inv_pair_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 4 4
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def lookup_keys
        <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lift_p_P lookup_correct<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main"><span class="main"><span class="main"><span class="main">_</span></span></span></span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">k</span></span></span></span></span></span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> map_le_implies_dom_le<span class="main"><span class="main">]</span></span>
     <span class="main">)</span>

<span class="keyword1" id="Pair_Memory-inv_pair_update1"><span class="command">lemma</span></span> inv_pair_update1<span class="main">:</span>
  <span class="quoted"><span class="quoted">"inv_pair <span class="free">m'</span>"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"State_Monad.run_state <span class="main">(</span><span class="free">update1</span> <span class="main">(</span><span class="free">key2</span> <span class="free">k</span><span class="main">)</span> <span class="free">v</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span> <span class="main">(</span><span class="free">v'</span><span class="main">,</span> <span class="free">m'</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"inv_pair <span class="free">m</span>"</span></span> <span class="quoted"><span class="quoted">"fst <span class="main">(</span>State_Monad.run_state <span class="free">get_k1</span> <span class="free">m</span><span class="main">)</span> <span class="main">=</span> <span class="free">key1</span> <span class="free">k</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that update_inv<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">key2</span></span> <span class="free"><span class="free">k</span></span>"</span></span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">v</span></span></span></span><span class="main">]</span> inv_pair_P_D<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹inv_pair <span class="free">m</span>›</span></span><span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> inv_pair_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span>
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def update_keys
        <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lift_p_P update_correct<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main"><span class="main"><span class="main"><span class="main">_</span></span></span></span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free"><span class="free"><span class="free">key2</span></span></span></span> <span class="free"><span class="free"><span class="free"><span class="free">k</span></span></span></span>"</span></span></span></span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">v</span></span></span></span></span></span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> map_le_implies_dom_le<span class="main"><span class="main">]</span></span>
     <span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> update_correct<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free"><span class="free"><span class="free"><span class="free"><span class="free"><span class="free"><span class="free">key2</span></span></span></span></span></span></span></span> <span class="free"><span class="free"><span class="free"><span class="free"><span class="free"><span class="free"><span class="free"><span class="free">k</span></span></span></span></span></span></span></span>"</span></span></span></span></span></span></span></span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">v</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> map_le_implies_dom_le<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> 13 2<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> update_correct<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free"><span class="free"><span class="free"><span class="free"><span class="free"><span class="free"><span class="free">key2</span></span></span></span></span></span></span></span> <span class="free"><span class="free"><span class="free"><span class="free"><span class="free"><span class="free"><span class="free"><span class="free">k</span></span></span></span></span></span></span></span>"</span></span></span></span></span></span></span></span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">v</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> map_le_implies_dom_le<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> 13 2<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Pair_Memory-inv_pair_update2"><span class="command">lemma</span></span> inv_pair_update2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"inv_pair <span class="free">m'</span>"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"State_Monad.run_state <span class="main">(</span><span class="free">update2</span> <span class="main">(</span><span class="free">key2</span> <span class="free">k</span><span class="main">)</span> <span class="free">v</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span> <span class="main">(</span><span class="free">v'</span><span class="main">,</span> <span class="free">m'</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"inv_pair <span class="free">m</span>"</span></span> <span class="quoted"><span class="quoted">"fst <span class="main">(</span>State_Monad.run_state <span class="free">get_k2</span> <span class="free">m</span><span class="main">)</span> <span class="main">=</span> <span class="free">key1</span> <span class="free">k</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that update_inv<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">key2</span></span> <span class="free"><span class="free">k</span></span>"</span></span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">v</span></span></span></span><span class="main">]</span> inv_pair_P_D<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹inv_pair <span class="free">m</span>›</span></span><span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> inv_pair_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span>
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def update_keys
        <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lift_p_P update_correct<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main"><span class="main"><span class="main"><span class="main">_</span></span></span></span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free"><span class="free"><span class="free">key2</span></span></span></span> <span class="free"><span class="free"><span class="free"><span class="free">k</span></span></span></span>"</span></span></span></span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">v</span></span></span></span></span></span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> map_le_implies_dom_le<span class="main"><span class="main">]</span></span>
     <span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> update_correct<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free"><span class="free"><span class="free"><span class="free"><span class="free"><span class="free"><span class="free">key2</span></span></span></span></span></span></span></span> <span class="free"><span class="free"><span class="free"><span class="free"><span class="free"><span class="free"><span class="free"><span class="free">k</span></span></span></span></span></span></span></span>"</span></span></span></span></span></span></span></span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">v</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> map_le_implies_dom_le<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> 13 2<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> update_correct<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free"><span class="free"><span class="free"><span class="free"><span class="free"><span class="free"><span class="free">key2</span></span></span></span></span></span></span></span> <span class="free"><span class="free"><span class="free"><span class="free"><span class="free"><span class="free"><span class="free"><span class="free">k</span></span></span></span></span></span></span></span>"</span></span></span></span></span></span></span></span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">v</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> map_le_implies_dom_le<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> 13 2<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Pair_Memory-inv_pair_move12"><span class="command">lemma</span></span> inv_pair_move12<span class="main">:</span>
  <span class="quoted"><span class="quoted">"inv_pair <span class="free">m'</span>"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"State_Monad.run_state <span class="main">(</span><span class="free">move12</span> <span class="free">k</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span> <span class="main">(</span><span class="free">v'</span><span class="main">,</span> <span class="free">m'</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"inv_pair <span class="free">m</span>"</span></span> <span class="quoted"><span class="quoted">"fst <span class="main">(</span>State_Monad.run_state <span class="free">get_k1</span> <span class="free">m</span><span class="main">)</span> <span class="main">≠</span> <span class="free">k</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that move12_inv<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="free">k</span>"</span></span><span class="main">]</span> inv_pair_P_D<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹inv_pair <span class="free">m</span>›</span></span><span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> inv_pair_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span>
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def move12_keys
        <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lift_p_P move12_correct<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main"><span class="main">_</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">k</span></span>"</span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> map_le_implies_dom_le<span class="main"><span class="main">]</span></span>
     <span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> move12_correct<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main"><span class="main">_</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">k</span></span>"</span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> map_le_implies_dom_le<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Pair_Memory-mem_correct_pair"><span class="command">lemma</span></span> mem_correct_pair<span class="main">:</span>
  <span class="quoted"><span class="quoted">"mem_correct lookup_pair update_pair inv_pair"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> injective<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">k</span> <span class="bound">k'</span><span class="main">.</span> <span class="free">key1</span> <span class="bound">k</span> <span class="main">=</span> <span class="free">key1</span> <span class="bound">k'</span> <span class="main">∧</span> <span class="free">key2</span> <span class="bound">k</span> <span class="main">=</span> <span class="free">key2</span> <span class="bound">k'</span> <span class="main">⟶</span> <span class="bound">k</span> <span class="main">=</span> <span class="bound">k'</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">k</span><span class="main">)</span> <span class="comment1">― ‹Lookup invariant›</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> lookup_pair_def Let_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 4 4
        <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> lift_pI
        <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> get_state inv_pair_lookup1 inv_pair_lookup2
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> State_Monad.bind_def State_Monad.run_state_return
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm prod.split_asm
        <span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>2 <span class="skolem">k</span> <span class="skolem">v</span><span class="main">)</span> <span class="comment1">― ‹Update invariant›</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> update_pair_def Let_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 4 4
        <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> lift_pI <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> inv_pair_update1 inv_pair_update2
        <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> get_state
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> State_Monad.bind_def get_state State_Monad.run_state_return
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm prod.split_asm
        <span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> inv_pair_update1 inv_pair_move12<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="operator">subst</span> get_state<span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span><span class="main"><span class="keyword3">?</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> move12_keys <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> get_state<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>3 <span class="skolem">m</span> <span class="skolem">k</span><span class="main">)</span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?m</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"snd <span class="main">(</span>State_Monad.run_state <span class="main">(</span><span class="free">lookup2</span> <span class="main">(</span><span class="free">key2</span> <span class="skolem">k</span><span class="main">)</span><span class="main">)</span> <span class="skolem">m</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_of1 <span class="var">?m</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> map_of1 <span class="skolem">m</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> 3 domIff inv_pair_P_D local.lookup_keys lookup_correct map_le_def map_of1_def surjective_pairing<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_of2 <span class="var">?m</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> map_of2 <span class="skolem">m</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> 3 domIff inv_pair_P_D local.lookup_keys lookup_correct map_le_def map_of2_def surjective_pairing<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"dom <span class="main">(</span>map_of1 <span class="var">?m</span><span class="main">)</span> <span class="main">∩</span> dom <span class="main">(</span>map_of2 <span class="skolem">m</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> 3 <span class="quoted"><span class="quoted">‹map_of1 <span class="var">?m</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> map_of1 <span class="skolem">m</span>›</span></span> inv_pair_domD map_le_implies_dom_le <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"inv_pair <span class="var">?m</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> 3 inv_pair_lookup2 surjective_pairing <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"pair.map_of <span class="var">?m</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> pair.map_of <span class="skolem">m</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> map_of_eq_pair<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> map_of_eq_pair<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> 3 map_add_mono<span class="main">)</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?m</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"snd <span class="main">(</span>State_Monad.run_state <span class="main">(</span><span class="free">lookup1</span> <span class="main">(</span><span class="free">key2</span> <span class="skolem">k</span><span class="main">)</span><span class="main">)</span> <span class="skolem">m</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_of1 <span class="var">?m</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> map_of1 <span class="skolem">m</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> 3 domIff inv_pair_P_D local.lookup_keys lookup_correct map_le_def map_of1_def surjective_pairing<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_of2 <span class="var">?m</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> map_of2 <span class="skolem">m</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> 3 domIff inv_pair_P_D local.lookup_keys lookup_correct map_le_def map_of2_def surjective_pairing<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"dom <span class="main">(</span>map_of1 <span class="var">?m</span><span class="main">)</span> <span class="main">∩</span> dom <span class="main">(</span>map_of2 <span class="skolem">m</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> 3 <span class="quoted"><span class="quoted">‹map_of1 <span class="var">?m</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> map_of1 <span class="skolem">m</span>›</span></span> inv_pair_domD map_le_implies_dom_le <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"inv_pair <span class="var">?m</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> 3 inv_pair_lookup1 surjective_pairing <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"pair.map_of <span class="var">?m</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> pair.map_of <span class="skolem">m</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> map_of_eq_pair<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> map_of_eq_pair<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> 3 map_add_mono<span class="main">)</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span>
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span>if_split prod.split
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def lookup_pair_def State_Monad.bind_def State_Monad.run_state_return <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> get_state <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> map_le_refl
        <span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> prems<span class="main">:</span> <span class="main">(</span>4 <span class="skolem">m</span> <span class="skolem">k</span> <span class="skolem">v</span><span class="main">)</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?m1</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"snd <span class="main">(</span>State_Monad.run_state <span class="main">(</span><span class="free">update1</span> <span class="main">(</span><span class="free">key2</span> <span class="skolem">k</span><span class="main">)</span> <span class="skolem">v</span><span class="main">)</span> <span class="skolem">m</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?m2</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"snd <span class="main">(</span>State_Monad.run_state <span class="main">(</span><span class="free">update2</span> <span class="main">(</span><span class="free">key2</span> <span class="skolem">k</span><span class="main">)</span> <span class="skolem">v</span><span class="main">)</span> <span class="skolem">m</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> prems <span class="keyword1"><span class="command">have</span></span> disjoint<span class="main">:</span> <span class="quoted"><span class="quoted">"dom <span class="main">(</span>map_of1 <span class="skolem">m</span><span class="main">)</span> <span class="main">∩</span> dom <span class="main">(</span>map_of2 <span class="skolem">m</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inv_pair_domD<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span>
        <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> map_le_refl <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> get_state
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def update_pair_def State_Monad.bind_def State_Monad.run_state_return
        <span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">goal_cases</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">m'</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m'</span> <span class="main">=</span> <span class="skolem">m</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> get_state<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> 1 prems <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_of1 <span class="var">?m1</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> map_of1 <span class="skolem">m</span><span class="main">(</span><span class="skolem">k</span> <span class="main">↦</span> <span class="skolem">v</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> inv_pair_P_D map_le_def map_of1_def surjective_pairing domIff
          fst_conv fun_upd_apply injective update_correct update_keys
          <span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> prems <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_of2 <span class="var">?m1</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> map_of2 <span class="skolem">m</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> domIff inv_pair_P_D update_correct update_keys map_le_def map_of2_def surjective_pairing<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> prems <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"dom <span class="main">(</span>map_of1 <span class="var">?m1</span><span class="main">)</span> <span class="main">∩</span> dom <span class="main">(</span>map_of2 <span class="skolem">m</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> inv_pair_P_D<span class="main"><span class="main">[</span></span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹inv_pair <span class="skolem">m</span>›</span></span><span class="main"><span class="main">]</span></span> domIff Int_emptyI eq_snd_iff inv_pair_neq 
          map_of1_def map_of2_def update_keys<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span>
          <span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> 1 prems <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span> <span class="main">∉</span> dom <span class="main">(</span>map_of2 <span class="skolem">m</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> inv_pair_neq map_of2_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> 1 prems <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"inv_pair <span class="var">?m1</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> inv_pair_update1 fst_conv surjective_pairing <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"pair.map_of <span class="main">(</span>snd <span class="main">(</span>State_Monad.run_state <span class="main">(</span><span class="free">update1</span> <span class="main">(</span><span class="free">key2</span> <span class="skolem">k</span><span class="main">)</span> <span class="skolem">v</span><span class="main">)</span> <span class="skolem">m'</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> pair.map_of <span class="skolem">m</span><span class="main">(</span><span class="skolem">k</span> <span class="main">↦</span> <span class="skolem">v</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">m'</span> <span class="main">=</span> <span class="skolem">m</span>›</span></span> <span class="keyword1"><span class="command">using</span></span> disjoint
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> map_of_eq_pair<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> map_of_eq_pair<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> prems<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> map_add_upd2<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> map_add_mono<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>2 <span class="skolem">k1</span> <span class="skolem">m'</span> <span class="skolem">m''</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m'</span> <span class="main">=</span> <span class="skolem">m</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m''</span> <span class="main">=</span> <span class="skolem">m</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> get_state<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> 2 prems <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_of2 <span class="var">?m2</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> map_of2 <span class="skolem">m</span><span class="main">(</span><span class="skolem">k</span> <span class="main">↦</span> <span class="skolem">v</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">m'</span> <span class="main">=</span> <span class="skolem">m</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">m''</span> <span class="main">=</span> <span class="skolem">m</span>›</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> inv_pair_P_D map_le_def map_of2_def surjective_pairing domIff
          fst_conv fun_upd_apply injective update_correct update_keys
          <span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> prems <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_of1 <span class="var">?m2</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> map_of1 <span class="skolem">m</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> domIff inv_pair_P_D update_correct update_keys map_le_def map_of1_def surjective_pairing<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> 2 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"dom <span class="main">(</span>map_of1 <span class="var">?m2</span><span class="main">)</span> <span class="main">∩</span> dom <span class="main">(</span>map_of2 <span class="skolem">m</span><span class="main">(</span><span class="skolem">k</span> <span class="main">↦</span> <span class="skolem">v</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">m'</span> <span class="main">=</span> <span class="skolem">m</span>›</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> domIff <span class="quoted"><span class="quoted">‹map_of1 <span class="var">?m2</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> map_of1 <span class="skolem">m</span>›</span></span> disjoint_iff_not_equal fst_conv fun_upd_apply
          map_le_def map_of1_def map_of2_def
          <span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> 2 prems <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"inv_pair <span class="var">?m2</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">m'</span> <span class="main">=</span> <span class="skolem">m</span>›</span></span>
      <span class="keyword1"><span class="command">using</span></span> inv_pair_update2 fst_conv surjective_pairing <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"pair.map_of <span class="main">(</span>snd <span class="main">(</span>State_Monad.run_state <span class="main">(</span><span class="free">update2</span> <span class="main">(</span><span class="free">key2</span> <span class="skolem">k</span><span class="main">)</span> <span class="skolem">v</span><span class="main">)</span> <span class="skolem">m''</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> pair.map_of <span class="skolem">m</span><span class="main">(</span><span class="skolem">k</span> <span class="main">↦</span> <span class="skolem">v</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">m'</span> <span class="main">=</span> <span class="skolem">m</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">m''</span> <span class="main">=</span> <span class="skolem">m</span>›</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> map_of_eq_pair<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> map_of_eq_pair<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> prems<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> map_add_upd<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> map_add_mono<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>3 <span class="skolem">k1</span> <span class="skolem">m1</span> <span class="skolem">k2</span> <span class="skolem">m2</span> <span class="skolem">m3</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m1</span> <span class="main">=</span> <span class="skolem">m</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m2</span> <span class="main">=</span> <span class="skolem">m</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> get_state<span class="main">)</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?m3</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"snd <span class="main">(</span>State_Monad.run_state <span class="main">(</span><span class="free">update1</span> <span class="main">(</span><span class="free">key2</span> <span class="skolem">k</span><span class="main">)</span> <span class="skolem">v</span><span class="main">)</span> <span class="skolem">m3</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> 3 prems <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_of1 <span class="var">?m3</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> map_of2 <span class="skolem">m</span><span class="main">(</span><span class="skolem">k</span> <span class="main">↦</span> <span class="skolem">v</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">m2</span> <span class="main">=</span> <span class="skolem">m</span>›</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> inv_pair_P_D map_le_def map_of1_def surjective_pairing domIff
          fst_conv fun_upd_apply injective
          inv_pair_move12 move12_correct move12_keys update_correct update_keys
          <span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_of2 <span class="var">?m3</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> map_of1 <span class="skolem">m</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">from</span></span> prems 3 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="skolem">m</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="skolem">m3</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">m1</span> <span class="main">=</span> <span class="skolem">m</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">m2</span> <span class="main">=</span> <span class="skolem">m</span>›</span></span>
        <span class="keyword1"><span class="command">using</span></span> inv_pair_P_D<span class="main">[</span><span class="operator">OF</span> prems<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> lift_p_P<span class="main"><span class="main">[</span></span><span class="operator">OF</span> move12_inv<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> 3<span class="main">(</span>3<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> <span class="quoted"><span class="quoted">‹<span class="skolem">m2</span> <span class="main">=</span> <span class="skolem">m</span>›</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"mem2.map_of <span class="var">?m3</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> mem1.map_of <span class="skolem">m</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">erule</span> map_le_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> update_correct<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="free">P</span> <span class="skolem">m3</span>›</span></span><span class="main"><span class="main">]</span></span> move12_correct<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="free">P</span> <span class="skolem">m</span>›</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> 3 prems <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">m1</span> <span class="main">=</span> <span class="skolem">m</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">m2</span> <span class="main">=</span> <span class="skolem">m</span>›</span></span> map_le_def map_of2_def
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> move12_keys<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span>
            domI inv_pair_def map_of1_def surjective_pairing
            inv_pair_move12 move12_keys<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> update_keys<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span>
            <span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> prems 3 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"dom <span class="main">(</span>map_of1 <span class="var">?m3</span><span class="main">)</span> <span class="main">∩</span> dom <span class="main">(</span>map_of1 <span class="skolem">m</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">m1</span> <span class="main">=</span> <span class="skolem">m</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">m2</span> <span class="main">=</span> <span class="skolem">m</span>›</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> inv_pair_P_D disjoint_iff_not_equal map_of1_def surjective_pairing domIff
          fst_conv inv_pair_move12 move12_keys update_keys
          <span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> 3 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span> <span class="main">∉</span> dom <span class="main">(</span>map_of1 <span class="skolem">m</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> domIff map_of1_def<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> 3 prems <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"inv_pair <span class="var">?m3</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">m2</span> <span class="main">=</span> <span class="skolem">m</span>›</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> inv_pair_move12 inv_pair_update1 move12_keys<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> fst_conv surjective_pairing<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">m1</span> <span class="main">=</span> <span class="skolem">m</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">m2</span> <span class="main">=</span> <span class="skolem">m</span>›</span></span> <span class="keyword1"><span class="command">using</span></span> disjoint
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> map_of_eq_pair<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> map_of_eq_pair<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> prems<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> map_add_comm<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> map_add_upd2<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> map_add_mono<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Pair_Memory-emptyI"><span class="command">lemma</span></span> emptyI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"inv_pair <span class="free">m</span>"</span></span> <span class="quoted"><span class="quoted">"mem1.map_of <span class="free">m</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> Map.empty"</span></span> <span class="quoted"><span class="quoted">"mem2.map_of <span class="free">m</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> Map.empty"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"pair.map_of <span class="free">m</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> Map.empty"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> map_of1_def map_of2_def map_le_def map_of_eq_pair<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Pair Mem *)</span>


<span class="keyword1"><span class="command">datatype</span></span> <span class="main">(</span><span class="tfree">'k</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> pair_storage <span class="main">=</span> Pair_Storage <span class="tfree"><span class="quoted"><span class="tfree">'k</span></span></span> <span class="tfree"><span class="quoted"><span class="tfree">'k</span></span></span> <span class="tfree"><span class="quoted"><span class="tfree">'v</span></span></span> <span class="tfree"><span class="quoted"><span class="tfree">'v</span></span></span>

<span class="keyword1"><span class="command">context</span></span> mem_correct_empty
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">key</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'k</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We assume that look-ups happen on the older row, so it is biased towards the second entry.›</span></span>
<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lookup_pair</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">=</span>
    State <span class="main">(</span><span class="main">λ</span> <span class="bound">mem</span><span class="main">.</span>
    <span class="main">(</span>
      <span class="keyword1">case</span> <span class="bound">mem</span> <span class="keyword1">of</span> Pair_Storage <span class="bound">k1</span> <span class="bound">k2</span> <span class="bound">m1</span> <span class="bound">m2</span> <span class="main">⇒</span> <span class="keyword1">let</span> <span class="bound">k'</span> <span class="main">=</span> <span class="free">key</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="keyword1">in</span>
        <span class="keyword1">if</span> <span class="bound">k'</span> <span class="main">=</span> <span class="bound">k2</span> <span class="keyword1">then</span> <span class="keyword1">case</span> State_Monad.run_state <span class="main">(</span><span class="free">lookup</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">)</span> <span class="bound">m2</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">m</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> Pair_Storage <span class="bound">k1</span> <span class="bound">k2</span> <span class="bound">m1</span> <span class="bound">m</span><span class="main">)</span>
        <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="bound">k'</span> <span class="main">=</span> <span class="bound">k1</span> <span class="keyword1">then</span> <span class="keyword1">case</span> State_Monad.run_state <span class="main">(</span><span class="free">lookup</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">)</span> <span class="bound">m1</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">m</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> Pair_Storage <span class="bound">k1</span> <span class="bound">k2</span> <span class="bound">m</span> <span class="bound">m2</span><span class="main">)</span>
        <span class="keyword1">else</span> <span class="main">(</span>None<span class="main">,</span> <span class="bound">mem</span><span class="main">)</span>
    <span class="main">)</span>
    <span class="main">)</span>
  "</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We assume that updates happen on the newer row, so it is biased towards the first entry.›</span></span>
<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">update_pair</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span>
    State <span class="main">(</span><span class="main">λ</span> <span class="bound">mem</span><span class="main">.</span>
    <span class="main">(</span>
      <span class="keyword1">case</span> <span class="bound">mem</span> <span class="keyword1">of</span> Pair_Storage <span class="bound">k1</span> <span class="bound">k2</span> <span class="bound">m1</span> <span class="bound">m2</span> <span class="main">⇒</span> <span class="keyword1">let</span> <span class="bound">k'</span> <span class="main">=</span> <span class="free">key</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="keyword1">in</span>
        <span class="keyword1">if</span> <span class="bound">k'</span> <span class="main">=</span> <span class="bound">k1</span> <span class="keyword1">then</span> <span class="keyword1">case</span> State_Monad.run_state <span class="main">(</span><span class="free">update</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="bound">m1</span> <span class="keyword1">of</span> <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">m</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">()</span><span class="main">,</span> Pair_Storage <span class="bound">k1</span> <span class="bound">k2</span> <span class="bound">m</span> <span class="bound">m2</span><span class="main">)</span>
        <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="bound">k'</span> <span class="main">=</span> <span class="bound">k2</span> <span class="keyword1">then</span> <span class="keyword1">case</span> State_Monad.run_state <span class="main">(</span><span class="free">update</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="bound">m2</span> <span class="keyword1">of</span> <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">m</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">()</span><span class="main">,</span>Pair_Storage <span class="bound">k1</span> <span class="bound">k2</span> <span class="bound">m1</span> <span class="bound">m</span><span class="main">)</span>
        <span class="keyword1">else</span> <span class="keyword1">case</span> State_Monad.run_state <span class="main">(</span><span class="free">update</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="free">empty</span> <span class="keyword1">of</span> <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">m</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">()</span><span class="main">,</span> Pair_Storage <span class="bound">k'</span> <span class="bound">k1</span> <span class="bound">m</span> <span class="bound">m1</span><span class="main">)</span>
    <span class="main">)</span>
    <span class="main">)</span>
  "</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> pair<span class="main">:</span> state_mem_defs <span class="quoted">lookup_pair</span> <span class="quoted">update_pair</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">inv_pair</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="keyword1">of</span> Pair_Storage <span class="bound">k1</span> <span class="bound">k2</span> <span class="bound">m1</span> <span class="bound">m2</span> <span class="main">⇒</span>
    <span class="free">key</span> <span class="main">`</span> dom <span class="main">(</span>map_of <span class="bound">m1</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">k1</span><span class="main">}</span> <span class="main">∧</span> <span class="free">key</span> <span class="main">`</span> dom <span class="main">(</span>map_of <span class="bound">m2</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">k2</span><span class="main">}</span> <span class="main">∧</span> <span class="bound">k1</span> <span class="main">≠</span> <span class="bound">k2</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">m1</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">m2</span>
  <span class="main">)</span>"</span></span>

<span class="keyword1" id="Pair_Memory-map_of_le_pair"><span class="command">lemma</span></span> map_of_le_pair<span class="main">:</span>
  <span class="quoted"><span class="quoted">"pair.map_of <span class="main">(</span>Pair_Storage <span class="free">k1</span> <span class="free">k2</span> <span class="free">m1</span> <span class="free">m2</span><span class="main">)</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> <span class="main">(</span>map_of <span class="free">m1</span> <span class="main">++</span> map_of <span class="free">m2</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"inv_pair <span class="main">(</span>Pair_Storage <span class="free">k1</span> <span class="free">k2</span> <span class="free">m1</span> <span class="free">m2</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that
  <span class="keyword1"><span class="command">unfolding</span></span> pair.map_of_def
  <span class="keyword1"><span class="command">unfolding</span></span> lookup_pair_def inv_pair_def map_of_def map_le_def dom_def map_add_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 4 6 <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split_asm if_split_asm option.split <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Pair_Memory-pair_le_map_of"><span class="command">lemma</span></span> pair_le_map_of<span class="main">:</span>
  <span class="quoted"><span class="quoted">"map_of <span class="free">m1</span> <span class="main">++</span> map_of <span class="free">m2</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> pair.map_of <span class="main">(</span>Pair_Storage <span class="free">k1</span> <span class="free">k2</span> <span class="free">m1</span> <span class="free">m2</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"inv_pair <span class="main">(</span>Pair_Storage <span class="free">k1</span> <span class="free">k2</span> <span class="free">m1</span> <span class="free">m2</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that
  <span class="keyword1"><span class="command">unfolding</span></span> pair.map_of_def
  <span class="keyword1"><span class="command">unfolding</span></span> lookup_pair_def inv_pair_def map_of_def map_le_def dom_def map_add_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 4 5 <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split_asm if_split_asm option.split <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>

<span class="keyword1" id="Pair_Memory-map_of_eq_pair"><span class="command">lemma</span></span> map_of_eq_pair<span class="main">:</span>
  <span class="quoted"><span class="quoted">"map_of <span class="free">m1</span> <span class="main">++</span> map_of <span class="free">m2</span> <span class="main">=</span> pair.map_of <span class="main">(</span>Pair_Storage <span class="free">k1</span> <span class="free">k2</span> <span class="free">m1</span> <span class="free">m2</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"inv_pair <span class="main">(</span>Pair_Storage <span class="free">k1</span> <span class="free">k2</span> <span class="free">m1</span> <span class="free">m2</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that
  <span class="keyword1"><span class="command">unfolding</span></span> pair.map_of_def
  <span class="keyword1"><span class="command">unfolding</span></span> lookup_pair_def inv_pair_def map_of_def map_le_def dom_def map_add_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 4 7 <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split_asm if_split_asm option.split <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>

<span class="keyword1" id="Pair_Memory-inv_pair_neq"><span class="command">lemma</span></span> inv_pair_neq<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">dest</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted">False</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"inv_pair <span class="main">(</span>Pair_Storage <span class="free">k</span> <span class="free">k</span> <span class="free">x</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> inv_pair_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Pair_Memory-inv_pair_P_D1"><span class="command">lemma</span></span> inv_pair_P_D1<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">m1</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"inv_pair <span class="main">(</span>Pair_Storage <span class="free">k1</span> <span class="free">k2</span> <span class="free">m1</span> <span class="free">m2</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> inv_pair_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Pair_Memory-inv_pair_P_D2"><span class="command">lemma</span></span> inv_pair_P_D2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">m2</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"inv_pair <span class="main">(</span>Pair_Storage <span class="free">k1</span> <span class="free">k2</span> <span class="free">m1</span> <span class="free">m2</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> inv_pair_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Pair_Memory-inv_pair_domD"><span class="command">lemma</span></span> inv_pair_domD<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"dom <span class="main">(</span>map_of <span class="free">m1</span><span class="main">)</span> <span class="main">∩</span> dom <span class="main">(</span>map_of <span class="free">m2</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"inv_pair <span class="main">(</span>Pair_Storage <span class="free">k1</span> <span class="free">k2</span> <span class="free">m1</span> <span class="free">m2</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> inv_pair_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="Pair_Memory-mem_correct_pair"><span class="command">lemma</span></span> mem_correct_pair<span class="main">:</span>
  <span class="quoted"><span class="quoted">"mem_correct lookup_pair update_pair inv_pair"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">k</span><span class="main">)</span> <span class="comment1">― ‹Lookup invariant›</span>
  <span class="keyword1"><span class="command">with</span></span> lookup_inv<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">k</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> lookup_pair_def Let_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> lift_pI <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> pair_storage.split_asm if_split_asm prod.split_asm<span class="main">)</span>
       <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lift_p_P <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inv_pair_def<span class="main"><span class="keyword3">,</span></span>
         <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> lookup_correct<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="skolem">k</span></span><span class="main"><span class="main">]</span></span> map_le_implies_dom_le<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
       <span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>2 <span class="skolem">k</span> <span class="skolem">v</span><span class="main">)</span> <span class="comment1">― ‹Update invariant›</span>
  <span class="keyword1"><span class="command">with</span></span> update_inv<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">k</span></span> <span class="quoted"><span class="skolem">v</span></span><span class="main">]</span> update_correct<span class="main">[</span><span class="operator">OF</span> P_empty<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">k</span></span> <span class="quoted"><span class="skolem">v</span></span><span class="main">]</span> P_empty <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> update_pair_def Let_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> lift_pI <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> pair_storage.split_asm if_split_asm prod.split_asm<span class="main">)</span>
       <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lift_p_P <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inv_pair_def<span class="main"><span class="keyword3">,</span></span>
         <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lift_p_P <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> update_correct<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="skolem">k</span></span> <span class="quoted"><span class="skolem">v</span></span><span class="main"><span class="main">]</span></span> map_le_implies_dom_le<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
       <span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>3 <span class="skolem">m</span> <span class="skolem">k</span><span class="main">)</span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">m1</span> <span class="skolem">v1</span> <span class="skolem">m1'</span> <span class="skolem">m2</span> <span class="skolem">v2</span> <span class="skolem">m2'</span> <span class="skolem">k1</span> <span class="skolem">k2</span>
    <span class="keyword3"><span class="command">assume</span></span> assms<span class="main">:</span>
      <span class="quoted"><span class="quoted">"State_Monad.run_state <span class="main">(</span><span class="free">lookup</span> <span class="skolem">k</span><span class="main">)</span> <span class="skolem">m1</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">v1</span><span class="main">,</span> <span class="skolem">m1'</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"State_Monad.run_state <span class="main">(</span><span class="free">lookup</span> <span class="skolem">k</span><span class="main">)</span> <span class="skolem">m2</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">v2</span><span class="main">,</span> <span class="skolem">m2'</span><span class="main">)</span>"</span></span>
      <span class="quoted"><span class="quoted">"inv_pair <span class="main">(</span>Pair_Storage <span class="skolem">k1</span> <span class="skolem">k2</span> <span class="skolem">m1</span> <span class="skolem">m2</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="skolem">m1</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="skolem">m2</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> inv_pair_P_D1 inv_pair_P_D2<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"map_of <span class="skolem">m1'</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> map_of <span class="skolem">m1</span>"</span></span> <span class="quoted"><span class="quoted">"map_of <span class="skolem">m2'</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> map_of <span class="skolem">m2</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> lookup_correct<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="free">P</span> <span class="skolem">m1</span>›</span></span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">k</span></span><span class="main">]</span> lookup_correct<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="free">P</span> <span class="skolem">m2</span>›</span></span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">k</span></span><span class="main">]</span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> inv_pair_domD<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"dom <span class="main">(</span>map_of <span class="skolem">m1'</span><span class="main">)</span> <span class="main">∩</span> dom <span class="main">(</span>map_of <span class="skolem">m2</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">)</span></span> <span class="quoted"><span class="quoted">‹map_of <span class="skolem">m1'</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> map_of <span class="skolem">m1</span>›</span></span> disjoint_iff_not_equal domIff map_le_def<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> inv1<span class="main">:</span> <span class="quoted"><span class="quoted">"inv_pair <span class="main">(</span>Pair_Storage <span class="main">(</span><span class="free">key</span> <span class="skolem">k</span><span class="main">)</span> <span class="skolem">k2</span> <span class="skolem">m1'</span> <span class="skolem">m2</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k2</span> <span class="main">≠</span> <span class="free">key</span> <span class="skolem">k</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k1</span> <span class="main">=</span> <span class="free">key</span> <span class="skolem">k</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> that <span class="quoted"><span class="quoted">‹<span class="free">P</span> <span class="skolem">m1</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">P</span> <span class="skolem">m2</span>›</span></span> <span class="keyword1"><span class="command">unfolding</span></span> inv_pair_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> x' y
        <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">,</span>3<span class="main">)</span> lookup_correct<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="free">P</span> <span class="skolem">m1</span>›</span></span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">k</span></span><span class="main">,</span> <span class="operator">THEN</span> map_le_implies_dom_le<span class="main">]</span>
        <span class="keyword1"><span class="command">unfolding</span></span> inv_pair_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> x' y
        <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> inv_pair_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
      <span class="keyword1"><span class="command">using</span></span> lookup_inv<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">k</span></span><span class="main">]</span> assms <span class="keyword1"><span class="command">unfolding</span></span> lift_p_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
    <span class="keyword1"><span class="command">have</span></span> inv2<span class="main">:</span> <span class="quoted"><span class="quoted">"inv_pair <span class="main">(</span>Pair_Storage <span class="skolem">k1</span> <span class="main">(</span><span class="free">key</span> <span class="skolem">k</span><span class="main">)</span> <span class="skolem">m1</span> <span class="skolem">m2'</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k2</span> <span class="main">=</span> <span class="free">key</span> <span class="skolem">k</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k1</span> <span class="main">≠</span> <span class="free">key</span> <span class="skolem">k</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> that <span class="quoted"><span class="quoted">‹<span class="free">P</span> <span class="skolem">m1</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">P</span> <span class="skolem">m2</span>›</span></span> <span class="keyword1"><span class="command">unfolding</span></span> inv_pair_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> x' y
        <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> inv_pair_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> x x' y
        <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span> lookup_correct<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="free">P</span> <span class="skolem">m2</span>›</span></span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">k</span></span><span class="main">,</span> <span class="operator">THEN</span> map_le_implies_dom_le<span class="main">]</span>
        <span class="keyword1"><span class="command">unfolding</span></span> inv_pair_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
      <span class="keyword1"><span class="command">using</span></span> lookup_inv<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">k</span></span><span class="main">]</span> assms <span class="keyword1"><span class="command">unfolding</span></span> lift_p_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
    <span class="keyword1"><span class="command">have</span></span> A<span class="main">:</span>
      <span class="quoted"><span class="quoted">"pair.map_of <span class="main">(</span>Pair_Storage <span class="main">(</span><span class="free">key</span> <span class="skolem">k</span><span class="main">)</span> <span class="skolem">k2</span> <span class="skolem">m1'</span> <span class="skolem">m2</span><span class="main">)</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> pair.map_of <span class="main">(</span>Pair_Storage <span class="main">(</span><span class="free">key</span> <span class="skolem">k</span><span class="main">)</span> <span class="skolem">k2</span> <span class="skolem">m1</span> <span class="skolem">m2</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k2</span> <span class="main">≠</span> <span class="free">key</span> <span class="skolem">k</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k1</span> <span class="main">=</span> <span class="free">key</span> <span class="skolem">k</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> inv1 assms<span class="main">(</span>3<span class="main">)</span> 1
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> map_add_mono map_le_refl <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> that map_of_eq_pair<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> B<span class="main">:</span>
      <span class="quoted"><span class="quoted">"pair.map_of <span class="main">(</span>Pair_Storage <span class="skolem">k1</span> <span class="main">(</span><span class="free">key</span> <span class="skolem">k</span><span class="main">)</span> <span class="skolem">m1</span> <span class="skolem">m2'</span><span class="main">)</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> pair.map_of <span class="main">(</span>Pair_Storage <span class="skolem">k1</span> <span class="main">(</span><span class="free">key</span> <span class="skolem">k</span><span class="main">)</span> <span class="skolem">m1</span> <span class="skolem">m2</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k2</span> <span class="main">=</span> <span class="free">key</span> <span class="skolem">k</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k1</span> <span class="main">≠</span> <span class="free">key</span> <span class="skolem">k</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> inv2 assms<span class="main">(</span>3<span class="main">)</span> that
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> map_add_mono map_le_refl <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> map_of_eq_pair<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> inv_pair_domD<span class="main">)</span>
    <span class="keyword1"><span class="command">note</span></span> A B
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹inv_pair <span class="skolem">m</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> pair_storage.split if_split prod.split <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def lookup_pair_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>4 <span class="skolem">m</span> <span class="skolem">k</span> <span class="skolem">v</span><span class="main">)</span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">m1</span> <span class="skolem">v1</span> <span class="skolem">m1'</span> <span class="skolem">m2</span> <span class="skolem">v2</span> <span class="skolem">m2'</span> <span class="skolem">m3</span> <span class="skolem">k1</span> <span class="skolem">k2</span>
    <span class="keyword3"><span class="command">assume</span></span> assms<span class="main">:</span>
      <span class="quoted"><span class="quoted">"State_Monad.run_state <span class="main">(</span><span class="free">update</span> <span class="skolem">k</span> <span class="skolem">v</span><span class="main">)</span> <span class="skolem">m1</span> <span class="main">=</span> <span class="main">(</span><span class="main">()</span><span class="main">,</span> <span class="skolem">m1'</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"State_Monad.run_state <span class="main">(</span><span class="free">update</span> <span class="skolem">k</span> <span class="skolem">v</span><span class="main">)</span> <span class="skolem">m2</span> <span class="main">=</span> <span class="main">(</span><span class="main">()</span><span class="main">,</span> <span class="skolem">m2'</span><span class="main">)</span>"</span></span>
      <span class="quoted"><span class="quoted">"State_Monad.run_state <span class="main">(</span><span class="free">update</span> <span class="skolem">k</span> <span class="skolem">v</span><span class="main">)</span> <span class="free">empty</span> <span class="main">=</span> <span class="main">(</span><span class="main">()</span><span class="main">,</span> <span class="skolem">m3</span><span class="main">)</span>"</span></span>
      <span class="quoted"><span class="quoted">"inv_pair <span class="main">(</span>Pair_Storage <span class="skolem">k1</span> <span class="skolem">k2</span> <span class="skolem">m1</span> <span class="skolem">m2</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="skolem">m1</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="skolem">m2</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> inv_pair_P_D1 inv_pair_P_D2<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>3<span class="main">)</span> P_empty update_inv<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">k</span></span> <span class="quoted"><span class="skolem">v</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="skolem">m3</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> lift_p_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"map_of <span class="skolem">m1'</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> map_of <span class="skolem">m1</span><span class="main">(</span><span class="skolem">k</span> <span class="main">↦</span> <span class="skolem">v</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"map_of <span class="skolem">m2'</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> map_of <span class="skolem">m2</span><span class="main">(</span><span class="skolem">k</span> <span class="main">↦</span> <span class="skolem">v</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> update_correct<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="free">P</span> <span class="skolem">m1</span>›</span></span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">k</span></span> <span class="quoted"><span class="skolem">v</span></span><span class="main">]</span> update_correct<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="free">P</span> <span class="skolem">m2</span>›</span></span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">k</span></span> <span class="quoted"><span class="skolem">v</span></span><span class="main">]</span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_of <span class="skolem">m3</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> map_of <span class="free">empty</span><span class="main">(</span><span class="skolem">k</span> <span class="main">↦</span> <span class="skolem">v</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>3<span class="main">)</span> update_correct<span class="main">[</span><span class="operator">OF</span> P_empty<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">k</span></span> <span class="quoted"><span class="skolem">v</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> map_of <span class="skolem">m2</span><span class="main">(</span><span class="skolem">k</span> <span class="main">↦</span> <span class="skolem">v</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> empty_correct <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> map_le_trans <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> map_le_upd<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_of <span class="skolem">m3</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> map_of <span class="skolem">m2</span><span class="main">(</span><span class="skolem">k</span> <span class="main">↦</span> <span class="skolem">v</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">have</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"dom <span class="main">(</span>map_of <span class="skolem">m1</span><span class="main">)</span> <span class="main">∩</span> dom <span class="main">(</span>map_of <span class="skolem">m2</span><span class="main">(</span><span class="skolem">k</span> <span class="main">↦</span> <span class="skolem">v</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k1</span> <span class="main">≠</span> <span class="free">key</span> <span class="skolem">k</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>4<span class="main">)</span> that <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inv_pair_def<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"dom <span class="main">(</span>map_of <span class="skolem">m3</span><span class="main">)</span> <span class="main">∩</span> dom <span class="main">(</span>map_of <span class="skolem">m1</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k1</span> <span class="main">≠</span> <span class="free">key</span> <span class="skolem">k</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹local.map_of <span class="skolem">m3</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> local.map_of <span class="free">empty</span><span class="main">(</span><span class="skolem">k</span> <span class="main">↦</span> <span class="skolem">v</span><span class="main">)</span>›</span></span> assms<span class="main">(</span>4<span class="main">)</span> that
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> map_le_implies_dom_le <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inv_pair_def<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> inv<span class="main">:</span> <span class="quoted"><span class="quoted">"inv_pair <span class="main">(</span>Pair_Storage <span class="main">(</span><span class="free">key</span> <span class="skolem">k</span><span class="main">)</span> <span class="skolem">k1</span> <span class="skolem">m3</span> <span class="skolem">m1</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k2</span> <span class="main">≠</span> <span class="free">key</span> <span class="skolem">k</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k1</span> <span class="main">≠</span> <span class="free">key</span> <span class="skolem">k</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> that <span class="quoted"><span class="quoted">‹<span class="free">P</span> <span class="skolem">m1</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">P</span> <span class="skolem">m2</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">P</span> <span class="skolem">m3</span>›</span></span> <span class="keyword1"><span class="command">unfolding</span></span> inv_pair_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> x x' y
        <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>3<span class="main">)</span> update_correct<span class="main">[</span><span class="operator">OF</span> P_empty<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">k</span></span> <span class="quoted"><span class="skolem">v</span></span><span class="main">,</span> <span class="operator">THEN</span> map_le_implies_dom_le<span class="main">]</span>
          empty_correct
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> map_le_implies_dom_le<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> x x' y
        <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>4<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> inv_pair_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">have</span></span> A<span class="main">:</span>
      <span class="quoted"><span class="quoted">"pair.map_of <span class="main">(</span>Pair_Storage <span class="main">(</span><span class="free">key</span> <span class="skolem">k</span><span class="main">)</span> <span class="skolem">k1</span> <span class="skolem">m3</span> <span class="skolem">m1</span><span class="main">)</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> pair.map_of <span class="main">(</span>Pair_Storage <span class="skolem">k1</span> <span class="skolem">k2</span> <span class="skolem">m1</span> <span class="skolem">m2</span><span class="main">)</span><span class="main">(</span><span class="skolem">k</span> <span class="main">↦</span> <span class="skolem">v</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k2</span> <span class="main">≠</span> <span class="free">key</span> <span class="skolem">k</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k1</span> <span class="main">≠</span> <span class="free">key</span> <span class="skolem">k</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> inv assms<span class="main">(</span>4<span class="main">)</span> <span class="quoted"><span class="quoted">‹map_of <span class="skolem">m3</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> map_of <span class="skolem">m2</span><span class="main">(</span><span class="skolem">k</span> <span class="main">↦</span> <span class="skolem">v</span><span class="main">)</span>›</span></span> 1
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> that map_of_eq_pair<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> map_add_upd<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> Map.map_add_comm<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> 2<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> that<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> map_add_mono<span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> inv1<span class="main">:</span> <span class="quoted"><span class="quoted">"inv_pair <span class="main">(</span>Pair_Storage <span class="main">(</span><span class="free">key</span> <span class="skolem">k</span><span class="main">)</span> <span class="skolem">k2</span> <span class="skolem">m1'</span> <span class="skolem">m2</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k2</span> <span class="main">≠</span> <span class="free">key</span> <span class="skolem">k</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k1</span> <span class="main">=</span> <span class="free">key</span> <span class="skolem">k</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> that <span class="quoted"><span class="quoted">‹<span class="free">P</span> <span class="skolem">m1</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">P</span> <span class="skolem">m2</span>›</span></span> <span class="keyword1"><span class="command">unfolding</span></span> inv_pair_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> x' y
        <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">,</span>4<span class="main">)</span> update_correct<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="free">P</span> <span class="skolem">m1</span>›</span></span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">k</span></span> <span class="quoted"><span class="skolem">v</span></span><span class="main">,</span> <span class="operator">THEN</span> map_le_implies_dom_le<span class="main">]</span>
        <span class="keyword1"><span class="command">unfolding</span></span> inv_pair_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> x' y
        <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>4<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> inv_pair_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
      <span class="keyword1"><span class="command">using</span></span> update_inv<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">k</span></span> <span class="quoted"><span class="skolem">v</span></span><span class="main">]</span> assms <span class="keyword1"><span class="command">unfolding</span></span> lift_p_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
    <span class="keyword1"><span class="command">have</span></span> inv2<span class="main">:</span> <span class="quoted"><span class="quoted">"inv_pair <span class="main">(</span>Pair_Storage <span class="skolem">k1</span> <span class="main">(</span><span class="free">key</span> <span class="skolem">k</span><span class="main">)</span> <span class="skolem">m1</span> <span class="skolem">m2'</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k2</span> <span class="main">=</span> <span class="free">key</span> <span class="skolem">k</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k1</span> <span class="main">≠</span> <span class="free">key</span> <span class="skolem">k</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> that <span class="quoted"><span class="quoted">‹<span class="free">P</span> <span class="skolem">m1</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">P</span> <span class="skolem">m2</span>›</span></span> <span class="keyword1"><span class="command">unfolding</span></span> inv_pair_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> x' y
        <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>4<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> inv_pair_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> x x' y
        <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">,</span>4<span class="main">)</span> update_correct<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="free">P</span> <span class="skolem">m2</span>›</span></span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">k</span></span> <span class="quoted"><span class="skolem">v</span></span><span class="main">,</span> <span class="operator">THEN</span> map_le_implies_dom_le<span class="main">]</span>
        <span class="keyword1"><span class="command">unfolding</span></span> inv_pair_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
      <span class="keyword1"><span class="command">using</span></span> update_inv<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">k</span></span> <span class="quoted"><span class="skolem">v</span></span><span class="main">]</span> assms <span class="keyword1"><span class="command">unfolding</span></span> lift_p_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
    <span class="keyword1"><span class="command">have</span></span> C<span class="main">:</span>
      <span class="quoted"><span class="quoted">"pair.map_of <span class="main">(</span>Pair_Storage <span class="main">(</span><span class="free">key</span> <span class="skolem">k</span><span class="main">)</span> <span class="skolem">k2</span> <span class="skolem">m1'</span> <span class="skolem">m2</span><span class="main">)</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span>
       pair.map_of <span class="main">(</span>Pair_Storage <span class="main">(</span><span class="free">key</span> <span class="skolem">k</span><span class="main">)</span> <span class="skolem">k2</span> <span class="skolem">m1</span> <span class="skolem">m2</span><span class="main">)</span><span class="main">(</span><span class="skolem">k</span> <span class="main">↦</span> <span class="skolem">v</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k2</span> <span class="main">≠</span> <span class="free">key</span> <span class="skolem">k</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k1</span> <span class="main">=</span> <span class="free">key</span> <span class="skolem">k</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> inv1<span class="main">[</span><span class="operator">OF</span> that<span class="main">]</span> assms<span class="main">(</span>4<span class="main">)</span> <span class="quoted"><span class="quoted">‹inv_pair <span class="skolem">m</span>›</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> that map_of_eq_pair<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
         <span class="main">(</span><span class="operator">subst</span> map_add_upd2<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inv_pair_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> map_add_mono map_le_refl<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> B<span class="main">:</span>
      <span class="quoted"><span class="quoted">"pair.map_of <span class="main">(</span>Pair_Storage <span class="skolem">k1</span> <span class="main">(</span><span class="free">key</span> <span class="skolem">k</span><span class="main">)</span> <span class="skolem">m1</span> <span class="skolem">m2'</span><span class="main">)</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span>
       pair.map_of <span class="main">(</span>Pair_Storage <span class="skolem">k1</span> <span class="main">(</span><span class="free">key</span> <span class="skolem">k</span><span class="main">)</span> <span class="skolem">m1</span> <span class="skolem">m2</span><span class="main">)</span><span class="main">(</span><span class="skolem">k</span> <span class="main">↦</span> <span class="skolem">v</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k2</span> <span class="main">=</span> <span class="free">key</span> <span class="skolem">k</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k1</span> <span class="main">≠</span> <span class="free">key</span> <span class="skolem">k</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> inv2<span class="main">[</span><span class="operator">OF</span> that<span class="main">]</span> assms<span class="main">(</span>4<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> that map_of_eq_pair<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
         <span class="main">(</span><span class="operator">subst</span> map_add_upd<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">rule</span> map_add_mono<span class="main"><span class="keyword3">;</span></span> <span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inv_pair_def<span class="main">)</span>
    <span class="keyword1"><span class="command">note</span></span> A B C
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹inv_pair <span class="skolem">m</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> pair_storage.split if_split prod.split <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def update_pair_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Key function *)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Lookup &amp; Update w/ Empty *)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Theory *)</span>
</pre>
</div><div id="Index">
<div class="head">
<h1>Theory Index</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Index›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Index
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">injective</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span> <span class="main">⇒</span> nat<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">injective</span> <span class="free"><span class="bound"><span class="entity">size</span></span></span> <span class="free"><span class="bound"><span class="entity">to_index</span></span></span> <span class="main">≡</span> <span class="main">∀</span> <span class="bound">a</span> <span class="bound">b</span><span class="main">.</span>
      <span class="free"><span class="bound"><span class="entity">to_index</span></span></span> <span class="bound">a</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">to_index</span></span></span> <span class="bound">b</span>
    <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">to_index</span></span></span> <span class="bound">a</span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">size</span></span></span>
    <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">to_index</span></span></span> <span class="bound">b</span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">size</span></span></span>
    <span class="main">⟶</span> <span class="bound">a</span> <span class="main">=</span> <span class="bound">b</span>"</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">size</span> <span class="free">to_index</span>

<span class="keyword1" id="Index-index_mono"><span class="command">lemma</span></span> index_mono<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">a</span> <span class="free">b</span> <span class="free">a0</span> <span class="free">b0</span> <span class="main">::</span> <span class="quoted">nat</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">&lt;</span> <span class="free">a0</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> b<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">&lt;</span> <span class="free">b0</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">*</span> <span class="free">b0</span> <span class="main">+</span> <span class="free">b</span> <span class="main">&lt;</span> <span class="free">a0</span> <span class="main">*</span> <span class="free">b0</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">*</span> <span class="free">b0</span> <span class="main">+</span> <span class="free">b</span> <span class="main">&lt;</span> <span class="main">(</span>Suc <span class="free">a</span><span class="main">)</span> <span class="main">*</span> <span class="free">b0</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> b <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="free">a0</span> <span class="main">*</span> <span class="free">b0</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> a<span class="main">[</span><span class="operator">THEN</span> Suc_leI<span class="main">,</span> <span class="operator">THEN</span> mult_le_mono1<span class="main">]</span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Index-index_eq_iff"><span class="command">lemma</span></span> index_eq_iff<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">a</span> <span class="free">b</span> <span class="free">c</span> <span class="free">d</span> <span class="free">b0</span> <span class="main">::</span> <span class="quoted">nat</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">&lt;</span> <span class="free">b0</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">&lt;</span> <span class="free">b0</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">*</span> <span class="free">b0</span> <span class="main">+</span> <span class="free">b</span> <span class="main">=</span> <span class="free">c</span> <span class="main">*</span> <span class="free">b0</span> <span class="main">+</span> <span class="free">d</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">=</span> <span class="free">c</span> <span class="main">∧</span> <span class="free">b</span> <span class="main">=</span> <span class="free">d</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> conjI<span class="main">)</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="skolem">c</span> <span class="skolem">d</span> <span class="main">::</span> <span class="quoted">nat</span>
    <span class="keyword3"><span class="command">assume</span></span> ac<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">&lt;</span> <span class="skolem">c</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> b<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">&lt;</span> <span class="free">b0</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">*</span> <span class="free">b0</span> <span class="main">+</span> <span class="skolem">b</span> <span class="main">&lt;</span> <span class="main">(</span>Suc <span class="skolem">a</span><span class="main">)</span> <span class="main">*</span> <span class="free">b0</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> b <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="skolem">c</span> <span class="main">*</span> <span class="free">b0</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> ac<span class="main">[</span><span class="operator">THEN</span> Suc_leI<span class="main">,</span> <span class="operator">THEN</span> mult_le_mono1<span class="main">]</span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="skolem">c</span> <span class="main">*</span> <span class="free">b0</span> <span class="main">+</span> <span class="skolem">d</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">*</span> <span class="free">b0</span> <span class="main">+</span> <span class="skolem">b</span> <span class="main">≠</span> <span class="skolem">c</span> <span class="main">*</span> <span class="free">b0</span> <span class="main">+</span> <span class="skolem">d</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> ac <span class="main">=</span> this

  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">≠</span> <span class="free">c</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">consider</span></span> <span class="main">(</span>le<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">&lt;</span> <span class="free">c</span>"</span></span> <span class="main">|</span> <span class="main">(</span>ge<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">&gt;</span> <span class="free">c</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
      <span class="keyword3"><span class="command">case</span></span> le <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> ac<span class="main">[</span><span class="operator">OF</span> le assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> assms<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">..</span></span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> ge <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> ac<span class="main">[</span><span class="operator">OF</span> ge assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span> assms<span class="main">(</span>3<span class="main">)</span><span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">..</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">}</span></span>
  
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">=</span> <span class="free">c</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">with</span></span> assms<span class="main">(</span>3<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">=</span> <span class="free">d</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">locale</span></span> prod_order_def <span class="main">=</span>
  order0<span class="main">:</span> ord <span class="quoted"><span class="free">less_eq0</span></span> <span class="quoted"><span class="free">less0</span></span> <span class="main">+</span>
  order1<span class="main">:</span> ord <span class="quoted"><span class="free">less_eq1</span></span> <span class="quoted"><span class="free">less1</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">less_eq0</span> <span class="free">less0</span> <span class="free">less_eq1</span> <span class="free">less1</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">less</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">less</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">d</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="free">less0</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">∧</span> <span class="free">less1</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="free"><span class="bound"><span class="entity">d</span></span></span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">less_eq</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">less_eq</span> <span class="free"><span class="bound"><span class="entity">ab</span></span></span> <span class="free"><span class="bound"><span class="entity">cd</span></span></span> <span class="main">⟷</span> less <span class="free"><span class="bound"><span class="entity">ab</span></span></span> <span class="free"><span class="bound"><span class="entity">cd</span></span></span> <span class="main">∨</span> <span class="free"><span class="bound"><span class="entity">ab</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">cd</span></span></span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> prod_order <span class="main">=</span>
  prod_order_def <span class="quoted"><span class="free">less_eq0</span></span> <span class="quoted"><span class="free">less0</span></span> <span class="quoted"><span class="free">less_eq1</span></span> <span class="quoted"><span class="free">less1</span></span> <span class="main">+</span>
  order0<span class="main">:</span> order <span class="quoted"><span class="free">less_eq0</span></span> <span class="quoted"><span class="free">less0</span></span> <span class="main">+</span>
  order1<span class="main">:</span> order <span class="quoted"><span class="free">less_eq1</span></span> <span class="quoted"><span class="free">less1</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">less_eq0</span> <span class="free">less0</span> <span class="free">less_eq1</span> <span class="free">less1</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> order <span class="quoted">less_eq</span> <span class="quoted">less</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="keyword1"><span class="command">qed</span></span> <span class="operator">fastforce</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> option_order <span class="main">=</span>
  order0<span class="main">:</span> order <span class="quoted"><span class="free">less_eq0</span></span> <span class="quoted"><span class="free">less0</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">less_eq0</span> <span class="free">less0</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">less_eq_option</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> option <span class="main">⇒</span> <span class="tfree">'a</span> option <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">less_eq_option</span> None <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">⟷</span> True"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">less_eq_option</span> <span class="main">(</span>Some <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> None <span class="main">⟷</span> False"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">less_eq_option</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="free">less_eq0</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">less_option</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> option <span class="main">⇒</span> <span class="tfree">'a</span> option <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">less_option</span> <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="free"><span class="bound"><span class="entity">bo</span></span></span> <span class="main">⟷</span> less_eq_option <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="free"><span class="bound"><span class="entity">bo</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main">≠</span> <span class="free"><span class="bound"><span class="entity">bo</span></span></span>"</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> order <span class="quoted">less_eq_option</span> <span class="quoted">less_option</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> x y <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">y</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> x <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> x y z <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">y</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">z</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> x y <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">y</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="tfree">'a</span> bound <span class="main">=</span> Bound <span class="main">(</span><span class="free"><span class="entity">lower</span></span><span class="main">:</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="entity">upper</span></span><span class="main">:</span><span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span><span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">in_bound</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> bound <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">in_bound</span> <span class="free"><span class="bound"><span class="entity">less_eq</span></span></span> <span class="free"><span class="bound"><span class="entity">less</span></span></span> <span class="free"><span class="bound"><span class="entity">bound</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">bound</span></span></span> <span class="keyword1">of</span> Bound <span class="bound">l</span> <span class="bound">r</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">less_eq</span></span></span> <span class="bound">l</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">less</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="bound">r</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">less_eq</span> <span class="free">less</span>

<span class="keyword1"><span class="command">locale</span></span> index_locale_def <span class="main">=</span> ord <span class="quoted"><span class="free">less_eq</span></span> <span class="quoted"><span class="free">less</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">less_eq</span> <span class="free">less</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">idx</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> bound <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> nat"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">size</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> bound <span class="main">⇒</span> nat"</span></span>

<span class="keyword1"><span class="command">locale</span></span> index_locale <span class="main">=</span> index_locale_def <span class="main">+</span> idx_ord<span class="main">:</span> order <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> idx_valid<span class="main">:</span> <span class="quoted"><span class="quoted">"in_bound <span class="free">less_eq</span> <span class="free">less</span> <span class="free">bound</span> <span class="free">x</span> <span class="main">⟹</span> <span class="free">idx</span> <span class="free">bound</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="free">size</span> <span class="free">bound</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> idx_inj <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>in_bound <span class="free">less_eq</span> <span class="free">less</span> <span class="free">bound</span> <span class="free">x</span><span class="main">;</span> in_bound <span class="free">less_eq</span> <span class="free">less</span> <span class="free">bound</span> <span class="free">y</span><span class="main">;</span> <span class="free">idx</span> <span class="free">bound</span> <span class="free">x</span> <span class="main">=</span> <span class="free">idx</span> <span class="free">bound</span> <span class="free">y</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> prod_index_def <span class="main">=</span>
  index0<span class="main">:</span> index_locale_def <span class="quoted"><span class="free">less_eq0</span></span> <span class="quoted"><span class="free">less0</span></span> <span class="quoted"><span class="free">idx0</span></span> <span class="quoted"><span class="free">size0</span></span> <span class="main">+</span>
  index1<span class="main">:</span> index_locale_def <span class="quoted"><span class="free">less_eq1</span></span> <span class="quoted"><span class="free">less1</span></span> <span class="quoted"><span class="free">idx1</span></span> <span class="quoted"><span class="free">size1</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">less_eq0</span> <span class="free">less0</span> <span class="free">idx0</span> <span class="free">size0</span> <span class="free">less_eq1</span> <span class="free">less1</span> <span class="free">idx1</span> <span class="free">size1</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">idx</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> bound <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span> <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">idx</span> <span class="main">(</span>Bound <span class="main">(</span><span class="free"><span class="bound"><span class="entity">l0</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">r0</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">l1</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">r1</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">idx0</span> <span class="main">(</span>Bound <span class="free"><span class="bound"><span class="entity">l0</span></span></span> <span class="free"><span class="bound"><span class="entity">l1</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span><span class="free">size1</span> <span class="main">(</span>Bound <span class="free"><span class="bound"><span class="entity">r0</span></span></span> <span class="free"><span class="bound"><span class="entity">r1</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">+</span> <span class="free">idx1</span> <span class="main">(</span>Bound <span class="free"><span class="bound"><span class="entity">r0</span></span></span> <span class="free"><span class="bound"><span class="entity">r1</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">size</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> bound <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">size</span> <span class="main">(</span>Bound <span class="main">(</span><span class="free"><span class="bound"><span class="entity">l0</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">r0</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">l1</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">r1</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">size0</span> <span class="main">(</span>Bound <span class="free"><span class="bound"><span class="entity">l0</span></span></span> <span class="free"><span class="bound"><span class="entity">l1</span></span></span><span class="main">)</span> <span class="main">*</span> <span class="free">size1</span> <span class="main">(</span>Bound <span class="free"><span class="bound"><span class="entity">r0</span></span></span> <span class="free"><span class="bound"><span class="entity">r1</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> prod_index <span class="main">=</span> prod_index_def <span class="quoted"><span class="free">less_eq0</span></span> <span class="quoted"><span class="free">less0</span></span> <span class="quoted"><span class="free">idx0</span></span> <span class="quoted"><span class="free">size0</span></span> <span class="quoted"><span class="free">less_eq1</span></span> <span class="quoted"><span class="free">less1</span></span> <span class="quoted"><span class="free">idx1</span></span> <span class="quoted"><span class="free">size1</span></span> <span class="main">+</span>
  index0<span class="main">:</span> index_locale <span class="quoted"><span class="free">less_eq0</span></span> <span class="quoted"><span class="free">less0</span></span> <span class="quoted"><span class="free">idx0</span></span> <span class="quoted"><span class="free">size0</span></span> <span class="main">+</span>
  index1<span class="main">:</span> index_locale <span class="quoted"><span class="free">less_eq1</span></span> <span class="quoted"><span class="free">less1</span></span> <span class="quoted"><span class="free">idx1</span></span> <span class="quoted"><span class="free">size1</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">less_eq0</span> <span class="free">less0</span> <span class="free">idx0</span> <span class="free">size0</span> <span class="free">less_eq1</span> <span class="free">less1</span> <span class="free">idx1</span> <span class="free">size1</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> prod_order <span class="quoted"><span class="free">less_eq0</span></span> <span class="quoted"><span class="free">less0</span></span> <span class="quoted"><span class="free">less_eq1</span></span> <span class="quoted"><span class="free">less1</span></span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> index_locale <span class="quoted">less_eq</span> <span class="quoted">less</span> <span class="quoted">idx</span> <span class="quoted">size</span> <span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">ab</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">bound</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> bound"</span></span>
    <span class="keyword3"><span class="command">assume</span></span> bound<span class="main">:</span> <span class="quoted"><span class="quoted">"in_bound less_eq less <span class="skolem">bound</span> <span class="skolem">ab</span>"</span></span>

    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a</span></span> <span class="skolem"><span class="skolem">b</span></span> <span class="skolem"><span class="skolem">l0</span></span> <span class="skolem"><span class="skolem">r0</span></span> <span class="skolem"><span class="skolem">l1</span></span> <span class="skolem"><span class="skolem">r1</span></span> <span class="keyword2"><span class="keyword">where</span></span> defs<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">ab</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">bound</span> <span class="main">=</span> Bound <span class="main">(</span><span class="skolem">l0</span><span class="main">,</span> <span class="skolem">r0</span><span class="main">)</span> <span class="main">(</span><span class="skolem">l1</span><span class="main">,</span> <span class="skolem">r1</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ab</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">bound</span></span><span class="main">)</span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">with</span></span> bound <span class="keyword1"><span class="command">have</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"in_bound <span class="free">less_eq0</span> <span class="free">less0</span> <span class="main">(</span>Bound <span class="skolem">l0</span> <span class="skolem">l1</span><span class="main">)</span> <span class="skolem">a</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> b<span class="main">:</span> <span class="quoted"><span class="quoted">"in_bound <span class="free">less_eq1</span> <span class="free">less1</span> <span class="main">(</span>Bound <span class="skolem">r0</span> <span class="skolem">r1</span><span class="main">)</span> <span class="skolem">b</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> in_bound_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"idx <span class="main">(</span>Bound <span class="main">(</span><span class="skolem">l0</span><span class="main">,</span> <span class="skolem">r0</span><span class="main">)</span> <span class="main">(</span><span class="skolem">l1</span><span class="main">,</span> <span class="skolem">r1</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">&lt;</span> size <span class="main">(</span>Bound <span class="main">(</span><span class="skolem">l0</span><span class="main">,</span> <span class="skolem">r0</span><span class="main">)</span> <span class="main">(</span><span class="skolem">l1</span><span class="main">,</span> <span class="skolem">r1</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> index_mono<span class="main">[</span><span class="operator">OF</span> index0.idx_valid<span class="main"><span class="main">[</span></span><span class="operator">OF</span> a<span class="main"><span class="main">]</span></span> index1.idx_valid<span class="main"><span class="main">[</span></span><span class="operator">OF</span> b<span class="main"><span class="main">]</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"idx <span class="skolem">bound</span> <span class="skolem">ab</span> <span class="main">&lt;</span> size <span class="skolem">bound</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> defs <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">}</span></span>

  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">ab</span> <span class="skolem">cd</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">bound</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> bound"</span></span>
    <span class="keyword3"><span class="command">assume</span></span> bound<span class="main">:</span> <span class="quoted"><span class="quoted">"in_bound less_eq less <span class="skolem">bound</span> <span class="skolem">ab</span>"</span></span> <span class="quoted"><span class="quoted">"in_bound less_eq less <span class="skolem">bound</span> <span class="skolem">cd</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> idx_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"idx <span class="skolem">bound</span> <span class="skolem">ab</span> <span class="main">=</span> idx <span class="skolem">bound</span> <span class="skolem">cd</span>"</span></span>

    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a</span></span> <span class="skolem"><span class="skolem">b</span></span> <span class="skolem"><span class="skolem">c</span></span> <span class="skolem"><span class="skolem">d</span></span> <span class="skolem"><span class="skolem">l0</span></span> <span class="skolem"><span class="skolem">r0</span></span> <span class="skolem"><span class="skolem">l1</span></span> <span class="skolem"><span class="skolem">r1</span></span> <span class="keyword2"><span class="keyword">where</span></span>
      defs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">ab</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">cd</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">c</span><span class="main">,</span> <span class="skolem">d</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">bound</span> <span class="main">=</span> Bound <span class="main">(</span><span class="skolem">l0</span><span class="main">,</span> <span class="skolem">l1</span><span class="main">)</span> <span class="main">(</span><span class="skolem">r0</span><span class="main">,</span> <span class="skolem">r1</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ab</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">cd</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">bound</span></span><span class="main">)</span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">from</span></span> defs bound <span class="keyword1"><span class="command">have</span></span>
          a<span class="main">:</span> <span class="quoted"><span class="quoted">"in_bound <span class="free">less_eq0</span> <span class="free">less0</span> <span class="main">(</span>Bound <span class="skolem">l0</span> <span class="skolem">r0</span><span class="main">)</span> <span class="skolem">a</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> b<span class="main">:</span> <span class="quoted"><span class="quoted">"in_bound <span class="free">less_eq1</span> <span class="free">less1</span> <span class="main">(</span>Bound <span class="skolem">l1</span> <span class="skolem">r1</span><span class="main">)</span> <span class="skolem">b</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"in_bound <span class="free">less_eq0</span> <span class="free">less0</span> <span class="main">(</span>Bound <span class="skolem">l0</span> <span class="skolem">r0</span><span class="main">)</span> <span class="skolem">c</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> d<span class="main">:</span> <span class="quoted"><span class="quoted">"in_bound <span class="free">less_eq1</span> <span class="free">less1</span> <span class="main">(</span>Bound <span class="skolem">l1</span> <span class="skolem">r1</span><span class="main">)</span> <span class="skolem">d</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> in_bound_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">from</span></span> index_eq_iff<span class="main">[</span><span class="operator">OF</span> index1.idx_valid<span class="main"><span class="main">[</span></span><span class="operator">OF</span> b<span class="main"><span class="main">]</span></span> index1.idx_valid<span class="main"><span class="main">[</span></span><span class="operator">OF</span> d<span class="main"><span class="main">]</span></span> idx_eq<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> defs<span class="main"><span class="main">,</span></span> <span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> ac<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">idx0</span> <span class="main">(</span>Bound <span class="skolem">l0</span> <span class="skolem">r0</span><span class="main">)</span> <span class="skolem">a</span> <span class="main">=</span> <span class="free">idx0</span> <span class="main">(</span>Bound <span class="skolem">l0</span> <span class="skolem">r0</span><span class="main">)</span> <span class="skolem">c</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> bd<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">idx1</span> <span class="main">(</span>Bound <span class="skolem">l1</span> <span class="skolem">r1</span><span class="main">)</span> <span class="skolem">b</span> <span class="main">=</span> <span class="free">idx1</span> <span class="main">(</span>Bound <span class="skolem">l1</span> <span class="skolem">r1</span><span class="main">)</span> <span class="skolem">d</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ab</span> <span class="main">=</span> <span class="skolem">cd</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> defs <span class="keyword1"><span class="command">using</span></span> index0.idx_inj<span class="main">[</span><span class="operator">OF</span> a c ac<span class="main">]</span> index1.idx_inj<span class="main">[</span><span class="operator">OF</span> b d bd<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span>
<span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> option_index <span class="main">=</span>
  index0<span class="main">:</span> index_locale <span class="quoted"><span class="free">less_eq0</span></span> <span class="quoted"><span class="free">less0</span></span> <span class="quoted"><span class="free">idx0</span></span> <span class="quoted"><span class="free">size0</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">less_eq0</span> <span class="free">less0</span> <span class="free">idx0</span> <span class="free">size0</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">idx</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> option bound <span class="main">⇒</span> <span class="tfree">'a</span> option <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">idx</span> <span class="main">(</span>Bound <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">idx0</span> <span class="main">(</span>Bound <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">idx</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> undefined"</span></span>
<span class="comment1">(* option is NOT an index *)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> nat_index_def <span class="main">=</span> ord <span class="quoted"><span class="quoted">"<span class="main">(≤)</span> <span class="main">::</span> nat <span class="main">⇒</span> nat <span class="main">⇒</span> bool"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(&lt;)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">idx</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat bound <span class="main">⇒</span> nat <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">idx</span> <span class="main">(</span>Bound <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">size</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat bound <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">size</span> <span class="main">(</span>Bound <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span>"</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> index_locale <span class="quoted"><span class="quoted">"<span class="main">(≤)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(&lt;)</span>"</span></span> <span class="quoted">idx</span> <span class="quoted">size</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_bound_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> bound.splits<span class="main">)</span> 

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> nat_index <span class="main">=</span> nat_index_def <span class="main">+</span> order <span class="quoted"><span class="quoted">"<span class="main">(≤)</span> <span class="main">::</span> nat <span class="main">⇒</span> nat <span class="main">⇒</span> bool"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(&lt;)</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> int_index_def <span class="main">=</span> ord <span class="quoted"><span class="quoted">"<span class="main">(≤)</span> <span class="main">::</span> int <span class="main">⇒</span> int <span class="main">⇒</span> bool"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(&lt;)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">idx</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"int bound <span class="main">⇒</span> int <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">idx</span> <span class="main">(</span>Bound <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">=</span> nat <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">size</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"int bound <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">size</span> <span class="main">(</span>Bound <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> nat <span class="main">(</span><span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> index_locale <span class="quoted"><span class="quoted">"<span class="main">(≤)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(&lt;)</span>"</span></span> <span class="quoted">idx</span> <span class="quoted">size</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_bound_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> bound.splits<span class="main">)</span> 

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> int_index <span class="main">=</span> int_index_def <span class="main">+</span> order <span class="quoted"><span class="quoted">"<span class="main">(≤)</span> <span class="main">::</span> int <span class="main">⇒</span> int <span class="main">⇒</span> bool"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(&lt;)</span>"</span></span>

<span class="keyword1"><span class="command">class</span></span> index <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free"><span class="free"><span class="free">less_eq</span></span></span> <span class="free"><span class="free"><span class="free">less</span></span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free"><span class="free"><span class="free">idx</span></span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> bound <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> nat"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free"><span class="free"><span class="free">size</span></span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> bound <span class="main">⇒</span> nat"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> is_locale<span class="main">:</span> <span class="quoted"><span class="quoted">"index_locale <span class="free">less_eq</span> <span class="free">less</span> <span class="free">idx</span> <span class="free">size</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> bounded_index <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">bound</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span> <span class="main">::</span> index bound"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> index_locale <span class="quoted">less_eq</span> <span class="quoted">less</span> <span class="quoted">idx</span> <span class="quoted">size</span>
  <span class="keyword1"><span class="command">using</span></span> is_locale <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">size</span> <span class="main">≡</span> index_class.size <span class="free">bound</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">size</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">checked_idx</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> <span class="keyword1">if</span> in_bound less_eq less <span class="free">bound</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">then</span> idx <span class="free">bound</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">else</span> size"</span></span>

<span class="keyword1" id="Index-checked_idx_injective"><span class="command">lemma</span></span> checked_idx_injective<span class="main">:</span>
  <span class="quoted"><span class="quoted">"injective size checked_idx"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> injective_def
  <span class="keyword1"><span class="command">unfolding</span></span> checked_idx_def
  <span class="keyword1"><span class="command">using</span></span> idx_inj <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> nat <span class="main">::</span> <span class="quoted">index</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> nat_index <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">thm</span></span> index_locale_axioms

<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">less_eq_nat</span></span> <span class="main">≡</span> <span class="main">(≤)</span> <span class="main">::</span> nat <span class="main">⇒</span> nat <span class="main">⇒</span> bool"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">less_nat</span></span> <span class="main">≡</span> <span class="main">(&lt;)</span> <span class="main">::</span> nat <span class="main">⇒</span> nat <span class="main">⇒</span> bool"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">idx_nat</span></span> <span class="main">≡</span> idx"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity"><span class="class_parameter">size_nat</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">size_nat</span> <span class="main">≡</span> size"</span></span>

<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">fact</span> index_locale_axioms<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> int <span class="main">::</span> <span class="quoted">index</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> int_index <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">thm</span></span> index_locale_axioms

<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">less_eq_int</span></span> <span class="main">≡</span> <span class="main">(≤)</span> <span class="main">::</span> int <span class="main">⇒</span> int <span class="main">⇒</span> bool"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">less_int</span></span> <span class="main">≡</span> <span class="main">(&lt;)</span> <span class="main">::</span> int <span class="main">⇒</span> int <span class="main">⇒</span> bool"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">idx_int</span></span> <span class="main">≡</span> idx"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">size_int</span></span> <span class="main">≡</span> size"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> size_int <span class="main">=</span> size.simps

<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">fact</span> index_locale_axioms<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> prod <span class="main">::</span> <span class="main">(</span><span class="quoted">index</span><span class="main">,</span> <span class="quoted">index</span><span class="main">)</span> <span class="quoted">index</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> prod_index
  <span class="quoted"><span class="quoted">"less_eq<span class="main">::</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="quoted">less</span> <span class="quoted">idx</span> <span class="quoted">size</span>
  <span class="quoted"><span class="quoted">"less_eq<span class="main">::</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool"</span></span> <span class="quoted">less</span> <span class="quoted">idx</span> <span class="quoted">size</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> prod_index.intro<span class="main"><span class="keyword3">;</span></span> <span class="operator">fact</span> is_locale<span class="main">)</span>
<span class="keyword1"><span class="command">thm</span></span> index_locale_axioms

<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">less_eq_prod</span></span> <span class="main">≡</span> less_eq"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">less_prod</span></span> <span class="main">≡</span> less"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">idx_prod</span></span> <span class="main">≡</span> idx"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">size_prod</span></span> <span class="main">≡</span> size"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">size_prod</span>

<span class="keyword1"><span class="command">lemmas</span></span> size_prod <span class="main">=</span> size.simps

<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">fact</span> index_locale_axioms<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Index-bound_int_simp"><span class="command">lemma</span></span> bound_int_simp<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"bounded_index.size <span class="main">(</span>Bound <span class="main">(</span><span class="free">l1</span><span class="main">,</span> <span class="free">l2</span><span class="main">)</span> <span class="main">(</span><span class="free">u1</span><span class="main">,</span> <span class="free">u2</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> nat <span class="main">(</span><span class="free">u1</span> <span class="main">-</span> <span class="free">l1</span><span class="main">)</span> <span class="main">*</span> nat <span class="main">(</span><span class="free">u2</span> <span class="main">-</span> <span class="free">l2</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bounded_index.size_def<span class="main"><span class="keyword3">,</span></span><span class="operator">unfold</span> size_int_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> size_prod<span class="main"><span class="keyword3">,</span></span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> size_int<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> bounded_index.size_def bounded_index.checked_idx_def

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span>
  nat_index_def.size.simps
  nat_index_def.idx.simps

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span>
  int_index_def.size.simps
  int_index_def.idx.simps

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span>
  prod_index_def.size.simps
  prod_index_def.idx.simps

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span>
  prod_order_def.less_eq.simps
  prod_order_def.less.simps

<span class="keyword1"><span class="command">lemmas</span></span> index_size_defs <span class="main">=</span>
  prod_index_def.size.simps int_index_def.size.simps nat_index_def.size.simps bounded_index.size_def

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Memory_Heap">
<div class="head">
<h1>Theory Memory_Heap</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Heap Memory Implementations›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Memory_Heap
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="#State_Heap">State_Heap</a> <a href="#DP_CRelVH">DP_CRelVH</a> <a href="#Pair_Memory">Pair_Memory</a> <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Eisbach/Eisbach.html">HOL-Eisbach.Eisbach</a>"</span> <span class="quoted">"<a href="#Index">../Index</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Move›</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">result_of</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="main">≡</span> fst <span class="main">(</span>the <span class="main">(</span>execute <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="free"><span class="bound"><span class="entity">h</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">heap_of</span>   <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="main">≡</span> snd <span class="main">(</span>the <span class="main">(</span>execute <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="free"><span class="bound"><span class="entity">h</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Memory_Heap-map_emptyI"><span class="command">lemma</span></span> map_emptyI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> Map.empty"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">x</span><span class="main">.</span> <span class="free">m</span> <span class="bound">x</span> <span class="main">=</span> None"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> map_le_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Memory_Heap-result_of_return"><span class="command">lemma</span></span> result_of_return<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"result_of <span class="main">(</span>Heap_Monad.return <span class="free">x</span><span class="main">)</span> <span class="free">h</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span><span class="main">)</span>

<span class="keyword1" id="Memory_Heap-get_result_of_lookup"><span class="command">lemma</span></span> get_result_of_lookup<span class="main">:</span>
  <span class="quoted"><span class="quoted">"result_of <span class="main">(</span><span class="main">!</span><span class="free">r</span><span class="main">)</span> <span class="free">heap</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"Ref.get <span class="free">heap</span> <span class="free">r</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">size</span> <span class="main">::</span> <span class="quoted">nat</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">to_index</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k2</span> <span class="main">::</span> heap<span class="main">)</span> <span class="main">⇒</span> nat"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mem_empty</span> <span class="main">=</span> <span class="main">(</span>Array.new <span class="free">size</span> <span class="main">(</span>None <span class="main">::</span> <span class="main">(</span><span class="tfree">'v</span> <span class="main">::</span> heap<span class="main">)</span> option<span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Memory_Heap-success_empty"><span class="command">lemma</span></span> success_empty<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"success mem_empty <span class="free">heap</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> mem_empty_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">success_intros</span></span><span class="main">)</span>

<span class="keyword1" id="Memory_Heap-length_mem_empty"><span class="command">lemma</span></span> length_mem_empty<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Array.length
    <span class="main">(</span>heap_of <span class="main">(</span>mem_empty<span class="main">::</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'b</span> <span class="main">::</span> heap<span class="main">)</span> option array<span class="main">)</span> Heap<span class="main">)</span> <span class="free">h</span><span class="main">)</span>
    <span class="main">(</span>result_of <span class="main">(</span>mem_empty <span class="main">::</span> <span class="main">(</span><span class="tfree">'b</span> option array<span class="main">)</span> Heap<span class="main">)</span> <span class="free">h</span><span class="main">)</span> <span class="main">=</span> <span class="free">size</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> mem_empty_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span> Array.length_alloc<span class="main">)</span>

<span class="keyword1" id="Memory_Heap-nth_mem_empty"><span class="command">lemma</span></span> nth_mem_empty<span class="main">:</span>
  <span class="quoted"><span class="quoted">"result_of
    <span class="main">(</span>Array.nth <span class="main">(</span>result_of <span class="main">(</span>mem_empty <span class="main">::</span> <span class="main">(</span><span class="tfree">'b</span> option array<span class="main">)</span> Heap<span class="main">)</span> <span class="free">h</span><span class="main">)</span> <span class="free">i</span><span class="main">)</span>
    <span class="main">(</span>heap_of <span class="main">(</span>mem_empty <span class="main">::</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'b</span> <span class="main">::</span> heap<span class="main">)</span> option array<span class="main">)</span> Heap<span class="main">)</span> <span class="free">h</span><span class="main">)</span> <span class="main">=</span> None"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&lt;</span> <span class="free">size</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> execute_nth<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> length_mem_empty that<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span> mem_empty_def Array.get_alloc that<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">mem</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span> <span class="main">::</span> heap<span class="main">)</span> option array"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mem_lookup</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">i</span> <span class="main">=</span> <span class="free">to_index</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="keyword1">in</span>
    <span class="keyword1">if</span> <span class="bound">i</span> <span class="main">&lt;</span> <span class="free">size</span> <span class="keyword1">then</span> Array.nth <span class="free">mem</span> <span class="bound">i</span> <span class="keyword1">else</span> return None
  <span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mem_update</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">i</span> <span class="main">=</span> <span class="free">to_index</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="keyword1">in</span>
    <span class="keyword1">if</span> <span class="bound">i</span> <span class="main">&lt;</span> <span class="free">size</span> <span class="keyword1">then</span> <span class="main">(</span>Array.upd <span class="bound">i</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="free">mem</span> <span class="main">⤜</span> <span class="main">(</span><span class="main">λ</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> return <span class="main">()</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1">else</span> return <span class="main">()</span>
  <span class="main">)</span>
  "</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">assumes</span></span> injective<span class="main">:</span> <span class="quoted"><span class="quoted">"injective <span class="free">size</span> <span class="free">to_index</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> heap_correct <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">heap</span><span class="main">.</span> Array.length <span class="bound">heap</span> <span class="free">mem</span> <span class="main">=</span> <span class="free">size</span>"</span></span> <span class="quoted">mem_update</span> <span class="quoted">mem_lookup</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> lookup_inv
    <span class="keyword1"><span class="command">unfolding</span></span> State_Heap.lift_p_def mem_lookup_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def <span class="dynamic"><span class="dynamic">execute_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> update_inv
    <span class="keyword1"><span class="command">unfolding</span></span> State_Heap.lift_p_def mem_update_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def <span class="dynamic"><span class="dynamic">execute_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> k heap
    <span class="keyword1"><span class="command">unfolding</span></span> heap_mem_defs.map_of_heap_def map_le_def mem_lookup_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span> Let_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> heap k
    <span class="keyword1"><span class="command">unfolding</span></span> heap_mem_defs.map_of_heap_def map_le_def mem_lookup_def mem_update_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span> Let_def length_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> nth_list_update_neq<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> injective<span class="main">[</span><span class="operator">unfolded</span> injective_def<span class="main">]</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemmas</span></span> mem_heap_correct <span class="main">=</span> heap_correct_axioms

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">mem</span> <span class="main">=</span> result_of mem_empty Heap.empty"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> heap_correct_empty
  <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">heap</span><span class="main">.</span> Array.length <span class="bound">heap</span> <span class="free">mem</span> <span class="main">=</span> <span class="free">size</span>"</span></span> <span class="quoted">mem_update</span> <span class="quoted">mem_lookup</span>
  <span class="quoted"><span class="quoted">"heap_of <span class="main">(</span>mem_empty <span class="main">::</span> <span class="tfree">'v</span> option array Heap<span class="main">)</span> Heap.empty"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> map_emptyI<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> map_of_heap_def mem_lookup_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def nth_mem_empty<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> length_mem_empty<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemmas</span></span> array_heap_emptyI <span class="main">=</span> heap_correct_empty_axioms

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">dp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k2</span> <span class="main">⇒</span> <span class="tfree">'v</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> dp_consistency_heap_empty
  <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">heap</span><span class="main">.</span> Array.length <span class="bound">heap</span> <span class="free">mem</span> <span class="main">=</span> <span class="free">size</span>"</span></span> <span class="quoted">mem_update</span> <span class="quoted">mem_lookup</span> <span class="quoted"><span class="free">dp</span></span>
  <span class="quoted"><span class="quoted">"heap_of <span class="main">(</span>mem_empty <span class="main">::</span> <span class="tfree">'v</span> option array Heap<span class="main">)</span> Heap.empty"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span>

<span class="keyword1"><span class="command">lemmas</span></span> array_consistentI <span class="main">=</span> dp_consistency_heap_empty_axioms

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Empty Memory *)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Injectivity *)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Fixed array *)</span>

<span class="keyword1" id="Memory_Heap-execute_bind_success'"><span class="command">lemma</span></span> execute_bind_success'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"success <span class="free">f</span> <span class="free">h</span>"</span></span> <span class="quoted"><span class="quoted">"execute <span class="main">(</span><span class="free">f</span> <span class="main">⤜</span> <span class="free">g</span><span class="main">)</span> <span class="free">h</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">y</span><span class="main">,</span> <span class="free">h''</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">x</span> <span class="free">h'</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"execute <span class="free">f</span> <span class="free">h</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">h'</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"execute <span class="main">(</span><span class="free">g</span> <span class="free">x</span><span class="main">)</span> <span class="free">h'</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">y</span><span class="main">,</span> <span class="free">h''</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> successE<span class="main">)</span>

<span class="keyword1" id="Memory_Heap-success_bind_I"><span class="command">lemma</span></span> success_bind_I<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"success <span class="free">f</span> <span class="free">h</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">x</span> <span class="bound">h'</span><span class="main">.</span> execute <span class="free">f</span> <span class="free">h</span> <span class="main">=</span> Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">h'</span><span class="main">)</span> <span class="main">⟹</span> success <span class="main">(</span><span class="free">g</span> <span class="bound">x</span><span class="main">)</span> <span class="bound">h'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"success <span class="main">(</span><span class="free">f</span> <span class="main">⤜</span> <span class="free">g</span><span class="main">)</span> <span class="free">h</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> successE<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> success_bind_executeI<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">alloc_pair</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">r1</span> <span class="main">←</span> ref <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">;</span>
    <span class="bound">r2</span> <span class="main">←</span> ref <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">;</span>
    return <span class="main">(</span><span class="bound">r1</span><span class="main">,</span> <span class="bound">r2</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1" id="Memory_Heap-alloc_pair_alloc"><span class="command">lemma</span></span> alloc_pair_alloc<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Ref.get <span class="free">heap'</span> <span class="free">r1</span> <span class="main">=</span> <span class="free">a</span>"</span></span> <span class="quoted"><span class="quoted">"Ref.get <span class="free">heap'</span> <span class="free">r2</span> <span class="main">=</span> <span class="free">b</span>"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"execute <span class="main">(</span>alloc_pair <span class="free">a</span> <span class="free">b</span><span class="main">)</span> <span class="free">heap</span> <span class="main">=</span> Some <span class="main">(</span><span class="main">(</span><span class="free">r1</span><span class="main">,</span> <span class="free">r2</span><span class="main">)</span><span class="main">,</span> <span class="free">heap'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> alloc_pair_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> execute_bind_success'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> success_refI<span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">metis</span> Ref.get_alloc fst_conv get_alloc_neq next_present present_alloc_neq snd_conv<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Memory_Heap-alloc_pairD1"><span class="command">lemma</span></span> alloc_pairD1<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">=!=</span> <span class="free">r1</span> <span class="main">∧</span> <span class="free">r</span> <span class="main">=!=</span> <span class="free">r2</span> <span class="main">∧</span> Ref.present <span class="free">heap'</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"execute <span class="main">(</span>alloc_pair <span class="free">a</span> <span class="free">b</span><span class="main">)</span> <span class="free">heap</span> <span class="main">=</span> Some <span class="main">(</span><span class="main">(</span><span class="free">r1</span><span class="main">,</span> <span class="free">r2</span><span class="main">)</span><span class="main">,</span> <span class="free">heap'</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"Ref.present <span class="free">heap</span> <span class="free">r</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> alloc_pair_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> execute_bind_success'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> success_refI<span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">metis</span> next_fresh noteq_I Ref.present_alloc snd_conv<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Memory_Heap-alloc_pairD2"><span class="command">lemma</span></span> alloc_pairD2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">r1</span> <span class="main">=!=</span> <span class="free">r2</span> <span class="main">∧</span> Ref.present <span class="free">heap'</span> <span class="free">r2</span> <span class="main">∧</span> Ref.present <span class="free">heap'</span> <span class="free">r1</span>"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"execute <span class="main">(</span>alloc_pair <span class="free">a</span> <span class="free">b</span><span class="main">)</span> <span class="free">heap</span> <span class="main">=</span> Some <span class="main">(</span><span class="main">(</span><span class="free">r1</span><span class="main">,</span> <span class="free">r2</span><span class="main">)</span><span class="main">,</span> <span class="free">heap'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> alloc_pair_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> execute_bind_success'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> success_refI<span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">metis</span> next_fresh next_present noteq_I Ref.present_alloc snd_conv<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Memory_Heap-alloc_pairD3"><span class="command">lemma</span></span> alloc_pairD3<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Array.present <span class="free">heap'</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"execute <span class="main">(</span>alloc_pair <span class="free">a</span> <span class="free">b</span><span class="main">)</span> <span class="free">heap</span> <span class="main">=</span> Some <span class="main">(</span><span class="main">(</span><span class="free">r1</span><span class="main">,</span> <span class="free">r2</span><span class="main">)</span><span class="main">,</span> <span class="free">heap'</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"Array.present <span class="free">heap</span> <span class="free">r</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> alloc_pair_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> execute_bind_success'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> success_refI<span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">metis</span> array_present_alloc snd_conv<span class="main">)</span>

<span class="keyword1" id="Memory_Heap-alloc_pairD4"><span class="command">lemma</span></span> alloc_pairD4<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Ref.get <span class="free">heap'</span> <span class="free">r</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"execute <span class="main">(</span>alloc_pair <span class="free">a</span> <span class="free">b</span><span class="main">)</span> <span class="free">heap</span> <span class="main">=</span> Some <span class="main">(</span><span class="main">(</span><span class="free">r1</span><span class="main">,</span> <span class="free">r2</span><span class="main">)</span><span class="main">,</span> <span class="free">heap'</span><span class="main">)</span>"</span></span>
     <span class="quoted"><span class="quoted">"Ref.get <span class="free">heap</span> <span class="free">r</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="quoted"><span class="quoted">"Ref.present <span class="free">heap</span> <span class="free">r</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> alloc_pair_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> execute_bind_success'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> success_refI<span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">metis</span> Ref.not_present_alloc Ref.present_alloc get_alloc_neq noteq_I snd_conv<span class="main">)</span>

<span class="keyword1" id="Memory_Heap-alloc_pair_array_get"><span class="command">lemma</span></span> alloc_pair_array_get<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Array.get <span class="free">heap'</span> <span class="free">r</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"execute <span class="main">(</span>alloc_pair <span class="free">a</span> <span class="free">b</span><span class="main">)</span> <span class="free">heap</span> <span class="main">=</span> Some <span class="main">(</span><span class="main">(</span><span class="free">r1</span><span class="main">,</span> <span class="free">r2</span><span class="main">)</span><span class="main">,</span> <span class="free">heap'</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"Array.get <span class="free">heap</span> <span class="free">r</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> alloc_pair_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> execute_bind_success'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> success_refI<span class="main"><span class="main">]</span></span><span class="main">)</span>
 <span class="main">(</span><span class="operator">metis</span> array_get_alloc snd_conv<span class="main">)</span>

<span class="keyword1" id="Memory_Heap-alloc_pair_array_length"><span class="command">lemma</span></span> alloc_pair_array_length<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Array.length <span class="free">heap'</span> <span class="free">r</span> <span class="main">=</span> Array.length <span class="free">heap</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"execute <span class="main">(</span>alloc_pair <span class="free">a</span> <span class="free">b</span><span class="main">)</span> <span class="free">heap</span> <span class="main">=</span> Some <span class="main">(</span><span class="main">(</span><span class="free">r1</span><span class="main">,</span> <span class="free">r2</span><span class="main">)</span><span class="main">,</span> <span class="free">heap'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> alloc_pair_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> execute_bind_success'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> success_refI<span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">metis</span> Ref.length_alloc snd_conv<span class="main">)</span>

<span class="keyword1" id="Memory_Heap-alloc_pair_nth"><span class="command">lemma</span></span> alloc_pair_nth<span class="main">:</span>
  <span class="quoted"><span class="quoted">"result_of <span class="main">(</span>Array.nth <span class="free">r</span> <span class="free">i</span><span class="main">)</span> <span class="free">heap'</span> <span class="main">=</span> result_of <span class="main">(</span>Array.nth <span class="free">r</span> <span class="free">i</span><span class="main">)</span> <span class="free">heap</span>"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"execute <span class="main">(</span>alloc_pair <span class="free">a</span> <span class="free">b</span><span class="main">)</span> <span class="free">heap</span> <span class="main">=</span> Some <span class="main">(</span><span class="main">(</span><span class="free">r1</span><span class="main">,</span> <span class="free">r2</span><span class="main">)</span><span class="main">,</span> <span class="free">heap'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> alloc_pair_array_get<span class="main">[</span><span class="operator">OF</span> that<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> HOL.refl<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">r</span></span><span class="main">]</span> alloc_pair_array_length<span class="main">[</span><span class="operator">OF</span> that<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">r</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">h</span><span class="main">.</span> <span class="free">i</span> <span class="main">&lt;</span> Array.length <span class="bound">h</span> <span class="free">r</span><span class="main">)</span> <span class="free">heap</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span> Array.nth_def<span class="main">)</span>

<span class="keyword1" id="Memory_Heap-succes_alloc_pair"><span class="command">lemma</span></span> succes_alloc_pair<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"success <span class="main">(</span>alloc_pair <span class="free">a</span> <span class="free">b</span><span class="main">)</span> <span class="free">heap</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> alloc_pair_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">success_intros</span></span> success_bind_I<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">init_state_inner</span> <span class="free"><span class="bound"><span class="entity">k1</span></span></span> <span class="free"><span class="bound"><span class="entity">k2</span></span></span> <span class="free"><span class="bound"><span class="entity">m1</span></span></span> <span class="free"><span class="bound"><span class="entity">m2</span></span></span> <span class="main">≡</span>  <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="bound">k_ref1</span><span class="main">,</span> <span class="bound">k_ref2</span><span class="main">)</span> <span class="main">←</span> alloc_pair <span class="free"><span class="bound"><span class="entity">k1</span></span></span> <span class="free"><span class="bound"><span class="entity">k2</span></span></span><span class="main">;</span>
    <span class="main">(</span><span class="bound">m_ref1</span><span class="main">,</span> <span class="bound">m_ref2</span><span class="main">)</span> <span class="main">←</span> alloc_pair <span class="free"><span class="bound"><span class="entity">m1</span></span></span> <span class="free"><span class="bound"><span class="entity">m2</span></span></span><span class="main">;</span>
    return <span class="main">(</span><span class="bound">k_ref1</span><span class="main">,</span> <span class="bound">k_ref2</span><span class="main">,</span> <span class="bound">m_ref1</span><span class="main">,</span> <span class="bound">m_ref2</span><span class="main">)</span>
  <span class="main">}</span>
  "</span></span>

<span class="keyword1" id="Memory_Heap-init_state_inner_alloc"><span class="command">lemma</span></span> init_state_inner_alloc<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span>
    <span class="quoted"><span class="quoted">"execute <span class="main">(</span>init_state_inner <span class="free">k1</span> <span class="free">k2</span> <span class="free">m1</span> <span class="free">m2</span><span class="main">)</span> <span class="free">heap</span> <span class="main">=</span> Some <span class="main">(</span><span class="main">(</span><span class="free">k_ref1</span><span class="main">,</span> <span class="free">k_ref2</span><span class="main">,</span> <span class="free">m_ref1</span><span class="main">,</span> <span class="free">m_ref2</span><span class="main">)</span><span class="main">,</span> <span class="free">heap'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>
    <span class="quoted"><span class="quoted">"Ref.get <span class="free">heap'</span> <span class="free">k_ref1</span> <span class="main">=</span> <span class="free">k1</span>"</span></span> <span class="quoted"><span class="quoted">"Ref.get <span class="free">heap'</span> <span class="free">k_ref2</span> <span class="main">=</span> <span class="free">k2</span>"</span></span>
    <span class="quoted"><span class="quoted">"Ref.get <span class="free">heap'</span> <span class="free">m_ref1</span> <span class="main">=</span> <span class="free">m1</span>"</span></span> <span class="quoted"><span class="quoted">"Ref.get <span class="free">heap'</span> <span class="free">m_ref2</span> <span class="main">=</span> <span class="free">m2</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> init_state_inner_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> execute_bind_success'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> succes_alloc_pair<span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> alloc_pair_alloc <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> alloc_pairD2 <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> alloc_pairD4<span class="main">)</span>

<span class="keyword1" id="Memory_Heap-init_state_inner_distinct"><span class="command">lemma</span></span> init_state_inner_distinct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span>
    <span class="quoted"><span class="quoted">"execute <span class="main">(</span>init_state_inner <span class="free">k1</span> <span class="free">k2</span> <span class="free">m1</span> <span class="free">m2</span><span class="main">)</span> <span class="free">heap</span> <span class="main">=</span> Some <span class="main">(</span><span class="main">(</span><span class="free">k_ref1</span><span class="main">,</span> <span class="free">k_ref2</span><span class="main">,</span> <span class="free">m_ref1</span><span class="main">,</span> <span class="free">m_ref2</span><span class="main">)</span><span class="main">,</span> <span class="free">heap'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">m_ref1</span> <span class="main">=!=</span> <span class="free">m_ref2</span> <span class="main">∧</span> <span class="free">m_ref1</span> <span class="main">=!=</span> <span class="free">k_ref1</span> <span class="main">∧</span> <span class="free">m_ref1</span> <span class="main">=!=</span> <span class="free">k_ref2</span> <span class="main">∧</span> <span class="free">m_ref2</span> <span class="main">=!=</span> <span class="free">k_ref1</span>
   <span class="main">∧</span> <span class="free">m_ref2</span> <span class="main">=!=</span> <span class="free">k_ref2</span> <span class="main">∧</span> <span class="free">k_ref1</span> <span class="main">=!=</span> <span class="free">k_ref2</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> init_state_inner_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> execute_bind_success'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> succes_alloc_pair<span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> alloc_pairD1 alloc_pairD2 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> noteq_sym<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Memory_Heap-init_state_inner_present"><span class="command">lemma</span></span> init_state_inner_present<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span>
    <span class="quoted"><span class="quoted">"execute <span class="main">(</span>init_state_inner <span class="free">k1</span> <span class="free">k2</span> <span class="free">m1</span> <span class="free">m2</span><span class="main">)</span> <span class="free">heap</span> <span class="main">=</span> Some <span class="main">(</span><span class="main">(</span><span class="free">k_ref1</span><span class="main">,</span> <span class="free">k_ref2</span><span class="main">,</span> <span class="free">m_ref1</span><span class="main">,</span> <span class="free">m_ref2</span><span class="main">)</span><span class="main">,</span> <span class="free">heap'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>
    <span class="quoted"><span class="quoted">"Ref.present <span class="free">heap'</span> <span class="free">k_ref1</span>"</span></span> <span class="quoted"><span class="quoted">"Ref.present <span class="free">heap'</span> <span class="free">k_ref2</span>"</span></span>
    <span class="quoted"><span class="quoted">"Ref.present <span class="free">heap'</span> <span class="free">m_ref1</span>"</span></span> <span class="quoted"><span class="quoted">"Ref.present <span class="free">heap'</span> <span class="free">m_ref2</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> init_state_inner_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> execute_bind_success'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> succes_alloc_pair<span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> alloc_pairD1 alloc_pairD2<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Memory_Heap-inite_state_inner_present'"><span class="command">lemma</span></span> inite_state_inner_present'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span>
    <span class="quoted"><span class="quoted">"execute <span class="main">(</span>init_state_inner <span class="free">k1</span> <span class="free">k2</span> <span class="free">m1</span> <span class="free">m2</span><span class="main">)</span> <span class="free">heap</span> <span class="main">=</span> Some <span class="main">(</span><span class="main">(</span><span class="free">k_ref1</span><span class="main">,</span> <span class="free">k_ref2</span><span class="main">,</span> <span class="free">m_ref1</span><span class="main">,</span> <span class="free">m_ref2</span><span class="main">)</span><span class="main">,</span> <span class="free">heap'</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"Array.present <span class="free">heap</span> <span class="free">a</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>
    <span class="quoted"><span class="quoted">"Array.present <span class="free">heap'</span> <span class="free">a</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> init_state_inner_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> execute_bind_success'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> succes_alloc_pair<span class="main"><span class="main">]</span></span> alloc_pairD3<span class="main">)</span>

<span class="keyword1" id="Memory_Heap-succes_init_state_inner"><span class="command">lemma</span></span> succes_init_state_inner<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"success <span class="main">(</span>init_state_inner <span class="free">k1</span> <span class="free">k2</span> <span class="free">m1</span> <span class="free">m2</span><span class="main">)</span> <span class="free">heap</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> init_state_inner_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">success_intros</span></span> success_bind_I<span class="main">)</span>

<span class="keyword1" id="Memory_Heap-init_state_inner_nth"><span class="command">lemma</span></span> init_state_inner_nth<span class="main">:</span>
  <span class="quoted"><span class="quoted">"result_of <span class="main">(</span>Array.nth <span class="free">r</span> <span class="free">i</span><span class="main">)</span> <span class="free">heap'</span> <span class="main">=</span> result_of <span class="main">(</span>Array.nth <span class="free">r</span> <span class="free">i</span><span class="main">)</span> <span class="free">heap</span>"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"execute <span class="main">(</span>init_state_inner <span class="free">k1</span> <span class="free">k2</span> <span class="free">m1</span> <span class="free">m2</span><span class="main">)</span> <span class="free">heap</span> <span class="main">=</span> Some <span class="main">(</span><span class="main">(</span><span class="free">r1</span><span class="main">,</span> <span class="free">r2</span><span class="main">)</span><span class="main">,</span> <span class="free">heap'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> init_state_inner_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span> alloc_pair_nth <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> execute_bind_success'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> succes_alloc_pair<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">init_state</span> <span class="free"><span class="bound"><span class="entity">k1</span></span></span> <span class="free"><span class="bound"><span class="entity">k2</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">m1</span> <span class="main">←</span> mem_empty<span class="main">;</span>
    <span class="bound">m2</span> <span class="main">←</span> mem_empty<span class="main">;</span>
    init_state_inner <span class="free"><span class="bound"><span class="entity">k1</span></span></span> <span class="free"><span class="bound"><span class="entity">k2</span></span></span> <span class="bound">m1</span> <span class="bound">m2</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1" id="Memory_Heap-succes_init_state"><span class="command">lemma</span></span> succes_init_state<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"success <span class="main">(</span>init_state <span class="free">k1</span> <span class="free">k2</span><span class="main">)</span> <span class="free">heap</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> init_state_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">success_intros</span></span> success_bind_I<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">inv_distinct</span> <span class="free"><span class="bound"><span class="entity">k_ref1</span></span></span> <span class="free"><span class="bound"><span class="entity">k_ref2</span></span></span> <span class="free"><span class="bound"><span class="entity">m_ref1</span></span></span> <span class="free"><span class="bound"><span class="entity">m_ref2</span></span></span> <span class="main">≡</span>
     <span class="free"><span class="bound"><span class="entity">m_ref1</span></span></span> <span class="main">=!=</span> <span class="free"><span class="bound"><span class="entity">m_ref2</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">m_ref1</span></span></span> <span class="main">=!=</span> <span class="free"><span class="bound"><span class="entity">k_ref1</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">m_ref1</span></span></span> <span class="main">=!=</span> <span class="free"><span class="bound"><span class="entity">k_ref2</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">m_ref2</span></span></span> <span class="main">=!=</span> <span class="free"><span class="bound"><span class="entity">k_ref1</span></span></span>
   <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">m_ref2</span></span></span> <span class="main">=!=</span> <span class="free"><span class="bound"><span class="entity">k_ref2</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">k_ref1</span></span></span> <span class="main">=!=</span> <span class="free"><span class="bound"><span class="entity">k_ref2</span></span></span>
  "</span></span>

<span class="keyword1" id="Memory_Heap-init_state_distinct"><span class="command">lemma</span></span> init_state_distinct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span>
    <span class="quoted"><span class="quoted">"execute <span class="main">(</span>init_state <span class="free">k1</span> <span class="free">k2</span><span class="main">)</span> <span class="free">heap</span> <span class="main">=</span> Some <span class="main">(</span><span class="main">(</span><span class="free">k_ref1</span><span class="main">,</span> <span class="free">k_ref2</span><span class="main">,</span> <span class="free">m_ref1</span><span class="main">,</span> <span class="free">m_ref2</span><span class="main">)</span><span class="main">,</span> <span class="free">heap'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>
    <span class="quoted"><span class="quoted">"inv_distinct <span class="free">k_ref1</span> <span class="free">k_ref2</span> <span class="free">m_ref1</span> <span class="free">m_ref2</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> init_state_def inv_distinct_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">elim</span> execute_bind_success'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> success_empty<span class="main"><span class="main">]</span></span> init_state_inner_distinct<span class="main">)</span>

<span class="keyword1" id="Memory_Heap-init_state_present"><span class="command">lemma</span></span> init_state_present<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span>
    <span class="quoted"><span class="quoted">"execute <span class="main">(</span>init_state <span class="free">k1</span> <span class="free">k2</span><span class="main">)</span> <span class="free">heap</span> <span class="main">=</span> Some <span class="main">(</span><span class="main">(</span><span class="free">k_ref1</span><span class="main">,</span> <span class="free">k_ref2</span><span class="main">,</span> <span class="free">m_ref1</span><span class="main">,</span> <span class="free">m_ref2</span><span class="main">)</span><span class="main">,</span> <span class="free">heap'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>
    <span class="quoted"><span class="quoted">"Ref.present <span class="free">heap'</span> <span class="free">k_ref1</span>"</span></span> <span class="quoted"><span class="quoted">"Ref.present <span class="free">heap'</span> <span class="free">k_ref2</span>"</span></span>
    <span class="quoted"><span class="quoted">"Ref.present <span class="free">heap'</span> <span class="free">m_ref1</span>"</span></span> <span class="quoted"><span class="quoted">"Ref.present <span class="free">heap'</span> <span class="free">m_ref2</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> init_state_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span>
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> execute_bind_success'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> success_empty<span class="main"><span class="main">]</span></span>
        <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> init_state_inner_present
     <span class="main">)</span>

<span class="keyword1" id="Memory_Heap-empty_present"><span class="command">lemma</span></span> empty_present<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Array.present <span class="free">h'</span> <span class="free">x</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"execute mem_empty <span class="free">heap</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">h'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> mem_empty_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> Array.present_alloc fst_conv snd_conv<span class="main">)</span>

<span class="keyword1" id="Memory_Heap-empty_present'"><span class="command">lemma</span></span> empty_present'<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Array.present <span class="free">h'</span> <span class="free">a</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"execute mem_empty <span class="free">heap</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">h'</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"Array.present <span class="free">heap</span> <span class="free">a</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> mem_empty_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span> Array.present_def Array.alloc_def Array.set_def Let_def<span class="main">)</span>

<span class="keyword1" id="Memory_Heap-init_state_present2"><span class="command">lemma</span></span> init_state_present2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span>
    <span class="quoted"><span class="quoted">"execute <span class="main">(</span>init_state <span class="free">k1</span> <span class="free">k2</span><span class="main">)</span> <span class="free">heap</span> <span class="main">=</span> Some <span class="main">(</span><span class="main">(</span><span class="free">k_ref1</span><span class="main">,</span> <span class="free">k_ref2</span><span class="main">,</span> <span class="free">m_ref1</span><span class="main">,</span> <span class="free">m_ref2</span><span class="main">)</span><span class="main">,</span> <span class="free">heap'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>
    <span class="quoted"><span class="quoted">"Array.present <span class="free">heap'</span> <span class="main">(</span>Ref.get <span class="free">heap'</span> <span class="free">m_ref1</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"Array.present <span class="free">heap'</span> <span class="main">(</span>Ref.get <span class="free">heap'</span> <span class="free">m_ref2</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> init_state_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 4 3
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span> init_state_inner_alloc <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> execute_bind_success'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> success_empty<span class="main"><span class="main">]</span></span>
        <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> inite_state_inner_present' empty_present empty_present'
     <span class="main">)</span>

<span class="keyword1" id="Memory_Heap-init_state_neq"><span class="command">lemma</span></span> init_state_neq<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span>
    <span class="quoted"><span class="quoted">"execute <span class="main">(</span>init_state <span class="free">k1</span> <span class="free">k2</span><span class="main">)</span> <span class="free">heap</span> <span class="main">=</span> Some <span class="main">(</span><span class="main">(</span><span class="free">k_ref1</span><span class="main">,</span> <span class="free">k_ref2</span><span class="main">,</span> <span class="free">m_ref1</span><span class="main">,</span> <span class="free">m_ref2</span><span class="main">)</span><span class="main">,</span> <span class="free">heap'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>
    <span class="quoted"><span class="quoted">"Ref.get <span class="free">heap'</span> <span class="free">m_ref1</span> <span class="main">=!!=</span> Ref.get <span class="free">heap'</span> <span class="free">m_ref2</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> init_state_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 4 3
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span> init_state_inner_alloc <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> execute_bind_success'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> success_empty<span class="main"><span class="main">]</span></span>
        <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> inite_state_inner_present' empty_present empty_present'
     <span class="main">)</span>
    <span class="main">(</span><span class="operator">metis</span> empty_present execute_new fst_conv mem_empty_def option.inject present_alloc_noteq<span class="main">)</span>

<span class="keyword1" id="Memory_Heap-present_alloc_get"><span class="command">lemma</span></span> present_alloc_get<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Array.get <span class="free">heap'</span> <span class="free">a</span> <span class="main">=</span> Array.get <span class="free">heap</span> <span class="free">a</span>"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"Array.alloc <span class="free">xs</span> <span class="free">heap</span> <span class="main">=</span> <span class="main">(</span><span class="free">a'</span><span class="main">,</span> <span class="free">heap'</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"Array.present <span class="free">heap</span> <span class="free">a</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Array.alloc_def Array.present_def Array.get_def Let_def Array.set_def<span class="main">)</span>

<span class="keyword1" id="Memory_Heap-init_state_length"><span class="command">lemma</span></span> init_state_length<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span>
    <span class="quoted"><span class="quoted">"execute <span class="main">(</span>init_state <span class="free">k1</span> <span class="free">k2</span><span class="main">)</span> <span class="free">heap</span> <span class="main">=</span> Some <span class="main">(</span><span class="main">(</span><span class="free">k_ref1</span><span class="main">,</span> <span class="free">k_ref2</span><span class="main">,</span> <span class="free">m_ref1</span><span class="main">,</span> <span class="free">m_ref2</span><span class="main">)</span><span class="main">,</span> <span class="free">heap'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>
    <span class="quoted"><span class="quoted">"Array.length <span class="free">heap'</span> <span class="main">(</span>Ref.get <span class="free">heap'</span> <span class="free">m_ref1</span><span class="main">)</span> <span class="main">=</span> <span class="free">size</span>"</span></span>
    <span class="quoted"><span class="quoted">"Array.length <span class="free">heap'</span> <span class="main">(</span>Ref.get <span class="free">heap'</span> <span class="free">m_ref2</span><span class="main">)</span> <span class="main">=</span> <span class="free">size</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> init_state_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span>
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span> init_state_inner_alloc <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> execute_bind_success'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> success_empty<span class="main"><span class="main">]</span></span>
        <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> inite_state_inner_present' empty_present empty_present'
     <span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span>
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span> init_state_inner_def alloc_pair_def mem_empty_def Array.length_def
      <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> execute_bind_success'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> success_refI<span class="main"><span class="main">]</span></span>
     <span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span>
      Array.alloc_def Array.get_set_eq Array.present_alloc array_get_alloc fst_conv length_replicate
      present_alloc_get snd_conv
     <span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">key1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k1</span> <span class="main">::</span> heap<span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">key2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'k2</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">m_ref1</span> <span class="free">m_ref2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span> <span class="main">::</span> heap<span class="main">)</span> option array ref"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">k_ref1</span> <span class="free">k_ref2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k1</span> <span class="main">::</span> heap<span class="main">)</span> ref"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We assume that look-ups happen on the older row, so this is biased towards the second entry.›</span></span>
<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lookup_pair</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">let</span> <span class="bound">k'</span> <span class="main">=</span> <span class="free">key1</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">;</span>
    <span class="bound">k2</span> <span class="main">←</span> <span class="main">!</span><span class="free">k_ref2</span><span class="main">;</span>
    <span class="keyword1">if</span> <span class="bound">k'</span> <span class="main">=</span> <span class="bound">k2</span> <span class="keyword1">then</span>
      <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">m2</span> <span class="main">←</span> <span class="main">!</span><span class="free">m_ref2</span><span class="main">;</span>
        mem_lookup <span class="bound">m2</span> <span class="main">(</span><span class="free">key2</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">)</span>
      <span class="main">}</span>
    <span class="keyword1">else</span>
      <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">k1</span> <span class="main">←</span> <span class="main">!</span><span class="free">k_ref1</span><span class="main">;</span>
      <span class="keyword1">if</span> <span class="bound">k'</span> <span class="main">=</span> <span class="bound">k1</span> <span class="keyword1">then</span>
        <span class="keyword1">do</span> <span class="main">{</span>
          <span class="bound">m1</span> <span class="main">←</span> <span class="main">!</span><span class="free">m_ref1</span><span class="main">;</span>
          mem_lookup <span class="bound">m1</span> <span class="main">(</span><span class="free">key2</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">)</span>
        <span class="main">}</span>
      <span class="keyword1">else</span>
        return None
    <span class="main">}</span>
  <span class="main">}</span>
   "</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We assume that updates happen on the newer row, so this is biased towards the first entry.›</span></span>
<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">update_pair</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">let</span> <span class="bound">k'</span> <span class="main">=</span> <span class="free">key1</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">;</span>
      <span class="bound">k1</span> <span class="main">←</span> <span class="main">!</span><span class="free">k_ref1</span><span class="main">;</span>
      <span class="keyword1">if</span> <span class="bound">k'</span> <span class="main">=</span> <span class="bound">k1</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">m</span> <span class="main">←</span> <span class="main">!</span><span class="free">m_ref1</span><span class="main">;</span>
        mem_update <span class="bound">m</span> <span class="main">(</span><span class="free">key2</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span>
      <span class="main">}</span>
      <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">k2</span> <span class="main">←</span> <span class="main">!</span><span class="free">k_ref2</span><span class="main">;</span>
        <span class="keyword1">if</span> <span class="bound">k'</span> <span class="main">=</span> <span class="bound">k2</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="bound">m</span> <span class="main">←</span> <span class="main">!</span><span class="free">m_ref2</span><span class="main">;</span>
          mem_update <span class="bound">m</span> <span class="main">(</span><span class="free">key2</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span>
        <span class="main">}</span>
        <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="keyword1">do</span> <span class="main">{</span>
            <span class="bound">k1</span> <span class="main">←</span> <span class="main">!</span><span class="free">k_ref1</span><span class="main">;</span>
            <span class="bound">m</span> <span class="main">←</span> mem_empty<span class="main">;</span>
            <span class="bound">m1</span> <span class="main">←</span> <span class="main">!</span><span class="free">m_ref1</span><span class="main">;</span>
            <span class="free">k_ref2</span> <span class="main">:=</span> <span class="bound">k1</span><span class="main">;</span>
            <span class="free">k_ref1</span> <span class="main">:=</span> <span class="bound">k'</span><span class="main">;</span>
            <span class="free">m_ref2</span> <span class="main">:=</span> <span class="bound">m1</span><span class="main">;</span>
            <span class="free">m_ref1</span> <span class="main">:=</span> <span class="bound">m</span>
          <span class="main">}</span>
        <span class="main">;</span>
        <span class="bound">m</span> <span class="main">←</span> <span class="main">!</span><span class="free">m_ref1</span><span class="main">;</span>
        mem_update <span class="bound">m</span> <span class="main">(</span><span class="free">key2</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span>
      <span class="main">}</span>
    <span class="main">}</span>
   <span class="main">}</span>
   "</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">inv_pair_weak</span> <span class="free"><span class="bound"><span class="entity">heap</span></span></span> <span class="main">=</span> <span class="main">(</span>
    <span class="keyword1">let</span>
      <span class="bound">m1</span> <span class="main">=</span> Ref.get <span class="free"><span class="bound"><span class="entity">heap</span></span></span> <span class="free">m_ref1</span><span class="main">;</span>
      <span class="bound">m2</span> <span class="main">=</span> Ref.get <span class="free"><span class="bound"><span class="entity">heap</span></span></span> <span class="free">m_ref2</span>
    <span class="keyword1">in</span> Array.length <span class="free"><span class="bound"><span class="entity">heap</span></span></span> <span class="bound">m1</span> <span class="main">=</span> <span class="free">size</span> <span class="main">∧</span> Array.length <span class="free"><span class="bound"><span class="entity">heap</span></span></span> <span class="bound">m2</span> <span class="main">=</span> <span class="free">size</span>
      <span class="main">∧</span> Ref.present <span class="free"><span class="bound"><span class="entity">heap</span></span></span> <span class="free">k_ref1</span> <span class="main">∧</span> Ref.present <span class="free"><span class="bound"><span class="entity">heap</span></span></span> <span class="free">k_ref2</span>
      <span class="main">∧</span> Ref.present <span class="free"><span class="bound"><span class="entity">heap</span></span></span> <span class="free">m_ref1</span> <span class="main">∧</span> Ref.present <span class="free"><span class="bound"><span class="entity">heap</span></span></span> <span class="free">m_ref2</span>
      <span class="main">∧</span> Array.present <span class="free"><span class="bound"><span class="entity">heap</span></span></span> <span class="bound">m1</span> <span class="main">∧</span> Array.present <span class="free"><span class="bound"><span class="entity">heap</span></span></span> <span class="bound">m2</span>
      <span class="main">∧</span> <span class="bound">m1</span> <span class="main">=!!=</span> <span class="bound">m2</span>
  <span class="main">)</span>"</span></span>

<span class="comment1">(* TODO: Remove? *)</span>
<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">inv_pair</span> <span class="free"><span class="bound"><span class="entity">heap</span></span></span> <span class="main">≡</span> inv_pair_weak <span class="free"><span class="bound"><span class="entity">heap</span></span></span> <span class="main">∧</span> inv_distinct <span class="free">k_ref1</span> <span class="free">k_ref2</span> <span class="free">m_ref1</span> <span class="free">m_ref2</span>"</span></span>

<span class="keyword1" id="Memory_Heap-init_state_inv"><span class="command">lemma</span></span> init_state_inv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span>
    <span class="quoted"><span class="quoted">"execute <span class="main">(</span>init_state <span class="free">k1</span> <span class="free">k2</span><span class="main">)</span> <span class="free">heap</span> <span class="main">=</span> Some <span class="main">(</span><span class="main">(</span><span class="free">k_ref1</span><span class="main">,</span> <span class="free">k_ref2</span><span class="main">,</span> <span class="free">m_ref1</span><span class="main">,</span> <span class="free">m_ref2</span><span class="main">)</span><span class="main">,</span> <span class="free">heap'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"inv_pair_weak <span class="free">heap'</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> inv_pair_weak_def Let_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span>
      init_state_present init_state_present2 init_state_neq init_state_length
      init_state_distinct
     <span class="main">)</span>

<span class="keyword1" id="Memory_Heap-inv_pair_lengthD1"><span class="command">lemma</span></span> inv_pair_lengthD1<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Array.length <span class="free">heap</span> <span class="main">(</span>Ref.get <span class="free">heap</span> <span class="free">m_ref1</span><span class="main">)</span> <span class="main">=</span> <span class="free">size</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"inv_pair_weak <span class="free">heap</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> inv_pair_weak_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>

<span class="keyword1" id="Memory_Heap-inv_pair_lengthD2"><span class="command">lemma</span></span> inv_pair_lengthD2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Array.length <span class="free">heap</span> <span class="main">(</span>Ref.get <span class="free">heap</span> <span class="free">m_ref2</span><span class="main">)</span> <span class="main">=</span> <span class="free">size</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"inv_pair_weak <span class="free">heap</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> inv_pair_weak_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>

<span class="keyword1" id="Memory_Heap-inv_pair_presentD"><span class="command">lemma</span></span> inv_pair_presentD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Array.present <span class="free">heap</span> <span class="main">(</span>Ref.get <span class="free">heap</span> <span class="free">m_ref1</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"Array.present <span class="free">heap</span> <span class="main">(</span>Ref.get <span class="free">heap</span> <span class="free">m_ref2</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"inv_pair_weak <span class="free">heap</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> inv_pair_weak_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>

<span class="keyword1" id="Memory_Heap-inv_pair_presentD2"><span class="command">lemma</span></span> inv_pair_presentD2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Ref.present <span class="free">heap</span> <span class="free">m_ref1</span>"</span></span> <span class="quoted"><span class="quoted">"Ref.present <span class="free">heap</span> <span class="free">m_ref2</span>"</span></span>
  <span class="quoted"><span class="quoted">"Ref.present <span class="free">heap</span> <span class="free">k_ref1</span>"</span></span> <span class="quoted"><span class="quoted">"Ref.present <span class="free">heap</span> <span class="free">k_ref2</span>"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"inv_pair_weak <span class="free">heap</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> inv_pair_weak_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>

<span class="keyword1" id="Memory_Heap-inv_pair_not_eqD"><span class="command">lemma</span></span> inv_pair_not_eqD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Ref.get <span class="free">heap</span> <span class="free">m_ref1</span> <span class="main">=!!=</span> Ref.get <span class="free">heap</span> <span class="free">m_ref2</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"inv_pair_weak <span class="free">heap</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> inv_pair_weak_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">lookup1</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">≡</span> state_of <span class="main">(</span><span class="keyword1">do</span> <span class="main">{</span><span class="bound">m</span> <span class="main">←</span> <span class="main">!</span><span class="free">m_ref1</span><span class="main">;</span> mem_lookup <span class="bound">m</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">lookup2</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">≡</span> state_of <span class="main">(</span><span class="keyword1">do</span> <span class="main">{</span><span class="bound">m</span> <span class="main">←</span> <span class="main">!</span><span class="free">m_ref2</span><span class="main">;</span> mem_lookup <span class="bound">m</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">update1</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span> state_of <span class="main">(</span><span class="keyword1">do</span> <span class="main">{</span><span class="bound">m</span> <span class="main">←</span> <span class="main">!</span><span class="free">m_ref1</span><span class="main">;</span> mem_update <span class="bound">m</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">update2</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span> state_of <span class="main">(</span><span class="keyword1">do</span> <span class="main">{</span><span class="bound">m</span> <span class="main">←</span> <span class="main">!</span><span class="free">m_ref2</span><span class="main">;</span> mem_update <span class="bound">m</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">move12</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">≡</span> state_of <span class="main">(</span><span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">k1</span> <span class="main">←</span> <span class="main">!</span><span class="free">k_ref1</span><span class="main">;</span>
    <span class="bound">m</span> <span class="main">←</span> mem_empty<span class="main">;</span>
    <span class="bound">m1</span> <span class="main">←</span> <span class="main">!</span><span class="free">m_ref1</span><span class="main">;</span>
    <span class="free">k_ref2</span> <span class="main">:=</span> <span class="bound">k1</span><span class="main">;</span>
    <span class="free">k_ref1</span> <span class="main">:=</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">;</span>
    <span class="free">m_ref2</span> <span class="main">:=</span> <span class="bound">m1</span><span class="main">;</span>
    <span class="free">m_ref1</span> <span class="main">:=</span> <span class="bound">m</span>
  <span class="main">}</span><span class="main">)</span>
  "</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">get_k1</span> <span class="main">≡</span> state_of <span class="main">(</span><span class="main">!</span><span class="free">k_ref1</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">get_k2</span> <span class="main">≡</span> state_of <span class="main">(</span><span class="main">!</span><span class="free">k_ref2</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Memory_Heap-run_state_state_of"><span class="command">lemma</span></span> run_state_state_of<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"State_Monad.run_state <span class="main">(</span>state_of <span class="free">p</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span> the <span class="main">(</span>execute <span class="free">p</span> <span class="free">m</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> state_of_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">assumes</span></span> injective<span class="main">:</span> <span class="quoted"><span class="quoted">"injective <span class="free">size</span> <span class="free">to_index</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> inv_distinct<span class="main">:</span> <span class="quoted"><span class="quoted">"inv_distinct <span class="free">k_ref1</span> <span class="free">k_ref2</span> <span class="free">m_ref1</span> <span class="free">m_ref2</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Memory_Heap-disjoint"><span class="command">lemma</span></span> disjoint<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">m_ref1</span> <span class="main">=!=</span> <span class="free">m_ref2</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">m_ref1</span> <span class="main">=!=</span> <span class="free">k_ref1</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">m_ref1</span> <span class="main">=!=</span> <span class="free">k_ref2</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">m_ref2</span> <span class="main">=!=</span> <span class="free">k_ref1</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">m_ref2</span> <span class="main">=!=</span> <span class="free">k_ref2</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">k_ref1</span> <span class="main">=!=</span> <span class="free">k_ref2</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> inv_distinct <span class="keyword1"><span class="command">unfolding</span></span> inv_distinct_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> disjoint<span class="main">[</span><span class="operator">THEN</span> noteq_sym<span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Array.get <span class="main">(</span>snd <span class="main">(</span>Array.alloc <span class="free">xs</span> <span class="free">heap</span><span class="main">)</span><span class="main">)</span> <span class="free">a</span> <span class="main">=</span> Array.get <span class="free">heap</span> <span class="free">a</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"Array.present <span class="free">heap</span> <span class="free">a</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> Array.alloc_def Array.present_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> Array.get_set_neq<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Array.noteq_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> Array.get_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Ref.get <span class="main">(</span>snd <span class="main">(</span>Array.alloc <span class="free">xs</span> <span class="free">heap</span><span class="main">)</span><span class="main">)</span> <span class="free">r</span> <span class="main">=</span> Ref.get <span class="free">heap</span> <span class="free">r</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"Ref.present <span class="free">heap</span> <span class="free">r</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> Array.alloc_def Ref.present_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def Ref.get_def Array.set_def<span class="main">)</span>

<span class="keyword1" id="Memory_Heap-alloc_present"><span class="command">lemma</span></span> alloc_present<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Array.present <span class="main">(</span>snd <span class="main">(</span>Array.alloc <span class="free">xs</span> <span class="free">heap</span><span class="main">)</span><span class="main">)</span> <span class="free">a</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"Array.present <span class="free">heap</span> <span class="free">a</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> Array.present_def Array.alloc_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def Array.set_def<span class="main">)</span>

<span class="keyword1" id="Memory_Heap-alloc_present'"><span class="command">lemma</span></span> alloc_present'<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Ref.present <span class="main">(</span>snd <span class="main">(</span>Array.alloc <span class="free">xs</span> <span class="free">heap</span><span class="main">)</span><span class="main">)</span> <span class="free">r</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"Ref.present <span class="free">heap</span> <span class="free">r</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> Ref.present_def Array.alloc_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def Array.set_def<span class="main">)</span>

<span class="keyword1" id="Memory_Heap-length_get_upd"><span class="command">lemma</span></span> length_get_upd<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"length <span class="main">(</span>Array.get <span class="main">(</span>Array.update <span class="free">a</span> <span class="free">i</span> <span class="free">x</span> <span class="free">heap</span><span class="main">)</span> <span class="free">r</span><span class="main">)</span> <span class="main">=</span> length <span class="main">(</span>Array.get <span class="free">heap</span> <span class="free">r</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Array.get_def Array.update_def Array.set_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">method</span></span> solve1 <span class="main">=</span>
  <span class="main">(</span><span class="operator">frule</span> inv_pair_lengthD1<span class="main"><span class="keyword3">,</span></span> <span class="operator">frule</span> inv_pair_lengthD2<span class="main"><span class="keyword3">,</span></span> <span class="operator">frule</span> inv_pair_not_eqD<span class="main">)</span><span class="main"><span class="keyword3">?</span></span><span class="main"><span class="keyword3">,</span></span>
  <span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Array.noteq_sym

<span class="keyword1"><span class="command">interpretation</span></span> pair<span class="main">:</span> pair_mem <span class="quoted">lookup1</span> <span class="quoted">lookup2</span> <span class="quoted">update1</span> <span class="quoted">update2</span> <span class="quoted">move12</span> <span class="quoted">get_k1</span> <span class="quoted">get_k2</span> <span class="quoted">inv_pair_weak</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span>
    mem_empty_def state_mem_defs.map_of_def map_le_def
    move12_def update1_def update2_def lookup1_def lookup2_def get_k1_def get_k2_def
    mem_update_def mem_lookup_def
    execute_bind_success<span class="main">[</span><span class="operator">OF</span> success_newI<span class="main">]</span> <span class="dynamic"><span class="dynamic">execute_simps</span></span> Let_def Array.get_alloc length_def
    inv_pair_presentD inv_pair_presentD2
    Memory_Heap.lookup1_def Memory_Heap.lookup2_def Memory_Heap.mem_lookup_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
                      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">solve1</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> lift_pI<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> inv_pair_weak_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>
        <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> alloc_present alloc_present'
        <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> present_alloc_noteq<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> Array.noteq_sym<span class="main"><span class="main">]</span></span>
        <span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
                     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> lift_pI<span class="main"><span class="keyword3">,</span></span> <span class="operator">unfold</span> inv_pair_weak_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
                 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">solve1</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">using</span></span> injective<span class="main">[</span><span class="operator">unfolded</span> injective_def<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">solve1</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> nth_list_update_neq<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">using</span></span> injective<span class="main">[</span><span class="operator">unfolded</span> injective_def<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">solve1</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> nth_list_update_neq<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">solve1</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemmas</span></span> mem_correct_pair <span class="main">=</span> pair.mem_correct_pair

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mem_lookup1</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span><span class="bound">m</span> <span class="main">←</span> <span class="main">!</span><span class="free">m_ref1</span><span class="main">;</span> mem_lookup <span class="bound">m</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mem_lookup2</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span><span class="bound">m</span> <span class="main">←</span> <span class="main">!</span><span class="free">m_ref2</span><span class="main">;</span> mem_lookup <span class="bound">m</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">get_k1'</span> <span class="main">≡</span> <span class="main">!</span><span class="free">k_ref1</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">get_k2'</span> <span class="main">≡</span> <span class="main">!</span><span class="free">k_ref2</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">update1'</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span><span class="bound">m</span> <span class="main">←</span> <span class="main">!</span><span class="free">m_ref1</span><span class="main">;</span> mem_update <span class="bound">m</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">update2'</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span><span class="bound">m</span> <span class="main">←</span> <span class="main">!</span><span class="free">m_ref2</span><span class="main">;</span> mem_update <span class="bound">m</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">move12'</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">k1</span> <span class="main">←</span> <span class="main">!</span><span class="free">k_ref1</span><span class="main">;</span>
    <span class="bound">m</span> <span class="main">←</span> mem_empty<span class="main">;</span>
    <span class="bound">m1</span> <span class="main">←</span> <span class="main">!</span><span class="free">m_ref1</span><span class="main">;</span>
    <span class="free">k_ref2</span> <span class="main">:=</span> <span class="bound">k1</span><span class="main">;</span>
    <span class="free">k_ref1</span> <span class="main">:=</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">;</span>
    <span class="free">m_ref2</span> <span class="main">:=</span> <span class="bound">m1</span><span class="main">;</span>
    <span class="free">m_ref1</span> <span class="main">:=</span> <span class="bound">m</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> heap_mem_defs <span class="quoted">inv_pair_weak</span> <span class="quoted">lookup_pair</span> <span class="quoted">update_pair</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1" id="Memory_Heap-rel_state_ofI"><span class="command">lemma</span></span> rel_state_ofI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"rel_state <span class="main">(=)</span> <span class="main">(</span>state_of <span class="free">m</span><span class="main">)</span> <span class="free">m</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">heap</span><span class="main">.</span> inv_pair_weak <span class="bound">heap</span> <span class="main">⟶</span> success <span class="free">m</span> <span class="bound">heap</span>"</span></span>
  <span class="quoted"><span class="quoted">"lift_p inv_pair_weak <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> rel_state_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> lift_p_P'' <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> success_def<span class="main">)</span>

<span class="keyword1" id="Memory_Heap-inv_pair_iff"><span class="command">lemma</span></span> inv_pair_iff<span class="main">:</span>
  <span class="quoted"><span class="quoted">"inv_pair_weak <span class="main">=</span> inv_pair"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> inv_pair_def <span class="keyword1"><span class="command">using</span></span> inv_distinct <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Memory_Heap-lift_p_inv_pairI"><span class="command">lemma</span></span> lift_p_inv_pairI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"State_Heap.lift_p inv_pair <span class="free">m</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"State_Heap.lift_p inv_pair_weak <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> inv_pair_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Memory_Heap-lift_p_success"><span class="command">lemma</span></span> lift_p_success<span class="main">:</span>
  <span class="quoted"><span class="quoted">"State_Heap.lift_p inv_pair_weak <span class="free">m</span>"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"DP_CRelVS.lift_p inv_pair_weak <span class="main">(</span>state_of <span class="free">m</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">heap</span><span class="main">.</span> inv_pair_weak <span class="bound">heap</span> <span class="main">⟶</span> success <span class="free">m</span> <span class="bound">heap</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that
  <span class="keyword1"><span class="command">unfolding</span></span> lift_p_def DP_CRelVS.lift_p_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> success_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1" id="Memory_Heap-rel_state_ofI2"><span class="command">lemma</span></span> rel_state_ofI2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"rel_state <span class="main">(=)</span> <span class="main">(</span>state_of <span class="free">m</span><span class="main">)</span> <span class="free">m</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">heap</span><span class="main">.</span> inv_pair_weak <span class="bound">heap</span> <span class="main">⟶</span> success <span class="free">m</span> <span class="bound">heap</span>"</span></span>
  <span class="quoted"><span class="quoted">"DP_CRelVS.lift_p inv_pair_weak <span class="main">(</span>state_of <span class="free">m</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rel_state_ofI lift_p_success<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> rel_state <span class="main">(=)</span><span class="main">)</span> move12 move12'"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> move12_def move12'_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> rel_funI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> rel_state_ofI2<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span>
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mem_empty_def inv_pair_lengthD1 <span class="dynamic"><span class="dynamic">execute_simps</span></span> Let_def
        <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">success_intros</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> success_bind_I
       <span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">using</span></span> pair.move12_inv <span class="keyword1"><span class="command">unfolding</span></span> move12_def <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> rel_state <span class="main">(</span>rel_option <span class="main">(=)</span><span class="main">)</span><span class="main">)</span> lookup1 mem_lookup1"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> lookup1_def mem_lookup1_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> rel_funI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> option.rel_eq<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> rel_state_ofI2<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 4 4
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mem_lookup_def inv_pair_lengthD1 <span class="dynamic"><span class="dynamic">execute_simps</span></span> Let_def
        <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> success_bind_executeI success_returnI Array.success_nthI
       <span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">using</span></span> pair.lookup_inv<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> lookup1_def <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> rel_state <span class="main">(</span>rel_option <span class="main">(=)</span><span class="main">)</span><span class="main">)</span> lookup2 mem_lookup2"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> lookup2_def mem_lookup2_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> rel_funI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> option.rel_eq<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> rel_state_ofI2<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 4 3
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mem_lookup_def inv_pair_lengthD2 <span class="dynamic"><span class="dynamic">execute_simps</span></span> Let_def
        <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">success_intros</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> success_bind_I
       <span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">using</span></span> pair.lookup_inv<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> lookup2_def <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"rel_state <span class="main">(=)</span> get_k1 get_k1'"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> get_k1_def get_k1'_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> rel_state_ofI2<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> success_lookupI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> get_k1_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> pair.get_state<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> lift_pI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"rel_state <span class="main">(=)</span> get_k2 get_k2'"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> get_k2_def get_k2'_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> rel_state_ofI2<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> success_lookupI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> get_k2_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> pair.get_state<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> lift_pI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> rel_state <span class="main">(=)</span><span class="main">)</span> update1 update1'"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> update1_def update1'_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> rel_funI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> rel_state_ofI2<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 4 3
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mem_update_def inv_pair_lengthD1 <span class="dynamic"><span class="dynamic">execute_simps</span></span> Let_def
        <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">success_intros</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> success_bind_I
       <span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">using</span></span> pair.update_inv<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> update1_def <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> rel_state <span class="main">(=)</span><span class="main">)</span> update2 update2'"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> update2_def update2'_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> rel_funI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> rel_state_ofI2<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 4 3
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mem_update_def inv_pair_lengthD2 <span class="dynamic"><span class="dynamic">execute_simps</span></span> Let_def
        <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">success_intros</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> success_bind_I
       <span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">using</span></span> pair.update_inv<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> update2_def <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> rel_state <span class="main">(</span>rel_option <span class="main">(=)</span><span class="main">)</span><span class="main">)</span> lookup1 mem_lookup1"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> lookup1_def mem_lookup1_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> rel_funI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> option.rel_eq<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> rel_state_ofI2<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 4 3
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mem_lookup_def inv_pair_lengthD1 <span class="dynamic"><span class="dynamic">execute_simps</span></span> Let_def
        <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">success_intros</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> success_bind_I
       <span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">using</span></span> pair.lookup_inv<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> lookup1_def <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Memory_Heap-rel_state_lookup"><span class="command">lemma</span></span> rel_state_lookup<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> rel_state <span class="main">(=)</span><span class="main">)</span> pair.lookup_pair lookup_pair"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> pair.lookup_pair_def lookup_pair_def
  <span class="keyword1"><span class="command">unfolding</span></span>
    mem_lookup1_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> mem_lookup2_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
    get_k2_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> get_k2'_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
    get_k1_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> get_k1'_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Memory_Heap-rel_state_update"><span class="command">lemma</span></span> rel_state_update<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> rel_state <span class="main">(=)</span><span class="main">)</span> pair.update_pair update_pair"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> pair.update_pair_def update_pair_def
  <span class="keyword1"><span class="command">unfolding</span></span> move12'_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
  <span class="keyword1"><span class="command">unfolding</span></span>
    update1'_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> update2'_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
    get_k2_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> get_k2'_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
    get_k1_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> get_k1'_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1"><span class="command">interpretation</span></span> mem<span class="main">:</span> heap_mem_defs <span class="quoted">pair.inv_pair</span> <span class="quoted">lookup_pair</span> <span class="quoted">update_pair</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1" id="Memory_Heap-inv_pairD"><span class="command">lemma</span></span> inv_pairD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"inv_pair_weak <span class="free">heap</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"pair.inv_pair <span class="free">heap</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> pair.inv_pair_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>

<span class="keyword1" id="Memory_Heap-mem_rel_state_ofI"><span class="command">lemma</span></span> mem_rel_state_ofI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"mem.rel_state <span class="main">(=)</span> <span class="free">m'</span> <span class="free">m</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span>
  <span class="quoted"><span class="quoted">"rel_state <span class="main">(=)</span> <span class="free">m'</span> <span class="free">m</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">heap</span><span class="main">.</span> pair.inv_pair <span class="bound">heap</span> <span class="main">⟹</span>
    <span class="main">(</span><span class="keyword1">case</span> State_Monad.run_state <span class="free">m'</span> <span class="bound">heap</span> <span class="keyword1">of</span> <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">heap</span><span class="main">)</span> <span class="main">⇒</span> inv_pair_weak <span class="bound">heap</span> <span class="main">⟶</span> pair.inv_pair <span class="bound">heap</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> mem.rel_state_intro<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> heap v heap'
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> rel_state_elim<span class="main"><span class="main">[</span></span><span class="operator">OF</span> that<span class="main"><span class="main"><span class="main">(</span></span></span>1<span class="main"><span class="main"><span class="main">)</span></span></span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> inv_pairD<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> prems <span class="keyword2"><span class="keyword">for</span></span> heap v heap'
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">from</span></span> prems that<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"inv_pair_weak <span class="skolem">heap'</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> rel_state_elim <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> inv_pairD<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> prems <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> that<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Memory_Heap-mem_rel_state_ofI'"><span class="command">lemma</span></span> mem_rel_state_ofI'<span class="main">:</span>
  <span class="quoted"><span class="quoted">"mem.rel_state <span class="main">(=)</span> <span class="free">m'</span> <span class="free">m</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span>
  <span class="quoted"><span class="quoted">"rel_state <span class="main">(=)</span> <span class="free">m'</span> <span class="free">m</span>"</span></span>
  <span class="quoted"><span class="quoted">"DP_CRelVS.lift_p pair.inv_pair <span class="free">m'</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> DP_CRelVS.lift_p_P <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> mem_rel_state_ofI<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> keys<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">k</span> <span class="bound">k'</span><span class="main">.</span> <span class="free">key1</span> <span class="bound">k</span> <span class="main">=</span> <span class="free">key1</span> <span class="bound">k'</span> <span class="main">∧</span> <span class="free">key2</span> <span class="bound">k</span> <span class="main">=</span> <span class="free">key2</span> <span class="bound">k'</span> <span class="main">⟶</span> <span class="bound">k</span> <span class="main">=</span> <span class="bound">k'</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> mem_correct <span class="quoted">pair.lookup_pair</span> <span class="quoted">pair.update_pair</span> <span class="quoted">pair.inv_pair</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> mem_correct_pair<span class="main"><span class="main">[</span></span><span class="operator">OF</span> keys<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Memory_Heap-rel_state_lookup'"><span class="command">lemma</span></span> rel_state_lookup'<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> mem.rel_state <span class="main">(=)</span><span class="main">)</span> pair.lookup_pair lookup_pair"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> rel_funI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> mem_rel_state_ofI'<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> rel_state_lookup <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> rel_funD<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> refl<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> lookup_inv<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Memory_Heap-rel_state_update'"><span class="command">lemma</span></span> rel_state_update'<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> mem.rel_state <span class="main">(=)</span><span class="main">)</span> pair.update_pair update_pair"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> rel_funI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> mem_rel_state_ofI'<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> x y a b
    <span class="keyword1"><span class="command">using</span></span> rel_state_update <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> rel_funD<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> update_inv<span class="main">)</span>

<span class="keyword1"><span class="command">interpretation</span></span> heap_correct <span class="quoted">pair.inv_pair</span> <span class="quoted">update_pair</span> <span class="quoted">lookup_pair</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> mem.mem_correct_heap_correct<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ rel_state_lookup' rel_state_update'<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">standard</span>

<span class="keyword1"><span class="command">lemmas</span></span> heap_correct_pairI <span class="main">=</span> heap_correct_axioms 

<span class="comment1">(* TODO: Generalize *)</span>
<span class="keyword1" id="Memory_Heap-mem_rel_state_resultD"><span class="command">lemma</span></span> mem_rel_state_resultD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"result_of <span class="free">m</span> <span class="free">heap</span> <span class="main">=</span> fst <span class="main">(</span>run_state <span class="free">m'</span> <span class="free">heap</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"mem.rel_state <span class="main">(=)</span> <span class="free">m'</span> <span class="free">m</span>"</span></span> <span class="quoted"><span class="quoted">"pair.inv_pair <span class="free">heap</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> mem.rel_state_elim option.sel that<span class="main">)</span>

<span class="keyword1" id="Memory_Heap-map_of_heap_eq"><span class="command">lemma</span></span> map_of_heap_eq<span class="main">:</span>
  <span class="quoted"><span class="quoted">"mem.map_of_heap <span class="free">heap</span> <span class="main">=</span> pair.pair.map_of <span class="free">heap</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"pair.inv_pair <span class="free">heap</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> mem.map_of_heap_def pair.pair.map_of_def
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mem_rel_state_resultD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> rel_state_lookup'<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">THEN</span> rel_funD<span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">k1</span> <span class="free">k2</span> <span class="free">heap</span> <span class="free">heap'</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> init<span class="main">:</span> <span class="quoted"><span class="quoted">"execute <span class="main">(</span>init_state <span class="free">k1</span> <span class="free">k2</span><span class="main">)</span> <span class="free">heap</span> <span class="main">=</span> Some <span class="main">(</span><span class="main">(</span><span class="free">k_ref1</span><span class="main">,</span> <span class="free">k_ref2</span><span class="main">,</span> <span class="free">m_ref1</span><span class="main">,</span> <span class="free">m_ref2</span><span class="main">)</span><span class="main">,</span> <span class="free">heap'</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Memory_Heap-init_state_empty1"><span class="command">lemma</span></span> init_state_empty1<span class="main">:</span>
  <span class="quoted"><span class="quoted">"pair.mem1.map_of <span class="free">heap'</span> <span class="free">k</span> <span class="main">=</span> None"</span></span>
  <span class="keyword1"><span class="command">using</span></span> init
  <span class="keyword1"><span class="command">unfolding</span></span> pair.mem1.map_of_def lookup1_def mem_lookup_def init_state_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span>
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> init_state_inner_nth init_state_inner_alloc<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span> Let_def
        <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> execute_bind_success'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> success_empty<span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">metis</span>
        Array.present_alloc Memory_Heap.length_mem_empty execute_new execute_nth<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> fst_conv
        length_def mem_empty_def nth_mem_empty option.sel present_alloc_get snd_conv
     <span class="main">)</span>

<span class="keyword1" id="Memory_Heap-init_state_empty2"><span class="command">lemma</span></span> init_state_empty2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"pair.mem2.map_of <span class="free">heap'</span> <span class="free">k</span> <span class="main">=</span> None"</span></span>
  <span class="keyword1"><span class="command">using</span></span> init
  <span class="keyword1"><span class="command">unfolding</span></span> pair.mem2.map_of_def lookup2_def mem_lookup_def init_state_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span>
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span> init_state_inner_nth init_state_inner_alloc<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span> Let_def
        <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> execute_bind_success'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> success_empty<span class="main"><span class="main">]</span></span>
     <span class="main">)</span>
     <span class="main">(</span><span class="operator">metis</span> fst_conv nth_mem_empty option.sel snd_conv<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> init_state_k1<span class="main">:</span> <span class="quoted"><span class="quoted">"result_of <span class="main">(</span><span class="main">!</span><span class="free">k_ref1</span><span class="main">)</span> <span class="free">heap'</span> <span class="main">=</span> <span class="free">k1</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> init_state_k2<span class="main">:</span> <span class="quoted"><span class="quoted">"result_of <span class="main">(</span><span class="main">!</span><span class="free">k_ref2</span><span class="main">)</span> <span class="free">heap'</span> <span class="main">=</span> <span class="free">k2</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> init init_state_inner_alloc
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span> init_state_def <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> execute_bind_success'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> success_empty<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> neq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">k1</span> <span class="main">≠</span> <span class="free">k2</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Memory_Heap-init_state_inv'"><span class="command">lemma</span></span> init_state_inv'<span class="main">:</span>
  <span class="quoted"><span class="quoted">"pair.inv_pair <span class="free">heap'</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> pair.inv_pair_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">using</span></span> init_state_empty1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">using</span></span> init_state_empty2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">using</span></span> neq init <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> get_k1_def get_k2_def init_state_k1 init_state_k2<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> init_state_inv<span class="main"><span class="main">[</span></span><span class="operator">OF</span> init<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Memory_Heap-init_state_empty"><span class="command">lemma</span></span> init_state_empty<span class="main">:</span>
  <span class="quoted"><span class="quoted">"pair.pair.map_of <span class="free">heap'</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> Map.empty"</span></span>
  <span class="keyword1"><span class="command">using</span></span> neq <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> pair.emptyI init_state_inv' map_emptyI init_state_empty1 init_state_empty2<span class="main">)</span>

<span class="keyword1"><span class="command">interpretation</span></span> heap_correct_empty <span class="quoted">pair.inv_pair</span> <span class="quoted">update_pair</span> <span class="quoted">lookup_pair</span> <span class="quoted"><span class="free">heap'</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> heap_correct_empty.intro<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> heap_correct_pairI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> map_of_heap_eq<span class="main"><span class="keyword3">;</span></span> <span class="operator">intro</span> init_state_inv' init_state_empty<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> init_state_inv'<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemmas</span></span> heap_correct_empty_pairI <span class="main">=</span> heap_correct_empty_axioms

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">dp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'v</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> dp_consistency_heap_empty
  <span class="quoted">pair.inv_pair</span> <span class="quoted">update_pair</span> <span class="quoted">lookup_pair</span> <span class="quoted"><span class="free">dp</span></span> <span class="quoted"><span class="free">heap'</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span>

<span class="keyword1"><span class="command">lemmas</span></span> consistent_empty_pairI <span class="main">=</span> dp_consistency_heap_empty_axioms

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* DP *)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Unequal Keys *)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Init State *)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Keys injective *)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Lifting Syntax *)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Disjoint *)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Injectivity *)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Refs *)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Key functions &amp; Size *)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Theory *)</span>
</pre>
</div><div id="Transform_Cmd">
<div class="head">
<h1>Theory Transform_Cmd</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Tool Setup›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Transform_Cmd
  <span class="keyword2"><span class="keyword">imports</span></span>
    <span class="quoted">"<a href="#Pure_Monad">../Pure_Monad</a>"</span>
    <span class="quoted">"<a href="#DP_CRelVS">../state_monad/DP_CRelVS</a>"</span>
    <span class="quoted">"<a href="#DP_CRelVH">../heap_monad/DP_CRelVH</a>"</span>
  <span class="keyword2"><span class="keyword">keywords</span></span>
    <span class="quoted">"memoize_fun"</span> <span class="main">::</span> thy_decl
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted">"monadifies"</span> <span class="main">::</span> thy_decl
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted">"memoize_correct"</span> <span class="main">::</span> thy_goal
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted">"with_memory"</span> <span class="main">::</span> quasi_command
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted">"default_proof"</span> <span class="main">::</span> quasi_command
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹../transform/Transform_Misc.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹../transform/Transform_Const.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹../transform/Transform_Data.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹../transform/Transform_Tactic.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹../transform/Transform_Term.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹../transform/Transform.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹../transform/Transform_Parser.ML›</span>

<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹
<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.local_theory</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> <span class="keyword1">memoize_fun</span><span class="antiquote">}</span></span></span> <span class="inner_quoted">"whatever"</span>
    <span class="main">(</span><span class="entity">Transform_Parser.dp_fun_part1_parser</span> &gt;&gt; <span class="entity">Transform_DP.dp_fun_part1_cmd</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.local_theory</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> <span class="keyword1">monadifies</span><span class="antiquote">}</span></span></span> <span class="inner_quoted">"whatever"</span>
    <span class="main">(</span><span class="entity">Transform_Parser.dp_fun_part2_parser</span> &gt;&gt; <span class="entity">Transform_DP.dp_fun_part2_cmd</span><span class="main">)</span>
›</span>

<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹
<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.local_theory_to_proof</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> <span class="keyword1">memoize_correct</span><span class="antiquote">}</span></span></span> <span class="inner_quoted">"whatever"</span>
    <span class="main">(</span>Scan.succeed <span class="entity">Transform_DP.dp_correct_cmd</span><span class="main">)</span>
›</span>

<span class="keyword1"><span class="command">method_setup</span></span> memoize_prover <span class="main">=</span> <span class="quoted">‹
Scan.succeed <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">SIMPLE_METHOD'</span> <span class="main">(</span>
  <span class="entity">Transform_Data.get_last_cmd_info</span> <span class="entity">ctxt</span>
  |&gt; <span class="entity">Transform_Tactic.solve_consistentDP_tac</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
›</span>

<span class="keyword1"><span class="command">method_setup</span></span> memoize_prover_init <span class="main">=</span> <span class="quoted">‹
Scan.succeed <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">SIMPLE_METHOD'</span> <span class="main">(</span>
  <span class="entity">Transform_Data.get_last_cmd_info</span> <span class="entity">ctxt</span>
  |&gt; <span class="entity">Transform_Tactic.prepare_consistentDP_tac</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
›</span>

<span class="keyword1"><span class="command">method_setup</span></span> memoize_prover_case_init <span class="main">=</span> <span class="quoted">‹
Scan.succeed <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">SIMPLE_METHOD'</span> <span class="main">(</span>
  <span class="entity">Transform_Data.get_last_cmd_info</span> <span class="entity">ctxt</span>
  |&gt; <span class="entity">Transform_Tactic.prepare_case_tac</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
›</span>

<span class="keyword1"><span class="command">method_setup</span></span> memoize_prover_match_step <span class="main">=</span> <span class="quoted">‹
Scan.succeed <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">SIMPLE_METHOD'</span> <span class="main">(</span>
  <span class="entity">Transform_Data.get_last_cmd_info</span> <span class="entity">ctxt</span>
  |&gt; <span class="entity">Transform_Tactic.step_tac</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
›</span>

<span class="keyword1"><span class="command">method_setup</span></span> memoize_unfold_defs  <span class="main">=</span> <span class="quoted">‹
Scan.option <span class="main">(</span>Scan.lift <span class="main">(</span>Args.parens Args.name<span class="main">)</span> -- Args.term<span class="main">)</span> &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">tm_opt</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">SIMPLE_METHOD'</span> <span class="main">(</span>
  <span class="entity">Transform_Data.get_or_last_cmd_info</span> <span class="entity">ctxt</span> <span class="entity">tm_opt</span>
  |&gt; <span class="entity">Transform_Tactic.dp_unfold_defs_tac</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
›</span>

<span class="keyword1"><span class="command">method_setup</span></span> memoize_combinator_init  <span class="main">=</span> <span class="quoted">‹
Scan.option <span class="main">(</span>Scan.lift <span class="main">(</span>Args.parens Args.name<span class="main">)</span> -- Args.term<span class="main">)</span> &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">tm_opt</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">SIMPLE_METHOD'</span> <span class="main">(</span>
  <span class="entity">Transform_Data.get_or_last_cmd_info</span> <span class="entity">ctxt</span> <span class="entity">tm_opt</span>
  |&gt; <span class="entity">Transform_Tactic.prepare_combinator_tac</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
›</span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* theory *)</span>
</pre>
</div><div id="files/Transform_Misc.ML">
<div class="head">
<h1>File ‹Transform_Misc.ML›</h1>
</div>
<pre class="source"><span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Transform_Misc</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">struct</span></span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">import_function_info</span> <span class="entity">term_opt</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">term_opt</span> <span class="keyword2"><span class="keyword">of</span></span>
      SOME <span class="entity">tm</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">Function_Common.import_function_data</span> <span class="entity">tm</span> <span class="entity">ctxt</span> <span class="keyword2"><span class="keyword">of</span></span>
        SOME <span class="entity">info</span> <span class="main">=&gt;</span> <span class="entity">info</span>
      <span class="main">|</span> NONE <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> TERM<span class="main">(</span><span class="inner_quoted">"not a function"</span><span class="main">,</span> <span class="main">[</span><span class="entity">tm</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
    <span class="main">|</span> NONE <span class="main">=&gt;</span> <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">Function_Common.import_last_function</span> <span class="entity">ctxt</span> <span class="keyword2"><span class="keyword">of</span></span>
        SOME <span class="entity">info</span> <span class="main">=&gt;</span> <span class="entity">info</span>
      <span class="main">|</span> NONE <span class="main">=&gt;</span> error <span class="inner_quoted">"no function defined yet"</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_const_pat</span> <span class="entity">ctxt</span> <span class="entity">tm_pat</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span>Const <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Proof_Context.read_const <span class="main">{</span>proper<span class="main">=</span>false<span class="main">,</span> strict<span class="main">=</span>false<span class="main">}</span> <span class="entity">ctxt</span> <span class="entity">tm_pat</span>
    <span class="keyword2"><span class="keyword">in</span></span> Const <span class="main">(</span><span class="entity">name</span><span class="main">,</span> dummyT<span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">head_of</span> <span class="main">(</span><span class="entity">func_info</span><span class="main">:</span> <span class="entity">Function.info</span><span class="main">)</span> <span class="main">=</span> <span class="main">#</span>fs <span class="entity">func_info</span> |&gt; the_single
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">bind_of</span> <span class="main">(</span><span class="entity">func_info</span><span class="main">:</span> <span class="entity">Function.info</span><span class="main">)</span> <span class="main">=</span> <span class="main">#</span>fnames <span class="entity">func_info</span> |&gt; the_single

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">totality_of</span> <span class="main">(</span><span class="entity">func_info</span><span class="main">:</span> <span class="entity">Function.info</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">func_info</span> |&gt; <span class="main">#</span>totality |&gt; the<span class="main">;</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rel_of</span> <span class="main">(</span><span class="entity">func_info</span><span class="main">:</span> <span class="entity">Function.info</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="entity">Inductive.the_inductive</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="main">#</span>R <span class="entity">func_info</span><span class="main">)</span> |&gt; snd |&gt; <span class="main">#</span>eqs |&gt; the_single<span class="main">;</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">the_element</span> <span class="entity">l</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> tl <span class="entity">l</span> |&gt; find_first <span class="main">(</span>not o equal <span class="main">(</span>hd <span class="entity">l</span><span class="main">)</span><span class="main">)</span> |&gt; is_none
      <span class="keyword2"><span class="keyword">then</span></span> hd <span class="entity">l</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="entity"><span class="entity"><span class="entity"><span class="entity"><span class="entity"><span class="antiquote">@{</span><span class="operator">print</span><span class="antiquote">}</span></span></span></span></span></span></span></span> <span class="entity">l</span><span class="main">;</span> error <span class="inner_quoted">"inconsistent n_args"</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_function</span> <span class="entity">bind</span> <span class="entity">defs</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fixes</span> <span class="main">=</span> <span class="main">[</span><span class="main">(</span><span class="entity">bind</span><span class="main">,</span> NONE<span class="main">,</span> NoSyn<span class="main">)</span><span class="main">]</span><span class="main">;</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">specs</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">def</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span>Binding.empty<span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">def</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="entity">defs</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pat_completeness_auto</span> <span class="main">=</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span>
        <span class="entity">Pat_Completeness.pat_completeness_tac</span> <span class="entity">ctxt</span> <span class="inner_numeral">1</span>
        THEN <span class="entity">auto_tac</span> <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">Function.add_function</span> <span class="entity">fixes</span> <span class="entity">specs</span> <span class="entity">Function_Fun.fun_config</span> <span class="entity">pat_completeness_auto</span>
    <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">behead</span> <span class="entity">head</span> <span class="entity">tm</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">head_nargs</span> <span class="main">=</span> strip_comb <span class="entity">head</span> |&gt; snd |&gt; length
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">tm_head</span><span class="main">,</span> <span class="entity">tm_args</span><span class="main">)</span> <span class="main">=</span> strip_comb <span class="entity">tm</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">tm_args0</span><span class="main">,</span> <span class="entity">tm_args1</span><span class="main">)</span> <span class="main">=</span> chop <span class="entity">head_nargs</span> <span class="entity">tm_args</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tm_head'</span> <span class="main">=</span> list_comb <span class="main">(</span><span class="entity">tm_head</span><span class="main">,</span> <span class="entity">tm_args0</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> Term.aconv_untyped <span class="main">(</span><span class="entity">head</span><span class="main">,</span> <span class="entity">tm_head'</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword3"><span class="keyword">raise</span></span> TERM<span class="main">(</span><span class="inner_quoted">"head does not match"</span><span class="main">,</span> <span class="main">[</span><span class="entity">head</span><span class="main">,</span> <span class="entity">tm_head'</span><span class="main">]</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">(</span><span class="entity">tm_head'</span><span class="main">,</span> <span class="entity">tm_args1</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">term_name</span> <span class="entity">tm</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> is_Free <span class="entity">tm</span> <span class="keyword1"><span class="keyword">orelse</span></span> is_Const <span class="entity">tm</span>
      <span class="keyword2"><span class="keyword">then</span></span> Term.term_name <span class="entity">tm</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword3"><span class="keyword">raise</span></span> TERM<span class="main">(</span><span class="inner_quoted">"not an atom, explicit name required"</span><span class="main">,</span> <span class="main">[</span><span class="entity">tm</span><span class="main">]</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">locale_term</span> <span class="entity">lthy</span> <span class="entity">locale_name</span> <span class="entity">term_name</span> <span class="main">=</span>
    Syntax.read_term <span class="entity">lthy</span> <span class="main">(</span>Long_Name.qualify <span class="entity">locale_name</span> <span class="entity">term_name</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">locale_thms</span> <span class="entity">lthy</span> <span class="entity">locale_name</span> <span class="entity">thms_name</span> <span class="main">=</span>
    Proof_Context.get_thms <span class="entity">lthy</span> <span class="main">(</span>Long_Name.qualify <span class="entity">locale_name</span> <span class="entity">thms_name</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">uncurry</span> <span class="entity">tm</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg_typs</span> <span class="main">=</span> fastype_of <span class="entity">tm</span> |&gt; binder_types
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg_names</span> <span class="main">=</span> Name.invent_list <span class="main">[</span><span class="main">]</span> <span class="inner_quoted">"a"</span> <span class="main">(</span>length <span class="entity">arg_typs</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> map Free <span class="main">(</span><span class="entity">arg_names</span> ~~ <span class="entity">arg_typs</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args_tuple</span> <span class="main">=</span> <span class="entity">HOLogic.mk_tuple</span> <span class="entity">args</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tm'</span> <span class="main">=</span> list_comb <span class="main">(</span><span class="entity">tm</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span> |&gt; <span class="entity">HOLogic.tupled_lambda</span> <span class="entity">args_tuple</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">tm'</span>
    <span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/Transform_Const.ML">
<div class="head">
<h1>File ‹Transform_Const.ML›</h1>
</div>
<pre class="source"><span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Transform_Const</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">struct</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pureappN</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Pure_Monad.App<span class="antiquote">}</span></span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pureapp</span> <span class="entity">tm</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">pureappN</span><span class="main">,</span> dummyT<span class="main">)</span> $ <span class="entity">tm</span>

  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">MONAD_CONSTS</span> <span class="main">=</span> <span class="main">{</span>
    monad_name<span class="main">:</span> string<span class="main">,</span>
    mk_stateT<span class="main">:</span> typ <span class="main">-&gt;</span> typ<span class="main">,</span>
    return<span class="main">:</span> term <span class="main">-&gt;</span> term<span class="main">,</span>
    app<span class="main">:</span> <span class="main">(</span>term * term<span class="main">)</span> <span class="main">-&gt;</span> term<span class="main">,</span>
    if_termN<span class="main">:</span> string<span class="main">,</span>
    checkmemVN<span class="main">:</span> string<span class="main">,</span>
    rewrite_app_beta_conv<span class="main">:</span> conv
  <span class="main">}</span>
  
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">state_monad</span><span class="main">:</span> <span class="entity">MONAD_CONSTS</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">memT</span> <span class="main">=</span> TFree <span class="main">(</span><span class="inner_quoted">"MemoryType"</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">type</span><span class="antiquote">}</span></span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">memT</span> <span class="main">=</span> dummyT
    
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_stateT</span> <span class="entity">tp</span> <span class="main">=</span>
        Type <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> State_Monad.state<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">[</span><span class="entity">memT</span><span class="main">,</span> <span class="entity">tp</span><span class="main">]</span><span class="main">)</span>
    
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">returnN</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> State_Monad.return<span class="antiquote">}</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">return</span> <span class="entity">tm</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">returnN</span><span class="main">,</span> dummyT --&gt; <span class="entity">mk_stateT</span> dummyT<span class="main">)</span> $ <span class="entity">tm</span>
    
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">appN</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> State_Monad_Ext.fun_app_lifted<span class="antiquote">}</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">app</span> <span class="main">(</span><span class="entity">tm0</span><span class="main">,</span> <span class="entity">tm1</span><span class="main">)</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">appN</span><span class="main">,</span> dummyT<span class="main">)</span> $ <span class="entity">tm0</span> $ <span class="entity">tm1</span>
    
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">checkmem'C</span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="entity">Transform_Misc.get_const_pat</span> <span class="entity">ctxt</span> <span class="inner_quoted">"checkmem'"</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">checkmem'</span> <span class="entity">ctxt</span> <span class="entity">param</span> <span class="entity">body</span> <span class="main">=</span> <span class="entity">checkmem'C</span> <span class="entity">ctxt</span> $ <span class="entity">param</span> $ <span class="entity">body</span>
    
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">checkmemVN</span> <span class="main">=</span> <span class="inner_quoted">"checkmem"</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">checkmemC</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "state_mem_defs.checkmem"<span class="antiquote">}</span></span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rewrite_app_beta_conv</span> <span class="entity">ctm</span> <span class="main">=</span>
        <span class="keyword2"><span class="keyword">case</span></span> Thm.term_of <span class="entity">ctm</span> <span class="keyword2"><span class="keyword">of</span></span>
          Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> State_Monad_Ext.fun_app_lifted<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span>
            $ <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> State_Monad.return<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ Abs <span class="main">_</span><span class="main">)</span>
            $ <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> State_Monad.return<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">_</span><span class="main">)</span>
            <span class="main">=&gt;</span> Conv.rewr_conv <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> State_Monad_Ext.return_app_return_meta<span class="antiquote">}</span></span></span> <span class="entity">ctm</span>
        <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> Conv.no_conv <span class="entity">ctm</span>

    <span class="keyword2"><span class="keyword">in</span></span> <span class="main">{</span>
      monad_name <span class="main">=</span> <span class="inner_quoted">"state"</span><span class="main">,</span>
      mk_stateT <span class="main">=</span> <span class="entity">mk_stateT</span><span class="main">,</span>
      return <span class="main">=</span> <span class="entity">return</span><span class="main">,</span>
      app <span class="main">=</span> <span class="entity">app</span><span class="main">,</span>
      if_termN <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> State_Monad_Ext.if<span class="hidden">⇩</span><sub>T</sub><span class="antiquote">}</span></span><span class="main">,</span>
      checkmemVN <span class="main">=</span> <span class="entity">checkmemVN</span><span class="main">,</span>
      rewrite_app_beta_conv <span class="main">=</span> <span class="entity">rewrite_app_beta_conv</span>
    <span class="main">}</span> <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">heap_monad</span><span class="main">:</span> <span class="entity">MONAD_CONSTS</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_stateT</span> <span class="entity">tp</span> <span class="main">=</span>
        Type <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> Heap_Monad.Heap<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">[</span><span class="entity">tp</span><span class="main">]</span><span class="main">)</span>
    
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">returnN</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Heap_Monad.return<span class="antiquote">}</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">return</span> <span class="entity">tm</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">returnN</span><span class="main">,</span> dummyT --&gt; <span class="entity">mk_stateT</span> dummyT<span class="main">)</span> $ <span class="entity">tm</span>
    
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">appN</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Heap_Monad_Ext.fun_app_lifted<span class="antiquote">}</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">app</span> <span class="main">(</span><span class="entity">tm0</span><span class="main">,</span> <span class="entity">tm1</span><span class="main">)</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">appN</span><span class="main">,</span> dummyT<span class="main">)</span> $ <span class="entity">tm0</span> $ <span class="entity">tm1</span>
    
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">checkmem'C</span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="entity">Transform_Misc.get_const_pat</span> <span class="entity">ctxt</span> <span class="inner_quoted">"checkmem'"</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">checkmem'</span> <span class="entity">ctxt</span> <span class="entity">param</span> <span class="entity">body</span> <span class="main">=</span> <span class="entity">checkmem'C</span> <span class="entity">ctxt</span> $ <span class="entity">param</span> $ <span class="entity">body</span>
    
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">checkmemVN</span> <span class="main">=</span> <span class="inner_quoted">"checkmem"</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">checkmemC</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "heap_mem_defs.checkmem"<span class="antiquote">}</span></span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rewrite_app_beta_conv</span> <span class="entity">ctm</span> <span class="main">=</span>
        <span class="keyword2"><span class="keyword">case</span></span> Thm.term_of <span class="entity">ctm</span> <span class="keyword2"><span class="keyword">of</span></span>
          Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Heap_Monad_Ext.fun_app_lifted<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span>
            $ <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Heap_Monad.return<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ Abs <span class="main">_</span><span class="main">)</span>
            $ <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Heap_Monad.return<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">_</span><span class="main">)</span>
            <span class="main">=&gt;</span> Conv.rewr_conv <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Heap_Monad_Ext.return_app_return_meta<span class="antiquote">}</span></span></span> <span class="entity">ctm</span>
        <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> Conv.no_conv <span class="entity">ctm</span>
    <span class="keyword2"><span class="keyword">in</span></span> <span class="main">{</span>
      monad_name <span class="main">=</span> <span class="inner_quoted">"heap"</span><span class="main">,</span>
      mk_stateT <span class="main">=</span> <span class="entity">mk_stateT</span><span class="main">,</span>
      return <span class="main">=</span> <span class="entity">return</span><span class="main">,</span>
      app <span class="main">=</span> <span class="entity">app</span><span class="main">,</span>
      if_termN <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Heap_Monad_Ext.if<span class="hidden">⇩</span><sub>T</sub><span class="antiquote">}</span></span><span class="main">,</span>
      checkmemVN <span class="main">=</span> <span class="entity">checkmemVN</span><span class="main">,</span>
      rewrite_app_beta_conv <span class="main">=</span> <span class="entity">rewrite_app_beta_conv</span>
    <span class="main">}</span> <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">monad_consts_dict</span> <span class="main">=</span> <span class="main">[</span>
    <span class="main">(</span><span class="inner_quoted">"state"</span><span class="main">,</span> <span class="entity">state_monad</span><span class="main">)</span><span class="main">,</span>
    <span class="main">(</span><span class="inner_quoted">"heap"</span><span class="main">,</span> <span class="entity">heap_monad</span><span class="main">)</span>
  <span class="main">]</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_monad_const</span> <span class="entity">name</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> AList.lookup <span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span> <span class="entity">monad_consts_dict</span> <span class="entity">name</span> <span class="keyword2"><span class="keyword">of</span></span>
      SOME <span class="entity">consts</span> <span class="main">=&gt;</span> <span class="entity">consts</span>
    <span class="main">|</span> NONE <span class="main">=&gt;</span> error<span class="main">(</span><span class="inner_quoted">"unrecognized monad: "</span> ^ <span class="entity">name</span> ^ <span class="inner_quoted">" , choices: "</span> ^ commas <span class="main">(</span>map fst <span class="entity">monad_consts_dict</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span>

</pre>
</div><div id="files/Transform_Data.ML">
<div class="head">
<h1>File ‹Transform_Data.ML›</h1>
</div>
<pre class="source"><span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Transform_Data</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">dp_info</span> <span class="main">=</span> <span class="main">{</span>
  old_head<span class="main">:</span> term<span class="main">,</span>
  new_head'<span class="main">:</span> term<span class="main">,</span>
  new_headT<span class="main">:</span> term<span class="main">,</span>

  old_defs<span class="main">:</span> thm list<span class="main">,</span>
  new_defT<span class="main">:</span> thm<span class="main">,</span>
  new_def'<span class="main">:</span> thm list
<span class="main">}</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">cmd_info</span> <span class="main">=</span> <span class="main">{</span>
  scope<span class="main">:</span> binding<span class="main">,</span>
  head<span class="main">:</span> term<span class="main">,</span>
  locale<span class="main">:</span> string option<span class="main">,</span>
  dp_info<span class="main">:</span> <span class="entity">dp_info</span> option
<span class="main">}</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_cmd_info</span> <span class="entity">f0</span> <span class="entity">f1</span> <span class="entity">f2</span> <span class="entity">f3</span> <span class="main">{</span><span class="entity">scope</span><span class="main">,</span> <span class="entity">head</span><span class="main">,</span> <span class="entity">locale</span><span class="main">,</span> <span class="entity">dp_info</span><span class="main">}</span> <span class="main">=</span>
  <span class="main">{</span>scope <span class="main">=</span> <span class="entity">f0</span> <span class="entity">scope</span><span class="main">,</span> head <span class="main">=</span> <span class="entity">f1</span> <span class="entity">head</span><span class="main">,</span> locale <span class="main">=</span> <span class="entity">f2</span> <span class="entity">locale</span><span class="main">,</span> dp_info <span class="main">=</span> <span class="entity">f3</span> <span class="entity">dp_info</span><span class="main">}</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_cmd_dp_info</span> <span class="entity">f</span> <span class="main">=</span> <span class="entity">map_cmd_info</span> I I I <span class="entity">f</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Data</span> <span class="main">=</span> Generic_Data <span class="main">(</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="main">{</span>
    monadified_terms<span class="main">:</span> <span class="main">(</span>string * <span class="entity">cmd_info</span> Item_Net.T<span class="main">)</span> list<span class="main">,</span>
    last_cmd_info<span class="main">:</span> <span class="entity">cmd_info</span> option
  <span class="main">}</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">empty</span> <span class="main">=</span> <span class="main">{</span>
    monadified_terms <span class="main">=</span>
      <span class="main">[</span><span class="inner_quoted">"state"</span><span class="main">,</span> <span class="inner_quoted">"heap"</span><span class="main">]</span>
      ~~ replicate <span class="inner_numeral">2</span> <span class="main">(</span>Item_Net.init <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv o apply2 <span class="main">#</span>head<span class="main">)</span> <span class="main">(</span>single o <span class="main">#</span>head<span class="main">)</span><span class="main">)</span><span class="main">,</span>
    last_cmd_info <span class="main">=</span> NONE
  <span class="main">}</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">extend</span> <span class="main">=</span> I

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">merge</span> <span class="main">(</span>
    <span class="main">{</span>monadified_terms <span class="main">=</span> <span class="entity">m0</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">,</span>
    <span class="main">{</span>monadified_terms <span class="main">=</span> <span class="entity">m1</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span>
  <span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">keys0</span> <span class="main">=</span> map fst <span class="entity">m0</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">keys1</span> <span class="main">=</span> map fst <span class="entity">m1</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="entity"><span class="antiquote">@{</span><span class="operator">assert</span><span class="antiquote">}</span></span></span></span> <span class="main">(</span><span class="entity">keys0</span> <span class="main">=</span> <span class="entity">keys1</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vals</span> <span class="main">=</span> map Item_Net.merge <span class="main">(</span>map snd <span class="entity">m0</span> ~~ map snd <span class="entity">m1</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ms</span> <span class="main">=</span> <span class="entity">keys0</span> ~~ <span class="entity">vals</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">{</span>monadified_terms <span class="main">=</span> <span class="entity">ms</span><span class="main">,</span> last_cmd_info <span class="main">=</span> NONE<span class="main">}</span>
    <span class="keyword2"><span class="keyword">end</span></span>
<span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">transform_dp_info</span> <span class="entity">phi</span> <span class="main">{</span><span class="entity">old_head</span><span class="main">,</span> <span class="entity">new_head'</span><span class="main">,</span> <span class="entity">new_headT</span><span class="main">,</span> <span class="entity">old_defs</span><span class="main">,</span> <span class="entity">new_defT</span><span class="main">,</span> <span class="entity">new_def'</span><span class="main">}</span> <span class="main">=</span>
  <span class="main">{</span>
    old_head <span class="main">=</span> Morphism.term <span class="entity">phi</span> <span class="entity">old_head</span><span class="main">,</span>
    new_head' <span class="main">=</span> Morphism.term <span class="entity">phi</span> <span class="entity">new_head'</span><span class="main">,</span>
    new_headT <span class="main">=</span> Morphism.term <span class="entity">phi</span> <span class="entity">new_headT</span><span class="main">,</span>
  
    old_defs <span class="main">=</span> Morphism.fact <span class="entity">phi</span> <span class="entity">old_defs</span><span class="main">,</span>
    new_def' <span class="main">=</span> Morphism.fact <span class="entity">phi</span> <span class="entity">new_def'</span><span class="main">,</span>
    new_defT <span class="main">=</span> Morphism.thm <span class="entity">phi</span> <span class="entity">new_defT</span>
  <span class="main">}</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_monadified_terms_generic</span> <span class="entity">monad_name</span> <span class="entity">ctxt</span> <span class="main">=</span>
  Data.get <span class="entity">ctxt</span>
  |&gt; <span class="main">#</span>monadified_terms
  |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">l</span> <span class="main">=&gt;</span> AList.lookup <span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span> <span class="entity">l</span> <span class="entity">monad_name</span><span class="main">)</span>
  |&gt; the

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_monadified_terms</span> <span class="entity">monad_name</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="entity">get_monadified_terms_generic</span> <span class="entity">monad_name</span> <span class="main">(</span>Context.Proof <span class="entity">lthy</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_data</span> <span class="entity">f0</span> <span class="entity">f1</span> <span class="main">=</span> Data.map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span><span class="entity">monadified_terms</span><span class="main">,</span> <span class="entity">last_cmd_info</span><span class="main">}</span> <span class="main">=&gt;</span>
  <span class="main">{</span>monadified_terms <span class="main">=</span> <span class="entity">f0</span> <span class="entity">monadified_terms</span><span class="main">,</span> last_cmd_info <span class="main">=</span> <span class="entity">f1</span> <span class="entity">last_cmd_info</span><span class="main">}</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_monadified_terms</span> <span class="entity">f</span> <span class="main">=</span> <span class="entity">map_data</span> <span class="entity">f</span> I
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_last_cmd_info</span> <span class="entity">f</span>    <span class="main">=</span> <span class="entity">map_data</span> I <span class="entity">f</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">put_monadified_terms_generic</span> <span class="entity">monad_name</span> <span class="entity">new_terms</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="entity">ctxt</span> |&gt; <span class="entity">map_monadified_terms</span> <span class="main">(</span>AList.update <span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span> <span class="main">(</span><span class="entity">monad_name</span><span class="main">,</span> <span class="entity">new_terms</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_monadified_terms_generic</span> <span class="entity">monad_name</span> <span class="entity">f</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="entity">ctxt</span> |&gt; <span class="entity">map_monadified_terms</span> <span class="main">(</span>AList.map_entry <span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span> <span class="entity">monad_name</span> <span class="entity">f</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">put_last_cmd_info</span> <span class="entity">cmd_info_opt</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="entity">map_last_cmd_info</span> <span class="main">(</span>K <span class="entity">cmd_info_opt</span><span class="main">)</span> <span class="entity">ctxt</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_cmd_info</span> <span class="entity">monad_name</span> <span class="entity">lthy</span> <span class="entity">tm</span> <span class="main">=</span>
  <span class="entity">get_monadified_terms</span> <span class="entity">monad_name</span> <span class="entity">lthy</span>
  |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">net</span> <span class="main">=&gt;</span> Item_Net.retrieve <span class="entity">net</span> <span class="entity">tm</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_dp_info</span> <span class="entity">monad_name</span> <span class="entity">lthy</span> <span class="entity">tm</span> <span class="main">=</span>
  <span class="entity">get_cmd_info</span> <span class="entity">monad_name</span> <span class="entity">lthy</span> <span class="entity">tm</span>
  |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">result</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">result</span> <span class="keyword2"><span class="keyword">of</span></span>
      <span class="main">{</span>dp_info <span class="main">=</span> SOME <span class="entity">dp_info'</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> :: <span class="main">_</span> <span class="main">=&gt;</span> SOME <span class="entity">dp_info'</span>
    <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> NONE<span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_last_cmd_info_generic</span> <span class="entity">ctxt</span> <span class="main">=</span>
  Data.get <span class="entity">ctxt</span>
  |&gt; <span class="main">#</span>last_cmd_info
  |&gt; the

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_last_cmd_info</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="entity">get_last_cmd_info_generic</span> <span class="main">(</span>Context.Proof <span class="entity">lthy</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">commit_dp_info</span> <span class="entity">monad_name</span> <span class="entity">dp_info</span> <span class="main">=</span>
  Local_Theory.declaration
    <span class="main">{</span>pervasive <span class="main">=</span> false<span class="main">,</span> syntax <span class="main">=</span> false<span class="main">}</span>
    <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">phi</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">old_cmd_info</span> <span class="main">=</span> <span class="entity">get_last_cmd_info_generic</span> <span class="entity">ctxt</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">new_dp_info</span> <span class="main">=</span> <span class="entity">transform_dp_info</span> <span class="entity">phi</span> <span class="entity">dp_info</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">new_cmd_info</span> <span class="main">=</span> <span class="entity">old_cmd_info</span> |&gt; <span class="entity">map_cmd_dp_info</span> <span class="main">(</span>K <span class="main">(</span>SOME <span class="entity">new_dp_info</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="entity">ctxt</span>
        |&gt; <span class="entity">map_monadified_terms_generic</span> <span class="entity">monad_name</span> <span class="main">(</span>Item_Net.update <span class="entity">new_cmd_info</span><span class="main">)</span>
         |&gt; <span class="entity">put_last_cmd_info</span> <span class="main">(</span>SOME <span class="entity">new_cmd_info</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_tmp_cmd_info</span> <span class="main">(</span><span class="entity">scope</span><span class="main">,</span> <span class="entity">head</span><span class="main">,</span> <span class="entity">locale_opt</span><span class="main">)</span> <span class="main">=</span>
  Local_Theory.declaration
    <span class="main">{</span>pervasive <span class="main">=</span> false<span class="main">,</span> syntax <span class="main">=</span> false<span class="main">}</span>
    <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">phi</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">new_cmd_info</span> <span class="main">=</span> <span class="main">{</span>
          scope <span class="main">=</span> Morphism.binding <span class="entity">phi</span> <span class="entity">scope</span><span class="main">,</span>
          head <span class="main">=</span> Morphism.term <span class="entity">phi</span> <span class="entity">head</span><span class="main">,</span>
          locale <span class="main">=</span> <span class="entity">locale_opt</span><span class="main">,</span>
          dp_info <span class="main">=</span> NONE
        <span class="main">}</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="entity">ctxt</span> |&gt; <span class="entity">put_last_cmd_info</span> <span class="main">(</span>SOME <span class="entity">new_cmd_info</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span> <span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_or_last_cmd_info</span> <span class="entity">lthy</span> <span class="entity">monad_name_tm_opt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">monad_name_tm_opt</span> <span class="keyword2"><span class="keyword">of</span></span>
    NONE <span class="main">=&gt;</span> <span class="entity">get_last_cmd_info</span> <span class="entity">lthy</span>
  <span class="main">|</span> SOME <span class="main">(</span><span class="entity">monad_name</span><span class="main">,</span> <span class="entity">tm</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">get_cmd_info</span> <span class="entity">monad_name</span> <span class="entity">lthy</span> <span class="entity">tm</span> |&gt; the_single

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/Transform_Tactic.ML">
<div class="head">
<h1>File ‹Transform_Tactic.ML›</h1>
</div>
<pre class="source"><span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Transform_Tactic</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">struct</span></span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">my_print_tac</span> <span class="entity">msg</span> <span class="entity">st</span> <span class="main">=</span> <span class="main">(</span>tracing <span class="entity">msg</span><span class="main">;</span> all_tac <span class="entity">st</span><span class="main">)</span>
  
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">totality_resolve_tac</span> <span class="entity">totality0</span> <span class="entity">def0</span> <span class="entity">def1</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">totality0_unfolded</span> <span class="main">=</span> <span class="entity">totality0</span> |&gt; Local_Defs.unfold <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">def0</span><span class="main">]</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">totality1</span> <span class="main">=</span> <span class="entity">totality0_unfolded</span> |&gt; Local_Defs.fold <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">def1</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> Thm.full_prop_of <span class="entity">totality0_unfolded</span> aconv Thm.full_prop_of <span class="entity">totality1</span>
        <span class="keyword2"><span class="keyword">then</span></span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">msg</span> <span class="main">=</span> Pretty.string_of <span class="main">(</span>Pretty.block <span class="main">[</span>
              Pretty.str <span class="inner_quoted">"Failed to transform totality from"</span><span class="main">,</span> Pretty.brk <span class="inner_numeral">1</span><span class="main">,</span>
              Pretty.quote <span class="main">(</span>Syntax.pretty_term <span class="entity">ctxt</span> <span class="main">(</span>Thm.full_prop_of <span class="entity">def0</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> Pretty.brk <span class="inner_numeral">1</span><span class="main">,</span>
              Pretty.str <span class="inner_quoted">"to"</span><span class="main">,</span> Pretty.brk <span class="inner_numeral">1</span><span class="main">,</span>
              Pretty.quote <span class="main">(</span>Syntax.pretty_term <span class="entity">ctxt</span> <span class="main">(</span>Thm.full_prop_of <span class="entity">def1</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> Pretty.brk <span class="inner_numeral">1</span><span class="main">]</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span> <span class="comment1">(*print_tac ctxt msg THEN*)</span> no_tac <span class="keyword2"><span class="keyword">end</span></span>
        <span class="keyword2"><span class="keyword">else</span></span> HEADGOAL <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">totality1</span><span class="main">]</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>
  
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">totality_blast_tac</span> <span class="entity">totality0</span> <span class="entity">def0</span> <span class="entity">def1</span> <span class="entity">ctxt</span> <span class="main">=</span>
    HEADGOAL <span class="main">(</span>
      <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">totality0</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> rev_iffD1<span class="antiquote">}</span></span></span><span class="main">]</span><span class="main">)</span>
      THEN' <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> arg_cong<span class="main">[</span><span class="operator">where</span> f<span class="main"><span class="main">=</span></span><span class="quoted">HOL.All</span><span class="main">]</span><span class="antiquote">}</span></span></span><span class="main">]</span><span class="main">)</span>
      THEN' SELECT_GOAL <span class="main">(</span><span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="main">(</span>map <span class="main">(</span>Local_Defs.abs_def_rule <span class="entity">ctxt</span><span class="main">)</span> <span class="main">[</span><span class="entity">def0</span><span class="main">,</span> <span class="entity">def1</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
      THEN' <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> arg_cong<span class="main">[</span><span class="operator">where</span> f<span class="main"><span class="main">=</span></span><span class="quoted">Wellfounded.accp</span><span class="main">]</span><span class="antiquote">}</span></span></span><span class="main">]</span><span class="main">)</span>
      THEN' <span class="main">(</span><span class="entity">Blast.depth_tac</span> <span class="entity">ctxt</span> <span class="inner_numeral">2</span><span class="main">)</span>
    <span class="main">)</span>
  
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">totality_replay_tac</span> <span class="entity">old_info</span> <span class="entity">new_info</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">totality0</span> <span class="main">=</span> <span class="entity">Transform_Misc.totality_of</span> <span class="entity">old_info</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">def0</span> <span class="main">=</span> <span class="entity">Transform_Misc.rel_of</span> <span class="entity">old_info</span> <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">def1</span> <span class="main">=</span> <span class="entity">Transform_Misc.rel_of</span> <span class="entity">new_info</span> <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">my_print_tac</span> <span class="entity">msg</span> <span class="entity">st</span> <span class="main">=</span> <span class="main">(</span>tracing <span class="entity">msg</span><span class="main">;</span> all_tac <span class="entity">st</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      no_tac
      ORELSE <span class="main">(</span><span class="entity">totality_resolve_tac</span> <span class="entity">totality0</span> <span class="entity">def0</span> <span class="entity">def1</span> <span class="entity">ctxt</span>
        THEN <span class="entity">my_print_tac</span> <span class="inner_quoted">"termination by replaying"</span><span class="main">)</span>
      ORELSE <span class="main">(</span><span class="entity">totality_blast_tac</span> <span class="entity">totality0</span> <span class="entity">def0</span> <span class="entity">def1</span> <span class="entity">ctxt</span>
        THEN <span class="entity">my_print_tac</span> <span class="inner_quoted">"termination by blast"</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dp_intro_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">cmd_info</span><span class="main">:</span> <span class="entity">Transform_Data.cmd_info</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">scope_name</span> <span class="main">=</span> Binding.name_of <span class="main">(</span><span class="main">#</span>scope <span class="entity">cmd_info</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">consistentDP_rule</span> <span class="main">=</span> <span class="entity">Transform_Misc.locale_thms</span> <span class="entity">ctxt</span> <span class="entity">scope_name</span> <span class="inner_quoted">"consistentDP_intro"</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      resolve_tac <span class="entity">ctxt</span> <span class="entity">consistentDP_rule</span>
    <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">expand_relator_tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
    SELECT_GOAL <span class="main">(</span>Local_Defs.fold_tac <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">Transfer.get_relator_eq</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">solve_relator_tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
    SOLVED' <span class="main">(</span><span class="entity">Transfer.eq_tac</span> <span class="entity">ctxt</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">split_params_tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="entity">clarify_tac</span> <span class="entity">ctxt</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dp_induct_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">cmd_info</span><span class="main">:</span> <span class="entity">Transform_Data.cmd_info</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dpT'</span> <span class="main">=</span> <span class="entity">cmd_info</span> |&gt; <span class="main">#</span>dp_info |&gt; the |&gt; <span class="main">#</span>new_head'
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dpT'_info</span> <span class="main">=</span> <span class="entity">Function.get_info</span> <span class="entity">ctxt</span> <span class="entity">dpT'</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">induct_rule</span> <span class="main">=</span> <span class="entity">dpT'_info</span> |&gt; <span class="main">#</span>inducts |&gt; the
    <span class="keyword2"><span class="keyword">in</span></span>
      resolve_tac <span class="entity">ctxt</span> <span class="entity">induct_rule</span>
    <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dp_unfold_def_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">cmd_info</span><span class="main">:</span> <span class="entity">Transform_Data.cmd_info</span><span class="main">)</span> <span class="entity">sel</span> <span class="main">=</span>
    <span class="entity">cmd_info</span> |&gt; <span class="main">#</span>dp_info |&gt; the |&gt; <span class="entity">sel</span>
    |&gt; map <span class="main">(</span>Local_Defs.meta_rewrite_rule <span class="entity">ctxt</span><span class="main">)</span>
    |&gt; Conv.rewrs_conv 
    |&gt; Conv.try_conv
    |&gt; Conv.binop_conv
    |&gt; <span class="entity">HOLogic.Trueprop_conv</span> 
    |&gt; Conv.concl_conv <span class="inner_numeral">~1</span>
    |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">cv</span> <span class="main">=&gt;</span> Conv.params_conv <span class="inner_numeral">~1</span> <span class="main">(</span>K <span class="entity">cv</span><span class="main">)</span> <span class="entity">ctxt</span><span class="main">)</span>
    |&gt; CONVERSION
    <span class="comment1">(* |&gt; EqSubst.eqsubst_tac ctxt [0] : may rewrite locale parameters in certain situations *)</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dp_match_rule_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">cmd_info</span><span class="main">:</span> <span class="entity">Transform_Data.cmd_info</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">scope_name</span> <span class="main">=</span> Binding.name_of <span class="main">(</span><span class="main">#</span>scope <span class="entity">cmd_info</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dp_match_rules</span> <span class="main">=</span> <span class="entity">Transform_Misc.locale_thms</span> <span class="entity">ctxt</span> <span class="entity">scope_name</span> <span class="inner_quoted">"dp_match_rule"</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      resolve_tac <span class="entity">ctxt</span> <span class="entity">dp_match_rules</span>
    <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">checkmem_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">cmd_info</span><span class="main">:</span> <span class="entity">Transform_Data.cmd_info</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">scope_name</span> <span class="main">=</span> Binding.name_of <span class="main">(</span><span class="main">#</span>scope <span class="entity">cmd_info</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dp_match_rules</span> <span class="main">=</span> <span class="entity">Transform_Misc.locale_thms</span> <span class="entity">ctxt</span> <span class="entity">scope_name</span> <span class="inner_quoted">"crel_vs_checkmem_tupled"</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      resolve_tac <span class="entity">ctxt</span> <span class="entity">dp_match_rules</span>
      THEN' SOLVED' <span class="main">(</span><span class="entity">clarify_tac</span> <span class="entity">ctxt</span><span class="main">)</span>
      THEN' <span class="entity">Transfer.eq_tac</span> <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">solve_IH_tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="entity">Method.assm_tac</span> <span class="entity">ctxt</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">transfer_raw_tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
    resolve_tac <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">Transfer.get_transfer_raw</span> <span class="entity">ctxt</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">step_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">cmd_info</span><span class="main">:</span> <span class="entity">Transform_Data.cmd_info</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">solve_IH_tac</span> <span class="entity">ctxt</span>
    ORELSE' <span class="entity">solve_relator_tac</span> <span class="entity">ctxt</span>
    ORELSE' <span class="entity">dp_match_rule_tac</span> <span class="entity">ctxt</span> <span class="entity">cmd_info</span>
    ORELSE' <span class="entity">transfer_raw_tac</span> <span class="entity">ctxt</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prepare_case_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">cmd_info</span><span class="main">:</span> <span class="entity">Transform_Data.cmd_info</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">dp_unfold_def_tac</span> <span class="entity">ctxt</span> <span class="entity">cmd_info</span> <span class="main">#</span>new_def'
    THEN' <span class="entity">checkmem_tac</span> <span class="entity">ctxt</span> <span class="entity">cmd_info</span>
    THEN' <span class="entity">dp_unfold_def_tac</span> <span class="entity">ctxt</span> <span class="entity">cmd_info</span> <span class="main">#</span>old_defs

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">solve_case_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">cmd_info</span><span class="main">:</span> <span class="entity">Transform_Data.cmd_info</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">prepare_case_tac</span> <span class="entity">ctxt</span> <span class="entity">cmd_info</span>
    THEN' REPEAT_ALL_NEW <span class="main">(</span><span class="entity">step_tac</span> <span class="entity">ctxt</span> <span class="entity">cmd_info</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prepare_consistentDP_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">cmd_info</span><span class="main">:</span> <span class="entity">Transform_Data.cmd_info</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">dp_intro_tac</span> <span class="entity">ctxt</span> <span class="entity">cmd_info</span>
    THEN' <span class="entity">expand_relator_tac</span> <span class="entity">ctxt</span>
    THEN' <span class="entity">split_params_tac</span> <span class="entity">ctxt</span>
    THEN' <span class="entity">dp_induct_tac</span> <span class="entity">ctxt</span> <span class="entity">cmd_info</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">solve_consistentDP_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">cmd_info</span><span class="main">:</span> <span class="entity">Transform_Data.cmd_info</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">prepare_consistentDP_tac</span> <span class="entity">ctxt</span> <span class="entity">cmd_info</span>
    THEN_ALL_NEW SOLVED' <span class="main">(</span><span class="entity">solve_case_tac</span> <span class="entity">ctxt</span> <span class="entity">cmd_info</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prepare_combinator_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">cmd_info</span><span class="main">:</span> <span class="entity">Transform_Data.cmd_info</span><span class="main">)</span> <span class="main">=</span>
     <span class="entity">EqSubst.eqsubst_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="inner_numeral">0</span><span class="main">]</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> Rel_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span><span class="antiquote">}</span></span></span>
     THEN' <span class="entity">dp_unfold_def_tac</span> <span class="entity">ctxt</span> <span class="entity">cmd_info</span> <span class="main">(</span>single o <span class="main">#</span>new_defT<span class="main">)</span>
     THEN' REPEAT_ALL_NEW <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Rel_abs<span class="antiquote">}</span></span></span> :: <span class="entity">Transform_Misc.locale_thms</span> <span class="entity">ctxt</span> <span class="inner_quoted">"local"</span> <span class="inner_quoted">"crel_vs_return_ext"</span><span class="main">)</span><span class="main">)</span>
     THEN' <span class="main">(</span>SELECT_GOAL <span class="main">(</span><span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> Rel_def<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">)</span>

   <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dp_unfold_defs_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">cmd_info</span><span class="main">:</span> <span class="entity">Transform_Data.cmd_info</span><span class="main">)</span> <span class="main">=</span>
     <span class="entity">dp_unfold_def_tac</span> <span class="entity">ctxt</span> <span class="entity">cmd_info</span> <span class="main">#</span>new_def'
     THEN' <span class="entity">dp_unfold_def_tac</span> <span class="entity">ctxt</span> <span class="entity">cmd_info</span> <span class="main">#</span>old_defs

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/Transform_Term.ML">
<div class="head">
<h1>File ‹Transform_Term.ML›</h1>
</div>
<pre class="source"><span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">list_conv</span> <span class="main">(</span><span class="entity">head_conv</span><span class="main">,</span> <span class="entity">arg_convs</span><span class="main">)</span> <span class="entity">lthy</span> <span class="main">=</span>
  Library.foldl <span class="main">(</span>uncurry Conv.combination_conv<span class="main">)</span> <span class="main">(</span><span class="entity">head_conv</span> <span class="entity">lthy</span><span class="main">,</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">conv</span> <span class="main">=&gt;</span> <span class="entity">conv</span> <span class="entity">lthy</span><span class="main">)</span> <span class="entity">arg_convs</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eta_conv1</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="main">(</span>Conv.abs_conv <span class="main">(</span>K Conv.all_conv<span class="main">)</span> <span class="entity">ctxt</span><span class="main">)</span>
  else_conv
  <span class="main">(</span>Thm.eta_long_conversion then_conv Conv.abs_conv <span class="main">(</span>K Thm.eta_conversion<span class="main">)</span> <span class="entity">ctxt</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eta_conv_n</span> <span class="entity">n</span> <span class="main">=</span>
  funpow <span class="entity">n</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">conv</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="entity">eta_conv1</span> <span class="entity">ctxt</span> then_conv Conv.abs_conv <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">conv</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="main">(</span>K Conv.all_conv<span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">conv_changed</span> <span class="entity">conv</span> <span class="entity">ctm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq</span> <span class="main">=</span> <span class="entity">conv</span> <span class="entity">ctm</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="keyword2"><span class="keyword">if</span></span> Thm.is_reflexive <span class="entity">eq</span> <span class="keyword2"><span class="keyword">then</span></span> Conv.no_conv <span class="entity">ctm</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">eq</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">repeat_sweep_conv</span> <span class="entity">conv</span> <span class="main">=</span>
  Conv.repeat_conv o <span class="entity">conv_changed</span> o Conv.top_sweep_conv <span class="entity">conv</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">app_mark_conv</span> <span class="main">=</span> Conv.rewr_conv <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> App_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span><span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">app_unmark_conv</span> <span class="main">=</span> Conv.rewr_conv <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> App_def<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">wrap_mark_conv</span> <span class="main">=</span> Conv.rewr_conv <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Wrap_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span><span class="antiquote">}</span></span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Transform_Term</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eta_expand</span> <span class="entity">tm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">n_args</span> <span class="main">=</span> Integer.min <span class="inner_numeral">1</span> <span class="main">(</span>length <span class="main">(</span>binder_types <span class="main">(</span>fastype_of <span class="entity">tm</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">args</span><span class="main">,</span> <span class="entity">body</span><span class="main">)</span> <span class="main">=</span> Term.strip_abs_eta <span class="entity">n_args</span> <span class="entity">tm</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Library.foldr <span class="main">(</span>uncurry Term.absfree<span class="main">)</span> <span class="main">(</span><span class="entity">args</span><span class="main">,</span> <span class="entity">body</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_ctr_sugar</span> <span class="entity">ctxt</span> <span class="entity">tp_name</span> <span class="main">=</span>
  is_some <span class="main">(</span><span class="entity">Ctr_Sugar.ctr_sugar_of</span> <span class="entity">ctxt</span> <span class="entity">tp_name</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">type_nargs</span> <span class="entity">tp</span> <span class="main">=</span> <span class="entity">tp</span> |&gt; strip_type |&gt; fst |&gt; length
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">term_nargs</span> <span class="entity">tm</span> <span class="main">=</span> <span class="entity">type_nargs</span> <span class="main">(</span>fastype_of <span class="entity">tm</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span>
  <span class="entity">lift_type</span> <span class="main">(</span><span class="entity">monad_consts</span><span class="main">:</span> <span class="entity">Transform_Const.MONAD_CONSTS</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="entity">tp</span> <span class="main">=</span> <span class="main">#</span>mk_stateT <span class="entity">monad_consts</span>  <span class="main">(</span><span class="entity">lift_type'</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span> <span class="entity">tp</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">and</span></span>
  <span class="entity">lift_type'</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">tp</span> <span class="keyword1"><span class="keyword">as</span></span> Type <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> fun<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span>
    <span class="main">=</span> <span class="entity">lift_type'</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span> <span class="main">(</span>domain_type <span class="entity">tp</span><span class="main">)</span> --&gt; <span class="entity">lift_type</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span> <span class="main">(</span>range_type <span class="entity">tp</span><span class="main">)</span>
<span class="main">|</span> <span class="entity">lift_type'</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">tp</span> <span class="keyword1"><span class="keyword">as</span></span> Type <span class="main">(</span><span class="entity">tp_name</span><span class="main">,</span> <span class="entity">tp_args</span><span class="main">)</span><span class="main">)</span>
    <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_ctr_sugar</span> <span class="entity">ctxt</span> <span class="entity">tp_name</span> <span class="keyword2"><span class="keyword">then</span></span> Type <span class="main">(</span><span class="entity">tp_name</span><span class="main">,</span> map <span class="main">(</span><span class="entity">lift_type'</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">tp_args</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">tp_args</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">tp</span> <span class="comment1">(* int, nat, … *)</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword3"><span class="keyword">raise</span></span> TYPE<span class="main">(</span><span class="inner_quoted">"not a ctr_sugar"</span><span class="main">,</span> <span class="main">[</span><span class="entity">tp</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
<span class="main">|</span> <span class="entity">lift_type'</span> <span class="main">_</span> <span class="main">_</span> <span class="entity">tp</span> <span class="main">=</span> <span class="entity">tp</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_atom_type</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span> <span class="entity">tp</span> <span class="main">=</span>
  <span class="entity">tp</span> <span class="main">=</span> <span class="entity">lift_type'</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span> <span class="entity">tp</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_1st_type</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span> <span class="entity">tp</span> <span class="main">=</span>
  body_type <span class="entity">tp</span> :: binder_types <span class="entity">tp</span>
  |&gt; forall <span class="main">(</span><span class="entity">is_atom_type</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">orig_atom</span> <span class="entity">ctxt</span> <span class="entity">atom_name</span> <span class="main">=</span>
  Proof_Context.read_term_pattern <span class="entity">ctxt</span> <span class="entity">atom_name</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_1st_term</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span> <span class="entity">tm</span> <span class="main">=</span>
  <span class="entity">is_1st_type</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span> <span class="main">(</span>fastype_of <span class="entity">tm</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_1st_atom</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span> <span class="entity">atom_name</span> <span class="main">=</span>
  <span class="entity">is_1st_term</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">orig_atom</span> <span class="entity">ctxt</span> <span class="entity">atom_name</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">wrap_1st_term</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span> <span class="entity">tm</span> <span class="entity">n_args_opt</span> <span class="entity">inner_wrap</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">n_args</span> <span class="main">=</span> the_default <span class="main">(</span><span class="entity">term_nargs</span> <span class="entity">tm</span><span class="main">)</span> <span class="entity">n_args_opt</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">vars_name_typ</span><span class="main">,</span> <span class="entity">body</span><span class="main">)</span> <span class="main">=</span> Term.strip_abs_eta <span class="entity">n_args</span> <span class="entity">tm</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">wrap</span> <span class="main">(</span><span class="entity">name_typ</span><span class="main">,</span> <span class="main">(</span><span class="entity">conv</span><span class="main">,</span> <span class="entity">tm</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
      <span class="entity">eta_conv1</span> <span class="entity">ctxt</span> then_conv Conv.abs_conv <span class="main">(</span>K <span class="entity">conv</span><span class="main">)</span> <span class="entity">ctxt</span> then_conv <span class="entity">wrap_mark_conv</span><span class="main">,</span>
      <span class="main">#</span>return <span class="entity">monad_consts</span> <span class="main">(</span>Term.absfree <span class="entity">name_typ</span> <span class="entity">tm</span><span class="main">)</span>
    <span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">conv</span><span class="main">,</span> <span class="entity">result</span><span class="main">)</span> <span class="main">=</span> Library.foldr <span class="entity">wrap</span> <span class="main">(</span><span class="entity">vars_name_typ</span><span class="main">,</span> <span class="main">(</span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">inner_wrap</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="entity">wrap_mark_conv</span><span class="main">,</span> <span class="main">#</span>return <span class="entity">monad_consts</span> <span class="entity">body</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span>Conv.all_conv<span class="main">,</span> <span class="entity">body</span><span class="main">)</span> 
    <span class="main">)</span><span class="main">)</span>
    
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span>K <span class="entity">conv</span><span class="main">,</span> <span class="entity">result</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">lift_1st_atom</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span> <span class="entity">atom</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">tp</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">arg_typs</span><span class="main">,</span> <span class="entity">body_typ</span><span class="main">)</span> <span class="main">=</span> strip_type <span class="entity">tp</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">n_args</span> <span class="main">=</span> <span class="entity">term_nargs</span> <span class="main">(</span><span class="entity">orig_atom</span> <span class="entity">ctxt</span> <span class="entity">name</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">arg_typs</span><span class="main">,</span> <span class="entity">body_arg_typs</span><span class="main">)</span> <span class="main">=</span> chop <span class="entity">n_args</span> <span class="entity">arg_typs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg_typs'</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">lift_type'</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">arg_typs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">body_typ'</span> <span class="main">=</span> <span class="entity">lift_type'</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">body_arg_typs</span> ---&gt; <span class="entity">body_typ</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tm'</span> <span class="main">=</span> <span class="entity">atom</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">arg_typs'</span> ---&gt; <span class="entity">body_typ'</span><span class="main">)</span> <span class="comment1">(* " *)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">wrap_1st_term</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span> <span class="entity">tm'</span> <span class="main">(</span>SOME <span class="entity">n_args</span><span class="main">)</span> true
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">fixed_args</span> <span class="entity">head_n_args</span> <span class="entity">tm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">tm_head</span><span class="main">,</span> <span class="entity">tm_args</span><span class="main">)</span> <span class="main">=</span> strip_comb <span class="entity">tm</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">n_tm_args</span> <span class="main">=</span> length <span class="entity">tm_args</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">head_n_args</span> <span class="entity">tm_head</span>
    |&gt; Option.mapPartial <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">n_args</span> <span class="main">=&gt;</span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">n_tm_args</span> &gt; <span class="entity">n_args</span> <span class="keyword2"><span class="keyword">then</span></span> NONE
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">n_tm_args</span> &lt; <span class="entity">n_args</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="keyword3"><span class="keyword">raise</span></span> TERM<span class="main">(</span><span class="inner_quoted">"need "</span> ^ string_of_int <span class="entity">n_args</span> ^ <span class="inner_quoted">" args"</span><span class="main">,</span> <span class="main">[</span><span class="entity">tm</span><span class="main">]</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span> SOME <span class="main">(</span><span class="entity">tm_head</span><span class="main">,</span> <span class="entity">tm_args</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">lift_abs'</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span> <span class="entity">cont</span> <span class="entity">lift_dict</span> <span class="entity">body</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">free</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">typ'</span> <span class="main">=</span> <span class="entity">lift_type'</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span> <span class="entity">typ</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">freeT'</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">typ'</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">freeT</span> <span class="main">=</span> <span class="main">#</span>return <span class="entity">monad_consts</span> <span class="main">(</span><span class="entity">freeT'</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lift_dict'</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_atom_type</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span> <span class="entity">typ</span>
      <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">lift_dict</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="entity">free</span><span class="main">,</span> <span class="main">(</span>K <span class="entity">wrap_mark_conv</span><span class="main">,</span> <span class="entity">freeT</span><span class="main">)</span><span class="main">)</span>::<span class="entity">lift_dict</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">conv_free</span><span class="main">,</span> <span class="entity">body_free</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">cont</span> <span class="main">(</span><span class="entity">lift_dict'</span><span class="main">)</span> <span class="entity">body</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">body'</span> <span class="main">=</span> lambda <span class="entity">freeT'</span> <span class="entity">body_free</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">conv</span> <span class="entity">lthy</span> <span class="main">=</span>
      <span class="entity">eta_conv1</span> <span class="entity">ctxt</span> then_conv Conv.abs_conv <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">conv_free</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="entity">conv</span><span class="main">,</span> <span class="entity">body'</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">lift_arg</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span> <span class="entity">lift_dict</span> <span class="entity">tm</span> <span class="main">=</span>
  <span class="comment1">(*
  let
    val (conv, tm') = lift_term ctxt lift_dict (eta_expand tm)
    fun conv' ctxt = Conv.try_conv (eta_conv1 ctxt) then_conv (conv ctxt)
  in
    (conv', tm')
  end

  eta_expand AFTER lifting
  *)</span>
  <span class="entity">lift_term</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span> <span class="entity">lift_dict</span> <span class="entity">tm</span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">lift_term</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span> <span class="entity">lift_dict</span> <span class="entity">tm</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">case_terms</span> <span class="main">=</span> <span class="entity">Ctr_Sugar.ctr_sugars_of</span> <span class="entity">ctxt</span> |&gt; map <span class="main">#</span>casex

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">lookup_case_term</span> <span class="entity">tm</span> <span class="main">=</span>
    find_first <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> Term.aconv_untyped <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">tm</span><span class="main">)</span><span class="main">)</span> <span class="entity">case_terms</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">check_cont</span> <span class="main">=</span> <span class="entity">lift_term</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">check_cont_arg</span> <span class="main">=</span> <span class="entity">lift_arg</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">check_const</span> <span class="entity">tm</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">tm</span> <span class="keyword2"><span class="keyword">of</span></span>
      Const <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span>
        <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">Transform_Data.get_dp_info</span> <span class="main">(</span><span class="main">#</span>monad_name <span class="entity">monad_consts</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="entity">tm</span> <span class="keyword2"><span class="keyword">of</span></span>
          SOME <span class="main">{</span>new_headT<span class="main">=</span>Const <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span> SOME <span class="main">(</span>K Conv.all_conv<span class="main">,</span> Const <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">lift_type</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span> <span class="entity">typ</span><span class="main">)</span><span class="main">)</span>
        <span class="main">|</span> SOME <span class="main">{</span>new_headT<span class="main">=</span><span class="entity">tm'</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> TERM<span class="main">(</span><span class="inner_quoted">"not a constant"</span><span class="main">,</span> <span class="main">[</span><span class="entity">tm'</span><span class="main">]</span><span class="main">)</span>
        <span class="main">|</span> NONE <span class="main">=&gt;</span> NONE<span class="main">)</span>
    <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> NONE

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">check_1st_atom</span> <span class="entity">tm</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">tm</span> <span class="keyword2"><span class="keyword">of</span></span>
      Const <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_1st_atom</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span> <span class="entity">name</span> <span class="keyword2"><span class="keyword">then</span></span> SOME <span class="main">(</span><span class="entity">lift_1st_atom</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span> Const <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> NONE
    <span class="main">|</span> Free <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_1st_atom</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span> <span class="entity">name</span> <span class="keyword2"><span class="keyword">then</span></span> SOME <span class="main">(</span><span class="entity">lift_1st_atom</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span> Free <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> NONE
    <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="comment1">(*
        if is_1st_term ctxt tm andalso exists_subterm (AList.defined (op aconv) lift_dict) tm
          then SOME (wrap_1st_term tm NONE)
          else *)</span> NONE

<span class="comment1">(*
  fun check_dict tm =
    (* TODO: map -&gt; mapT, dummyT *)
    AList.lookup Term.aconv_untyped lift_dict tm
    |&gt; Option.map (fn tm' =&gt;
      if is_Const tm
        then (@{assert} (is_Const tm'); map_types (K (lift_type ctxt (type_of tm))) tm')
        else tm')
*)</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">check_dict</span> <span class="entity">tm</span> <span class="main">=</span>
    AList.lookup Term.aconv_untyped <span class="entity">lift_dict</span> <span class="entity">tm</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">check_if</span> <span class="entity">tm</span> <span class="main">=</span>
    <span class="entity">fixed_args</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">head</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> Term.aconv_untyped <span class="main">(</span><span class="entity">head</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">If</span><span class="antiquote">}</span></span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> SOME <span class="inner_numeral">3</span> <span class="keyword2"><span class="keyword">else</span></span> NONE<span class="main">)</span> <span class="entity">tm</span>
    |&gt; Option.map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span> <span class="main">=&gt;</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">arg_convs</span><span class="main">,</span> <span class="entity">args'</span><span class="main">)</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">check_cont</span> <span class="entity">lift_dict</span><span class="main">)</span> <span class="entity">args</span> |&gt; split_list
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">conv</span> <span class="main">=</span> <span class="entity">list_conv</span> <span class="main">(</span>K Conv.all_conv<span class="main">,</span> <span class="entity">arg_convs</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tm'</span> <span class="main">=</span> list_comb <span class="main">(</span>Const <span class="main">(</span><span class="main">#</span>if_termN <span class="entity">monad_consts</span><span class="main">,</span> dummyT<span class="main">)</span><span class="main">,</span> <span class="entity">args'</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="entity">conv</span><span class="main">,</span> <span class="entity">tm'</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">check_abs</span> <span class="entity">tm</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">tm</span> <span class="keyword2"><span class="keyword">of</span></span>
      Abs <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">typ</span><span class="main">,</span> <span class="entity">body</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">name'</span><span class="main">,</span> <span class="entity">body'</span><span class="main">)</span> <span class="main">=</span> Term.dest_abs <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">typ</span><span class="main">,</span> <span class="entity">body</span><span class="main">)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">conv</span><span class="main">,</span> <span class="entity">tm'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">lift_abs'</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">name'</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span> <span class="entity">check_cont</span> <span class="entity">lift_dict</span> <span class="entity">body'</span>
          <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">convT</span> <span class="entity">lthy</span> <span class="main">=</span> <span class="entity">conv</span> <span class="entity">lthy</span> then_conv <span class="entity">wrap_mark_conv</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tmT</span> <span class="main">=</span> <span class="main">#</span>return <span class="entity">monad_consts</span> <span class="entity">tm'</span>
        <span class="keyword2"><span class="keyword">in</span></span> SOME <span class="main">(</span><span class="entity">convT</span><span class="main">,</span> <span class="entity">tmT</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>
    <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> NONE

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">check_case</span> <span class="entity">tm</span> <span class="main">=</span>
    <span class="entity">fixed_args</span> <span class="main">(</span><span class="entity">lookup_case_term</span> #&gt; Option.map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">cs</span> <span class="main">=&gt;</span> <span class="entity">term_nargs</span> <span class="entity">cs</span> - <span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span> <span class="entity">tm</span>
    |&gt; Option.map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">head</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span> <span class="main">=&gt;</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">case_name</span><span class="main">,</span> <span class="entity">case_type</span><span class="main">)</span> <span class="main">=</span> <span class="entity">lookup_case_term</span> <span class="entity">head</span> |&gt; the |&gt; dest_Const
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">clause_typs</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span>
          strip_type <span class="entity">case_type</span> |&gt;&gt; split_last
        
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">clase_nparams</span> <span class="main">=</span> <span class="entity">clause_typs</span> |&gt; map <span class="entity">type_nargs</span>
        <span class="comment1">(* ('a⇒'b) ⇒ ('a⇒'b) |&gt; type_nargs = 1*)</span>
  
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">lift_clause</span> <span class="entity">n_param</span> <span class="entity">clause</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">vars_name_typ</span><span class="main">,</span> <span class="entity">body</span><span class="main">)</span> <span class="main">=</span> Term.strip_abs_eta <span class="entity">n_param</span> <span class="entity">clause</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">abs_lift_wraps</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">lift_abs'</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">vars_name_typ</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lift_wrap</span> <span class="main">=</span> Library.foldr <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> o<span class="main">)</span> <span class="main">(</span><span class="entity">abs_lift_wraps</span><span class="main">,</span> I<span class="main">)</span> <span class="entity">check_cont</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">conv</span><span class="main">,</span> <span class="entity">clauseT</span><span class="main">)</span> <span class="main">=</span> <span class="entity">lift_wrap</span> <span class="entity">lift_dict</span> <span class="entity">body</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="main">(</span><span class="entity">conv</span><span class="main">,</span> <span class="entity">clauseT</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>
  
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">head'</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">case_name</span><span class="main">,</span> dummyT<span class="main">)</span> <span class="comment1">(* clauses are sufficient for type inference *)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">convs</span><span class="main">,</span> <span class="entity">clauses'</span><span class="main">)</span> <span class="main">=</span> map2 <span class="entity">lift_clause</span> <span class="entity">clase_nparams</span> <span class="entity">args</span> |&gt; split_list

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">conv</span> <span class="entity">lthy</span> <span class="main">=</span> <span class="entity">list_conv</span> <span class="main">(</span>K Conv.all_conv<span class="main">,</span> <span class="entity">convs</span><span class="main">)</span> <span class="entity">lthy</span> then_conv <span class="entity">wrap_mark_conv</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tm'</span> <span class="main">=</span> <span class="main">#</span>return <span class="entity">monad_consts</span> <span class="main">(</span>list_comb <span class="main">(</span><span class="entity">head'</span><span class="main">,</span> <span class="entity">clauses'</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="entity">conv</span><span class="main">,</span> <span class="entity">tm'</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">check_app</span> <span class="entity">tm</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">tm</span> <span class="keyword2"><span class="keyword">of</span></span>
      <span class="entity">f</span> $ <span class="entity">x</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">f_conv</span><span class="main">,</span> <span class="entity">tmf</span><span class="main">)</span> <span class="main">=</span> <span class="entity">check_cont</span> <span class="entity">lift_dict</span> <span class="entity">f</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">x_conv</span><span class="main">,</span> <span class="entity">tmx</span><span class="main">)</span> <span class="main">=</span> <span class="entity">check_cont_arg</span> <span class="entity">lift_dict</span> <span class="entity">x</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tm'</span> <span class="main">=</span> <span class="main">#</span>app <span class="entity">monad_consts</span> <span class="main">(</span><span class="entity">tmf</span><span class="main">,</span> <span class="entity">tmx</span><span class="main">)</span>
          <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">conv</span> <span class="entity">lthy</span> <span class="main">=</span> Conv.combination_conv <span class="main">(</span><span class="entity">f_conv</span> <span class="entity">lthy</span> then_conv <span class="entity">app_mark_conv</span><span class="main">)</span> <span class="main">(</span><span class="entity">x_conv</span> <span class="entity">lthy</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          SOME <span class="main">(</span><span class="entity">conv</span><span class="main">,</span> <span class="entity">tm'</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span>
    <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> NONE

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">check_pure</span> <span class="entity">tm</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">tm</span> |&gt; exists_subterm <span class="main">(</span>AList.defined <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span> <span class="entity">lift_dict</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">orelse</span></span> not <span class="main">(</span><span class="entity">is_1st_term</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span> <span class="entity">tm</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">then</span></span> NONE
      <span class="keyword2"><span class="keyword">else</span></span> SOME <span class="main">(</span><span class="entity">wrap_1st_term</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span> <span class="entity">tm</span> NONE true<span class="main">)</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">choke</span> <span class="entity">tm</span> <span class="main">=</span>
    <span class="keyword3"><span class="keyword">raise</span></span> TERM<span class="main">(</span><span class="inner_quoted">"cannot process term"</span><span class="main">,</span> <span class="main">[</span><span class="entity">tm</span><span class="main">]</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">checks</span> <span class="main">=</span> <span class="main">[</span>
    <span class="entity">check_pure</span><span class="main">,</span>
    <span class="entity">check_const</span><span class="main">,</span>
    <span class="entity">check_case</span><span class="main">,</span>
    <span class="entity">check_if</span><span class="main">,</span>
    <span class="entity">check_abs</span><span class="main">,</span>
    <span class="entity">check_app</span><span class="main">,</span>
    <span class="entity">check_dict</span><span class="main">,</span>
    <span class="entity">check_1st_atom</span><span class="main">,</span>
    <span class="entity">choke</span>
  <span class="main">]</span>
  <span class="keyword2"><span class="keyword">in</span></span> get_first <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">check</span> <span class="main">=&gt;</span> <span class="entity">check</span> <span class="entity">tm</span><span class="main">)</span> <span class="entity">checks</span> |&gt; the <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rewrite_pureapp_beta_conv</span> <span class="entity">ctm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">case</span></span> Thm.term_of <span class="entity">ctm</span> <span class="keyword2"><span class="keyword">of</span></span>
    Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Pure_Monad.App<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span>
      $ <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Pure_Monad.Wrap<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ Abs <span class="main">_</span><span class="main">)</span>
      $ <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Pure_Monad.Wrap<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">_</span><span class="main">)</span>
      <span class="main">=&gt;</span> Conv.rewr_conv <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Wrap_App_Wrap<span class="antiquote">}</span></span></span> <span class="entity">ctm</span>
  <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> Conv.no_conv <span class="entity">ctm</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">monadify</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span> <span class="entity">tm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">tm</span><span class="main">)</span> <span class="main">=</span> <span class="entity">lift_term</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="entity">tm</span>
    <span class="comment1">(*val tm = rewrite_return_app_return tm*)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tm</span> <span class="main">=</span> Syntax.check_term <span class="entity">ctxt</span> <span class="entity">tm</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">tm</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">wrap_head</span> <span class="main">(</span><span class="entity">monad_consts</span><span class="main">:</span> <span class="entity">Transform_Const.MONAD_CONSTS</span><span class="main">)</span> <span class="entity">head</span> <span class="entity">n_args</span> <span class="main">=</span>
  Library.foldr
    <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">typ</span><span class="main">,</span> <span class="entity">tm</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">#</span>return <span class="entity">monad_consts</span> <span class="main">(</span>absdummy <span class="entity">typ</span> <span class="entity">tm</span><span class="main">)</span><span class="main">)</span>
    <span class="main">(</span>replicate <span class="entity">n_args</span> dummyT<span class="main">,</span> list_comb <span class="main">(</span><span class="entity">head</span><span class="main">,</span> rev <span class="main">(</span>map_range Bound <span class="entity">n_args</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">lift_head</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span> <span class="entity">head</span> <span class="entity">n_args</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dest_head</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> is_Const <span class="entity">head</span> <span class="keyword2"><span class="keyword">then</span></span> dest_Const <span class="keyword2"><span class="keyword">else</span></span> dest_Free
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">head_name</span><span class="main">,</span> <span class="entity">head_typ</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_head</span> <span class="entity">head</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">arg_typs</span><span class="main">,</span> <span class="entity">body_typ</span><span class="main">)</span> <span class="main">=</span> strip_type <span class="entity">head_typ</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">arg_typs0</span><span class="main">,</span> <span class="entity">arg_typs1</span><span class="main">)</span> <span class="main">=</span> chop <span class="entity">n_args</span> <span class="entity">arg_typs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg_typs0'</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">lift_type'</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">arg_typs0</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg_typs1T</span> <span class="main">=</span> <span class="entity">lift_type</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">arg_typs1</span> ---&gt; <span class="entity">body_typ</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">head_typ'</span> <span class="main">=</span> <span class="entity">arg_typs0'</span> ---&gt; <span class="entity">arg_typs1T</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">head'</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">head_name</span><span class="main">,</span> <span class="entity">head_typ'</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">head_conv</span><span class="main">,</span> <span class="entity">headT</span><span class="main">)</span> <span class="main">=</span> <span class="entity">wrap_1st_term</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span> <span class="entity">head'</span> <span class="main">(</span>SOME <span class="entity">n_args</span><span class="main">)</span> false
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="entity">head'</span><span class="main">,</span> <span class="main">(</span><span class="entity">head_conv</span><span class="main">,</span> <span class="entity">headT</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">lift_equation</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="entity">memoizer_opt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">head</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span> <span class="main">=</span> strip_comb <span class="entity">lhs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">n_args</span> <span class="main">=</span> length <span class="entity">args</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">head'</span><span class="main">,</span> <span class="main">(</span><span class="entity">head_conv</span><span class="main">,</span> <span class="entity">headT</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">lift_head</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span> <span class="entity">head</span> <span class="entity">n_args</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args'</span> <span class="main">=</span> <span class="entity">args</span> |&gt; map <span class="main">(</span>map_aterms <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">tm</span> <span class="main">=&gt;</span> <span class="entity">tm</span> |&gt; map_types
      <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> is_Const <span class="entity">tm</span> <span class="keyword2"><span class="keyword">then</span></span> K dummyT <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">lift_type'</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs'</span> <span class="main">=</span> list_comb <span class="main">(</span><span class="entity">head'</span><span class="main">,</span> <span class="entity">args'</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">frees</span> <span class="main">=</span> fold Term.add_frees <span class="entity">args</span> <span class="main">[</span><span class="main">]</span>
     |&gt; filter_out <span class="main">(</span><span class="entity">is_atom_type</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span> o snd<span class="main">)</span>
    
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lift_dict_args</span> <span class="main">=</span> <span class="entity">frees</span> |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span>
      Free <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span><span class="main">,</span> 
      <span class="main">(</span>K <span class="entity">wrap_mark_conv</span><span class="main">,</span>
       <span class="main">#</span>return <span class="entity">monad_consts</span> <span class="main">(</span>Free <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">lift_type'</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span> <span class="entity">typ</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lift_dict</span> <span class="main">=</span> <span class="main">(</span><span class="entity">head</span><span class="main">,</span> <span class="main">(</span><span class="entity">head_conv</span><span class="main">,</span> <span class="entity">headT</span><span class="main">)</span><span class="main">)</span> :: <span class="entity">lift_dict_args</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">rhs_conv</span><span class="main">,</span> <span class="entity">rhsT</span><span class="main">)</span> <span class="main">=</span> <span class="entity">lift_term</span> <span class="entity">monad_consts</span> <span class="entity">ctxt</span> <span class="entity">lift_dict</span> <span class="entity">rhs</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhsT_memoized</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">memoizer_opt</span> <span class="keyword2"><span class="keyword">of</span></span>
      SOME <span class="entity">memoizer</span> <span class="main">=&gt;</span>
        <span class="entity">memoizer</span>
        $ <span class="entity">HOLogic.mk_tuple</span> <span class="entity">args</span>
        $ <span class="entity">rhsT</span>
    <span class="main">|</span> NONE <span class="main">=&gt;</span> <span class="entity">rhsT</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eqs'</span> <span class="main">=</span> <span class="main">(</span><span class="entity">lhs'</span><span class="main">,</span> <span class="entity">rhsT_memoized</span><span class="main">)</span> |&gt; <span class="entity">HOLogic.mk_eq</span> |&gt; <span class="entity">HOLogic.mk_Trueprop</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="entity">rhs_conv</span><span class="main">,</span> <span class="entity">eqs'</span><span class="main">,</span> <span class="entity">n_args</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/Transform.ML">
<div class="head">
<h1>File ‹Transform.ML›</h1>
</div>
<pre class="source"><span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Transform_DP</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dp_interpretation</span> <span class="entity">standard_proof</span> <span class="entity">locale_name</span> <span class="entity">instance</span> <span class="entity">qualifier</span> <span class="entity">dp_term</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="entity">lthy</span>
  |&gt; <span class="entity">Interpretation.isar_interpretation</span> <span class="main">(</span><span class="main">[</span><span class="main">(</span><span class="entity">locale_name</span><span class="main">,</span> <span class="main">(</span><span class="main">(</span><span class="entity">qualifier</span><span class="main">,</span> true<span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">Expression.Named</span> <span class="main">(</span><span class="main">(</span><span class="inner_quoted">"dp"</span><span class="main">,</span> <span class="entity">dp_term</span><span class="main">)</span> :: <span class="entity">instance</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
  |&gt; <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">standard_proof</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">Proof.global_default_proof</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">Proof.global_immediate_proof</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prep_params</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">scope</span><span class="main">,</span> <span class="entity">tm_str</span><span class="main">)</span><span class="main">,</span> <span class="entity">def_thms_opt</span><span class="main">)</span><span class="main">,</span> <span class="entity">mem_locale_opt</span><span class="main">)</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tm</span> <span class="main">=</span> Syntax.read_term <span class="entity">lthy</span> <span class="entity">tm_str</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">scope'</span> <span class="main">=</span> <span class="main">(</span>Binding.is_empty <span class="entity">scope</span>? Binding.map_name <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">Transform_Misc.term_name</span> <span class="entity">tm</span> ^ <span class="inner_quoted">"<span class="hidden">⇩</span><sub>T</sub>"</span><span class="main">)</span><span class="main">)</span> <span class="entity">scope</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">def_thms_opt'</span> <span class="main">=</span> Option.map <span class="main">(</span><span class="entity">Attrib.eval_thms</span> <span class="entity">lthy</span><span class="main">)</span> <span class="entity">def_thms_opt</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mem_locale_opt'</span> <span class="main">=</span> Option.map <span class="main">(</span><span class="entity">Locale.check</span> <span class="main">(</span>Proof_Context.theory_of <span class="entity">lthy</span><span class="main">)</span><span class="main">)</span> <span class="entity">mem_locale_opt</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="entity">scope'</span><span class="main">,</span> <span class="entity">tm</span><span class="main">,</span> <span class="entity">def_thms_opt'</span><span class="main">,</span> <span class="entity">mem_locale_opt'</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*
fun dp_interpretation_cmd args lthy =
  let
    val (scope, tm, _, mem_locale_opt) = prep_params args lthy
    val scope_name = Binding.name_of scope
  in
    case mem_locale_opt of
      NONE =&gt; lthy
    | SOME x =&gt; dp_interpretation x scope_name (Transform_Misc.uncurry tm) lthy
  end
*)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">do_monadify</span> <span class="entity">heap_name</span> <span class="entity">scope</span> <span class="entity">tm</span> <span class="entity">mem_locale_opt</span> <span class="entity">def_thms_opt</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">monad_consts</span> <span class="main">=</span> <span class="entity">Transform_Const.get_monad_const</span> <span class="entity">heap_name</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">scope_name</span> <span class="main">=</span> Binding.name_of <span class="entity">scope</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">memoizer_opt</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> is_none <span class="entity">mem_locale_opt</span> <span class="keyword2"><span class="keyword">then</span></span> NONE <span class="keyword2"><span class="keyword">else</span></span>
      SOME <span class="main">(</span><span class="entity">Transform_Misc.locale_term</span> <span class="entity">lthy</span> <span class="entity">scope_name</span> <span class="inner_quoted">"checkmem"</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">old_info_opt</span> <span class="main">=</span> <span class="entity">Function_Common.import_function_data</span> <span class="entity">tm</span> <span class="entity">lthy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">old_defs_opt</span> <span class="main">=</span> <span class="main">[</span>
      K <span class="entity">def_thms_opt</span><span class="main">,</span>
      K <span class="main">(</span>Option.mapPartial <span class="main">#</span>simps <span class="entity">old_info_opt</span><span class="main">)</span>
    <span class="main">]</span> |&gt; Library.get_first <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="entity">x</span> <span class="main">(</span><span class="main">)</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">old_defs</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">old_defs_opt</span> <span class="keyword2"><span class="keyword">of</span></span>
      SOME <span class="entity">defs</span> <span class="main">=&gt;</span> <span class="entity">defs</span>
    <span class="main">|</span> NONE <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> TERM<span class="main">(</span><span class="inner_quoted">"no definition"</span><span class="main">,</span> <span class="main">[</span><span class="entity">tm</span><span class="main">]</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">old_defs_imported</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> Variable.import true <span class="entity">old_defs</span> <span class="entity">lthy</span>
<span class="comment1">(*
    val new_bind = Binding.suffix_name "<span class="hidden">⇩</span><sub>T</sub>'" scope
    val new_bindT = Binding.suffix_name "<span class="hidden">⇩</span><sub>T</sub>" scope
*)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">new_bind</span> <span class="main">=</span> Binding.suffix_name <span class="inner_quoted">"'"</span> <span class="entity">scope</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">new_bindT</span> <span class="main">=</span> <span class="entity">scope</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_def</span> <span class="main">(</span><span class="entity">def</span><span class="main">,</span> <span class="entity">def_imported</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">def_imported_meta</span> <span class="main">=</span> <span class="entity">def_imported</span> |&gt; Local_Defs.meta_rewrite_rule <span class="entity">lthy</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eqs</span> <span class="main">=</span> <span class="entity">def_imported_meta</span> |&gt; Thm.full_prop_of
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">head</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> Logic.dest_equals <span class="entity">eqs</span> |&gt; fst |&gt; <span class="entity">Transform_Misc.behead</span> <span class="entity">tm</span>

        <span class="comment1">(*val _ = if Term.aconv_untyped (head, tm) then () else raise THM("invalid definition", 0, [def])*)</span>
        <span class="keyword1"><span class="keyword">val</span></span> Abs <span class="entity">t</span> <span class="main">=</span> Term.lambda_name <span class="main">(</span>Binding.name_of <span class="entity">new_bind</span><span class="main">,</span> <span class="entity">head</span><span class="main">)</span> <span class="entity">eqs</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">t_name</span><span class="main">,</span> <span class="entity">eqs'</span><span class="main">)</span> <span class="main">=</span> Term.dest_abs <span class="entity">t</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="entity"><span class="antiquote">@{</span><span class="operator">assert</span><span class="antiquote">}</span></span></span></span> <span class="main">(</span><span class="entity">t_name</span> <span class="main">=</span> Binding.name_of <span class="entity">new_bind</span><span class="main">)</span>

        <span class="comment1">(*val eqs' = Term.subst_atomic [(head, Free (Binding.name_of new_bind, fastype_of head))] eqs*)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">rhs_conv</span><span class="main">,</span> <span class="entity">eqsT</span><span class="main">,</span> <span class="entity">n_args</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Transform_Term.lift_equation</span> <span class="entity">monad_consts</span> <span class="entity">lthy</span> <span class="main">(</span>Logic.dest_equals <span class="entity">eqs'</span><span class="main">)</span> <span class="entity">memoizer_opt</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">def_meta'</span> <span class="main">=</span> <span class="entity">def</span> |&gt; Local_Defs.meta_rewrite_rule <span class="entity">lthy</span> |&gt; Conv.fconv_rule <span class="main">(</span>Conv.arg_conv <span class="main">(</span><span class="entity">rhs_conv</span> <span class="entity">lthy</span><span class="main">)</span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">def_meta_simped</span> <span class="main">=</span> <span class="entity">def_meta'</span>
          |&gt; Conv.fconv_rule <span class="main">(</span>
               <span class="entity">repeat_sweep_conv</span> <span class="main">(</span>K <span class="entity">Transform_Term.rewrite_pureapp_beta_conv</span><span class="main">)</span> <span class="entity">lthy</span>
             <span class="main">)</span>
<span class="comment1">(*
        val eqsT_simped = eqsT
          |&gt; Syntax.check_term lthy
          |&gt; Thm.cterm_of lthy
          |&gt; repeat_sweep_conv (K Transform_Term.rewrite_app_beta_conv) lthy
          |&gt; Thm.full_prop_of |&gt; Logic.dest_equals |&gt; snd
*)</span>

      <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">def_meta_simped</span><span class="main">,</span> <span class="entity">eqsT</span><span class="main">)</span><span class="main">,</span> <span class="entity">n_args</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">old_defs'</span><span class="main">,</span> <span class="entity">new_defs_raw</span><span class="main">)</span><span class="main">,</span> <span class="entity">n_args</span><span class="main">)</span> <span class="main">=</span>
      map <span class="entity">dest_def</span> <span class="main">(</span><span class="entity">old_defs</span> ~~ <span class="entity">old_defs_imported</span><span class="main">)</span>
      |&gt; split_list |&gt;&gt; split_list
      ||&gt; <span class="entity">Transform_Misc.the_element</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">new_defs</span> <span class="main">=</span> Syntax.check_props <span class="entity">lthy</span> <span class="entity">new_defs_raw</span> |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">eqsT</span> <span class="main">=&gt;</span> <span class="entity">eqsT</span>
      |&gt; Thm.cterm_of <span class="entity">lthy</span>
      |&gt; <span class="entity">repeat_sweep_conv</span> <span class="main">(</span>K <span class="main">(</span><span class="main">#</span>rewrite_app_beta_conv <span class="entity">monad_consts</span><span class="main">)</span><span class="main">)</span> <span class="entity">lthy</span>
      |&gt; Thm.full_prop_of |&gt; Logic.dest_equals |&gt; snd<span class="main">)</span>

    <span class="comment1">(*val _ = map (Pretty.writeln o Syntax.pretty_term @{context} o Thm.full_prop_of) old_defs'*)</span>
    <span class="comment1">(*val (new_defs, lthy) = Variable.importT_terms new_defs lthy*)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">new_info</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Transform_Misc.add_function</span> <span class="entity">new_bind</span> <span class="entity">new_defs</span> <span class="entity">lthy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">replay_tac</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">old_info_opt</span> <span class="keyword2"><span class="keyword">of</span></span>
      NONE <span class="main">=&gt;</span> no_tac
    <span class="main">|</span> SOME <span class="entity">info</span> <span class="main">=&gt;</span> <span class="entity">Transform_Tactic.totality_replay_tac</span> <span class="entity">info</span> <span class="entity">new_info</span> <span class="entity">lthy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">totality_tac</span> <span class="main">=</span>
      <span class="entity">replay_tac</span>
      ORELSE <span class="main">(</span><span class="entity">Function_Common.termination_prover_tac</span> false <span class="entity">lthy</span>
        THEN <span class="entity">Transform_Tactic.my_print_tac</span> <span class="inner_quoted">"termination by default prover"</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">new_info</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Function.prove_termination</span> NONE <span class="entity">totality_tac</span> <span class="entity">lthy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">new_def'</span> <span class="main">=</span> <span class="entity">new_info</span> |&gt; <span class="main">#</span>simps |&gt; the

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">head'</span> <span class="main">=</span> <span class="entity">new_info</span> |&gt; <span class="main">#</span>fs |&gt; the_single
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">headT</span> <span class="main">=</span> <span class="entity">Transform_Term.wrap_head</span> <span class="entity">monad_consts</span> <span class="entity">head'</span> <span class="entity">n_args</span> |&gt; Syntax.check_term <span class="entity">lthy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">headTC</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">new_defT</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span> Local_Theory.define <span class="main">(</span><span class="main">(</span><span class="entity">new_bindT</span><span class="main">,</span> NoSyn<span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">(</span>Thm.def_binding <span class="entity">new_bindT</span><span class="main">,</span><span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">headT</span><span class="main">)</span><span class="main">)</span> <span class="entity">lthy</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lthy</span> <span class="main">=</span> <span class="entity">Transform_Data.commit_dp_info</span> <span class="main">(</span><span class="main">#</span>monad_name <span class="entity">monad_consts</span><span class="main">)</span> <span class="main">(</span><span class="main">{</span>
      old_head <span class="main">=</span> <span class="entity">tm</span><span class="main">,</span>
      new_head' <span class="main">=</span> <span class="entity">head'</span><span class="main">,</span>
      new_headT <span class="main">=</span> <span class="entity">headTC</span><span class="main">,</span>

      old_defs <span class="main">=</span> <span class="entity">old_defs'</span><span class="main">,</span>
      new_def' <span class="main">=</span> <span class="entity">new_def'</span><span class="main">,</span>
      new_defT <span class="main">=</span> <span class="entity">new_defT</span>
    <span class="main">}</span><span class="main">)</span> <span class="entity">lthy</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">Proof_Display.print_consts</span> true <span class="main">(</span>Position.thread_data <span class="main">(</span><span class="main">)</span><span class="main">)</span> <span class="entity">lthy</span> <span class="main">(</span>K false<span class="main">)</span> <span class="main">[</span>
      <span class="main">(</span>Binding.name_of <span class="entity">new_bind</span><span class="main">,</span> Term.type_of <span class="entity">head'</span><span class="main">)</span><span class="main">,</span>
      <span class="main">(</span>Binding.name_of <span class="entity">new_bindT</span><span class="main">,</span> Term.type_of <span class="entity">headTC</span><span class="main">)</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">lthy</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">gen_dp_monadify</span> <span class="entity">prep_term</span> <span class="entity">args</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">scope</span><span class="main">,</span> <span class="entity">tm</span><span class="main">,</span> <span class="entity">def_thms_opt</span><span class="main">,</span> <span class="entity">mem_locale_opt</span><span class="main">)</span> <span class="main">=</span> <span class="entity">prep_params</span> <span class="entity">args</span> <span class="entity">lthy</span>
<span class="comment1">(*
    val memoizer_opt = memoizer_scope_opt |&gt; Option.map (fn memoizer_scope =&gt;
      Syntax.read_term lthy (Long_Name.qualify memoizer_scope Transform_Const.checkmemVN))
    val _ = memoizer_opt |&gt; Option.map (fn memoizer =&gt;
      if Term.aconv_untyped (head_of memoizer, @{term mem_defs.checkmem})
        then () else raise TERM("invalid memoizer", [the memoizer_opt]))
*)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">do_monadify</span> <span class="inner_quoted">"state"</span> <span class="entity">scope</span> <span class="entity">tm</span> <span class="entity">mem_locale_opt</span> <span class="entity">def_thms_opt</span> <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dp_monadify_cmd</span> <span class="main">=</span> <span class="entity">gen_dp_monadify</span> Syntax.read_term

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dp_fun_part1_cmd</span> <span class="main">(</span><span class="main">(</span><span class="entity">scope</span><span class="main">,</span> <span class="entity">tm_str</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">mem_locale_instance_opt</span><span class="main">)</span><span class="main">)</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">scope_name</span> <span class="main">=</span> Binding.name_of <span class="entity">scope</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tm</span> <span class="main">=</span> Syntax.read_term <span class="entity">lthy</span> <span class="entity">tm_str</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> is_Free <span class="entity">tm</span> <span class="keyword2"><span class="keyword">then</span></span> warning <span class="main">(</span><span class="inner_quoted">"Free term: "</span> ^ <span class="main">(</span>Syntax.pretty_term <span class="entity">lthy</span> <span class="entity">tm</span> |&gt; Pretty.string_of<span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mem_locale_opt'</span> <span class="main">=</span> Option.map <span class="main">(</span><span class="entity">Locale.check</span> <span class="main">(</span>Proof_Context.theory_of <span class="entity">lthy</span><span class="main">)</span> o <span class="main">(</span>snd o fst<span class="main">)</span><span class="main">)</span> <span class="entity">mem_locale_instance_opt</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lthy_f</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">mem_locale_instance_opt</span> <span class="keyword2"><span class="keyword">of</span></span>
      NONE <span class="main">=&gt;</span> I
    <span class="main">|</span> SOME <span class="main">(</span><span class="main">(</span><span class="entity">standard_proof</span><span class="main">,</span> <span class="entity">locale_name</span><span class="main">)</span><span class="main">,</span> <span class="entity">instance</span><span class="main">)</span> <span class="main">=&gt;</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">locale_name</span> <span class="main">=</span> <span class="entity">Locale.check</span> <span class="main">(</span>Proof_Context.theory_of <span class="entity">lthy</span><span class="main">)</span> <span class="entity">locale_name</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">instance</span> <span class="main">=</span> map <span class="main">(</span>apsnd <span class="main">(</span>Syntax.read_term <span class="entity">lthy</span><span class="main">)</span><span class="main">)</span> <span class="entity">instance</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="entity">dp_interpretation</span> <span class="entity">standard_proof</span> <span class="entity">locale_name</span> <span class="entity">instance</span> <span class="entity">scope_name</span> <span class="main">(</span><span class="entity">Transform_Misc.uncurry</span> <span class="entity">tm</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lthy</span> <span class="main">=</span> <span class="entity">lthy_f</span> <span class="entity">lthy</span>
   <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lthy</span> <span class="main">=</span> <span class="entity">Transform_Data.add_tmp_cmd_info</span> <span class="main">(</span>Binding.reset_pos <span class="entity">scope</span><span class="main">,</span> <span class="entity">tm</span><span class="main">,</span> <span class="entity">mem_locale_opt'</span><span class="main">)</span> <span class="entity">lthy</span>
    
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dp_fun_part2_cmd</span> <span class="main">(</span><span class="entity">heap_name</span><span class="main">,</span> <span class="entity">def_thms_str</span><span class="main">)</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">scope</span><span class="main">,</span> head<span class="main">=</span><span class="entity">tm</span><span class="main">,</span> locale<span class="main">=</span><span class="entity">locale_opt</span><span class="main">,</span> dp_info<span class="main">=</span><span class="entity">dp_info_opt</span><span class="main">}</span> <span class="main">=</span> <span class="entity">Transform_Data.get_last_cmd_info</span> <span class="entity">lthy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> is_none <span class="entity">dp_info_opt</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword3"><span class="keyword">raise</span></span> TERM<span class="main">(</span><span class="inner_quoted">"already monadified"</span><span class="main">,</span> <span class="main">[</span><span class="entity">tm</span><span class="main">]</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">def_thms</span> <span class="main">=</span> <span class="entity">Attrib.eval_thms</span> <span class="entity">lthy</span> <span class="entity">def_thms_str</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">heap_typ</span> <span class="main">=</span> Syntax.read_typ
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lthy</span> <span class="main">=</span> <span class="entity">do_monadify</span> <span class="entity">heap_name</span> <span class="entity">scope</span> <span class="entity">tm</span> <span class="entity">locale_opt</span> <span class="main">(</span>SOME <span class="entity">def_thms</span><span class="main">)</span> <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dp_correct_cmd</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">scope</span><span class="main">,</span> head<span class="main">=</span><span class="entity">tm</span><span class="main">,</span> locale<span class="main">=</span><span class="entity">locale_opt</span><span class="main">,</span> dp_info<span class="main">=</span><span class="entity">dp_info_opt</span><span class="main">}</span> <span class="main">=</span> <span class="entity">Transform_Data.get_last_cmd_info</span> <span class="entity">lthy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dp_info</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">dp_info_opt</span> <span class="keyword2"><span class="keyword">of</span></span> SOME <span class="entity">x</span> <span class="main">=&gt;</span> <span class="entity">x</span> <span class="main">|</span> NONE <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> TERM<span class="main">(</span><span class="inner_quoted">"not yet monadified"</span><span class="main">,</span> <span class="main">[</span><span class="entity">tm</span><span class="main">]</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> is_some <span class="entity">locale_opt</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword3"><span class="keyword">raise</span></span> TERM<span class="main">(</span><span class="inner_quoted">"not interpreted yet"</span><span class="main">,</span> <span class="main">[</span><span class="entity">tm</span><span class="main">]</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">scope_name</span> <span class="main">=</span> Binding.name_of <span class="entity">scope</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">consistentDP</span> <span class="main">=</span> <span class="entity">Transform_Misc.locale_term</span> <span class="entity">lthy</span> <span class="entity">scope_name</span> <span class="inner_quoted">"consistentDP"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dpT'</span> <span class="main">=</span> <span class="main">#</span>new_head' <span class="entity">dp_info</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dpT'_curried</span> <span class="main">=</span> <span class="entity">dpT'</span> |&gt; <span class="entity">Transform_Misc.uncurry</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goal_pat</span> <span class="main">=</span> <span class="entity">consistentDP</span> $ <span class="entity">dpT'_curried</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goal_prop</span> <span class="main">=</span> Syntax.check_term <span class="entity">lthy</span> <span class="main">(</span><span class="entity">HOLogic.mk_Trueprop</span> <span class="entity">goal_pat</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tuple_pat</span> <span class="main">=</span> type_of <span class="entity">dpT'</span> |&gt; strip_type |&gt; fst |&gt; length
      |&gt; Name.invent_list <span class="main">[</span><span class="main">]</span> <span class="inner_quoted">"a"</span>
      |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">s</span> <span class="main">=&gt;</span> Var <span class="main">(</span><span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span> TVar <span class="main">(</span><span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">type</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      |&gt; <span class="entity">HOLogic.mk_tuple</span>
      |&gt; Thm.cterm_of <span class="entity">lthy</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">memoized_thm_opt</span> <span class="main">=</span> <span class="entity">Transform_Misc.locale_thms</span> <span class="entity">lthy</span> <span class="entity">scope_name</span> <span class="inner_quoted">"memoized"</span> |&gt; the_single |&gt; SOME
      <span class="keyword3"><span class="keyword">handle</span></span> ERROR <span class="entity">msg</span> <span class="main">=&gt;</span> <span class="main">(</span>warning <span class="entity">msg</span><span class="main">;</span> NONE<span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">memoized_thm'_opt</span> <span class="main">=</span> <span class="entity">memoized_thm_opt</span>
      |&gt; Option.map <span class="main">(</span>Drule.infer_instantiate' <span class="entity">lthy</span> <span class="main">[</span>NONE<span class="main">,</span> SOME <span class="entity">tuple_pat</span><span class="main">]</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">display_thms</span> <span class="entity">thm_binds</span> <span class="entity">ctxt</span> <span class="main">=</span>
      <span class="entity">Proof_Display.print_results</span> true <span class="main">(</span>Position.thread_data <span class="main">(</span><span class="main">)</span><span class="main">)</span> <span class="entity">ctxt</span><span class="main">(</span><span class="main">(</span>Thm.theoremK<span class="main">,</span> <span class="inner_quoted">""</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="entity">thm_binds</span><span class="main">]</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">crel_thm_name</span> <span class="main">=</span> <span class="inner_quoted">"crel"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">memoized_thm_name</span> <span class="main">=</span> <span class="inner_quoted">"memoized_correct"</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">afterqed</span> <span class="entity">thmss</span> <span class="entity">ctxt</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">[</span><span class="main">[</span><span class="entity">crel_thm</span><span class="main">]</span><span class="main">]</span> <span class="main">=</span> <span class="entity">thmss</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">crel_thm_binds</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="main">=</span> Local_Theory.note <span class="main">(</span>
          <span class="main">(</span>Binding.qualify_name true <span class="entity">scope</span> <span class="entity">crel_thm_name</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
          <span class="main">[</span><span class="entity">crel_thm</span><span class="main">]</span>
        <span class="main">)</span> <span class="entity">ctxt</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">display_thms</span> <span class="entity">crel_thm_binds</span> <span class="entity">ctxt</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">memoized_thm'_opt</span> <span class="keyword2"><span class="keyword">of</span></span> NONE <span class="main">=&gt;</span> <span class="entity">ctxt</span> <span class="main">|</span> SOME <span class="entity">memoized_thm'</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">memoized_thm_binds</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="main">=</span> Local_Theory.note <span class="main">(</span>
            <span class="main">(</span>Binding.qualify_name true <span class="entity">scope</span> <span class="entity">memoized_thm_name</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
            <span class="main">[</span><span class="main">(</span><span class="entity">crel_thm</span> RS <span class="entity">memoized_thm'</span><span class="main">)</span> |&gt; Local_Defs.unfold <span class="entity">lthy</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> prod.case<span class="antiquote">}</span></span></span><span class="main">]</span>
          <span class="main">)</span> <span class="entity">ctxt</span>

          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">display_thms</span> <span class="entity">memoized_thm_binds</span> <span class="entity">ctxt</span>
        <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">ctxt</span> <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="entity">ctxt</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goal</span> <span class="main">=</span> <span class="entity">Proof.theorem</span> NONE <span class="entity">afterqed</span> <span class="main">[</span><span class="main">[</span><span class="main">(</span><span class="entity">goal_prop</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">]</span><span class="main">]</span> <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">goal</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/Transform_Parser.ML">
<div class="head">
<h1>File ‹Transform_Parser.ML›</h1>
</div>
<pre class="source"><span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Transform_Parser</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dp_fun_parser</span> <span class="main">=</span>
  Parse.binding <span class="comment1">(* name of instantiation and monadified term *)</span>

<span class="comment1">(*
fun dp_fun binding =
  Transform_Data.update_last_binding binding
*)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">memoizes_parser</span> <span class="main">=</span>
  Parse.name_position <span class="comment1">(* name of locale, e.g. dp_consistency_rbt *)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">monadifies_parser</span> <span class="main">=</span>
  Parse.term <span class="comment1">(* term to be monadified *)</span>
  -- Scan.option <span class="main">(</span>
    <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">(</span>"<span class="antiquote">}</span></span></span>
    |--  Parse.thms1 --| <span class="comment1">(* optional definitions, ".simps" as default *)</span>
    <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">)</span>"<span class="antiquote">}</span></span></span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dp_monadify_cmd_parser</span> <span class="main">=</span>
  Scan.optional <span class="main">(</span>Parse.binding --| Parse.$$$ <span class="inner_quoted">":"</span><span class="main">)</span> Binding.empty <span class="comment1">(* optional scope *)</span>
  -- Parse.term <span class="comment1">(* term to be monadified *)</span>
  -- Scan.option <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">(</span>"<span class="antiquote">}</span></span></span> |-- <span class="comment1">(* optional definitions, ".simps" as default *)</span>
      Parse.thms1
    --| <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">)</span>"<span class="antiquote">}</span></span></span><span class="main">)</span>
  -- Scan.option <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> <span class="keyword2">with_memory</span><span class="antiquote">}</span></span></span> |-- Parse.name_position<span class="main">)</span> <span class="comment1">(* e.g. dp_consistency_rbt *)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">instance</span> <span class="main">=</span>
  <span class="main">(</span>Parse.where_ |-- Parse.and_list1 <span class="main">(</span>Parse.name -- <span class="main">(</span>Parse.$$$ <span class="inner_quoted">"="</span> |-- Parse.term<span class="main">)</span><span class="main">)</span>
  || Scan.succeed <span class="main">[</span><span class="main">]</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dp_fun_part1_parser</span> <span class="main">=</span>
  <span class="main">(</span>Parse.binding --| Parse.$$$ <span class="inner_quoted">":"</span><span class="main">)</span> <span class="comment1">(* scope, e.g., bf<span class="hidden">⇩</span><sub>T</sub> *)</span>
  -- Parse.term <span class="comment1">(* term to be monadified, e.g., bf *)</span>
  -- Scan.option <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> <span class="keyword2">with_memory</span><span class="antiquote">}</span></span></span>
    |-- Parse.opt_keyword <span class="inner_quoted">"default_proof"</span> -- Parse.name_position -- <span class="entity">instance</span>
    <span class="main">)</span> <span class="comment1">(* e.g. dp_consistency_rbt *)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dp_fun_part2_parser</span> <span class="main">=</span>
  <span class="comment1">(* monadifies *)</span>
  <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">(</span>"<span class="antiquote">}</span></span></span> |-- Parse.name --| <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">)</span>"<span class="antiquote">}</span></span></span><span class="main">)</span> -- Parse.thms1

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Bottom_Up_Computation">
<div class="head">
<h1>Theory Bottom_Up_Computation</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Bottom-Up Computation›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Bottom_Up_Computation
  <span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="#Memory">../state_monad/Memory</a>"</span> <span class="quoted">"<a href="#DP_CRelVS">../state_monad/DP_CRelVS</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">iterate_state</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">iterate_state</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">[]</span> <span class="main">=</span> State_Monad.return <span class="main">()</span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">iterate_state</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">;</span> <span class="free">iterate_state</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> iterator_defs <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">cnt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">nxt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">iter_state</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span>
    wfrec
      <span class="main">{</span><span class="main">(</span><span class="free">nxt</span> <span class="bound">x</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span> <span class="main">|</span> <span class="bound">x</span><span class="main">.</span> <span class="free">cnt</span> <span class="bound">x</span><span class="main">}</span>
      <span class="main">(</span><span class="main">λ</span> <span class="bound">rec</span> <span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="free">cnt</span> <span class="bound">x</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">x</span><span class="main">;</span> <span class="bound">rec</span> <span class="main">(</span><span class="free">nxt</span> <span class="bound">x</span><span class="main">)</span><span class="main">}</span> <span class="keyword1">else</span> State_Monad.return <span class="main">()</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">iterator_to_list</span> <span class="main">≡</span>
    wfrec <span class="main">{</span><span class="main">(</span><span class="free">nxt</span> <span class="bound">x</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span> <span class="main">|</span> <span class="bound">x</span><span class="main">.</span> <span class="free">cnt</span> <span class="bound">x</span><span class="main">}</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">rec</span> <span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="free">cnt</span> <span class="bound">x</span> <span class="keyword1">then</span> <span class="bound">x</span> <span class="main">#</span> <span class="bound">rec</span> <span class="main">(</span><span class="free">nxt</span> <span class="bound">x</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">[]</span><span class="main">)</span>
  "</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> iterator <span class="main">=</span> iterator_defs <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">sizef</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> nat"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> terminating<span class="main">:</span>
    <span class="quoted"><span class="quoted">"finite <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="free">cnt</span> <span class="bound">x</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">x</span><span class="main">.</span> <span class="free">cnt</span> <span class="bound">x</span> <span class="main">⟶</span> <span class="free">sizef</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="free">sizef</span> <span class="main">(</span><span class="free">nxt</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Bottom_Up_Computation-admissible"><span class="command">lemma</span></span> admissible<span class="main">:</span>
  <span class="quoted"><span class="quoted">"adm_wf
      <span class="main">{</span><span class="main">(</span><span class="free">nxt</span> <span class="bound">x</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span> <span class="main">|</span> <span class="bound">x</span><span class="main">.</span> <span class="free">cnt</span> <span class="bound">x</span><span class="main">}</span>
      <span class="main">(</span><span class="main">λ</span> <span class="bound">rec</span> <span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="free">cnt</span> <span class="bound">x</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span><span class="free">f</span> <span class="bound">x</span><span class="main">;</span> <span class="bound">rec</span> <span class="main">(</span><span class="free">nxt</span> <span class="bound">x</span><span class="main">)</span><span class="main">}</span> <span class="keyword1">else</span> State_Monad.return <span class="main">()</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> adm_wf_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Bottom_Up_Computation-wellfounded"><span class="command">lemma</span></span> wellfounded<span class="main">:</span>
  <span class="quoted"><span class="quoted">"wf <span class="main">{</span><span class="main">(</span><span class="free">nxt</span> <span class="bound">x</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span> <span class="main">|</span> <span class="bound">x</span><span class="main">.</span> <span class="free">cnt</span> <span class="bound">x</span><span class="main">}</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"wf <span class="var">?S</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> terminating <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"acyclic <span class="var">?S</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> acyclicI_order<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="free">sizef</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="var">?S</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">simproc</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finite_Collect<span class="main">]</span><span class="main">]</span> terminating<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> finite_acyclic_wf<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Bottom_Up_Computation-iter_state_unfold"><span class="command">lemma</span></span> iter_state_unfold<span class="main">:</span>
  <span class="quoted"><span class="quoted">"iter_state <span class="free">f</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">cnt</span> <span class="free">x</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span><span class="free">f</span> <span class="free">x</span><span class="main">;</span> iter_state <span class="free">f</span> <span class="main">(</span><span class="free">nxt</span> <span class="free">x</span><span class="main">)</span><span class="main">}</span> <span class="keyword1">else</span> State_Monad.return <span class="main">()</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> iter_state_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> wfrec_fixpoint<span class="main"><span class="main">[</span></span><span class="operator">OF</span> wellfounded admissible<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Bottom_Up_Computation-iterator_to_list_unfold"><span class="command">lemma</span></span> iterator_to_list_unfold<span class="main">:</span>
  <span class="quoted"><span class="quoted">"iterator_to_list <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">cnt</span> <span class="free">x</span> <span class="keyword1">then</span> <span class="free">x</span> <span class="main">#</span> iterator_to_list <span class="main">(</span><span class="free">nxt</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">[]</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> iterator_to_list_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> adm_wf_def wfrec_fixpoint<span class="main"><span class="main">[</span></span><span class="operator">OF</span> wellfounded<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Bottom_Up_Computation-iter_state_iterate_state"><span class="command">lemma</span></span> iter_state_iterate_state<span class="main">:</span>
  <span class="quoted"><span class="quoted">"iter_state <span class="free">f</span> <span class="free">x</span> <span class="main">=</span> iterate_state <span class="free">f</span> <span class="main">(</span>iterator_to_list <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="quoted">"iterator_to_list <span class="free">x</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> iterator_to_list_unfold <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> iter_state_unfold<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> iterator_to_list_unfold<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> iterator_to_list_unfold iter_state_unfold<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Termination *)</span>

<span class="keyword1"><span class="command">context</span></span> dp_consistency
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Bottom_Up_Computation-crel_vs_iterate_state"><span class="command">lemma</span></span> crel_vs_iterate_state<span class="main">:</span>
  <span class="quoted"><span class="quoted">"crel_vs <span class="main">(=)</span> <span class="main">()</span> <span class="main">(</span>iterate_state <span class="free">f</span> <span class="free">xs</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="keyword1">===&gt;<span class="hidden">⇩</span><sub>T</sub></span> <span class="free">R</span><span class="main">)</span> <span class="free">g</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">rule</span> crel_vs_return_ext<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> Transfer.Rel_def<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> unit_expand<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">()</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">a</span> <span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">a</span><span class="main">)</span> <span class="main">()</span> <span class="main">(</span><span class="main">λ</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">()</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">from</span></span> Cons <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="main">(</span><span class="operator">rule</span>
        bind_transfer<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> rel_fun_def<span class="main"><span class="main">,</span></span> <span class="operator">rule_format</span><span class="main"><span class="main">,</span></span> <span class="operator">unfolded</span> unit_expand<span class="main"><span class="main">]</span></span>
        that<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> rel_fun_def<span class="main"><span class="main">,</span></span> <span class="operator">rule_format</span><span class="main"><span class="main">]</span></span> HOL.refl
      <span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Bottom_Up_Computation-crel_vs_bind_ignore"><span class="command">lemma</span></span> crel_vs_bind_ignore<span class="main">:</span>
  <span class="quoted"><span class="quoted">"crel_vs <span class="free">R</span> <span class="free">a</span> <span class="main">(</span><span class="keyword1">do</span> <span class="main">{</span><span class="free">d</span><span class="main">;</span> <span class="free">b</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"crel_vs <span class="free">R</span> <span class="free">a</span> <span class="free">b</span>"</span></span> <span class="quoted"><span class="quoted">"crel_vs <span class="free">S</span> <span class="free">c</span> <span class="free">d</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> unit_expand<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">a</span> <span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">a</span><span class="main">)</span> <span class="main">()</span> <span class="main">(</span><span class="main">λ</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">a</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> unit_expand<span class="main">)</span>
       <span class="main">(</span><span class="operator">rule</span> bind_transfer<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> rel_fun_def<span class="main"><span class="main">,</span></span> <span class="operator">rule_format</span><span class="main"><span class="main">,</span></span> <span class="operator">unfolded</span> unit_expand<span class="main"><span class="main">]</span></span> that<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Bottom_Up_Computation-crel_vs_iterate_and_compute"><span class="command">lemma</span></span> crel_vs_iterate_and_compute<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="keyword1">===&gt;<span class="hidden">⇩</span><sub>T</sub></span> <span class="free">R</span><span class="main">)</span> <span class="free">g</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"crel_vs <span class="free">R</span> <span class="main">(</span><span class="free">g</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span><span class="keyword1">do</span> <span class="main">{</span>iterate_state <span class="free">f</span> <span class="free">xs</span><span class="main">;</span> <span class="free">f</span> <span class="free">x</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span>
        crel_vs_bind_ignore crel_vs_iterate_state HOL.refl
        assms<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> rel_fun_def<span class="main"><span class="main">,</span></span> <span class="operator">rule_format</span><span class="main"><span class="main">]</span></span> assms
     <span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Lifting Syntax *)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* DP Consistency *)</span>

<span class="keyword1"><span class="command">locale</span></span> dp_consistency_iterator <span class="main">=</span>
  dp_consistency <span class="quoted"><span class="free">lookup</span></span> <span class="quoted"><span class="free">update</span></span> <span class="main">+</span> iterator <span class="quoted"><span class="free">cnt</span></span> <span class="quoted"><span class="free">nxt</span></span> <span class="quoted"><span class="free">sizef</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">lookup</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'c</span> option<span class="main">)</span> state"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">update</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">cnt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">nxt</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">sizef</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Bottom_Up_Computation-crel_vs_iter_and_compute"><span class="command">lemma</span></span> crel_vs_iter_and_compute<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="keyword1">===&gt;<span class="hidden">⇩</span><sub>T</sub></span> <span class="free">R</span><span class="main">)</span> <span class="free">g</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"crel_vs <span class="free">R</span> <span class="main">(</span><span class="free">g</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span><span class="keyword1">do</span> <span class="main">{</span>iter_state <span class="free">f</span> <span class="free">y</span><span class="main">;</span> <span class="free">f</span> <span class="free">x</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> iter_state_iterate_state <span class="keyword1"><span class="command">using</span></span> crel_vs_iterate_and_compute<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1" id="Bottom_Up_Computation-consistentDP_iter_and_compute"><span class="command">lemma</span></span> consistentDP_iter_and_compute<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"consistentDP <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"crel_vs <span class="main">(=)</span> <span class="main">(</span><span class="free">dp</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span><span class="keyword1">do</span> <span class="main">{</span>iter_state <span class="free">f</span> <span class="free">y</span><span class="main">;</span> <span class="free">f</span> <span class="free">x</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> consistentDP_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> crel_vs_iter_and_compute<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Consistency + Iterator *)</span>

<span class="keyword1"><span class="command">locale</span></span> dp_consistency_iterator_empty <span class="main">=</span>
  dp_consistency_iterator <span class="main">+</span> dp_consistency_empty
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Bottom_Up_Computation-memoized"><span class="command">lemma</span></span> memoized<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">dp</span> <span class="free">x</span> <span class="main">=</span> fst <span class="main">(</span>run_state <span class="main">(</span><span class="keyword1">do</span> <span class="main">{</span>iter_state <span class="free">f</span> <span class="free">y</span><span class="main">;</span> <span class="free">f</span> <span class="free">x</span><span class="main">}</span><span class="main">)</span> <span class="free">empty</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"consistentDP <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> consistentDP_iter_and_compute<span class="main">[</span><span class="operator">OF</span> that<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">y</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> crel_vs_elim <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> P_empty cmem_empty<span class="main">)</span>

<span class="keyword1" id="Bottom_Up_Computation-cmem_result"><span class="command">lemma</span></span> cmem_result<span class="main">:</span>
  <span class="quoted"><span class="quoted">"cmem <span class="main">(</span>snd <span class="main">(</span>run_state <span class="main">(</span><span class="keyword1">do</span> <span class="main">{</span>iter_state <span class="free">f</span> <span class="free">y</span><span class="main">;</span> <span class="free">f</span> <span class="free">x</span><span class="main">}</span><span class="main">)</span> <span class="free">empty</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"consistentDP <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> consistentDP_iter_and_compute<span class="main">[</span><span class="operator">OF</span> that<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">y</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> crel_vs_elim <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> P_empty cmem_empty<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Consistency + Iterator *)</span>

<span class="keyword1" id="Bottom_Up_Computation-dp_consistency_iterator_emptyI"><span class="command">lemma</span></span> dp_consistency_iterator_emptyI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"dp_consistency_iterator_empty <span class="free">P</span> <span class="free">lookup</span> <span class="free">update</span> <span class="free">cnt</span>
    <span class="free">nxt</span> <span class="free">sizef</span> <span class="free">empty</span>"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"dp_consistency_empty <span class="free">lookup</span> <span class="free">update</span> <span class="free">P</span> <span class="free">empty</span>"</span></span>
     <span class="quoted"><span class="quoted">"iterator <span class="free">cnt</span> <span class="free">nxt</span> <span class="free">sizef</span>"</span></span>
   <span class="keyword2"><span class="keyword">for</span></span> <span class="free">empty</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span>
      dp_consistency_empty.axioms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> dp_consistency_iterator_def
      dp_consistency_iterator_empty_def that
     <span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">m</span> <span class="main">::</span> <span class="quoted">nat</span> <span class="comment1">― ‹Width of a row›</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">n</span> <span class="main">::</span> <span class="quoted">nat</span> <span class="comment1">― ‹Number of rows›</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Bottom_Up_Computation-table_iterator_up"><span class="command">lemma</span></span> table_iterator_up<span class="main">:</span>
  <span class="quoted"><span class="quoted">"iterator
    <span class="main">(</span><span class="main">λ</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="free">n</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">≤</span> <span class="free">m</span><span class="main">)</span>
    <span class="main">(</span><span class="main">λ</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="free">m</span> <span class="keyword1">then</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="bound">x</span> <span class="main">+</span> <span class="main">1</span><span class="main">,</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span>
    <span class="main">(</span><span class="main">λ</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">*</span> <span class="main">(</span><span class="free">m</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">+</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="operator">auto</span>

<span class="keyword1" id="Bottom_Up_Computation-table_iterator_down"><span class="command">lemma</span></span> table_iterator_down<span class="main">:</span>
  <span class="quoted"><span class="quoted">"iterator
    <span class="main">(</span><span class="main">λ</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="free">n</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">≤</span> <span class="free">m</span> <span class="main">∧</span> <span class="bound">x</span> <span class="main">&gt;</span> <span class="main">0</span><span class="main">)</span>
    <span class="main">(</span><span class="main">λ</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">y</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="bound">x</span> <span class="main">-</span> <span class="main">1</span><span class="main">,</span> <span class="free">m</span><span class="main">)</span><span class="main">)</span>
    <span class="main">(</span><span class="main">λ</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">n</span> <span class="main">-</span> <span class="bound">x</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span><span class="free">m</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="free">m</span> <span class="main">-</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">simproc</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finite_Collect<span class="main">]</span><span class="main">]</span>  <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Suc_diff_le<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Table *)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Theory *)</span>
</pre>
</div><div id="Bottom_Up_Computation_Heap">
<div class="head">
<h1>Theory Bottom_Up_Computation_Heap</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> Bottom_Up_Computation_Heap
  <span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="#Bottom_Up_Computation">../state_monad/Bottom_Up_Computation</a>"</span> <span class="quoted">"<a href="#DP_CRelVH">../heap_monad/DP_CRelVH</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> iterator_defs<span class="main">)</span>
  <span class="quoted"><span class="quoted">"<span class="free">iter_heap</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span>
    wfrec
      <span class="main">{</span><span class="main">(</span><span class="free">nxt</span> <span class="bound">x</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span> <span class="main">|</span> <span class="bound">x</span><span class="main">.</span> <span class="free">cnt</span> <span class="bound">x</span><span class="main">}</span>
      <span class="main">(</span><span class="main">λ</span> <span class="bound">rec</span> <span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="free">cnt</span> <span class="bound">x</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">x</span><span class="main">;</span> <span class="bound">rec</span> <span class="main">(</span><span class="free">nxt</span> <span class="bound">x</span><span class="main">)</span><span class="main">}</span> <span class="keyword1">else</span> return <span class="main">()</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> iterator<span class="main">)</span> iter_heap_unfold<span class="main">:</span>
  <span class="quoted"><span class="quoted">"iter_heap <span class="free">f</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">cnt</span> <span class="free">x</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span><span class="free">f</span> <span class="free">x</span><span class="main">;</span> iter_heap <span class="free">f</span> <span class="main">(</span><span class="free">nxt</span> <span class="free">x</span><span class="main">)</span><span class="main">}</span> <span class="keyword1">else</span> return <span class="main">()</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> iter_heap_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> wfrec_fixpoint<span class="main"><span class="main">[</span></span><span class="operator">OF</span> iterator.wellfounded<span class="main"><span class="main">,</span></span><span class="operator">OF</span> iterator.intro<span class="main"><span class="main">,</span></span><span class="operator">OF</span> terminating<span class="main"><span class="main">]</span></span> adm_wf_def<span class="main">)</span>

<span class="keyword1"><span class="command">locale</span></span> dp_consistency_iterator_heap <span class="main">=</span>
  dp_consistency_heap <span class="quoted"><span class="free">P</span></span> <span class="quoted"><span class="free">update</span></span> <span class="quoted"><span class="free">lookup</span></span> <span class="quoted"><span class="free">dp</span></span> <span class="main">+</span> iterator <span class="quoted"><span class="free">cnt</span></span> <span class="quoted"><span class="free">nxt</span></span> <span class="quoted"><span class="free">sizef</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">lookup</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'c</span> option<span class="main">)</span> Heap"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">update</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">P</span> <span class="free">dp</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">cnt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">nxt</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">sizef</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">term</span></span> <span class="quoted">iter_heap</span>

<span class="keyword1"><span class="command">term</span></span> <span class="quoted">crel_vs</span>

<span class="keyword1" id="Bottom_Up_Computation_Heap-crel_vs_iterate_state"><span class="command">lemma</span></span> crel_vs_iterate_state<span class="main">:</span>
  <span class="quoted"><span class="quoted">"crel_vs <span class="main">(=)</span> <span class="main">()</span> <span class="main">(</span>iter_heap <span class="free">f</span> <span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> crel_vs <span class="free">R</span><span class="main">)</span> <span class="free">g</span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> wellfounded
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">induction</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>less <span class="skolem">x</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> unit_expand<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">()</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">a</span> <span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">a</span><span class="main">)</span> <span class="main">()</span> <span class="main">(</span><span class="main">λ</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">()</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">from</span></span> less <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> iter_heap_unfold<span class="main">)</span>
       <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span>
          bind_transfer<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> rel_fun_def<span class="main"><span class="main">,</span></span> <span class="operator">rule_format</span><span class="main"><span class="main">,</span></span> <span class="operator">unfolded</span> unit_expand<span class="main"><span class="main">]</span></span>
          crel_vs_return_ext<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> Transfer.Rel_def<span class="main"><span class="main">]</span></span> that<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> rel_fun_def<span class="main"><span class="main">,</span></span> <span class="operator">rule_format</span><span class="main"><span class="main">]</span></span>
       <span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Bottom_Up_Computation_Heap-crel_vs_bind_ignore"><span class="command">lemma</span></span> crel_vs_bind_ignore<span class="main">:</span>
  <span class="quoted"><span class="quoted">"crel_vs <span class="free">R</span> <span class="free">a</span> <span class="main">(</span><span class="keyword1">do</span> <span class="main">{</span><span class="free">d</span><span class="main">;</span> <span class="free">b</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"crel_vs <span class="free">R</span> <span class="free">a</span> <span class="free">b</span>"</span></span> <span class="quoted"><span class="quoted">"crel_vs <span class="free">S</span> <span class="free">c</span> <span class="free">d</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> unit_expand<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">a</span> <span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">a</span><span class="main">)</span> <span class="main">()</span> <span class="main">(</span><span class="main">λ</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">a</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> unit_expand<span class="main">)</span>
       <span class="main">(</span><span class="operator">rule</span> bind_transfer<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> rel_fun_def<span class="main"><span class="main">,</span></span> <span class="operator">rule_format</span><span class="main"><span class="main">,</span></span> <span class="operator">unfolded</span> unit_expand<span class="main"><span class="main">]</span></span> that<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Bottom_Up_Computation_Heap-crel_vs_iter_and_compute"><span class="command">lemma</span></span> crel_vs_iter_and_compute<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> crel_vs <span class="free">R</span><span class="main">)</span> <span class="free">g</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"crel_vs <span class="free">R</span> <span class="main">(</span><span class="free">g</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span><span class="keyword1">do</span> <span class="main">{</span>iter_heap <span class="free">f</span> <span class="free">y</span><span class="main">;</span> <span class="free">f</span> <span class="free">x</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span>
        crel_vs_bind_ignore crel_vs_iterate_state HOL.refl
        assms<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> rel_fun_def<span class="main"><span class="main">,</span></span> <span class="operator">rule_format</span><span class="main"><span class="main">]</span></span> assms
     <span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Bottom_Up_Computation_Heap-consistent_DP_iter_and_compute"><span class="command">lemma</span></span> consistent_DP_iter_and_compute<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"consistentDP <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"consistentDP <span class="main">(</span><span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>iter_heap <span class="free">f</span> <span class="free">y</span><span class="main">;</span> <span class="free">f</span> <span class="bound">x</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> consistentDP_intro<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> consistentDP_def Rel_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> crel_vs_iter_and_compute<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Lifting Syntax *)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* DP Consistency Iterator Heap *)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Theory *)</span>
</pre>
</div><div id="Solve_Cong">
<div class="head">
<h1>Theory Solve_Cong</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Setup for the Heap Monad›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Solve_Cong
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL/Main.html">Main</a> <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Eisbach/Eisbach.html">HOL-Eisbach.Eisbach</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Method for solving trivial equalities with congruence reasoning›</span></span>

<span class="keyword1"><span class="command">named_theorems</span></span> cong_rules

<span class="keyword1"><span class="command">method</span></span> solve_cong <span class="keyword2"><span class="keyword">methods</span></span> solve <span class="main">=</span>
  <span class="operator">rule</span> HOL.refl <span class="main"><span class="keyword3">|</span></span>
  <span class="operator">rule</span> <span class="dynamic"><span class="dynamic">cong_rules</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">solve_cong</span> <span class="operator">solve</span> <span class="main"><span class="keyword3">|</span></span>
  <span class="operator">solve</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Heap_Main">
<div class="head">
<h1>Theory Heap_Main</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> Heap_Main
  <span class="keyword2"><span class="keyword">imports</span></span>
    <span class="quoted">"<a href="#Memory_Heap">../heap_monad/Memory_Heap</a>"</span>
    <span class="quoted">"<a href="#Transform_Cmd">../transform/Transform_Cmd</a>"</span>
    <a href="#Bottom_Up_Computation_Heap">Bottom_Up_Computation_Heap</a>
    <span class="quoted">"<a href="#Solve_Cong">../util/Solve_Cong</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> heap_monad_syntax <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">thm</span></span> if_cong
<span class="keyword1" id="Heap_Main-ifT_cong"><span class="command">lemma</span></span> ifT_cong<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">=</span> <span class="free">c</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">=</span> <span class="free">u</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="free">c</span> <span class="main">⟹</span> <span class="free">y</span> <span class="main">=</span> <span class="free">v</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Heap_Monad_Ext.if<span class="hidden">⇩</span><sub>T</sub> <span class="main">⟨</span><span class="free">b</span><span class="main">⟩</span> <span class="free">x</span> <span class="free">y</span> <span class="main">=</span> Heap_Monad_Ext.if<span class="hidden">⇩</span><sub>T</sub> <span class="main">⟨</span><span class="free">c</span><span class="main">⟩</span> <span class="free">u</span> <span class="free">v</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Heap_Monad_Ext.if<span class="hidden">⇩</span><sub>T</sub>_def
  <span class="keyword1"><span class="command">unfolding</span></span> return_bind
  <span class="keyword1"><span class="command">using</span></span> if_cong<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1" id="Heap_Main-return_app_return_cong"><span class="command">lemma</span></span> return_app_return_cong<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">x</span> <span class="main">=</span> <span class="free">g</span> <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟨</span><span class="free">f</span><span class="main">⟩</span> <span class="main">.</span> <span class="main">⟨</span><span class="free">x</span><span class="main">⟩</span> <span class="main">=</span> <span class="main">⟨</span><span class="free">g</span><span class="main">⟩</span> <span class="main">.</span> <span class="main">⟨</span><span class="free">y</span><span class="main">⟩</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Heap_Monad_Ext.return_app_return_meta assms <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">fundef_cong</span><span class="main">]</span> <span class="main">=</span>
  return_app_return_cong
  ifT_cong
<span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword1"><span class="command">memoize_fun</span></span> comp<span class="hidden">⇩</span><sub>T</sub><span class="main">:</span> <span class="quoted">comp</span> <span class="keyword1"><span class="command">monadifies</span></span> <span class="main">(</span>heap<span class="main">)</span> comp_def
<span class="keyword1"><span class="command">thm</span></span> comp<span class="hidden">⇩</span><sub>T</sub>'.simps
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> dp_consistency_heap<span class="main">)</span> <span class="keyword2"><span class="keyword">shows</span></span> comp<span class="hidden">⇩</span><sub>T</sub>_transfer<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"crel_vs <span class="main">(</span><span class="main">(</span><span class="free">R1</span> <span class="keyword1">===&gt;<span class="hidden">⇩</span><sub>T</sub></span> <span class="free">R2</span><span class="main">)</span> <span class="keyword1">===&gt;<span class="hidden">⇩</span><sub>T</sub></span> <span class="main">(</span><span class="free">R0</span> <span class="keyword1">===&gt;<span class="hidden">⇩</span><sub>T</sub></span> <span class="free">R1</span><span class="main">)</span> <span class="keyword1">===&gt;<span class="hidden">⇩</span><sub>T</sub></span> <span class="main">(</span><span class="free">R0</span> <span class="keyword1">===&gt;<span class="hidden">⇩</span><sub>T</sub></span> <span class="free">R2</span><span class="main">)</span><span class="main">)</span> comp comp<span class="hidden">⇩</span><sub>T</sub>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">memoize_combinator_init</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> IH <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">memoize_unfold_defs</span> <span class="operator">transfer_prover</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">memoize_fun</span></span> map<span class="hidden">⇩</span><sub>T</sub><span class="main">:</span> <span class="quoted">map</span> <span class="keyword1"><span class="command">monadifies</span></span> <span class="main">(</span>heap<span class="main">)</span> list.map
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> dp_consistency_heap<span class="main">)</span> map<span class="hidden">⇩</span><sub>T</sub>_transfer<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"crel_vs <span class="main">(</span><span class="main">(</span><span class="free">R0</span> <span class="keyword1">===&gt;<span class="hidden">⇩</span><sub>T</sub></span> <span class="free">R1</span><span class="main">)</span> <span class="keyword1">===&gt;<span class="hidden">⇩</span><sub>T</sub></span> list_all2 <span class="free">R0</span> <span class="keyword1">===&gt;<span class="hidden">⇩</span><sub>T</sub></span> list_all2 <span class="free">R1</span><span class="main">)</span> map map<span class="hidden">⇩</span><sub>T</sub>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">memoize_combinator_init</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> list_all2_induct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">memoize_unfold_defs</span> <span class="operator">transfer_prover</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">memoize_unfold_defs</span> <span class="operator">transfer_prover</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">memoize_fun</span></span> fold<span class="hidden">⇩</span><sub>T</sub><span class="main">:</span> <span class="quoted">fold</span> <span class="keyword1"><span class="command">monadifies</span></span> <span class="main">(</span>heap<span class="main">)</span> fold.simps
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> dp_consistency_heap<span class="main">)</span> fold<span class="hidden">⇩</span><sub>T</sub>_transfer<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"crel_vs <span class="main">(</span><span class="main">(</span><span class="free">R0</span> <span class="keyword1">===&gt;<span class="hidden">⇩</span><sub>T</sub></span> <span class="free">R1</span> <span class="keyword1">===&gt;<span class="hidden">⇩</span><sub>T</sub></span> <span class="free">R1</span><span class="main">)</span> <span class="keyword1">===&gt;<span class="hidden">⇩</span><sub>T</sub></span> list_all2 <span class="free">R0</span> <span class="keyword1">===&gt;<span class="hidden">⇩</span><sub>T</sub></span> <span class="free">R1</span> <span class="keyword1">===&gt;<span class="hidden">⇩</span><sub>T</sub></span> <span class="free">R1</span><span class="main">)</span> fold fold<span class="hidden">⇩</span><sub>T</sub>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">memoize_combinator_init</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> list_all2_induct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">memoize_unfold_defs</span> <span class="operator">transfer_prover</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">memoize_unfold_defs</span> <span class="operator">transfer_prover</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> heap_monad_syntax <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">thm</span></span> map_cong
<span class="keyword1" id="Heap_Main-mapT_cong"><span class="command">lemma</span></span> mapT_cong<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="free">ys</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">∈</span>set <span class="free">ys</span> <span class="main">⟹</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">g</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map<span class="hidden">⇩</span><sub>T</sub> <span class="main">.</span> <span class="main">⟨</span><span class="free">f</span><span class="main">⟩</span> <span class="main">.</span> <span class="main">⟨</span><span class="free">xs</span><span class="main">⟩</span> <span class="main">=</span> map<span class="hidden">⇩</span><sub>T</sub> <span class="main">.</span> <span class="main">⟨</span><span class="free">g</span><span class="main">⟩</span> <span class="main">.</span> <span class="main">⟨</span><span class="free">ys</span><span class="main">⟩</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> map<span class="hidden">⇩</span><sub>T</sub>_def 
  <span class="keyword1"><span class="command">unfolding</span></span> assms<span class="main">(</span>1<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Heap_Monad_Ext.return_app_return_meta<span class="main">)</span>

<span class="keyword1"><span class="command">thm</span></span> fold_cong
<span class="keyword1" id="Heap_Main-foldT_cong"><span class="command">lemma</span></span> foldT_cong<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="free">ys</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">∈</span>set <span class="free">ys</span> <span class="main">⟹</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">g</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fold<span class="hidden">⇩</span><sub>T</sub> <span class="main">.</span> <span class="main">⟨</span><span class="free">f</span><span class="main">⟩</span> <span class="main">.</span> <span class="main">⟨</span><span class="free">xs</span><span class="main">⟩</span> <span class="main">=</span> fold<span class="hidden">⇩</span><sub>T</sub> <span class="main">.</span> <span class="main">⟨</span><span class="free">g</span><span class="main">⟩</span> <span class="main">.</span> <span class="main">⟨</span><span class="free">ys</span><span class="main">⟩</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fold<span class="hidden">⇩</span><sub>T</sub>_def
  <span class="keyword1"><span class="command">unfolding</span></span> assms<span class="main">(</span>1<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Heap_Monad_Ext.return_app_return_meta<span class="main">)</span>

<span class="keyword1" id="Heap_Main-abs_unit_cong"><span class="command">lemma</span></span> abs_unit_cong<span class="main">:</span>
  <span class="comment1">(* for lazy checkmem *)</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">::</span>unit<span class="main">.</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">..</span></span>


<span class="keyword1" id="Heap_Main-arg_cong4"><span class="command">lemma</span></span> arg_cong4<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">a</span> <span class="free">b</span> <span class="free">c</span> <span class="free">d</span> <span class="main">=</span> <span class="free">f</span> <span class="free">a'</span> <span class="free">b'</span> <span class="free">c'</span> <span class="free">d'</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">=</span> <span class="free">a'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">=</span> <span class="free">b'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">=</span> <span class="free">c'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">=</span> <span class="free">d'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> that<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">fundef_cong</span><span class="main">,</span> <span class="operator">cong_rules</span><span class="main">]</span> <span class="main">=</span>
  return_app_return_cong
  ifT_cong
  mapT_cong
  foldT_cong
  abs_unit_cong
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">cong_rules</span><span class="main">]</span> <span class="main">=</span>
  arg_cong4<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f <span class="main"><span class="main">=</span></span> <span class="quoted">heap_mem_defs.checkmem</span><span class="main">]</span>
  arg_cong2<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f <span class="main"><span class="main">=</span></span> <span class="quoted">fun_app_lifted</span><span class="main">]</span>
<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">context</span></span> dp_consistency_heap <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax heap_monad_syntax <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">named_theorems</span></span> dp_match_rule

<span class="keyword1"><span class="command">thm</span></span> if_cong
<span class="keyword1" id="Heap_Main-if"><span class="command">lemma</span></span> if<span class="hidden">⇩</span><sub>T</sub>_cong2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">Rel</span> <span class="main">(=)</span> <span class="free">b</span> <span class="free">c</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">⟹</span> <span class="keyword1">Rel</span> <span class="main">(</span>crel_vs <span class="free">R</span><span class="main">)</span> <span class="free">x</span> <span class="free">x<span class="hidden">⇩</span><sub>T</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="free">c</span> <span class="main">⟹</span> <span class="keyword1">Rel</span> <span class="main">(</span>crel_vs <span class="free">R</span><span class="main">)</span> <span class="free">y</span> <span class="free">y<span class="hidden">⇩</span><sub>T</sub></span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">Rel</span> <span class="main">(</span>crel_vs <span class="free">R</span><span class="main">)</span> <span class="main">(</span><span class="keyword1">if</span> <span class="main">(</span>Wrap <span class="free">b</span><span class="main">)</span> <span class="keyword1">then</span> <span class="free">x</span> <span class="keyword1">else</span> <span class="free">y</span><span class="main">)</span> <span class="main">(</span>Heap_Monad_Ext.if<span class="hidden">⇩</span><sub>T</sub> <span class="main">⟨</span><span class="free">c</span><span class="main">⟩</span> <span class="free">x<span class="hidden">⇩</span><sub>T</sub></span> <span class="free">y<span class="hidden">⇩</span><sub>T</sub></span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> Heap_Monad_Ext.if<span class="hidden">⇩</span><sub>T</sub>_def bind_left_identity Rel_def Wrap_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split<span class="main">)</span>

<span class="keyword1" id="Heap_Main-map"><span class="command">lemma</span></span> map<span class="hidden">⇩</span><sub>T</sub>_cong2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span>
    <span class="quoted"><span class="quoted">"is_equality <span class="free">R</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="keyword1">Rel</span> <span class="free">R</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">∈</span>set <span class="free">ys</span> <span class="main">⟹</span> <span class="keyword1">Rel</span> <span class="main">(</span>crel_vs <span class="free">S</span><span class="main">)</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">f<span class="hidden">⇩</span><sub>T</sub>'</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">Rel</span> <span class="main">(</span>crel_vs <span class="main">(</span>list_all2 <span class="free">S</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>App <span class="main">(</span>App map <span class="main">(</span>Wrap <span class="free">f</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Wrap <span class="free">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>map<span class="hidden">⇩</span><sub>T</sub> <span class="main">.</span> <span class="main">⟨</span><span class="free">f<span class="hidden">⇩</span><sub>T</sub>'</span><span class="main">⟩</span> <span class="main">.</span> <span class="main">⟨</span><span class="free">ys</span><span class="main">⟩</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> map<span class="hidden">⇩</span><sub>T</sub>_def
  <span class="keyword1"><span class="command">unfolding</span></span> Heap_Monad_Ext.return_app_return_meta
  <span class="keyword1"><span class="command">unfolding</span></span> assms<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> Rel_def assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> is_equality_def<span class="main"><span class="main">]</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>3<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> Rel_def Wrap_def App_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">memoize_unfold_defs</span> <span class="main"><span class="main">(</span></span>heap<span class="main"><span class="main">)</span></span> <span class="quoted">map</span><span class="main">)</span> <span class="operator">transfer_prover</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> prems <span class="keyword2"><span class="keyword">for</span></span> a ys
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">memoize_unfold_defs</span> <span class="main"><span class="main">(</span></span>heap<span class="main"><span class="main">)</span></span> <span class="quoted">map</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> Heap_Monad_Ext.return_app_return_meta Wrap_App_Wrap<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span> <span class="main">=</span>
      prems<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> list.set_intros<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span>
      prems<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> prems<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">OF</span> list.set_intros<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Heap_Main-fold"><span class="command">lemma</span></span> fold<span class="hidden">⇩</span><sub>T</sub>_cong2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span>
    <span class="quoted"><span class="quoted">"is_equality <span class="free">R</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="keyword1">Rel</span> <span class="free">R</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">∈</span>set <span class="free">ys</span> <span class="main">⟹</span> <span class="keyword1">Rel</span> <span class="main">(</span>crel_vs <span class="main">(</span><span class="free">S</span> <span class="main">===&gt;</span> crel_vs <span class="free">S</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">f<span class="hidden">⇩</span><sub>T</sub>'</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>
    <span class="quoted"><span class="quoted">"<span class="keyword1">Rel</span> <span class="main">(</span>crel_vs <span class="main">(</span><span class="free">S</span> <span class="main">===&gt;</span> crel_vs <span class="free">S</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>fold <span class="free">f</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>fold<span class="hidden">⇩</span><sub>T</sub> <span class="main">.</span> <span class="main">⟨</span><span class="free">f<span class="hidden">⇩</span><sub>T</sub>'</span><span class="main">⟩</span> <span class="main">.</span> <span class="main">⟨</span><span class="free">ys</span><span class="main">⟩</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fold<span class="hidden">⇩</span><sub>T</sub>_def
  <span class="keyword1"><span class="command">unfolding</span></span> Heap_Monad_Ext.return_app_return_meta
  <span class="keyword1"><span class="command">unfolding</span></span> assms<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> Rel_def assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> is_equality_def<span class="main"><span class="main">]</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>3<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> Rel_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">memoize_unfold_defs</span> <span class="main"><span class="main">(</span></span>heap<span class="main"><span class="main">)</span></span> <span class="quoted">fold</span><span class="main">)</span> <span class="operator">transfer_prover</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> prems <span class="keyword2"><span class="keyword">for</span></span> a ys
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">memoize_unfold_defs</span> <span class="main"><span class="main">(</span></span>heap<span class="main"><span class="main">)</span></span> <span class="quoted">fold</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> Heap_Monad_Ext.return_app_return_meta Wrap_App_Wrap<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span> <span class="main">=</span>
      prems<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> list.set_intros<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span>
      prems<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> prems<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">OF</span> list.set_intros<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Heap_Main-refl2"><span class="command">lemma</span></span> refl2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"is_equality <span class="free">R</span> <span class="main">⟹</span> <span class="keyword1">Rel</span> <span class="free">R</span> <span class="free">x</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> is_equality_def Rel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Heap_Main-rel_fun2"><span class="command">lemma</span></span> rel_fun2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"is_equality <span class="free">R0</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">Rel</span> <span class="free">R1</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">g</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">Rel</span> <span class="main">(</span>rel_fun <span class="free">R0</span> <span class="free">R1</span><span class="main">)</span> <span class="free">f</span> <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> is_equality_def Rel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Heap_Main-crel_vs_return_app_return"><span class="command">lemma</span></span> crel_vs_return_app_return<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">Rel</span> <span class="free">R</span> <span class="main">(</span><span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span><span class="free">g</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">Rel</span> <span class="free">R</span> <span class="main">(</span>App <span class="main">(</span>Wrap <span class="free">f</span><span class="main">)</span> <span class="main">(</span>Wrap <span class="free">x</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">⟨</span><span class="free">g</span><span class="main">⟩</span> <span class="main">.</span> <span class="main">⟨</span><span class="free">x</span><span class="main">⟩</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> Heap_Monad_Ext.return_app_return_meta Wrap_App_Wrap <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">thm</span></span> option.case_cong<span class="main">[</span><span class="operator">no_vars</span><span class="main">]</span>
<span class="keyword1" id="Heap_Main-option_case_cong'"><span class="command">lemma</span></span> option_case_cong'<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="keyword1">Rel</span> <span class="main">(=)</span> <span class="free">option'</span> <span class="free">option</span> <span class="main">⟹</span>
<span class="main">(</span><span class="free">option</span> <span class="main">=</span> None <span class="main">⟹</span> <span class="keyword1">Rel</span> <span class="free">R</span> <span class="free">f1</span> <span class="free">g1</span><span class="main">)</span> <span class="main">⟹</span>
<span class="main">(</span><span class="main">⋀</span><span class="bound">x2</span><span class="main">.</span> <span class="free">option</span> <span class="main">=</span> Some <span class="bound">x2</span> <span class="main">⟹</span> <span class="keyword1">Rel</span> <span class="free">R</span> <span class="main">(</span><span class="free">f2</span> <span class="bound">x2</span><span class="main">)</span> <span class="main">(</span><span class="free">g2</span> <span class="bound">x2</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span>
<span class="keyword1">Rel</span> <span class="free">R</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">option'</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="free">f1</span> <span class="main">|</span> Some <span class="bound">x2</span> <span class="main">⇒</span> <span class="free">f2</span> <span class="bound">x2</span><span class="main">)</span>
<span class="main">(</span><span class="keyword1">case</span> <span class="free">option</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="free">g1</span> <span class="main">|</span> Some <span class="bound">x2</span> <span class="main">⇒</span> <span class="free">g2</span> <span class="bound">x2</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Rel_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1"><span class="command">thm</span></span> prod.case_cong<span class="main">[</span><span class="operator">no_vars</span><span class="main">]</span>
<span class="keyword1" id="Heap_Main-prod_case_cong'"><span class="command">lemma</span></span> prod_case_cong'<span class="main">:</span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">prod</span> <span class="free">prod'</span> <span class="keyword2"><span class="keyword">shows</span></span>
<span class="quoted"><span class="quoted">"<span class="keyword1">Rel</span> <span class="main">(=)</span> <span class="free">prod</span> <span class="free">prod'</span> <span class="main">⟹</span>
<span class="main">(</span><span class="main">⋀</span><span class="bound">x1</span> <span class="bound">x2</span><span class="main">.</span> <span class="free">prod'</span> <span class="main">=</span> <span class="main">(</span><span class="bound">x1</span><span class="main">,</span> <span class="bound">x2</span><span class="main">)</span> <span class="main">⟹</span> <span class="keyword1">Rel</span> <span class="free">R</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x1</span> <span class="bound">x2</span><span class="main">)</span> <span class="main">(</span><span class="free">g</span> <span class="bound">x1</span> <span class="bound">x2</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span>
<span class="keyword1">Rel</span> <span class="free">R</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">prod</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">x1</span><span class="main">,</span> <span class="bound">x2</span><span class="main">)</span> <span class="main">⇒</span> <span class="free">f</span> <span class="bound">x1</span> <span class="bound">x2</span><span class="main">)</span>
<span class="main">(</span><span class="keyword1">case</span> <span class="free">prod'</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">x1</span><span class="main">,</span> <span class="bound">x2</span><span class="main">)</span> <span class="main">⇒</span> <span class="free">g</span> <span class="bound">x1</span> <span class="bound">x2</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Rel_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">dp_match_rule</span><span class="main">]</span> <span class="main">=</span> prod_case_cong' option_case_cong'


<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">dp_match_rule</span><span class="main">]</span> <span class="main">=</span>
  crel_vs_return_app_return

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">dp_match_rule</span><span class="main">]</span> <span class="main">=</span>
  map<span class="hidden">⇩</span><sub>T</sub>_cong2
  fold<span class="hidden">⇩</span><sub>T</sub>_cong2
  if<span class="hidden">⇩</span><sub>T</sub>_cong2

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">dp_match_rule</span><span class="main">]</span> <span class="main">=</span>
  crel_vs_return
  crel_vs_fun_app
  refl2
  rel_fun2

<span class="comment1">(*
lemmas [dp_match_rule] =
  crel_vs_checkmem_tupled
*)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* context lifting_syntax *)</span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* context dp_consistency *)</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹More Heap›</span></span>

<span class="keyword1" id="Heap_Main-execute_heap_ofD"><span class="command">lemma</span></span> execute_heap_ofD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"heap_of <span class="free">c</span> <span class="free">h</span> <span class="main">=</span> <span class="free">h'</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"execute <span class="free">c</span> <span class="free">h</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="free">h'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Heap_Main-execute_result_ofD"><span class="command">lemma</span></span> execute_result_ofD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"result_of <span class="free">c</span> <span class="free">h</span> <span class="main">=</span> <span class="free">v</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"execute <span class="free">c</span> <span class="free">h</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="free">h'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">locale</span></span> heap_correct_init_defs <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">P</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> <span class="main">⇒</span> heap <span class="main">⇒</span> bool"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">lookup</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'v</span> option Heap"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">update</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> unit Heap"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">map_of_heap'</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">map_of_heap'</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">heap</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">=</span> fst <span class="main">(</span>the <span class="main">(</span>execute <span class="main">(</span><span class="free">lookup</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">heap</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> heap_correct_init_inv <span class="main">=</span> heap_correct_init_defs <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> lookup_inv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">m</span><span class="main">.</span> lift_p <span class="main">(</span><span class="free">P</span> <span class="bound">m</span><span class="main">)</span> <span class="main">(</span><span class="free">lookup</span> <span class="bound">m</span> <span class="free">k</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> update_inv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">m</span><span class="main">.</span> lift_p <span class="main">(</span><span class="free">P</span> <span class="bound">m</span><span class="main">)</span> <span class="main">(</span><span class="free">update</span> <span class="bound">m</span> <span class="free">k</span> <span class="free">v</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> heap_correct_init <span class="main">=</span>
  heap_correct_init_inv <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> lookup_correct<span class="main">:</span>
      <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">a</span><span class="main">.</span> <span class="free">P</span> <span class="bound">a</span> <span class="free">m</span> <span class="main">⟹</span> map_of_heap' <span class="bound">a</span> <span class="main">(</span>snd <span class="main">(</span>the <span class="main">(</span>execute <span class="main">(</span><span class="free">lookup</span> <span class="bound">a</span> <span class="free">k</span><span class="main">)</span> <span class="free">m</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> <span class="main">(</span>map_of_heap' <span class="bound">a</span> <span class="free">m</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> update_correct<span class="main">:</span>
      <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">a</span><span class="main">.</span> <span class="free">P</span> <span class="bound">a</span> <span class="free">m</span> <span class="main">⟹</span>
        map_of_heap' <span class="bound">a</span> <span class="main">(</span>snd <span class="main">(</span>the <span class="main">(</span>execute <span class="main">(</span><span class="free">update</span> <span class="bound">a</span> <span class="free">k</span> <span class="free">v</span><span class="main">)</span> <span class="free">m</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> <span class="main">(</span>map_of_heap' <span class="bound">a</span> <span class="free">m</span><span class="main">)</span><span class="main">(</span><span class="free">k</span> <span class="main">↦</span> <span class="free">v</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> dp_consistency_heap_init <span class="main">=</span> heap_correct_init _ <span class="quoted"><span class="free">lookup</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">lookup</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'v</span> option Heap"</span></span>  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">dp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'v</span>"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">init</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> Heap"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> success<span class="main">:</span> <span class="quoted"><span class="quoted">"success <span class="free">init</span> Heap.empty"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> empty_correct<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">empty</span> <span class="bound">heap</span><span class="main">.</span> execute <span class="free">init</span> Heap.empty <span class="main">=</span> Some <span class="main">(</span><span class="bound">empty</span><span class="main">,</span> <span class="bound">heap</span><span class="main">)</span> <span class="main">⟹</span> map_of_heap' <span class="bound">empty</span> <span class="bound">heap</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> Map.empty"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> P_empty<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">empty</span> <span class="bound">heap</span><span class="main">.</span> execute <span class="free">init</span> Heap.empty <span class="main">=</span> Some <span class="main">(</span><span class="bound">empty</span><span class="main">,</span> <span class="bound">heap</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">empty</span> <span class="bound">heap</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">init_mem</span> <span class="main">=</span> result_of <span class="free">init</span> Heap.empty"</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> dp_consistency_heap
  <span class="keyword2"><span class="keyword">where</span></span> P<span class="main">=</span><span class="quoted"><span class="quoted">"<span class="free">P</span> init_mem"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> lookup<span class="main">=</span><span class="quoted"><span class="quoted">"<span class="free">lookup</span> init_mem"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> update<span class="main">=</span><span class="quoted"><span class="quoted">"<span class="free">update</span> init_mem"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> lookup_inv<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted">init_mem</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> update_inv<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted">init_mem</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> heap_mem_defs.map_of_heap_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> lookup_correct<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted">init_mem</span><span class="main"><span class="main">,</span></span> <span class="operator">unfolded</span> map_of_heap'_def<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> heap_mem_defs.map_of_heap_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> update_correct<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted">init_mem</span><span class="main"><span class="main">,</span></span> <span class="operator">unfolded</span> map_of_heap'_def<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">interpretation</span></span> consistent<span class="main">:</span> dp_consistency_heap_empty
  <span class="keyword2"><span class="keyword">where</span></span> P<span class="main">=</span><span class="quoted"><span class="quoted">"<span class="free">P</span> init_mem"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> lookup<span class="main">=</span><span class="quoted"><span class="quoted">"<span class="free">lookup</span> init_mem"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> update<span class="main">=</span><span class="quoted"><span class="quoted">"<span class="free">update</span> init_mem"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> empty<span class="main">=</span> <span class="quoted"><span class="quoted">"heap_of <span class="free">init</span> Heap.empty"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> successE<span class="main"><span class="main">[</span></span><span class="operator">OF</span> success<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> empty_correct<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> heap_mem_defs.map_of_heap_def init_mem_def map_of_heap'_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> successE<span class="main"><span class="main">[</span></span><span class="operator">OF</span> success<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> P_empty<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> init_mem_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Heap_Main-memoized_empty"><span class="command">lemma</span></span> memoized_empty<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">dp</span> <span class="free">x</span> <span class="main">=</span> result_of <span class="main">(</span><span class="free">init</span> <span class="main">⤜</span> <span class="main">(</span><span class="main">λ</span><span class="bound">mem</span><span class="main">.</span> <span class="free">dp<span class="hidden">⇩</span><sub>T</sub></span> <span class="bound">mem</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span> Heap.empty"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"consistentDP <span class="main">(</span><span class="free">dp<span class="hidden">⇩</span><sub>T</sub></span> <span class="main">(</span>result_of <span class="free">init</span> Heap.empty<span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> execute_bind_success consistent.memoized<span class="main"><span class="main">[</span></span><span class="operator">OF</span> that<span class="main"><span class="main"><span class="main">(</span></span></span>1<span class="main"><span class="main"><span class="main">)</span></span></span><span class="main"><span class="main">]</span></span> success<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> dp_consistency_heap_init' <span class="main">=</span> heap_correct_init _ <span class="quoted"><span class="free">lookup</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">lookup</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'v</span> option Heap"</span></span>  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">dp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'v</span>"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">init</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> Heap"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> success<span class="main">:</span> <span class="quoted"><span class="quoted">"success <span class="free">init</span> Heap.empty"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> empty_correct<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">empty</span> <span class="bound">heap</span><span class="main">.</span> execute <span class="free">init</span> Heap.empty <span class="main">=</span> Some <span class="main">(</span><span class="bound">empty</span><span class="main">,</span> <span class="bound">heap</span><span class="main">)</span> <span class="main">⟹</span> map_of_heap' <span class="bound">empty</span> <span class="bound">heap</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> Map.empty"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> P_empty<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">empty</span> <span class="bound">heap</span><span class="main">.</span> execute <span class="free">init</span> Heap.empty <span class="main">=</span> Some <span class="main">(</span><span class="bound">empty</span><span class="main">,</span> <span class="bound">heap</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">empty</span> <span class="bound">heap</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> dp_consistency_heap
  <span class="keyword2"><span class="keyword">where</span></span> P<span class="main">=</span><span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">init_mem</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> lookup<span class="main">=</span><span class="quoted"><span class="quoted">"<span class="free">lookup</span> <span class="free">init_mem</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> update<span class="main">=</span><span class="quoted"><span class="quoted">"<span class="free">update</span> <span class="free">init_mem</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> lookup_inv<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">init_mem</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> update_inv<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">init_mem</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> heap_mem_defs.map_of_heap_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> lookup_correct<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">init_mem</span></span><span class="main"><span class="main">,</span></span> <span class="operator">unfolded</span> map_of_heap'_def<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> heap_mem_defs.map_of_heap_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> update_correct<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">init_mem</span></span><span class="main"><span class="main">,</span></span> <span class="operator">unfolded</span> map_of_heap'_def<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">init_mem</span> <span class="main">=</span> result_of <span class="free">init</span> Heap.empty"</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> consistent<span class="main">:</span> dp_consistency_heap_empty
  <span class="keyword2"><span class="keyword">where</span></span> P<span class="main">=</span><span class="quoted"><span class="quoted">"<span class="free">P</span> init_mem"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> lookup<span class="main">=</span><span class="quoted"><span class="quoted">"<span class="free">lookup</span> init_mem"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> update<span class="main">=</span><span class="quoted"><span class="quoted">"<span class="free">update</span> init_mem"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> empty<span class="main">=</span> <span class="quoted"><span class="quoted">"heap_of <span class="free">init</span> Heap.empty"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> successE<span class="main"><span class="main">[</span></span><span class="operator">OF</span> success<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> empty_correct<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> heap_mem_defs.map_of_heap_def init_mem_def map_of_heap'_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> successE<span class="main"><span class="main">[</span></span><span class="operator">OF</span> success<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> P_empty<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> init_mem_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Heap_Main-memoized_empty"><span class="command">lemma</span></span> memoized_empty<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">dp</span> <span class="free">x</span> <span class="main">=</span> result_of <span class="main">(</span><span class="free">init</span> <span class="main">⤜</span> <span class="main">(</span><span class="main">λ</span><span class="bound">mem</span><span class="main">.</span> <span class="free">dp<span class="hidden">⇩</span><sub>T</sub></span> <span class="bound">mem</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span> Heap.empty"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"consistentDP init_mem <span class="main">(</span><span class="free">dp<span class="hidden">⇩</span><sub>T</sub></span> <span class="main">(</span>result_of <span class="free">init</span> Heap.empty<span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> execute_bind_success consistent.memoized<span class="main"><span class="main">[</span></span><span class="operator">OF</span> that<span class="main"><span class="main"><span class="main">(</span></span></span>1<span class="main"><span class="main"><span class="main">)</span></span></span><span class="main"><span class="main">]</span></span> success<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> dp_consistency_new <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">dp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'v</span>"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">P</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> <span class="main">⇒</span> heap <span class="main">⇒</span> bool"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">lookup</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'v</span> option Heap"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">update</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> unit Heap"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">init</span>
  <span class="keyword2"><span class="keyword">assumes</span></span>
    success<span class="main">:</span> <span class="quoted"><span class="quoted">"success <span class="free">init</span> Heap.empty"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span>
    inv_init<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">empty</span> <span class="bound">heap</span><span class="main">.</span> execute <span class="free">init</span> Heap.empty <span class="main">=</span> Some <span class="main">(</span><span class="bound">empty</span><span class="main">,</span> <span class="bound">heap</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">empty</span> <span class="bound">heap</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> consistent<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">empty</span> <span class="bound">heap</span><span class="main">.</span> execute <span class="free">init</span> Heap.empty <span class="main">=</span> Some <span class="main">(</span><span class="bound">empty</span><span class="main">,</span> <span class="bound">heap</span><span class="main">)</span>
    <span class="main">⟹</span> dp_consistency_heap_empty <span class="main">(</span><span class="free">P</span> <span class="bound">empty</span><span class="main">)</span> <span class="main">(</span><span class="free">update</span> <span class="bound">empty</span><span class="main">)</span> <span class="main">(</span><span class="free">lookup</span> <span class="bound">empty</span><span class="main">)</span> <span class="bound">heap</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> dp_consistency_heap_empty
  <span class="keyword2"><span class="keyword">where</span></span> P<span class="main">=</span><span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span>result_of <span class="free">init</span> Heap.empty<span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> lookup<span class="main">=</span><span class="quoted"><span class="quoted">"<span class="free">lookup</span> <span class="main">(</span>result_of <span class="free">init</span> Heap.empty<span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> update<span class="main">=</span><span class="quoted"><span class="quoted">"<span class="free">update</span> <span class="main">(</span>result_of <span class="free">init</span> Heap.empty<span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> empty<span class="main">=</span> <span class="quoted"><span class="quoted">"heap_of <span class="free">init</span> Heap.empty"</span></span>
  <span class="keyword1"><span class="command">using</span></span> success <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> consistent successE<span class="main">)</span> <span class="comment1">(* Extract Theorem *)</span>

<span class="keyword1" id="Heap_Main-memoized_empty"><span class="command">lemma</span></span> memoized_empty<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">dp</span> <span class="free">x</span> <span class="main">=</span> result_of <span class="main">(</span><span class="free">init</span> <span class="main">⤜</span> <span class="main">(</span><span class="main">λ</span><span class="bound">mem</span><span class="main">.</span> <span class="free">dp<span class="hidden">⇩</span><sub>T</sub></span> <span class="bound">mem</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span> Heap.empty"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"consistentDP <span class="main">(</span><span class="free">dp<span class="hidden">⇩</span><sub>T</sub></span> <span class="main">(</span>result_of <span class="free">init</span> Heap.empty<span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> execute_bind_success memoized<span class="main"><span class="main">[</span></span><span class="operator">OF</span> that<span class="main"><span class="main"><span class="main">(</span></span></span>1<span class="main"><span class="main"><span class="main">)</span></span></span><span class="main"><span class="main">]</span></span> success<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> dp_consistency_new' <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">dp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'v</span>"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">P</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> <span class="main">⇒</span> heap <span class="main">⇒</span> bool"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">lookup</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'v</span> option Heap"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">update</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> unit Heap"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">init</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">mem</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'m</span></span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> mem_is_init<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">mem</span> <span class="main">=</span> result_of <span class="free">init</span> Heap.empty"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span>
    success<span class="main">:</span> <span class="quoted"><span class="quoted">"success <span class="free">init</span> Heap.empty"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span>
    inv_init<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">empty</span> <span class="bound">heap</span><span class="main">.</span> execute <span class="free">init</span> Heap.empty <span class="main">=</span> Some <span class="main">(</span><span class="bound">empty</span><span class="main">,</span> <span class="bound">heap</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">empty</span> <span class="bound">heap</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> consistent<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">empty</span> <span class="bound">heap</span><span class="main">.</span> execute <span class="free">init</span> Heap.empty <span class="main">=</span> Some <span class="main">(</span><span class="bound">empty</span><span class="main">,</span> <span class="bound">heap</span><span class="main">)</span>
    <span class="main">⟹</span> dp_consistency_heap_empty <span class="main">(</span><span class="free">P</span> <span class="bound">empty</span><span class="main">)</span> <span class="main">(</span><span class="free">update</span> <span class="bound">empty</span><span class="main">)</span> <span class="main">(</span><span class="free">lookup</span> <span class="bound">empty</span><span class="main">)</span> <span class="bound">heap</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> dp_consistency_heap_empty
  <span class="keyword2"><span class="keyword">where</span></span> P<span class="main">=</span><span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">mem</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> lookup<span class="main">=</span><span class="quoted"><span class="quoted">"<span class="free">lookup</span> <span class="free">mem</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> update<span class="main">=</span><span class="quoted"><span class="quoted">"<span class="free">update</span> <span class="free">mem</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> empty<span class="main">=</span> <span class="quoted"><span class="quoted">"heap_of <span class="free">init</span> Heap.empty"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> mem_is_init
  <span class="keyword1"><span class="command">using</span></span> success <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> consistent successE<span class="main">)</span> <span class="comment1">(* Extract Theorem *)</span>

<span class="keyword1" id="Heap_Main-memoized_empty"><span class="command">lemma</span></span> memoized_empty<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">dp</span> <span class="free">x</span> <span class="main">=</span> result_of <span class="main">(</span><span class="free">init</span> <span class="main">⤜</span> <span class="main">(</span><span class="main">λ</span><span class="bound">mem</span><span class="main">.</span> <span class="free">dp<span class="hidden">⇩</span><sub>T</sub></span> <span class="bound">mem</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span> Heap.empty"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"consistentDP <span class="main">(</span><span class="free">dp<span class="hidden">⇩</span><sub>T</sub></span> <span class="main">(</span>result_of <span class="free">init</span> Heap.empty<span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> execute_bind_success memoized<span class="main"><span class="main">[</span></span><span class="operator">OF</span> that<span class="main"><span class="main"><span class="main">(</span></span></span>1<span class="main"><span class="main"><span class="main">)</span></span></span><span class="main"><span class="main">]</span></span> success<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> dp_consistency_heap_array_new' <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">size</span> <span class="main">::</span> <span class="quoted">nat</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">to_index</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span> <span class="main">::</span> heap<span class="main">)</span> <span class="main">⇒</span> nat"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">mem</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">::</span>heap<span class="main">)</span> option array"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">dp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'v</span><span class="main">::</span>heap"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> mem_is_init<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">mem</span> <span class="main">=</span> result_of <span class="main">(</span>mem_empty <span class="free">size</span><span class="main">)</span> Heap.empty"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> injective<span class="main">:</span> <span class="quoted"><span class="quoted">"injective <span class="free">size</span> <span class="free">to_index</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> dp_consistency_new'
  <span class="keyword2"><span class="keyword">where</span></span> P      <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">mem</span> <span class="bound">heap</span><span class="main">.</span> Array.length <span class="bound">heap</span> <span class="bound">mem</span> <span class="main">=</span> <span class="free">size</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> lookup <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">mem</span><span class="main">.</span> mem_lookup <span class="free">size</span> <span class="free">to_index</span> <span class="bound">mem</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> update <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">mem</span><span class="main">.</span> mem_update <span class="free">size</span> <span class="free">to_index</span> <span class="bound">mem</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> init   <span class="main">=</span> <span class="quoted"><span class="quoted">"mem_empty <span class="free">size</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> mem    <span class="main">=</span> <span class="quoted"><span class="free">mem</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> dp_consistency_new'.intro<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> mem_is_init<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> success_empty<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> empty heap
    <span class="keyword1"><span class="command">using</span></span> length_mem_empty <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> fst_conv option.sel snd_conv<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> execute_heap_ofD<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> execute_result_ofD<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> array_consistentI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> injective HOL.refl<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">thm</span></span> memoized_empty

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> dp_consistency_heap_array_new <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">size</span> <span class="main">::</span> <span class="quoted">nat</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">to_index</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span> <span class="main">::</span> heap<span class="main">)</span> <span class="main">⇒</span> nat"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">dp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'v</span><span class="main">::</span>heap"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> injective<span class="main">:</span> <span class="quoted"><span class="quoted">"injective <span class="free">size</span> <span class="free">to_index</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> dp_consistency_new
  <span class="keyword2"><span class="keyword">where</span></span> P      <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">mem</span> <span class="bound">heap</span><span class="main">.</span> Array.length <span class="bound">heap</span> <span class="bound">mem</span> <span class="main">=</span> <span class="free">size</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> lookup <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">mem</span><span class="main">.</span> mem_lookup <span class="free">size</span> <span class="free">to_index</span> <span class="bound">mem</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> update <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">mem</span><span class="main">.</span> mem_update <span class="free">size</span> <span class="free">to_index</span> <span class="bound">mem</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> init   <span class="main">=</span> <span class="quoted"><span class="quoted">"mem_empty <span class="free">size</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> dp_consistency_new.intro<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> success_empty<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> empty heap
    <span class="keyword1"><span class="command">using</span></span> length_mem_empty <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> fst_conv option.sel snd_conv<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> execute_heap_ofD<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> execute_result_ofD<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> array_consistentI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> injective HOL.refl<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">thm</span></span> memoized_empty

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> dp_consistency_heap_array <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">size</span> <span class="main">::</span> <span class="quoted">nat</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">to_index</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span> <span class="main">::</span> heap<span class="main">)</span> <span class="main">⇒</span> nat"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">dp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'v</span><span class="main">::</span>heap"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> injective<span class="main">:</span> <span class="quoted"><span class="quoted">"injective <span class="free">size</span> <span class="free">to_index</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> dp_consistency_heap_init
  <span class="keyword2"><span class="keyword">where</span></span> P<span class="main">=</span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">mem</span> <span class="bound">heap</span><span class="main">.</span> Array.length <span class="bound">heap</span> <span class="bound">mem</span> <span class="main">=</span> <span class="free">size</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> lookup<span class="main">=</span><span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">mem</span><span class="main">.</span> mem_lookup <span class="free">size</span> <span class="free">to_index</span> <span class="bound">mem</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> update<span class="main">=</span><span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">mem</span><span class="main">.</span> mem_update <span class="free">size</span> <span class="free">to_index</span> <span class="bound">mem</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> init<span class="main">=</span><span class="quoted"><span class="quoted">"mem_empty <span class="free">size</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> lookup_inv
    <span class="keyword1"><span class="command">unfolding</span></span> lift_p_def mem_lookup_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def <span class="dynamic"><span class="dynamic">execute_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> update_inv
    <span class="keyword1"><span class="command">unfolding</span></span> State_Heap.lift_p_def mem_update_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def <span class="dynamic"><span class="dynamic">execute_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> k heap
    <span class="keyword1"><span class="command">unfolding</span></span> heap_correct_init_defs.map_of_heap'_def map_le_def mem_lookup_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span> Let_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> heap k
    <span class="keyword1"><span class="command">unfolding</span></span> heap_correct_init_defs.map_of_heap'_def map_le_def mem_lookup_def mem_update_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span> Let_def length_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> nth_list_update_neq<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> injective<span class="main">[</span><span class="operator">unfolded</span> injective_def<span class="main">]</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> success_empty<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> empty' heap
    <span class="keyword1"><span class="command">unfolding</span></span> heap_correct_init_defs.map_of_heap'_def mem_lookup_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> map_emptyI <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def <span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> fst_conv option.sel snd_conv nth_mem_empty<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> empty' heap
    <span class="keyword1"><span class="command">unfolding</span></span> heap_correct_init_defs.map_of_heap'_def mem_lookup_def map_le_def
    <span class="keyword1"><span class="command">using</span></span> length_mem_empty <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> fst_conv option.sel snd_conv<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">locale</span></span> dp_consistency_heap_array_pair' <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">size</span> <span class="main">::</span> <span class="quoted">nat</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">key1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k1</span> <span class="main">::</span> heap<span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">key2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'k2</span> <span class="main">::</span> heap"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">to_index</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k2</span> <span class="main">⇒</span> nat"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">dp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'v</span><span class="main">::</span>heap"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">k1</span> <span class="free">k2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k1</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">mem</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k1</span> ref <span class="main">×</span>
             <span class="tfree">'k1</span> ref <span class="main">×</span>
             <span class="tfree">'v</span> option array ref <span class="main">×</span>
             <span class="tfree">'v</span> option array ref<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> mem_is_init<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">mem</span> <span class="main">=</span> result_of <span class="main">(</span>init_state <span class="free">size</span> <span class="free">k1</span> <span class="free">k2</span><span class="main">)</span> Heap.empty"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> injective<span class="main">:</span> <span class="quoted"><span class="quoted">"injective <span class="free">size</span> <span class="free">to_index</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> keys_injective<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">k</span> <span class="bound">k'</span><span class="main">.</span> <span class="free">key1</span> <span class="bound">k</span> <span class="main">=</span> <span class="free">key1</span> <span class="bound">k'</span> <span class="main">∧</span> <span class="free">key2</span> <span class="bound">k</span> <span class="main">=</span> <span class="free">key2</span> <span class="bound">k'</span> <span class="main">⟶</span> <span class="bound">k</span> <span class="main">=</span> <span class="bound">k'</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> keys_neq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">k1</span> <span class="main">≠</span> <span class="free">k2</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">inv_pair'</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span> <span class="main">(</span><span class="bound">k_ref1</span><span class="main">,</span> <span class="bound">k_ref2</span><span class="main">,</span> <span class="bound">m_ref1</span><span class="main">,</span> <span class="bound">m_ref2</span><span class="main">)</span><span class="main">.</span>
      pair_mem_defs.inv_pair <span class="main">(</span>lookup1 <span class="free">size</span> <span class="free">to_index</span> <span class="bound">m_ref1</span><span class="main">)</span>
        <span class="main">(</span>lookup2 <span class="free">size</span> <span class="free">to_index</span> <span class="bound">m_ref2</span><span class="main">)</span> <span class="main">(</span>get_k1 <span class="bound">k_ref1</span><span class="main">)</span>
        <span class="main">(</span>get_k2 <span class="bound">k_ref2</span><span class="main">)</span>
        <span class="main">(</span>inv_pair_weak <span class="free">size</span> <span class="bound">m_ref1</span> <span class="bound">m_ref2</span> <span class="bound">k_ref1</span> <span class="bound">k_ref2</span><span class="main">)</span> <span class="free">key1</span> <span class="free">key2</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> dp_consistency_new'
  <span class="keyword2"><span class="keyword">where</span></span> P<span class="main">=</span><span class="quoted">inv_pair'</span>
    <span class="keyword2"><span class="keyword">and</span></span> lookup<span class="main">=</span><span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="main">(</span><span class="bound">k_ref1</span><span class="main">,</span> <span class="bound">k_ref2</span><span class="main">,</span> <span class="bound">m_ref1</span><span class="main">,</span> <span class="bound">m_ref2</span><span class="main">)</span><span class="main">.</span>
      lookup_pair <span class="free">size</span> <span class="free">to_index</span> <span class="free">key1</span> <span class="free">key2</span> <span class="bound">m_ref1</span> <span class="bound">m_ref2</span> <span class="bound">k_ref1</span> <span class="bound">k_ref2</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> update<span class="main">=</span><span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="main">(</span><span class="bound">k_ref1</span><span class="main">,</span> <span class="bound">k_ref2</span><span class="main">,</span> <span class="bound">m_ref1</span><span class="main">,</span> <span class="bound">m_ref2</span><span class="main">)</span><span class="main">.</span>
      update_pair <span class="free">size</span> <span class="free">to_index</span> <span class="free">key1</span> <span class="free">key2</span> <span class="bound">m_ref1</span> <span class="bound">m_ref2</span> <span class="bound">k_ref1</span> <span class="bound">k_ref2</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> init<span class="main">=</span><span class="quoted"><span class="quoted">"init_state <span class="free">size</span> <span class="free">k1</span> <span class="free">k2</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> dp_consistency_new'.intro<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> mem_is_init<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> succes_init_state<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> empty heap
    <span class="keyword1"><span class="command">unfolding</span></span> inv_pair'_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> init_state_inv'<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> injective<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> init_state_distinct<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> keys_injective<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> keys_neq<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command">unfolding</span></span> inv_pair'_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> consistent_empty_pairI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> injective<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> init_state_distinct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> keys_injective<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> keys_neq<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> dp_consistency_heap_array_pair_iterator <span class="main">=</span>
  dp_consistency_heap_array_pair' <span class="keyword2"><span class="keyword">where</span></span> dp <span class="main">=</span> <span class="quoted"><span class="free">dp</span></span> <span class="main">+</span> iterator <span class="keyword2"><span class="keyword">where</span></span> cnt <span class="main">=</span> <span class="quoted"><span class="free">cnt</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">dp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'v</span><span class="main">::</span>heap"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">cnt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> dp_consistency_iterator_heap
  <span class="keyword2"><span class="keyword">where</span></span> P <span class="main">=</span> <span class="quoted"><span class="quoted">"inv_pair' <span class="free">mem</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> update <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">case</span> <span class="free">mem</span> <span class="keyword1">of</span>
  <span class="main">(</span><span class="bound">k_ref1</span><span class="main">,</span> <span class="bound">k_ref2</span><span class="main">,</span> <span class="bound">m_ref1</span><span class="main">,</span> <span class="bound">m_ref2</span><span class="main">)</span> <span class="main">⇒</span>
    update_pair <span class="free">size</span> <span class="free">to_index</span> <span class="free">key1</span> <span class="free">key2</span> <span class="bound">m_ref1</span> <span class="bound">m_ref2</span> <span class="bound">k_ref1</span> <span class="bound">k_ref2</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> lookup <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">case</span> <span class="free">mem</span> <span class="keyword1">of</span>
  <span class="main">(</span><span class="bound">k_ref1</span><span class="main">,</span> <span class="bound">k_ref2</span><span class="main">,</span> <span class="bound">m_ref1</span><span class="main">,</span> <span class="bound">m_ref2</span><span class="main">)</span> <span class="main">⇒</span>
    lookup_pair <span class="free">size</span> <span class="free">to_index</span> <span class="free">key1</span> <span class="free">key2</span> <span class="bound">m_ref1</span> <span class="bound">m_ref2</span> <span class="bound">k_ref1</span> <span class="bound">k_ref2</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">..</span></span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">locale</span></span> dp_consistency_heap_array_pair <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">size</span> <span class="main">::</span> <span class="quoted">nat</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">key1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k1</span> <span class="main">::</span> heap<span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">key2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'k2</span> <span class="main">::</span> heap"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">to_index</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k2</span> <span class="main">⇒</span> nat"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">dp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'v</span><span class="main">::</span>heap"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">k1</span> <span class="free">k2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k1</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> injective<span class="main">:</span> <span class="quoted"><span class="quoted">"injective <span class="free">size</span> <span class="free">to_index</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> keys_injective<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">k</span> <span class="bound">k'</span><span class="main">.</span> <span class="free">key1</span> <span class="bound">k</span> <span class="main">=</span> <span class="free">key1</span> <span class="bound">k'</span> <span class="main">∧</span> <span class="free">key2</span> <span class="bound">k</span> <span class="main">=</span> <span class="free">key2</span> <span class="bound">k'</span> <span class="main">⟶</span> <span class="bound">k</span> <span class="main">=</span> <span class="bound">k'</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> keys_neq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">k1</span> <span class="main">≠</span> <span class="free">k2</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">inv_pair'</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span> <span class="main">(</span><span class="bound">k_ref1</span><span class="main">,</span> <span class="bound">k_ref2</span><span class="main">,</span> <span class="bound">m_ref1</span><span class="main">,</span> <span class="bound">m_ref2</span><span class="main">)</span><span class="main">.</span>
      pair_mem_defs.inv_pair <span class="main">(</span>lookup1 <span class="free">size</span> <span class="free">to_index</span> <span class="bound">m_ref1</span><span class="main">)</span>
        <span class="main">(</span>lookup2 <span class="free">size</span> <span class="free">to_index</span> <span class="bound">m_ref2</span><span class="main">)</span> <span class="main">(</span>get_k1 <span class="bound">k_ref1</span><span class="main">)</span>
        <span class="main">(</span>get_k2 <span class="bound">k_ref2</span><span class="main">)</span>
        <span class="main">(</span>inv_pair_weak <span class="free">size</span> <span class="bound">m_ref1</span> <span class="bound">m_ref2</span> <span class="bound">k_ref1</span> <span class="bound">k_ref2</span><span class="main">)</span> <span class="free">key1</span> <span class="free">key2</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> dp_consistency_new
  <span class="keyword2"><span class="keyword">where</span></span> P<span class="main">=</span><span class="quoted">inv_pair'</span>
    <span class="keyword2"><span class="keyword">and</span></span> lookup<span class="main">=</span><span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="main">(</span><span class="bound">k_ref1</span><span class="main">,</span> <span class="bound">k_ref2</span><span class="main">,</span> <span class="bound">m_ref1</span><span class="main">,</span> <span class="bound">m_ref2</span><span class="main">)</span><span class="main">.</span>
      lookup_pair <span class="free">size</span> <span class="free">to_index</span> <span class="free">key1</span> <span class="free">key2</span> <span class="bound">m_ref1</span> <span class="bound">m_ref2</span> <span class="bound">k_ref1</span> <span class="bound">k_ref2</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> update<span class="main">=</span><span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="main">(</span><span class="bound">k_ref1</span><span class="main">,</span> <span class="bound">k_ref2</span><span class="main">,</span> <span class="bound">m_ref1</span><span class="main">,</span> <span class="bound">m_ref2</span><span class="main">)</span><span class="main">.</span>
      update_pair <span class="free">size</span> <span class="free">to_index</span> <span class="free">key1</span> <span class="free">key2</span> <span class="bound">m_ref1</span> <span class="bound">m_ref2</span> <span class="bound">k_ref1</span> <span class="bound">k_ref2</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> init<span class="main">=</span><span class="quoted"><span class="quoted">"init_state <span class="free">size</span> <span class="free">k1</span> <span class="free">k2</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> dp_consistency_new.intro<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> succes_init_state<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> empty heap
    <span class="keyword1"><span class="command">unfolding</span></span> inv_pair'_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> init_state_inv'<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> injective<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> init_state_distinct<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> keys_injective<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> keys_neq<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command">unfolding</span></span> inv_pair'_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> consistent_empty_pairI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> injective<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> init_state_distinct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> keys_injective<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> keys_neq<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Code Setup›</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">]</span> <span class="main">=</span> heap_mem_defs.checkmem_checkmem'<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span>
  heap_mem_defs.checkmem'_def
  Heap_Main.map<span class="hidden">⇩</span><sub>T</sub>_def

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* theory *)</span>
</pre>
</div><div id="State_Main">
<div class="head">
<h1>Theory State_Main</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Setup for the State Monad›</span></span>

<span class="keyword1"><span class="command">theory</span></span> State_Main
  <span class="keyword2"><span class="keyword">imports</span></span>
    <span class="quoted">"<a href="#Transform_Cmd">../transform/Transform_Cmd</a>"</span>
    <a href="#Memory">Memory</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> state_monad_syntax <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">thm</span></span> if_cong
<span class="keyword1" id="State_Main-ifT_cong"><span class="command">lemma</span></span> ifT_cong<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">=</span> <span class="free">c</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">=</span> <span class="free">u</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="free">c</span> <span class="main">⟹</span> <span class="free">y</span> <span class="main">=</span> <span class="free">v</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"State_Monad_Ext.if<span class="hidden">⇩</span><sub>T</sub> <span class="main">⟨</span><span class="free">b</span><span class="main">⟩</span> <span class="free">x</span> <span class="free">y</span> <span class="main">=</span> State_Monad_Ext.if<span class="hidden">⇩</span><sub>T</sub> <span class="main">⟨</span><span class="free">c</span><span class="main">⟩</span> <span class="free">u</span> <span class="free">v</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> State_Monad_Ext.if<span class="hidden">⇩</span><sub>T</sub>_def
  <span class="keyword1"><span class="command">unfolding</span></span> bind_left_identity
  <span class="keyword1"><span class="command">using</span></span> if_cong<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1" id="State_Main-return_app_return_cong"><span class="command">lemma</span></span> return_app_return_cong<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">x</span> <span class="main">=</span> <span class="free">g</span> <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟨</span><span class="free">f</span><span class="main">⟩</span> <span class="main">.</span> <span class="main">⟨</span><span class="free">x</span><span class="main">⟩</span> <span class="main">=</span> <span class="main">⟨</span><span class="free">g</span><span class="main">⟩</span> <span class="main">.</span> <span class="main">⟨</span><span class="free">y</span><span class="main">⟩</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> State_Monad_Ext.return_app_return_meta assms <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">fundef_cong</span><span class="main">]</span> <span class="main">=</span>
  return_app_return_cong
  ifT_cong
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">memoize_fun</span></span> comp<span class="hidden">⇩</span><sub>T</sub><span class="main">:</span> <span class="quoted">comp</span> <span class="keyword1"><span class="command">monadifies</span></span> <span class="main">(</span>state<span class="main">)</span> comp_def
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> dp_consistency<span class="main">)</span> comp<span class="hidden">⇩</span><sub>T</sub>_transfer<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"crel_vs <span class="main">(</span><span class="main">(</span><span class="free">R1</span> <span class="keyword1">===&gt;<span class="hidden">⇩</span><sub>T</sub></span> <span class="free">R2</span><span class="main">)</span> <span class="keyword1">===&gt;<span class="hidden">⇩</span><sub>T</sub></span> <span class="main">(</span><span class="free">R0</span> <span class="keyword1">===&gt;<span class="hidden">⇩</span><sub>T</sub></span> <span class="free">R1</span><span class="main">)</span> <span class="keyword1">===&gt;<span class="hidden">⇩</span><sub>T</sub></span> <span class="main">(</span><span class="free">R0</span> <span class="keyword1">===&gt;<span class="hidden">⇩</span><sub>T</sub></span> <span class="free">R2</span><span class="main">)</span><span class="main">)</span> comp comp<span class="hidden">⇩</span><sub>T</sub>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">memoize_combinator_init</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> IH <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">memoize_unfold_defs</span> <span class="operator">transfer_prover</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">memoize_fun</span></span> map<span class="hidden">⇩</span><sub>T</sub><span class="main">:</span> <span class="quoted">map</span> <span class="keyword1"><span class="command">monadifies</span></span> <span class="main">(</span>state<span class="main">)</span> list.map
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> dp_consistency<span class="main">)</span> map<span class="hidden">⇩</span><sub>T</sub>_transfer<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"crel_vs <span class="main">(</span><span class="main">(</span><span class="free">R0</span> <span class="keyword1">===&gt;<span class="hidden">⇩</span><sub>T</sub></span> <span class="free">R1</span><span class="main">)</span> <span class="keyword1">===&gt;<span class="hidden">⇩</span><sub>T</sub></span> list_all2 <span class="free">R0</span> <span class="keyword1">===&gt;<span class="hidden">⇩</span><sub>T</sub></span> list_all2 <span class="free">R1</span><span class="main">)</span> map map<span class="hidden">⇩</span><sub>T</sub>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">memoize_combinator_init</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> list_all2_induct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">memoize_unfold_defs</span> <span class="operator">transfer_prover</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">memoize_unfold_defs</span> <span class="operator">transfer_prover</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">memoize_fun</span></span> fold<span class="hidden">⇩</span><sub>T</sub><span class="main">:</span> <span class="quoted">fold</span> <span class="keyword1"><span class="command">monadifies</span></span> <span class="main">(</span>state<span class="main">)</span> fold.simps
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> dp_consistency<span class="main">)</span> fold<span class="hidden">⇩</span><sub>T</sub>_transfer<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"crel_vs <span class="main">(</span><span class="main">(</span><span class="free">R0</span> <span class="keyword1">===&gt;<span class="hidden">⇩</span><sub>T</sub></span> <span class="free">R1</span> <span class="keyword1">===&gt;<span class="hidden">⇩</span><sub>T</sub></span> <span class="free">R1</span><span class="main">)</span> <span class="keyword1">===&gt;<span class="hidden">⇩</span><sub>T</sub></span> list_all2 <span class="free">R0</span> <span class="keyword1">===&gt;<span class="hidden">⇩</span><sub>T</sub></span> <span class="free">R1</span> <span class="keyword1">===&gt;<span class="hidden">⇩</span><sub>T</sub></span> <span class="free">R1</span><span class="main">)</span> fold fold<span class="hidden">⇩</span><sub>T</sub>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">memoize_combinator_init</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> list_all2_induct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">memoize_unfold_defs</span> <span class="operator">transfer_prover</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">memoize_unfold_defs</span> <span class="operator">transfer_prover</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> state_monad_syntax <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">thm</span></span> map_cong
<span class="keyword1" id="State_Main-mapT_cong"><span class="command">lemma</span></span> mapT_cong<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="free">ys</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">∈</span>set <span class="free">ys</span> <span class="main">⟹</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">g</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map<span class="hidden">⇩</span><sub>T</sub> <span class="main">.</span> <span class="main">⟨</span><span class="free">f</span><span class="main">⟩</span> <span class="main">.</span> <span class="main">⟨</span><span class="free">xs</span><span class="main">⟩</span> <span class="main">=</span> map<span class="hidden">⇩</span><sub>T</sub> <span class="main">.</span> <span class="main">⟨</span><span class="free">g</span><span class="main">⟩</span> <span class="main">.</span> <span class="main">⟨</span><span class="free">ys</span><span class="main">⟩</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> map<span class="hidden">⇩</span><sub>T</sub>_def 
  <span class="keyword1"><span class="command">unfolding</span></span> assms<span class="main">(</span>1<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> State_Monad_Ext.return_app_return_meta<span class="main">)</span>

<span class="keyword1"><span class="command">thm</span></span> fold_cong
<span class="keyword1" id="State_Main-foldT_cong"><span class="command">lemma</span></span> foldT_cong<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="free">ys</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">∈</span>set <span class="free">ys</span> <span class="main">⟹</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">g</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fold<span class="hidden">⇩</span><sub>T</sub> <span class="main">.</span> <span class="main">⟨</span><span class="free">f</span><span class="main">⟩</span> <span class="main">.</span> <span class="main">⟨</span><span class="free">xs</span><span class="main">⟩</span> <span class="main">=</span> fold<span class="hidden">⇩</span><sub>T</sub> <span class="main">.</span> <span class="main">⟨</span><span class="free">g</span><span class="main">⟩</span> <span class="main">.</span> <span class="main">⟨</span><span class="free">ys</span><span class="main">⟩</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fold<span class="hidden">⇩</span><sub>T</sub>_def
  <span class="keyword1"><span class="command">unfolding</span></span> assms<span class="main">(</span>1<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> State_Monad_Ext.return_app_return_meta<span class="main">)</span>

<span class="keyword1" id="State_Main-abs_unit_cong"><span class="command">lemma</span></span> abs_unit_cong<span class="main">:</span>
  <span class="comment1">(* for lazy checkmem *)</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">::</span>unit<span class="main">.</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">fundef_cong</span><span class="main">]</span> <span class="main">=</span>
  return_app_return_cong
  ifT_cong
  mapT_cong
  foldT_cong
  abs_unit_cong
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> dp_consistency <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax state_monad_syntax <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">named_theorems</span></span> dp_match_rule

<span class="keyword1"><span class="command">thm</span></span> if_cong
<span class="keyword1" id="State_Main-if"><span class="command">lemma</span></span> if<span class="hidden">⇩</span><sub>T</sub>_cong2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">Rel</span> <span class="main">(=)</span> <span class="free">b</span> <span class="free">c</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">⟹</span> <span class="keyword1">Rel</span> <span class="main">(</span>crel_vs <span class="free">R</span><span class="main">)</span> <span class="free">x</span> <span class="free">x<span class="hidden">⇩</span><sub>T</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="free">c</span> <span class="main">⟹</span> <span class="keyword1">Rel</span> <span class="main">(</span>crel_vs <span class="free">R</span><span class="main">)</span> <span class="free">y</span> <span class="free">y<span class="hidden">⇩</span><sub>T</sub></span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">Rel</span> <span class="main">(</span>crel_vs <span class="free">R</span><span class="main">)</span> <span class="main">(</span><span class="keyword1">if</span> <span class="main">(</span>Wrap <span class="free">b</span><span class="main">)</span> <span class="keyword1">then</span> <span class="free">x</span> <span class="keyword1">else</span> <span class="free">y</span><span class="main">)</span> <span class="main">(</span>State_Monad_Ext.if<span class="hidden">⇩</span><sub>T</sub> <span class="main">⟨</span><span class="free">c</span><span class="main">⟩</span> <span class="free">x<span class="hidden">⇩</span><sub>T</sub></span> <span class="free">y<span class="hidden">⇩</span><sub>T</sub></span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> State_Monad_Ext.if<span class="hidden">⇩</span><sub>T</sub>_def bind_left_identity Rel_def Wrap_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split<span class="main">)</span>

<span class="keyword1" id="State_Main-map"><span class="command">lemma</span></span> map<span class="hidden">⇩</span><sub>T</sub>_cong2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span>
    <span class="quoted"><span class="quoted">"is_equality <span class="free">R</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="keyword1">Rel</span> <span class="free">R</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">∈</span>set <span class="free">ys</span> <span class="main">⟹</span> <span class="keyword1">Rel</span> <span class="main">(</span>crel_vs <span class="free">S</span><span class="main">)</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">f<span class="hidden">⇩</span><sub>T</sub>'</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">Rel</span> <span class="main">(</span>crel_vs <span class="main">(</span>list_all2 <span class="free">S</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>App <span class="main">(</span>App map <span class="main">(</span>Wrap <span class="free">f</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Wrap <span class="free">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>map<span class="hidden">⇩</span><sub>T</sub> <span class="main">.</span> <span class="main">⟨</span><span class="free">f<span class="hidden">⇩</span><sub>T</sub>'</span><span class="main">⟩</span> <span class="main">.</span> <span class="main">⟨</span><span class="free">ys</span><span class="main">⟩</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> map<span class="hidden">⇩</span><sub>T</sub>_def
  <span class="keyword1"><span class="command">unfolding</span></span> State_Monad_Ext.return_app_return_meta
  <span class="keyword1"><span class="command">unfolding</span></span> assms<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> Rel_def assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> is_equality_def<span class="main"><span class="main">]</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>3<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> Rel_def Wrap_def App_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">memoize_unfold_defs</span> <span class="main"><span class="main">(</span></span>state<span class="main"><span class="main">)</span></span> <span class="quoted">map</span><span class="main">)</span> <span class="operator">transfer_prover</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> prems <span class="keyword2"><span class="keyword">for</span></span> a ys
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">memoize_unfold_defs</span> <span class="main"><span class="main">(</span></span>state<span class="main"><span class="main">)</span></span> <span class="quoted">map</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> State_Monad_Ext.return_app_return_meta Wrap_App_Wrap<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span> <span class="main">=</span>
      prems<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> list.set_intros<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span>
      prems<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> prems<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">OF</span> list.set_intros<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="State_Main-fold"><span class="command">lemma</span></span> fold<span class="hidden">⇩</span><sub>T</sub>_cong2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span>
    <span class="quoted"><span class="quoted">"is_equality <span class="free">R</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="keyword1">Rel</span> <span class="free">R</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">∈</span>set <span class="free">ys</span> <span class="main">⟹</span> <span class="keyword1">Rel</span> <span class="main">(</span>crel_vs <span class="main">(</span><span class="free">S</span> <span class="main">===&gt;</span> crel_vs <span class="free">S</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">f<span class="hidden">⇩</span><sub>T</sub>'</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>
    <span class="quoted"><span class="quoted">"<span class="keyword1">Rel</span> <span class="main">(</span>crel_vs <span class="main">(</span><span class="free">S</span> <span class="main">===&gt;</span> crel_vs <span class="free">S</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>fold <span class="free">f</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>fold<span class="hidden">⇩</span><sub>T</sub> <span class="main">.</span> <span class="main">⟨</span><span class="free">f<span class="hidden">⇩</span><sub>T</sub>'</span><span class="main">⟩</span> <span class="main">.</span> <span class="main">⟨</span><span class="free">ys</span><span class="main">⟩</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fold<span class="hidden">⇩</span><sub>T</sub>_def
  <span class="keyword1"><span class="command">unfolding</span></span> State_Monad_Ext.return_app_return_meta
  <span class="keyword1"><span class="command">unfolding</span></span> assms<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> Rel_def assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> is_equality_def<span class="main"><span class="main">]</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>3<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> Rel_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">memoize_unfold_defs</span> <span class="main"><span class="main">(</span></span>state<span class="main"><span class="main">)</span></span> <span class="quoted">fold</span><span class="main">)</span> <span class="operator">transfer_prover</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> prems <span class="keyword2"><span class="keyword">for</span></span> a ys
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">memoize_unfold_defs</span> <span class="main"><span class="main">(</span></span>state<span class="main"><span class="main">)</span></span> <span class="quoted">fold</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> State_Monad_Ext.return_app_return_meta Wrap_App_Wrap<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span> <span class="main">=</span>
      prems<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> list.set_intros<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span>
      prems<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> prems<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">OF</span> list.set_intros<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="State_Main-refl2"><span class="command">lemma</span></span> refl2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"is_equality <span class="free">R</span> <span class="main">⟹</span> <span class="keyword1">Rel</span> <span class="free">R</span> <span class="free">x</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> is_equality_def Rel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="State_Main-rel_fun2"><span class="command">lemma</span></span> rel_fun2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"is_equality <span class="free">R0</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">Rel</span> <span class="free">R1</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">g</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">Rel</span> <span class="main">(</span>rel_fun <span class="free">R0</span> <span class="free">R1</span><span class="main">)</span> <span class="free">f</span> <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> is_equality_def Rel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="State_Main-crel_vs_return_app_return"><span class="command">lemma</span></span> crel_vs_return_app_return<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">Rel</span> <span class="free">R</span> <span class="main">(</span><span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span><span class="free">g</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">Rel</span> <span class="free">R</span> <span class="main">(</span>App <span class="main">(</span>Wrap <span class="free">f</span><span class="main">)</span> <span class="main">(</span>Wrap <span class="free">x</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">⟨</span><span class="free">g</span><span class="main">⟩</span> <span class="main">.</span> <span class="main">⟨</span><span class="free">x</span><span class="main">⟩</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> State_Monad_Ext.return_app_return_meta Wrap_App_Wrap <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">thm</span></span> option.case_cong<span class="main">[</span><span class="operator">no_vars</span><span class="main">]</span>
<span class="keyword1" id="State_Main-option_case_cong'"><span class="command">lemma</span></span> option_case_cong'<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="keyword1">Rel</span> <span class="main">(=)</span> <span class="free">option'</span> <span class="free">option</span> <span class="main">⟹</span>
<span class="main">(</span><span class="free">option</span> <span class="main">=</span> None <span class="main">⟹</span> <span class="keyword1">Rel</span> <span class="free">R</span> <span class="free">f1</span> <span class="free">g1</span><span class="main">)</span> <span class="main">⟹</span>
<span class="main">(</span><span class="main">⋀</span><span class="bound">x2</span><span class="main">.</span> <span class="free">option</span> <span class="main">=</span> Some <span class="bound">x2</span> <span class="main">⟹</span> <span class="keyword1">Rel</span> <span class="free">R</span> <span class="main">(</span><span class="free">f2</span> <span class="bound">x2</span><span class="main">)</span> <span class="main">(</span><span class="free">g2</span> <span class="bound">x2</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span>
<span class="keyword1">Rel</span> <span class="free">R</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">option'</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="free">f1</span> <span class="main">|</span> Some <span class="bound">x2</span> <span class="main">⇒</span> <span class="free">f2</span> <span class="bound">x2</span><span class="main">)</span>
<span class="main">(</span><span class="keyword1">case</span> <span class="free">option</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="free">g1</span> <span class="main">|</span> Some <span class="bound">x2</span> <span class="main">⇒</span> <span class="free">g2</span> <span class="bound">x2</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Rel_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1"><span class="command">thm</span></span> prod.case_cong<span class="main">[</span><span class="operator">no_vars</span><span class="main">]</span>
<span class="keyword1" id="State_Main-prod_case_cong'"><span class="command">lemma</span></span> prod_case_cong'<span class="main">:</span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">prod</span> <span class="free">prod'</span> <span class="keyword2"><span class="keyword">shows</span></span>
<span class="quoted"><span class="quoted">"<span class="keyword1">Rel</span> <span class="main">(=)</span> <span class="free">prod</span> <span class="free">prod'</span> <span class="main">⟹</span>
<span class="main">(</span><span class="main">⋀</span><span class="bound">x1</span> <span class="bound">x2</span><span class="main">.</span> <span class="free">prod'</span> <span class="main">=</span> <span class="main">(</span><span class="bound">x1</span><span class="main">,</span> <span class="bound">x2</span><span class="main">)</span> <span class="main">⟹</span> <span class="keyword1">Rel</span> <span class="free">R</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x1</span> <span class="bound">x2</span><span class="main">)</span> <span class="main">(</span><span class="free">g</span> <span class="bound">x1</span> <span class="bound">x2</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span>
<span class="keyword1">Rel</span> <span class="free">R</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">prod</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">x1</span><span class="main">,</span> <span class="bound">x2</span><span class="main">)</span> <span class="main">⇒</span> <span class="free">f</span> <span class="bound">x1</span> <span class="bound">x2</span><span class="main">)</span>
<span class="main">(</span><span class="keyword1">case</span> <span class="free">prod'</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">x1</span><span class="main">,</span> <span class="bound">x2</span><span class="main">)</span> <span class="main">⇒</span> <span class="free">g</span> <span class="bound">x1</span> <span class="bound">x2</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Rel_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>

<span class="keyword1"><span class="command">thm</span></span> nat.case_cong<span class="main">[</span><span class="operator">no_vars</span><span class="main">]</span>
<span class="keyword1" id="State_Main-nat_case_cong'"><span class="command">lemma</span></span> nat_case_cong'<span class="main">:</span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">nat</span> <span class="free">nat'</span> <span class="keyword2"><span class="keyword">shows</span></span>
<span class="quoted"><span class="quoted">"<span class="keyword1">Rel</span> <span class="main">(=)</span> <span class="free">nat</span> <span class="free">nat'</span> <span class="main">⟹</span>
<span class="main">(</span><span class="free">nat'</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟹</span> <span class="keyword1">Rel</span> <span class="free">R</span> <span class="free">f1</span> <span class="free">g1</span><span class="main">)</span> <span class="main">⟹</span>
<span class="main">(</span><span class="main">⋀</span><span class="bound">x2</span><span class="main">.</span> <span class="free">nat'</span> <span class="main">=</span> Suc <span class="bound">x2</span> <span class="main">⟹</span> <span class="keyword1">Rel</span> <span class="free">R</span> <span class="main">(</span><span class="free">f2</span> <span class="bound">x2</span><span class="main">)</span> <span class="main">(</span><span class="free">g2</span> <span class="bound">x2</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span>
<span class="keyword1">Rel</span> <span class="free">R</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">nat</span> <span class="keyword1">of</span> <span class="main">0</span> <span class="main">⇒</span> <span class="free">f1</span> <span class="main">|</span> Suc <span class="bound">x2</span> <span class="main">⇒</span> <span class="free">f2</span> <span class="bound">x2</span><span class="main">)</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">nat'</span> <span class="keyword1">of</span> <span class="main">0</span> <span class="main">⇒</span> <span class="free">g1</span> <span class="main">|</span> Suc <span class="bound">x2</span> <span class="main">⇒</span> <span class="free">g2</span> <span class="bound">x2</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Rel_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> nat.splits<span class="main">)</span>
  

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">dp_match_rule</span><span class="main">]</span> <span class="main">=</span>
  prod_case_cong'
  option_case_cong'
  nat_case_cong'


<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">dp_match_rule</span><span class="main">]</span> <span class="main">=</span>
  crel_vs_return_app_return

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">dp_match_rule</span><span class="main">]</span> <span class="main">=</span>
  map<span class="hidden">⇩</span><sub>T</sub>_cong2
  fold<span class="hidden">⇩</span><sub>T</sub>_cong2
  if<span class="hidden">⇩</span><sub>T</sub>_cong2

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">dp_match_rule</span><span class="main">]</span> <span class="main">=</span>
  crel_vs_return
  crel_vs_fun_app
  refl2
  rel_fun2

<span class="comment1">(*
lemmas [dp_match_rule] =
  crel_vs_checkmem_tupled
*)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* context lifting_syntax *)</span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* context dp_consistency *)</span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Code Setup›</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">]</span> <span class="main">=</span>
  state_mem_defs.checkmem_checkmem'<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
  state_mem_defs.checkmem'_def
  map<span class="hidden">⇩</span><sub>T</sub>_def

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* theory *)</span>
</pre>
</div><div id="Example_Misc">
<div class="head">
<h1>Theory Example_Misc</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Examples›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Misc›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Example_Misc
  <span class="keyword2"><span class="keyword">imports</span></span>
    <a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL/Main.html">Main</a>
    <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/Extended.html">HOL-Library.Extended</a>"</span>
    <span class="quoted">"<a href="#State_Main">../state_monad/State_Main</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">paragraph</span></span> <span class="quoted"><span class="plain_text">‹Lists›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">min_list</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>ord list <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">min_list</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">of</span> <span class="main">[]</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> min <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="free">min_list</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Example_Misc-fold_min_commute"><span class="command">lemma</span></span> fold_min_commute<span class="main">:</span>
  <span class="quoted"><span class="quoted">"fold min <span class="free">xs</span> <span class="main">(</span>min <span class="free">a</span> <span class="free">b</span><span class="main">)</span> <span class="main">=</span> min <span class="free">a</span> <span class="main">(</span>fold min <span class="free">xs</span> <span class="free">b</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">a</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> linorder"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">a</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">metis</span> min.commute min.assoc<span class="main">)</span>

<span class="keyword1" id="Example_Misc-min_list_fold"><span class="command">lemma</span></span> min_list_fold<span class="main">:</span>
  <span class="quoted"><span class="quoted">"min_list <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> fold min <span class="free">xs</span> <span class="free">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> linorder"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fold_min_commute<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">metis</span> min.commute<span class="main">)</span>

<span class="comment1">(* FIXME mv List *)</span>
<span class="keyword1" id="Example_Misc-induct_list012"><span class="command">lemma</span></span> induct_list012<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">P</span> <span class="main">[]</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="main">[</span><span class="bound">x</span><span class="main">]</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">x</span> <span class="bound">y</span> <span class="bound">zs</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span><span class="bound">y</span> <span class="main">#</span> <span class="bound">zs</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span><span class="bound">x</span> <span class="main">#</span> <span class="bound">y</span> <span class="main">#</span> <span class="bound">zs</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">induction_schema</span> <span class="main">(</span><span class="operator">pat_completeness</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">lexicographic_order</span><span class="main">)</span>

<span class="keyword1" id="Example_Misc-min_list_Min"><span class="command">lemma</span></span> min_list_Min<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">⟹</span> min_list <span class="free">xs</span> <span class="main">=</span> Min <span class="main">(</span>set <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> induct_list012<span class="main">)</span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">paragraph</span></span> <span class="quoted"><span class="plain_text">‹Extended Data Type›</span></span>

<span class="comment1">(* TODO: Move to distribution! *)</span>
<span class="keyword1" id="Example_Misc-Pinf_add_right"><span class="command">lemma</span></span> Pinf_add_right<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">∞</span> <span class="main">+</span> <span class="free">x</span> <span class="main">=</span> <span class="main">∞</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">paragraph</span></span> <span class="quoted"><span class="plain_text">‹Syntax›</span></span>

<span class="keyword1"><span class="command">bundle</span></span> app_syntax <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">notation</span></span> App <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">$</span>"</span> 999<span class="main">)</span>
<span class="keyword1"><span class="command">notation</span></span> Wrap <span class="main">(</span><span class="quoted">"<span class="keyword1">⟪</span>_<span class="keyword1">⟫</span>"</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(*
paragraph ‹Code Setup›

definition map1<span class="hidden">⇩</span><sub>T</sub>' where
  "map1<span class="hidden">⇩</span><sub>T</sub>' f xs ≡ ⟨rec_list ⟨[]⟩ (λx xs a. ⟨λy. ⟨λys. ⟨y#ys⟩⟩⟩ . (f x) . a)⟩ . ⟨xs⟩ "

lemma map1<span class="hidden">⇩</span><sub>T</sub>_map1<span class="hidden">⇩</span><sub>T</sub>':
  "map1<span class="hidden">⇩</span><sub>T</sub> = ⟨λf. ⟨λxs. map1<span class="hidden">⇩</span><sub>T</sub>' f xs⟩⟩"
  unfolding map1<span class="hidden">⇩</span><sub>T</sub>_def map1<span class="hidden">⇩</span><sub>T</sub>'_def ..

lemmas [code] =
  mem_defs.checkmem'_def

lemmas [code_unfold] =
  map<span class="hidden">⇩</span><sub>T</sub>_def
  map1<span class="hidden">⇩</span><sub>T</sub>_map1<span class="hidden">⇩</span><sub>T</sub>'


paragraph ‹Simplifying monad expressions›

lemma app_return_right:
  "f . ⟨g⟩ = do {f ← f; f g}"
  unfolding fun_app_lifted_def left_identity ..

lemma app_return_left:
  "⟨f⟩ . g = g ⤜ f"
  unfolding fun_app_lifted_def left_identity ..

lemma get_return:
  "(do {m ← get; ⟨f m⟩}) = State (λ mem. (f mem, mem))"
  unfolding get_def bind_def return_def by simp

lemma get_put:
  "do {m ← get; put (f m)} = State (λ mem. ((), f mem))"
  unfolding get_def put_def bind_def return_def by simp

lemma bind_return_assoc:
  "(do {
       x ← a;
       ⟨f x⟩
     }) ⤜
    b =
    do {
      x ← a;
      b (f x)
    }"
  by (auto split: prod.split simp add: bind_def return_def)

lemma app_lifted_return_assoc:
  "(do {
       x ← a;
       ⟨f x⟩
     }) .
    b =
    do {
      x ← a;
      b ⤜ f x
    }"
  unfolding fun_app_lifted_def bind_return_assoc ..

(* There could be a simpproc for this pattern *)
lemma bind_return_assoc2:
  "(do {
       x ← a;
       y ← b;
       ⟨f x y⟩
     }) ⤜
    c =
    do {
      x ← a;
      y ← b;
      c (f x y)
    }"
  by (auto split: prod.split simp add: bind_def return_def)

lemma bind_return_assoc3:
  "(do {
       x ← a;
       y ← b;
       z ← c;
       ⟨f x y z⟩
     }) ⤜
    d =
    do {
      x ← a;
      y ← b;
      z ← c;
      d (f x y z)
    }"
  by (auto split: prod.split simp add: bind_def return_def)

lemma if<span class="hidden">⇩</span><sub>T</sub>_return:
  "if<span class="hidden">⇩</span><sub>T</sub> ⟨b⟩ x<span class="hidden">⇩</span><sub>T</sub> y<span class="hidden">⇩</span><sub>T</sub> ≡ if b then x<span class="hidden">⇩</span><sub>T</sub> else y<span class="hidden">⇩</span><sub>T</sub>"
  unfolding if<span class="hidden">⇩</span><sub>T</sub>_def return_def bind_def by simp

(* Would it be a good idea to just unfold fun_app_lifted? *)
lemmas monad_unfolds =
  app_return_right app_return_left Monad.left_identity Monad.right_identity
  app_lifted_return_assoc bind_return_assoc bind_return_assoc2 bind_return_assoc3
  get_return get_put
  map1<span class="hidden">⇩</span><sub>T</sub>_map1<span class="hidden">⇩</span><sub>T</sub>'
  if<span class="hidden">⇩</span><sub>T</sub>_return
*)</span>
<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Tracing">
<div class="head">
<h1>Theory Tracing</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> Tracing
  <span class="keyword2"><span class="keyword">imports</span></span>
    <span class="quoted">"<a href="#Heap_Main">../heap_monad/Heap_Main</a>"</span>
    <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/Code_Target_Numeral.html">HOL-Library.Code_Target_Numeral</a>"</span>
    <a href="../../show/theories/#Show_Instances">Show.Show_Instances</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹NB:
  A more complete solution could be built by using the following entry:
  <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">🌐</span></span>‹https://www.isa-afp.org/entries/Show.html›</span></span>.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">writeln</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"String.literal <span class="main">⇒</span> unit"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">writeln</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">s</span><span class="main">.</span> <span class="main">()</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">code_printing</span></span>
  <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">writeln</span> <span class="main">⇀</span> <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"writeln _"</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">trace</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">trace</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">a</span> <span class="main">=</span> writeln <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">in</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Tracing-trace_alt_def"><span class="command">lemma</span></span> trace_alt_def<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"trace <span class="free">s</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span>writeln <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> trace_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> heap_mem_defs<span class="main">)</span> <span class="entity">checkmem_trace</span> <span class="main">::</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span> <span class="main">⇒</span> String.literal<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'k</span> <span class="main">⇒</span> <span class="main">(</span>unit <span class="main">⇒</span> <span class="tfree">'v</span> Heap<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'v</span> Heap"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">checkmem_trace</span> <span class="free"><span class="bound"><span class="entity">trace_key</span></span></span> <span class="free"><span class="bound"><span class="entity">param</span></span></span> <span class="free"><span class="bound"><span class="entity">calc</span></span></span> <span class="main">≡</span>
    Heap_Monad.bind <span class="main">(</span><span class="free">lookup</span> <span class="free"><span class="bound"><span class="entity">param</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">x</span><span class="main">.</span>
    <span class="keyword1">case</span> <span class="bound">x</span> <span class="keyword1">of</span>
      Some <span class="bound">x</span> <span class="main">⇒</span> trace <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Hit ''</span> <span class="main">+</span> <span class="free"><span class="bound"><span class="entity">trace_key</span></span></span> <span class="free"><span class="bound"><span class="entity">param</span></span></span><span class="main">)</span> <span class="main">(</span>return <span class="bound">x</span><span class="main">)</span>
    <span class="main">|</span> None <span class="main">⇒</span> trace <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Miss ''</span>  <span class="main">+</span> <span class="free"><span class="bound"><span class="entity">trace_key</span></span></span> <span class="free"><span class="bound"><span class="entity">param</span></span></span><span class="main">)</span>
       Heap_Monad.bind <span class="main">(</span><span class="free"><span class="bound"><span class="entity">calc</span></span></span> <span class="main">()</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">x</span><span class="main">.</span>
        Heap_Monad.bind <span class="main">(</span><span class="free">update</span> <span class="free"><span class="bound"><span class="entity">param</span></span></span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span>
        return <span class="bound">x</span>
      <span class="main">)</span>
    <span class="main">)</span>
  <span class="main">)</span>
  "</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> heap_mem_defs<span class="main">)</span> checkmem_checkmem_trace<span class="main">:</span>
  <span class="quoted"><span class="quoted">"checkmem <span class="free">param</span> <span class="free">calc</span> <span class="main">=</span> checkmem_trace <span class="free">trace_key</span> <span class="free">param</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">calc</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> checkmem_trace_def checkmem_def trace_alt_def <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">nat_to_string</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> String.literal"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">nat_to_string</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> String.implode <span class="main">(</span>show <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">nat_pair_to_string</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">×</span> nat <span class="main">⇒</span> String.literal"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">nat_pair_to_string</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> String.implode <span class="main">(</span>show <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"show <span class="main">(</span><span class="numeral">3</span> <span class="main">::</span> nat<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">paragraph</span></span> <span class="quoted"><span class="plain_text">‹Code Setup›</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span>
  heap_mem_defs.checkmem_trace_def

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">]</span> <span class="main">=</span>
  heap_mem_defs.checkmem_checkmem_trace<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> trace_key <span class="main"><span class="main">=</span></span> <span class="quoted">nat_to_string</span><span class="main">]</span>
  heap_mem_defs.checkmem_checkmem_trace<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> trace_key <span class="main"><span class="main">=</span></span> <span class="quoted">nat_pair_to_string</span><span class="main">]</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Ground_Function">
<div class="head">
<h1>Theory Ground_Function</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> Ground_Function
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL/Main.html">Main</a>
  <span class="keyword2"><span class="keyword">keywords</span></span>
    <span class="quoted">"ground_function"</span> <span class="main">::</span> thy_decl
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹../util/Ground_Function.ML›</span>

<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ground_function_cmd</span> <span class="main">(</span><span class="main">(</span><span class="entity">termination</span><span class="main">,</span> <span class="entity">binding</span><span class="main">)</span><span class="main">,</span> <span class="entity">thm_refs</span><span class="main">)</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">def_thms</span> <span class="main">=</span> <span class="entity">Attrib.eval_thms</span> <span class="entity">lthy</span> <span class="entity">thm_refs</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">Ground_Function.mk_fun</span> <span class="main">(</span><span class="entity">termination</span> &lt;&gt; NONE<span class="main">)</span> <span class="entity">def_thms</span> <span class="entity">binding</span> <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ground_function_parser</span> <span class="main">=</span>
  Scan.option <span class="main">(</span>Parse.$$$ <span class="inner_quoted">"("</span> |-- Parse.reserved <span class="inner_quoted">"prove_termination"</span> --| Parse.$$$ <span class="inner_quoted">")"</span><span class="main">)</span>
  -- <span class="main">(</span>Parse.binding --| Parse.$$$ <span class="inner_quoted">":"</span><span class="main">)</span> <span class="comment1">(* scope, e.g., bf<span class="hidden">⇩</span><sub>T</sub> *)</span>
  -- Parse.thms1

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.local_theory</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> <span class="keyword1">ground_function</span><span class="antiquote">}</span></span></span>
  <span class="inner_quoted">"Define a new ground constant from an existing function definition"</span>
    <span class="main">(</span><span class="entity">ground_function_parser</span> &gt;&gt; <span class="entity">ground_function_cmd</span><span class="main">)</span>
›</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/Ground_Function.ML">
<div class="head">
<h1>File ‹Ground_Function.ML›</h1>
</div>
<pre class="source"><span class="comment1">(** Define a new ground constant from an existing function definition **)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Ground_Function</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_function</span> <span class="entity">bind</span> <span class="entity">defs</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fixes</span> <span class="main">=</span> <span class="main">[</span><span class="main">(</span><span class="entity">bind</span><span class="main">,</span> NONE<span class="main">,</span> NoSyn<span class="main">)</span><span class="main">]</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">specs</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">def</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span>Binding.empty<span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">def</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="entity">defs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pat_completeness_auto</span> <span class="main">=</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span>
      <span class="entity">Pat_Completeness.pat_completeness_tac</span> <span class="entity">ctxt</span> <span class="inner_numeral">1</span>
      THEN <span class="entity">auto_tac</span> <span class="entity">ctxt</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">Function.add_function</span> <span class="entity">fixes</span> <span class="entity">specs</span> <span class="entity">Function_Fun.fun_config</span> <span class="entity">pat_completeness_auto</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_hol_eq_prop</span> <span class="entity">t</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> Const <span class="main">(</span><span class="inner_quoted">"HOL.Trueprop"</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">(</span>Const <span class="main">(</span><span class="inner_quoted">"HOL.eq"</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="entity">a</span> $ <span class="entity">b</span><span class="main">)</span> <span class="main">=</span> <span class="entity">t</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">b</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_fun_head</span> <span class="entity">t</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_hol_eq_prop</span> <span class="entity">t</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Term.head_of <span class="entity">t</span>
    <span class="keyword1"><span class="keyword">val</span></span> Const <span class="main">(</span><span class="entity">fun_name</span><span class="main">,</span> <span class="entity">fun_ty</span><span class="main">)</span> <span class="main">=</span> <span class="entity">t</span>
 <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">fun_name</span><span class="main">,</span> <span class="entity">fun_ty</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_fun</span> <span class="entity">termination</span> <span class="entity">simps</span> <span class="entity">binding</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eqns</span> <span class="main">=</span> map Thm.concl_of <span class="entity">simps</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">eqns</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> Variable.import_terms true <span class="entity">eqns</span> <span class="entity">ctxt</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">f_name</span><span class="main">,</span> <span class="entity">f_ty</span><span class="main">)</span> <span class="main">=</span> <span class="entity">get_fun_head</span> <span class="main">(</span>hd <span class="entity">eqns</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">s</span> <span class="main">=</span> Binding.name_of <span class="entity">binding</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">replacement</span> <span class="main">=</span> <span class="main">(</span>Const <span class="main">(</span><span class="entity">f_name</span><span class="main">,</span> <span class="entity">f_ty</span><span class="main">)</span><span class="main">,</span> Free <span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="entity">f_ty</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eqns</span> <span class="main">=</span> map <span class="main">(</span>subst_free <span class="main">[</span><span class="entity">replacement</span><span class="main">]</span><span class="main">)</span> <span class="entity">eqns</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="main">=</span> <span class="entity">add_function</span> <span class="entity">binding</span> <span class="entity">eqns</span> <span class="entity">ctxt</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_termination</span> <span class="entity">lthy</span> <span class="main">=</span>
        <span class="entity">Function.prove_termination</span> NONE <span class="main">(</span><span class="entity">Function_Common.termination_prover_tac</span> false <span class="entity">lthy</span><span class="main">)</span> <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">ctxt</span> |&gt; <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">termination</span> <span class="keyword2"><span class="keyword">then</span></span> snd o <span class="entity">prove_termination</span> <span class="keyword2"><span class="keyword">else</span></span> I<span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Bellman_Ford">
<div class="head">
<h1>Theory Bellman_Ford</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The Bellman-Ford Algorithm›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Bellman_Ford
  <span class="keyword2"><span class="keyword">imports</span></span>
    <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/IArray.html">HOL-Library.IArray</a>"</span>
    <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/Code_Target_Numeral.html">HOL-Library.Code_Target_Numeral</a>"</span>
    <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/Product_Lexorder.html">HOL-Library.Product_Lexorder</a>"</span>
    <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/RBT_Mapping.html">HOL-Library.RBT_Mapping</a>"</span>
    <span class="quoted">"<a href="#Heap_Main">../heap_monad/Heap_Main</a>"</span>
    <a href="#Example_Misc">Example_Misc</a>
    <span class="quoted">"<a href="#Tracing">../util/Tracing</a>"</span>
    <span class="quoted">"<a href="#Ground_Function">../util/Ground_Function</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Misc›</span></span>

<span class="keyword1" id="Bellman_Ford-nat_le_cases"><span class="command">lemma</span></span> nat_le_cases<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">n</span> <span class="main">::</span> <span class="quoted">nat</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">≤</span> <span class="free">n</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&lt;</span> <span class="free">n</span>"</span></span> <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">=</span> <span class="free">n</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">=</span> <span class="free">n</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">context</span></span> dp_consistency_iterator
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Bellman_Ford-crel_vs_iterate_state"><span class="command">lemma</span></span> crel_vs_iterate_state<span class="main">:</span>
  <span class="quoted"><span class="quoted">"crel_vs <span class="main">(=)</span> <span class="main">()</span> <span class="main">(</span>iter_state <span class="free">f</span> <span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="keyword1">===&gt;<span class="hidden">⇩</span><sub>T</sub></span> <span class="free">R</span><span class="main">)</span> <span class="free">g</span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> crel_vs_iterate_state iter_state_iterate_state that<span class="main">)</span>

<span class="keyword1" id="Bellman_Ford-consistent_crel_vs_iterate_state"><span class="command">lemma</span></span> consistent_crel_vs_iterate_state<span class="main">:</span>
  <span class="quoted"><span class="quoted">"crel_vs <span class="main">(=)</span> <span class="main">()</span> <span class="main">(</span>iter_state <span class="free">f</span> <span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"consistentDP <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> consistentDP_def crel_vs_iterate_state that <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instance</span></span> extended <span class="main">::</span> <span class="main">(</span><span class="quoted">countable</span><span class="main">)</span> <span class="quoted">countable</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">standard</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">to_nat</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"inj <span class="skolem">to_nat</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?f</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">x</span> <span class="keyword1">of</span> Fin <span class="bound">n</span> <span class="main">⇒</span> <span class="skolem">to_nat</span> <span class="bound">n</span> <span class="main">+</span> <span class="numeral">2</span> <span class="main">|</span> Pinf <span class="main">⇒</span> <span class="main">0</span> <span class="main">|</span> Minf <span class="main">⇒</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹inj <span class="main">_</span> ›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"inj <span class="var">?f</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inj_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> extended.split<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">to_nat</span> <span class="main">::</span> <span class="tfree">'a</span> extended <span class="main">⇒</span> nat<span class="main">.</span> inj <span class="bound">to_nat</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">instance</span></span> extended <span class="main">::</span> <span class="main">(</span><span class="quoted">heap</span><span class="main">)</span> <span class="quoted">heap</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> <span class="quoted">"extended"</span> <span class="main">::</span> <span class="main">(</span><span class="quoted">conditionally_complete_lattice</span><span class="main">)</span> <span class="quoted">complete_lattice</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"Inf <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">=</span> <span class="main">(</span>
    <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">=</span> <span class="main">{}</span> <span class="main">∨</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="main">∞</span><span class="main">}</span> <span class="keyword1">then</span> <span class="main">∞</span>
    <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="main">-∞</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">∨</span> <span class="main">¬</span> bdd_below <span class="main">(</span>Fin <span class="main">-`</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">)</span> <span class="keyword1">then</span> <span class="main">-∞</span>
    <span class="keyword1">else</span> Fin <span class="main">(</span>Inf <span class="main">(</span>Fin <span class="main">-`</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"Sup <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">=</span> <span class="main">(</span>
    <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">=</span> <span class="main">{}</span> <span class="main">∨</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="main">-∞</span><span class="main">}</span> <span class="keyword1">then</span> <span class="main">-∞</span>
    <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="main">∞</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">∨</span> <span class="main">¬</span> bdd_above <span class="main">(</span>Fin <span class="main">-`</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">)</span> <span class="keyword1">then</span> <span class="main">∞</span>
    <span class="keyword1">else</span> Fin <span class="main">(</span>Sup <span class="main">(</span>Fin <span class="main">-`</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">instance</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">standard</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">dest</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Inf <span class="main">(</span>Fin <span class="main">-`</span> <span class="skolem">A</span><span class="main">)</span> <span class="main">≤</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"Fin <span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">A</span>"</span></span> <span class="quoted"><span class="quoted">"bdd_below <span class="main">(</span>Fin <span class="main">-`</span> <span class="skolem">A</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">A</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> cInf_lower<span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted">False</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="skolem">z</span> <span class="main">≤</span> Inf <span class="main">(</span>Fin <span class="main">-`</span> <span class="skolem">A</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="skolem">A</span> <span class="main">⟹</span> Fin <span class="skolem">z</span> <span class="main">≤</span> <span class="bound">x</span>"</span></span> <span class="quoted"><span class="quoted">"Fin <span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">A</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">A</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span> <span class="skolem">z</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> cInf_greatest<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"Fin <span class="main">-`</span> <span class="skolem">A</span>"</span></span> <span class="quoted"><span class="skolem">z</span></span><span class="main">]</span> that vimage_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Inf <span class="skolem">A</span> <span class="main">≤</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">A</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> extended"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">A</span>
    <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> Inf_extended_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">≤</span> Inf <span class="skolem">A</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="skolem">A</span> <span class="main">⟹</span> <span class="skolem">z</span> <span class="main">≤</span> <span class="bound">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">z</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> extended"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">A</span>
    <span class="keyword1"><span class="command">using</span></span> that
    <span class="keyword1"><span class="command">unfolding</span></span> Inf_extended_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">safe</span><span class="main">)</span>
         <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">z</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> bdd_below_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">z</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> bdd_below_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> x y
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">z</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">y</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> *<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> x y
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">z</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">y</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">metis</span> * less_eq_extended.elims<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">dest</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≤</span> Sup <span class="main">(</span>Fin <span class="main">-`</span> <span class="skolem">A</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"Fin <span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">A</span>"</span></span> <span class="quoted"><span class="quoted">"bdd_above <span class="main">(</span>Fin <span class="main">-`</span> <span class="skolem">A</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">A</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> cSup_upper<span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted">False</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> Sup <span class="main">(</span>Fin <span class="main">-`</span> <span class="skolem">A</span><span class="main">)</span> <span class="main">≤</span> <span class="skolem">z</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="skolem">A</span> <span class="main">⟹</span> <span class="bound">x</span> <span class="main">≤</span> Fin <span class="skolem">z</span>"</span></span> <span class="quoted"><span class="quoted">"Fin <span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">A</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">A</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span> <span class="skolem">z</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> cSup_least<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"Fin <span class="main">-`</span> <span class="skolem">A</span>"</span></span> <span class="quoted"><span class="skolem">z</span></span><span class="main">]</span> that vimage_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≤</span> Sup <span class="skolem">A</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">A</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> extended"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">A</span>
    <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> Sup_extended_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Sup <span class="skolem">A</span> <span class="main">≤</span> <span class="skolem">z</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="skolem">A</span> <span class="main">⟹</span> <span class="bound">x</span> <span class="main">≤</span> <span class="skolem">z</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">z</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> extended"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">A</span>
    <span class="keyword1"><span class="command">using</span></span> that
    <span class="keyword1"><span class="command">unfolding</span></span> Sup_extended_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">safe</span><span class="main">)</span>
         <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">z</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">force</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">z</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">force</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> x y
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">z</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">y</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> *<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> x y
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">z</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">y</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">metis</span> * extended.exhaust<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Inf <span class="main">{}</span> <span class="main">=</span> <span class="main">(</span>top<span class="main">::</span><span class="tfree">'a</span> extended<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> Inf_extended_def top_extended_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Sup <span class="main">{}</span> <span class="main">=</span> <span class="main">(</span>bot<span class="main">::</span><span class="tfree">'a</span> extended<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> Sup_extended_def bot_extended_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instance</span></span> <span class="quoted">"extended"</span> <span class="main">::</span> <span class="main">(</span><span class="quoted"><span class="quoted">"<span class="main">{</span>conditionally_complete_lattice<span class="main">,</span>linorder<span class="main">}</span>"</span></span><span class="main">)</span> <span class="quoted">complete_linorder</span> <span class="keyword1"><span class="command">..</span></span>


<span class="keyword1" id="Bellman_Ford-Minf_eq_zero"><span class="command">lemma</span></span> Minf_eq_zero<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">-∞</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟷</span> False"</span></span> <span class="keyword2"><span class="keyword">and</span></span> Pinf_eq_zero<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∞</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟷</span> False"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> zero_extended_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Bellman_Ford-Sup_int"><span class="command">lemma</span></span> Sup_int<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted">int</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">X</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"int set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="quoted"><span class="quoted">"bdd_above <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Sup <span class="free">X</span> <span class="main">∈</span> <span class="free">X</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">y</span><span class="main">∈</span><span class="free">X</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> Sup <span class="free">X</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">⊆</span> <span class="main">{..</span><span class="skolem">y</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">X</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> bdd_above_def<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="free">X</span> <span class="main">∩</span> <span class="main">{</span><span class="skolem">x</span><span class="main">..</span><span class="skolem">y</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">∩</span> <span class="main">{</span><span class="skolem">x</span><span class="main">..</span><span class="skolem">y</span><span class="main">}</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">y</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> subset_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃!</span><span class="bound"><span class="bound">x</span></span><span class="main">∈</span><span class="free">X</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound">y</span><span class="main">∈</span><span class="free">X</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">z</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> <span class="free">X</span>"</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">≤</span> Max <span class="main">(</span><span class="free">X</span> <span class="main">∩</span> <span class="main">{</span><span class="skolem">x</span><span class="main">..</span><span class="skolem">y</span><span class="main">}</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">z</span>"</span></span> <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">z</span> <span class="main">∈</span> <span class="free">X</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">X</span> <span class="main">⊆</span> <span class="main">{..</span><span class="skolem">y</span><span class="main">}</span>›</span></span> *<span class="main">(</span>1<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Max_ge<span class="main">)</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">z</span>"</span></span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">&lt;</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≤</span> Max <span class="main">(</span><span class="free">X</span> <span class="main">∩</span> <span class="main">{</span><span class="skolem">x</span><span class="main">..</span><span class="skolem">y</span><span class="main">}</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> <span class="free">X</span>›</span></span> *<span class="main">(</span>1<span class="main">)</span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">y</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> Max_ge<span class="main">)</span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">qed</span></span> <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">note</span></span> le <span class="main">=</span> this
    <span class="keyword1"><span class="command">with</span></span> Max_in<span class="main">[</span><span class="operator">OF</span> *<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> ex<span class="main">:</span> <span class="quoted"><span class="quoted">"Max <span class="main">(</span><span class="free">X</span> <span class="main">∩</span> <span class="main">{</span><span class="skolem">x</span><span class="main">..</span><span class="skolem">y</span><span class="main">}</span><span class="main">)</span> <span class="main">∈</span> <span class="free">X</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">z</span><span class="main">∈</span><span class="free">X</span><span class="main">.</span> <span class="bound">z</span> <span class="main">≤</span> Max <span class="main">(</span><span class="free">X</span> <span class="main">∩</span> <span class="main">{</span><span class="skolem">x</span><span class="main">..</span><span class="skolem">y</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">z</span> <span class="keyword3"><span class="command">assume</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> <span class="free">X</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">y</span><span class="main">∈</span><span class="free">X</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="skolem">z</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> le <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">≤</span> Max <span class="main">(</span><span class="free">X</span> <span class="main">∩</span> <span class="main">{</span><span class="skolem">x</span><span class="main">..</span><span class="skolem">y</span><span class="main">}</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Max <span class="main">(</span><span class="free">X</span> <span class="main">∩</span> <span class="main">{</span><span class="skolem">x</span><span class="main">..</span><span class="skolem">y</span><span class="main">}</span><span class="main">)</span> <span class="main">≤</span> <span class="skolem">z</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> * ex <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">=</span> Max <span class="main">(</span><span class="free">X</span> <span class="main">∩</span> <span class="main">{</span><span class="skolem">x</span><span class="main">..</span><span class="skolem">y</span><span class="main">}</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Sup <span class="free">X</span> <span class="main">∈</span> <span class="free">X</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">y</span><span class="main">∈</span><span class="free">X</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> Sup <span class="free">X</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> Sup_int_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> theI'<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> Sup_int_in <span class="main">=</span> Sup_int<span class="main">[</span><span class="operator">THEN</span> conjunct1<span class="main">]</span>

<span class="keyword1" id="Bellman_Ford-Inf_int_in"><span class="command">lemma</span></span> Inf_int_in<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">S</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"int set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">S</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="quoted"><span class="quoted">"bdd_below <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Inf <span class="free">S</span> <span class="main">∈</span> <span class="free">S</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> Inf_int_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> Sup_int_in bdd_above_uminus image_iff image_is_empty<span class="main">)</span>


<span class="keyword1" id="Bellman_Ford-finite_setcompr_eq_image"><span class="command">lemma</span></span> finite_setcompr_eq_image<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">{</span><span class="free">f</span> <span class="bound">x</span> <span class="main">|</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">}</span> <span class="main">⟷</span> finite <span class="main">(</span><span class="free">f</span> <span class="main">`</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> setcompr_eq_image<span class="main">)</span>

<span class="keyword1" id="Bellman_Ford-finite_lists_length_le1"><span class="command">lemma</span></span> finite_lists_length_le1<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> length <span class="bound">xs</span> <span class="main">≤</span> <span class="free">i</span> <span class="main">∧</span> set <span class="bound">xs</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="main">(</span><span class="free">n</span><span class="main">::</span>nat<span class="main">)</span><span class="main">}</span><span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">i</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_subset<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ finite_lists_length_le<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> finite_atLeastAtMost<span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Bellman_Ford-finite_lists_length_le2"><span class="command">lemma</span></span> finite_lists_length_le2<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> length <span class="bound">xs</span> <span class="main">+</span> <span class="main">1</span> <span class="main">≤</span> <span class="free">i</span> <span class="main">∧</span> set <span class="bound">xs</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="main">(</span><span class="free">n</span><span class="main">::</span>nat<span class="main">)</span><span class="main">}</span><span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">i</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_subset<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ finite_lists_length_le1<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="free">i</span>"</span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span>
  finite_setcompr_eq_image finite_lists_length_le2<span class="main">[</span><span class="operator">simplified</span><span class="main">]</span> finite_lists_length_le1


<span class="keyword1" id="Bellman_Ford-get_return"><span class="command">lemma</span></span> get_return<span class="main">:</span>
  <span class="quoted"><span class="quoted">"run_state <span class="main">(</span>State_Monad.bind State_Monad.get <span class="main">(</span><span class="main">λ</span> <span class="bound">m</span><span class="main">.</span> State_Monad.return <span class="main">(</span><span class="free">f</span> <span class="bound">m</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span> <span class="main">(</span><span class="free">f</span> <span class="free">m</span><span class="main">,</span> <span class="free">m</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> State_Monad.bind_def State_Monad.get_def<span class="main">)</span>


<span class="keyword1" id="Bellman_Ford-list_pidgeonhole"><span class="command">lemma</span></span> list_pidgeonhole<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"set <span class="free">xs</span> <span class="main">⊆</span> <span class="free">S</span>"</span></span> <span class="quoted"><span class="quoted">"card <span class="free">S</span> <span class="main">&lt;</span> length <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">as</span> <span class="free">a</span> <span class="free">bs</span> <span class="free">cs</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="free">as</span> <span class="main">@</span> <span class="free">a</span> <span class="main">#</span> <span class="free">bs</span> <span class="main">@</span> <span class="free">a</span> <span class="main">#</span> <span class="free">cs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> distinct <span class="free">xs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> card_mono distinct_card not_le<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> append.assoc append_Cons not_distinct_conv_prefix split_list that<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Bellman_Ford-path_eq_cycleE"><span class="command">lemma</span></span> path_eq_cycleE<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">#</span> <span class="free">ys</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span> <span class="main">=</span> <span class="free">as</span> <span class="main">@</span> <span class="free">a</span> <span class="main">#</span> <span class="free">bs</span> <span class="main">@</span> <span class="free">a</span> <span class="main">#</span> <span class="free">cs</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="main">(</span>Nil_Nil<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">as</span> <span class="main">=</span> <span class="main">[]</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">cs</span> <span class="main">=</span> <span class="main">[]</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">=</span> <span class="free">a</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">=</span> <span class="free">t</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">=</span> <span class="free">bs</span>"</span></span>
  <span class="main">|</span> <span class="main">(</span>Nil_Cons<span class="main">)</span> <span class="free">cs'</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">as</span> <span class="main">=</span> <span class="main">[]</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">=</span> <span class="free">a</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">=</span> <span class="free">bs</span> <span class="main">@</span> <span class="free">a</span> <span class="main">#</span> <span class="free">cs'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">cs</span> <span class="main">=</span> <span class="free">cs'</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span>"</span></span>
  <span class="main">|</span> <span class="main">(</span>Cons_Nil<span class="main">)</span> <span class="free">as'</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">as</span> <span class="main">=</span> <span class="free">v</span> <span class="main">#</span> <span class="free">as'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">cs</span> <span class="main">=</span> <span class="main">[]</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">=</span> <span class="free">t</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">=</span> <span class="free">as'</span> <span class="main">@</span> <span class="free">a</span> <span class="main">#</span> <span class="free">bs</span>"</span></span>
  <span class="main">|</span> <span class="main">(</span>Cons_Cons<span class="main">)</span> <span class="free">as'</span> <span class="free">cs'</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">as</span> <span class="main">=</span> <span class="free">v</span> <span class="main">#</span> <span class="free">as'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">cs</span> <span class="main">=</span> <span class="free">cs'</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">=</span> <span class="free">as'</span> <span class="main">@</span> <span class="free">a</span> <span class="main">#</span> <span class="free">bs</span> <span class="main">@</span> <span class="free">a</span> <span class="main">#</span> <span class="free">cs'</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Cons_eq_append_conv append_eq_Cons_conv append_eq_append_conv2<span class="main">)</span>

<span class="keyword1" id="Bellman_Ford-le_add_same_cancel1"><span class="command">lemma</span></span> le_add_same_cancel1<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">+</span> <span class="free">b</span> <span class="main">≥</span> <span class="free">a</span> <span class="main">⟷</span> <span class="free">b</span> <span class="main">≥</span> <span class="main">0</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">&lt;</span> <span class="main">∞</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">-∞</span> <span class="main">&lt;</span> <span class="free">a</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">a</span> <span class="free">b</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"int extended"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">a</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">b</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_extended_def<span class="main">)</span>

<span class="keyword1" id="Bellman_Ford-add_gt_minfI"><span class="command">lemma</span></span> add_gt_minfI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">-∞</span> <span class="main">&lt;</span> <span class="free">a</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">-∞</span> <span class="main">&lt;</span> <span class="free">b</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">-∞</span> <span class="main">&lt;</span> <span class="free">a</span> <span class="main">+</span> <span class="free">b</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">a</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">b</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Bellman_Ford-add_lt_infI"><span class="command">lemma</span></span> add_lt_infI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">&lt;</span> <span class="main">∞</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">&lt;</span> <span class="main">∞</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">+</span> <span class="free">b</span> <span class="main">&lt;</span> <span class="main">∞</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">a</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">b</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Bellman_Ford-sum_list_not_infI"><span class="command">lemma</span></span> sum_list_not_infI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"sum_list <span class="free">xs</span> <span class="main">&lt;</span> <span class="main">∞</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">x</span> <span class="main">∈</span> set <span class="free">xs</span><span class="main">.</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="main">∞</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"int extended list"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_extended_def<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> less_extended_simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> plus_extended.elims<span class="main">)</span>

<span class="keyword1" id="Bellman_Ford-sum_list_not_minfI"><span class="command">lemma</span></span> sum_list_not_minfI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"sum_list <span class="free">xs</span> <span class="main">&gt;</span> <span class="main">-∞</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">x</span> <span class="main">∈</span> set <span class="free">xs</span><span class="main">.</span> <span class="bound">x</span> <span class="main">&gt;</span> <span class="main">-∞</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"int extended list"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> add_gt_minfI <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> zero_extended_def<span class="main">)</span>



<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Single-Sink Shortest Path Problem›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> bf_result <span class="main">=</span> Path <span class="quoted"><span class="quoted">"nat list"</span></span> <span class="quoted">int</span> <span class="main">|</span> No_Path <span class="main">|</span> Computation_Error

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">n</span> <span class="main">::</span> <span class="quoted">nat</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">W</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat <span class="main">⇒</span> int extended"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">t</span> <span class="main">::</span> <span class="quoted">nat</span> <span class="comment1">― ‹Final node›</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The correctness proof closely follows Kleinberg <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>&amp;›</span></span></span></span> Tardos: "Algorithm Design",
  chapter "Dynamic Programming" <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> "Kleinberg-Tardos"<span class="antiquote"><span class="antiquote">}</span></span></span></span>
›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">weight</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat list <span class="main">⇒</span> int extended"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">weight</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">]</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">weight</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">W</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">+</span> <span class="free">weight</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">OPT</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> <span class="main">(</span>
    Min <span class="main">(</span>
      <span class="main">{</span>weight <span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">#</span> <span class="bound">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span> <span class="main">|</span> <span class="bound">xs</span><span class="main">.</span> length <span class="bound">xs</span> <span class="main">+</span> <span class="main">1</span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">∧</span> set <span class="bound">xs</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">}</span><span class="main">}</span> <span class="main">∪</span>
      <span class="main">{</span><span class="keyword1">if</span> <span class="free">t</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> <span class="main">∞</span><span class="main">}</span>
    <span class="main">)</span>
  <span class="main">)</span>"</span></span>

<span class="keyword1" id="Bellman_Ford-weight_alt_def'"><span class="command">lemma</span></span> weight_alt_def'<span class="main">:</span>
  <span class="quoted"><span class="quoted">"weight <span class="main">(</span><span class="free">s</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">+</span> <span class="free">w</span> <span class="main">=</span> snd <span class="main">(</span>fold <span class="main">(</span><span class="main">λ</span><span class="bound">j</span> <span class="main">(</span><span class="bound">i</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">j</span><span class="main">,</span> <span class="free">W</span> <span class="bound">i</span> <span class="bound">j</span> <span class="main">+</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="free">xs</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span> <span class="free">w</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">w</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">smt</span> add.commute add.left_commute<span class="main">)</span>

<span class="keyword1" id="Bellman_Ford-weight_alt_def"><span class="command">lemma</span></span> weight_alt_def<span class="main">:</span>
  <span class="quoted"><span class="quoted">"weight <span class="main">(</span><span class="free">s</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> snd <span class="main">(</span>fold <span class="main">(</span><span class="main">λ</span><span class="bound">j</span> <span class="main">(</span><span class="bound">i</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">j</span><span class="main">,</span> <span class="free">W</span> <span class="bound">i</span> <span class="bound">j</span> <span class="main">+</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="free">xs</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> weight_alt_def'<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="main">0</span></span><span class="main"><span class="main">,</span></span> <span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Bellman_Ford-weight_append"><span class="command">lemma</span></span> weight_append<span class="main">:</span>
  <span class="quoted"><span class="quoted">"weight <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">a</span> <span class="main">#</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> weight <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">a</span><span class="main">]</span><span class="main">)</span> <span class="main">+</span> weight <span class="main">(</span><span class="free">a</span> <span class="main">#</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> weight.induct<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> add.assoc<span class="main">)</span>

<span class="keyword1" id="Bellman_Ford-OPT_0"><span class="command">lemma</span></span> OPT_0<span class="main">:</span>
  <span class="quoted"><span class="quoted">"OPT <span class="main">0</span> <span class="free">v</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">t</span> <span class="main">=</span> <span class="free">v</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> <span class="main">∞</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> OPT_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Functional Correctness›</span></span>

<span class="keyword1" id="Bellman_Ford-OPT_cases"><span class="command">lemma</span></span> OPT_cases<span class="main">:</span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="main">(</span>path<span class="main">)</span> <span class="free">xs</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"OPT <span class="free">i</span> <span class="free">v</span> <span class="main">=</span> weight <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="free">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"length <span class="free">xs</span> <span class="main">+</span> <span class="main">1</span> <span class="main">≤</span> <span class="free">i</span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="free">xs</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">}</span>"</span></span>
  <span class="main">|</span> <span class="main">(</span>sink<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">=</span> <span class="free">t</span>"</span></span> <span class="quoted"><span class="quoted">"OPT <span class="free">i</span> <span class="free">v</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="main">|</span> <span class="main">(</span>unreachable<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">≠</span> <span class="free">t</span>"</span></span> <span class="quoted"><span class="quoted">"OPT <span class="free">i</span> <span class="free">v</span> <span class="main">=</span> <span class="main">∞</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> OPT_def
  <span class="keyword1"><span class="command">using</span></span> Min_in<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">{</span>weight <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="bound">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span> <span class="main">|</span><span class="bound">xs</span><span class="main">.</span> length <span class="bound">xs</span> <span class="main">+</span> <span class="main">1</span> <span class="main">≤</span> <span class="free">i</span> <span class="main">∧</span> set <span class="bound">xs</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">}</span><span class="main">}</span>
    <span class="main">∪</span> <span class="main">{</span><span class="keyword1">if</span> <span class="free">t</span> <span class="main">=</span> <span class="free">v</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> <span class="main">∞</span><span class="main">}</span>"</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> finite_lists_length_le2<span class="main"><span class="main">[</span></span><span class="operator">simplified</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>

<span class="keyword1" id="Bellman_Ford-OPT_Suc"><span class="command">lemma</span></span> OPT_Suc<span class="main">:</span>
  <span class="quoted"><span class="quoted">"OPT <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="free">v</span> <span class="main">=</span> min <span class="main">(</span>OPT <span class="free">i</span> <span class="free">v</span><span class="main">)</span> <span class="main">(</span>Min <span class="main">{</span>OPT <span class="free">i</span> <span class="bound">w</span> <span class="main">+</span> <span class="free">W</span> <span class="free">v</span> <span class="bound">w</span> <span class="main">|</span> <span class="bound">w</span><span class="main">.</span> <span class="bound">w</span> <span class="main">≤</span> <span class="free">n</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">≤</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"OPT <span class="free">i</span> <span class="skolem">w</span> <span class="main">+</span> <span class="free">W</span> <span class="free">v</span> <span class="skolem">w</span> <span class="main">≥</span> OPT <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="free">v</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">≤</span> <span class="free">n</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">w</span>
    <span class="keyword1"><span class="command">using</span></span> OPT_cases<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">i</span></span> <span class="quoted"><span class="skolem">w</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>path <span class="skolem">xs</span><span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">w</span> <span class="main">≤</span> <span class="free">n</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> OPT_def<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Min_le exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">#</span> <span class="skolem">xs</span>"</span></span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> add.commute<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> sink
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> OPT_def<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Min_le exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted">"<span class="main">[]</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> unreachable
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Min <span class="main">{</span>OPT <span class="free">i</span> <span class="bound">w</span> <span class="main">+</span> <span class="free">W</span> <span class="free">v</span> <span class="bound">w</span> <span class="main">|</span><span class="bound">w</span><span class="main">.</span> <span class="bound">w</span> <span class="main">≤</span> <span class="free">n</span><span class="main">}</span> <span class="main">≥</span> OPT <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="free">v</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Min.boundedI<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"OPT <span class="free">i</span> <span class="free">v</span> <span class="main">≥</span> OPT <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="free">v</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> OPT_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Min_antimono<span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">≤</span> <span class="var">?rhs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword1"><span class="command">from</span></span> OPT_cases<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"Suc <span class="free">i</span>"</span></span> <span class="quoted"><span class="free">v</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">≥</span> <span class="var">?rhs</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>path <span class="skolem">xs</span><span class="main">)</span>
    <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> path<span class="main">(</span>1<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> path <span class="keyword1"><span class="command">consider</span></span>
      <span class="main">(</span>zero<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="quoted"><span class="quoted">"length <span class="skolem">xs</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="main">|</span> <span class="main">(</span>new<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span> <span class="quoted"><span class="quoted">"length <span class="skolem">xs</span> <span class="main">=</span> <span class="free">i</span>"</span></span> <span class="main">|</span> <span class="main">(</span>old<span class="main">)</span> <span class="quoted"><span class="quoted">"length <span class="skolem">xs</span> <span class="main">&lt;</span> <span class="free">i</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"length <span class="skolem">xs</span> <span class="main">=</span> <span class="free">i</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
      <span class="keyword3"><span class="command">case</span></span> zero
      <span class="keyword1"><span class="command">with</span></span> path <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"OPT <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="free">v</span> <span class="main">=</span> <span class="free">W</span> <span class="free">v</span> <span class="free">t</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">W</span> <span class="free">v</span> <span class="free">t</span> <span class="main">=</span> OPT <span class="free">i</span> <span class="free">t</span> <span class="main">+</span> <span class="free">W</span> <span class="free">v</span> <span class="free">t</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> OPT_def <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">i</span> <span class="main">=</span> <span class="main">0</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≥</span> Min <span class="main">{</span>OPT <span class="free">i</span> <span class="bound">w</span> <span class="main">+</span> <span class="free">W</span> <span class="free">v</span> <span class="bound">w</span> <span class="main">|</span><span class="bound">w</span><span class="main">.</span> <span class="bound">w</span> <span class="main">≤</span> <span class="free">n</span><span class="main">}</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">t</span> <span class="main">≤</span> <span class="free">n</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> Min_le<span class="main">)</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> min.coboundedI2<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> new
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">_</span> <span class="main">=</span> <span class="free">i</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u</span></span> <span class="skolem"><span class="skolem">ys</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> <span class="skolem">u</span> <span class="main">#</span> <span class="skolem">ys</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> path <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"OPT <span class="free">i</span> <span class="skolem">u</span> <span class="main">≤</span> weight <span class="main">(</span><span class="skolem">u</span> <span class="main">#</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> OPT_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> Min_le<span class="main">)</span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> path <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Min <span class="main">{</span>OPT <span class="free">i</span> <span class="bound">w</span> <span class="main">+</span> <span class="free">W</span> <span class="free">v</span> <span class="bound">w</span> <span class="main">|</span><span class="bound">w</span><span class="main">.</span> <span class="bound">w</span> <span class="main">≤</span> <span class="free">n</span><span class="main">}</span> <span class="main">≤</span> <span class="free">W</span> <span class="free">v</span> <span class="skolem">u</span> <span class="main">+</span> OPT <span class="free">i</span> <span class="skolem">u</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> Min_le<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> add.commute<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹OPT <span class="free">i</span> <span class="skolem">u</span> <span class="main">≤</span> <span class="main">_</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> OPT <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="free">v</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> add_left_mono<span class="main">)</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> min.coboundedI2<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> old
      <span class="keyword1"><span class="command">with</span></span> path <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"OPT <span class="free">i</span> <span class="free">v</span> <span class="main">≤</span> OPT <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="free">v</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> Min_le <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> OPT_def<span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> min.coboundedI1<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> unreachable
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> sink
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"OPT <span class="free">i</span> <span class="free">v</span> <span class="main">≤</span> OPT <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="free">v</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> OPT_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> min.coboundedI1<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?lhs</span> <span class="main">≤</span> <span class="var">?rhs</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> order.antisym<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">bf</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat <span class="main">⇒</span> int extended"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">bf</span> <span class="main">0</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">t</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> <span class="main">∞</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bf</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> min_list
      <span class="main">(</span><span class="free">bf</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">#</span> <span class="main">[</span><span class="free">W</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="bound">w</span> <span class="main">+</span> <span class="free">bf</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="bound">w</span> <span class="main">.</span> w <span class="main">←</span> <span class="main">[</span><span class="main">0</span> <span class="main">..&lt;</span> Suc <span class="free">n</span><span class="main">]</span><span class="main">]</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword">del</span></span><span class="main">]</span> <span class="main">=</span> bf.simps
<span class="keyword1"><span class="command">lemmas</span></span> bf_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> bf.simps<span class="main">[</span><span class="operator">unfolded</span> min_list_fold<span class="main">]</span>

<span class="keyword1" id="Bellman_Ford-bf_correct"><span class="command">lemma</span></span> bf_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"OPT <span class="free">i</span> <span class="free">j</span> <span class="main">=</span> bf <span class="free">i</span> <span class="free">j</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">‹<span class="free">t</span> <span class="main">≤</span> <span class="free">n</span>›</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">i</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">j</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> OPT_0<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">{</span>bf <span class="skolem">i</span> <span class="bound">w</span> <span class="main">+</span> <span class="free">W</span> <span class="skolem">j</span> <span class="bound">w</span> <span class="main">|</span><span class="bound">w</span><span class="main">.</span> <span class="bound">w</span> <span class="main">≤</span> <span class="free">n</span><span class="main">}</span> <span class="main">=</span> set <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">w</span><span class="main">.</span> <span class="free">W</span> <span class="skolem">j</span> <span class="bound">w</span> <span class="main">+</span> bf <span class="skolem">i</span> <span class="bound">w</span><span class="main">)</span> <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span>Suc <span class="free">n</span><span class="main">]</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> add.commute image_def<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> Suc <span class="quoted"><span class="quoted">‹<span class="free">t</span> <span class="main">≤</span> <span class="free">n</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> OPT_Suc <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> upt_Suc<span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> Min.set_eq_fold<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> *<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Functional Memoization›</span></span>

<span class="keyword1"><span class="command">memoize_fun</span></span> bf<span class="hidden">⇩</span><sub>m</sub><span class="main">:</span> <span class="quoted">bf</span> <span class="keyword2"><span class="keyword">with_memory</span></span> dp_consistency_mapping <span class="keyword1"><span class="command">monadifies</span></span> <span class="main">(</span>state<span class="main">)</span> bf.simps

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Generated Definitions›</span></span>
<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> state_monad_syntax <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">thm</span></span> bf<span class="hidden">⇩</span><sub>m</sub>'.simps bf<span class="hidden">⇩</span><sub>m</sub>_def
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Correspondence Proof›</span></span>
<span class="keyword1"><span class="command">memoize_correct</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">memoize_prover</span>
<span class="keyword1"><span class="command">print_theorems</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> bf<span class="hidden">⇩</span><sub>m</sub>.memoized_correct

<span class="keyword1"><span class="command">interpretation</span></span> iterator
  <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="free">n</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">≤</span> <span class="free">n</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="keyword1">then</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="bound">x</span> <span class="main">+</span> <span class="main">1</span><span class="main">,</span> <span class="main">0</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">*</span> <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">+</span> <span class="bound">y</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> table_iterator_up<span class="main">)</span>

<span class="keyword1"><span class="command">interpretation</span></span> bottom_up<span class="main">:</span> dp_consistency_iterator_empty
  <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">::</span><span class="main">(</span>nat <span class="main">×</span> nat<span class="main">,</span> int extended<span class="main">)</span> mapping<span class="main">)</span><span class="main">.</span> True"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> bf <span class="bound">x</span> <span class="bound">y</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">k</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span><span class="bound">m</span> <span class="main">←</span> State_Monad.get<span class="main">;</span> State_Monad.return <span class="main">(</span>Mapping.lookup <span class="bound">m</span> <span class="bound">k</span> <span class="main">::</span> int extended option<span class="main">)</span><span class="main">}</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">k</span> <span class="bound">v</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span><span class="bound">m</span> <span class="main">←</span> State_Monad.get<span class="main">;</span> State_Monad.set <span class="main">(</span>Mapping.update <span class="bound">k</span> <span class="bound">v</span> <span class="bound">m</span><span class="main">)</span><span class="main">}</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="free">n</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">≤</span> <span class="free">n</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="keyword1">then</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="bound">x</span> <span class="main">+</span> <span class="main">1</span><span class="main">,</span> <span class="main">0</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">*</span> <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">+</span> <span class="bound">y</span>"</span></span>
  <span class="quoted">Mapping.empty</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">iter_bf</span> <span class="main">=</span> iter_state <span class="main">(</span><span class="main">λ</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> bf<span class="hidden">⇩</span><sub>m</sub>' <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Bellman_Ford-iter_bf_unfold"><span class="command">lemma</span></span> iter_bf_unfold<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"iter_bf <span class="main">=</span> <span class="main">(</span><span class="main">λ</span> <span class="main">(</span><span class="bound">i</span><span class="main">,</span> <span class="bound">j</span><span class="main">)</span><span class="main">.</span>
    <span class="main">(</span><span class="keyword1">if</span> <span class="bound">i</span> <span class="main">≤</span> <span class="free">n</span> <span class="main">∧</span> <span class="bound">j</span> <span class="main">≤</span> <span class="free">n</span>
     <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
            bf<span class="hidden">⇩</span><sub>m</sub>' <span class="bound">i</span> <span class="bound">j</span><span class="main">;</span>
            iter_bf <span class="main">(</span><span class="keyword1">if</span> <span class="bound">j</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="keyword1">then</span> <span class="main">(</span><span class="bound">i</span><span class="main">,</span> <span class="bound">j</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="bound">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">,</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span>
          <span class="main">}</span>
     <span class="keyword1">else</span> State_Monad.return <span class="main">()</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> iter_bf_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span> <span class="main">(</span><span class="operator">safe</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> iter_state_unfold<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> bf_memoized <span class="main">=</span> bf<span class="hidden">⇩</span><sub>m</sub>.memoized<span class="main">[</span><span class="operator">OF</span> bf<span class="hidden">⇩</span><sub>m</sub>.crel<span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> bf_bottom_up <span class="main">=</span> bottom_up.memoized<span class="main">[</span><span class="operator">OF</span> bf<span class="hidden">⇩</span><sub>m</sub>.crel<span class="main">,</span> <span class="operator">folded</span> iter_bf_def<span class="main">]</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
This will be our final implementation, which includes detection of negative cycles.
See the corresponding section below for the correctness proof.
›</span></span>
<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">bellman_ford</span> <span class="main">≡</span>
    <span class="keyword1">do</span> <span class="main">{</span>
      <span class="main"><span class="bound">_</span></span>  <span class="main">←</span> iter_bf <span class="main">(</span><span class="free">n</span><span class="main">,</span> <span class="free">n</span><span class="main">)</span><span class="main">;</span>
      <span class="bound">xs</span> <span class="main">←</span> State_Main.map<span class="hidden">⇩</span><sub>T</sub>' <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> bf<span class="hidden">⇩</span><sub>m</sub>' <span class="free">n</span> <span class="bound">i</span><span class="main">)</span> <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">+</span><span class="main">1</span><span class="main">]</span><span class="main">;</span>
      <span class="bound">ys</span> <span class="main">←</span> State_Main.map<span class="hidden">⇩</span><sub>T</sub>' <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> bf<span class="hidden">⇩</span><sub>m</sub>' <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="bound">i</span><span class="main">)</span> <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">+</span><span class="main">1</span><span class="main">]</span><span class="main">;</span>
      State_Monad.return <span class="main">(</span><span class="keyword1">if</span> <span class="bound">xs</span> <span class="main">=</span> <span class="bound">ys</span> <span class="keyword1">then</span> Some <span class="bound">xs</span> <span class="keyword1">else</span> None<span class="main">)</span>
    <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">includes</span></span> state_monad_syntax
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Bellman_Ford-bellman_ford_alt_def"><span class="command">lemma</span></span> bellman_ford_alt_def<span class="main">:</span>
  <span class="quoted"><span class="quoted">"bellman_ford <span class="main">≡</span>
    <span class="keyword1">do</span> <span class="main">{</span>
      <span class="main"><span class="bound">_</span></span>  <span class="main">←</span> iter_bf <span class="main">(</span><span class="free">n</span><span class="main">,</span> <span class="free">n</span><span class="main">)</span><span class="main">;</span>
      <span class="main">(</span><span class="main">⟨</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="main">⟨</span><span class="main">λ</span><span class="bound">ys</span><span class="main">.</span> State_Monad.return <span class="main">(</span><span class="keyword1">if</span> <span class="bound">xs</span> <span class="main">=</span> <span class="bound">ys</span> <span class="keyword1">then</span> Some <span class="bound">xs</span> <span class="keyword1">else</span> None<span class="main">)</span><span class="main">⟩</span>
      <span class="main">.</span> <span class="main">(</span>State_Main.map<span class="hidden">⇩</span><sub>T</sub> <span class="main">.</span> <span class="main">⟨</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> bf<span class="hidden">⇩</span><sub>m</sub>' <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="bound">i</span><span class="main">⟩</span> <span class="main">.</span> <span class="main">⟨</span><span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">+</span><span class="main">1</span><span class="main">]</span><span class="main">⟩</span><span class="main">)</span><span class="main">⟩</span><span class="main">)</span>
      <span class="main">.</span> <span class="main">(</span>State_Main.map<span class="hidden">⇩</span><sub>T</sub> <span class="main">.</span> <span class="main">⟨</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> bf<span class="hidden">⇩</span><sub>m</sub>' <span class="free">n</span> <span class="bound">i</span><span class="main">⟩</span>       <span class="main">.</span> <span class="main">⟨</span><span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">+</span><span class="main">1</span><span class="main">]</span><span class="main">⟩</span><span class="main">)</span>
    <span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span>
    State_Monad_Ext.fun_app_lifted_def bellman_ford_def State_Main.map<span class="hidden">⇩</span><sub>T</sub>_def bind_left_identity
  <span class="keyword1"><span class="command">.</span></span>

<span class="keyword2"><span class="keyword">end</span></span>



<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Imperative Memoization›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">mem</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat ref <span class="main">×</span> nat ref <span class="main">×</span> int extended option array ref <span class="main">×</span> int extended option array ref"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> mem_is_init<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">mem</span> <span class="main">=</span> result_of <span class="main">(</span>init_state <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">1</span> <span class="main">0</span><span class="main">)</span> Heap.empty"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"dp_consistency_heap_array_pair' <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> fst snd id <span class="main">1</span> <span class="main">0</span> <span class="free">mem</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mem_is_init injective_def<span class="main">)</span>

<span class="keyword1"><span class="command">interpretation</span></span> iterator
  <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="free">n</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">≤</span> <span class="free">n</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="keyword1">then</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="bound">x</span> <span class="main">+</span> <span class="main">1</span><span class="main">,</span> <span class="main">0</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">*</span> <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">+</span> <span class="bound">y</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> table_iterator_up<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"dp_consistency_heap_array_pair_iterator <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> fst snd id <span class="main">1</span> <span class="main">0</span> <span class="free">mem</span>
  <span class="main">(</span><span class="main">λ</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="keyword1">then</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="bound">x</span> <span class="main">+</span> <span class="main">1</span><span class="main">,</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span>
  <span class="main">(</span><span class="main">λ</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">*</span> <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">+</span> <span class="bound">y</span><span class="main">)</span>
  <span class="main">(</span><span class="main">λ</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="free">n</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">≤</span> <span class="free">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mem_is_init injective_def<span class="main">)</span>

<span class="keyword1"><span class="command">memoize_fun</span></span> bf<span class="hidden">⇩</span><sub>h</sub><span class="main">:</span> <span class="quoted">bf</span>
  <span class="keyword2"><span class="keyword">with_memory</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">default_proof</span></span><span class="main">)</span> dp_consistency_heap_array_pair_iterator
  <span class="keyword2"><span class="keyword">where</span></span> size <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> key1 <span class="main">=</span> <span class="quoted"><span class="quoted">"fst <span class="main">::</span> nat <span class="main">×</span> nat <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">and</span></span> key2 <span class="main">=</span> <span class="quoted"><span class="quoted">"snd <span class="main">::</span> nat <span class="main">×</span> nat <span class="main">⇒</span> nat"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> k1 <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">::</span> nat"</span></span> <span class="keyword2"><span class="keyword">and</span></span> k2 <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">::</span> nat"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> to_index <span class="main">=</span> <span class="quoted"><span class="quoted">"id <span class="main">::</span> nat <span class="main">⇒</span> nat"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> mem <span class="main">=</span> <span class="quoted"><span class="free">mem</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> cnt <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="free">n</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">≤</span> <span class="free">n</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> nxt <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="main">(</span><span class="bound">x</span> <span class="main">::</span> nat<span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="keyword1">then</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="bound">x</span> <span class="main">+</span> <span class="main">1</span><span class="main">,</span> <span class="main">0</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> sizef <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">*</span> <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">+</span> <span class="bound">y</span>"</span></span>
<span class="keyword1"><span class="command">monadifies</span></span> <span class="main">(</span>heap<span class="main">)</span> bf.simps

<span class="keyword1"><span class="command">memoize_correct</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">memoize_prover</span>

<span class="keyword1"><span class="command">lemmas</span></span> memoized_empty <span class="main">=</span> bf<span class="hidden">⇩</span><sub>h</sub>.memoized_empty<span class="main">[</span><span class="operator">OF</span> bf<span class="hidden">⇩</span><sub>h</sub>.consistent_DP_iter_and_compute<span class="main"><span class="main">[</span></span><span class="operator">OF</span> bf<span class="hidden">⇩</span><sub>h</sub>.crel<span class="main"><span class="main">]</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> iter_heap_unfold <span class="main">=</span> iter_heap_unfold

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Fixed Memory *)</span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Detecting Negative Cycles›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">shortest</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> <span class="main">(</span>
    Inf <span class="main">(</span>
      <span class="main">{</span>weight <span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">#</span> <span class="bound">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span> <span class="main">|</span> <span class="bound">xs</span><span class="main">.</span> set <span class="bound">xs</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">}</span><span class="main">}</span> <span class="main">∪</span>
      <span class="main">{</span><span class="keyword1">if</span> <span class="free">t</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> <span class="main">∞</span><span class="main">}</span>
    <span class="main">)</span>
  <span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">is_path</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≡</span> weight <span class="main">(</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span> <span class="main">&lt;</span> <span class="main">∞</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">has_negative_cycle</span> <span class="main">≡</span>
  <span class="main">∃</span><span class="bound">xs</span> <span class="bound">a</span> <span class="bound">ys</span><span class="main">.</span> set <span class="main">(</span><span class="bound">a</span> <span class="main">#</span> <span class="bound">xs</span> <span class="main">@</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">}</span> <span class="main">∧</span> weight <span class="main">(</span><span class="bound">a</span> <span class="main">#</span> <span class="bound">xs</span> <span class="main">@</span> <span class="main">[</span><span class="bound">a</span><span class="main">]</span><span class="main">)</span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∧</span> is_path <span class="main">(</span><span class="bound">a</span> <span class="main">#</span> <span class="bound">ys</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">reaches</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">≡</span> <span class="main">∃</span><span class="bound">xs</span><span class="main">.</span> is_path <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">#</span> <span class="bound">xs</span><span class="main">)</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">≤</span> <span class="free">n</span> <span class="main">∧</span> set <span class="bound">xs</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">}</span>"</span></span>

<span class="keyword1" id="Bellman_Ford-fold_sum_aux'"><span class="command">lemma</span></span> fold_sum_aux'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">u</span> <span class="main">∈</span> set <span class="main">(</span><span class="free">a</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span><span class="main">.</span> <span class="main">∀</span><span class="bound">v</span> <span class="main">∈</span> set <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">b</span><span class="main">]</span><span class="main">)</span><span class="main">.</span> <span class="free">f</span> <span class="bound">v</span> <span class="main">+</span> <span class="free">W</span> <span class="bound">u</span> <span class="bound">v</span> <span class="main">≥</span> <span class="free">f</span> <span class="bound">u</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sum_list <span class="main">(</span>map <span class="free">f</span> <span class="main">(</span><span class="free">a</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> sum_list <span class="main">(</span>map <span class="free">f</span> <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">b</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span> weight <span class="main">(</span><span class="free">a</span> <span class="main">#</span> <span class="free">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">b</span><span class="main">]</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">a</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
     <span class="main">(</span><span class="operator">smt</span> ab_semigroup_add_class.add_ac<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> add.left_commute add_mono<span class="main">)</span>

<span class="keyword1" id="Bellman_Ford-fold_sum_aux"><span class="command">lemma</span></span> fold_sum_aux<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">u</span> <span class="main">∈</span> set <span class="main">(</span><span class="free">a</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span><span class="main">.</span> <span class="main">∀</span><span class="bound">v</span> <span class="main">∈</span> set <span class="main">(</span><span class="free">a</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span><span class="main">.</span> <span class="free">f</span> <span class="bound">v</span> <span class="main">+</span> <span class="free">W</span> <span class="bound">u</span> <span class="bound">v</span> <span class="main">≥</span> <span class="free">f</span> <span class="bound">u</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sum_list <span class="main">(</span>map <span class="free">f</span> <span class="main">(</span><span class="free">a</span> <span class="main">#</span> <span class="free">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">a</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> sum_list <span class="main">(</span>map <span class="free">f</span> <span class="main">(</span><span class="free">a</span> <span class="main">#</span> <span class="free">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">a</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span> weight <span class="main">(</span><span class="free">a</span> <span class="main">#</span> <span class="free">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">a</span><span class="main">]</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> fold_sum_aux'<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">a</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">a</span></span> <span class="quoted"><span class="free">f</span></span><span class="main">]</span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> add.assoc add.commute add_left_mono<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">is_path2</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≡</span> weight <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">&lt;</span> <span class="main">∞</span>"</span></span>

<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="Bellman_Ford-is_path2_remove_cycle"><span class="command">lemma</span></span> is_path2_remove_cycle<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"is_path2 <span class="main">(</span><span class="free">as</span> <span class="main">@</span> <span class="free">a</span> <span class="main">#</span> <span class="free">bs</span> <span class="main">@</span> <span class="free">a</span> <span class="main">#</span> <span class="free">cs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"is_path2 <span class="main">(</span><span class="free">as</span> <span class="main">@</span> <span class="free">a</span> <span class="main">#</span> <span class="free">cs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"weight <span class="main">(</span><span class="free">as</span> <span class="main">@</span> <span class="free">a</span> <span class="main">#</span> <span class="free">bs</span> <span class="main">@</span> <span class="free">a</span> <span class="main">#</span> <span class="free">cs</span><span class="main">)</span> <span class="main">=</span>
    weight <span class="main">(</span><span class="free">as</span> <span class="main">@</span> <span class="main">[</span><span class="free">a</span><span class="main">]</span><span class="main">)</span> <span class="main">+</span> weight <span class="main">(</span><span class="free">a</span> <span class="main">#</span> <span class="free">bs</span> <span class="main">@</span> <span class="main">[</span><span class="free">a</span><span class="main">]</span><span class="main">)</span> <span class="main">+</span> weight <span class="main">(</span><span class="free">a</span> <span class="main">#</span> <span class="free">cs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Bellman_Ford.weight_append append_Cons append_assoc<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"weight <span class="main">(</span><span class="free">as</span> <span class="main">@</span> <span class="main">[</span><span class="free">a</span><span class="main">]</span><span class="main">)</span> <span class="main">&lt;</span> <span class="main">∞</span>"</span></span> <span class="quoted"><span class="quoted">"weight <span class="main">(</span><span class="free">a</span> <span class="main">#</span> <span class="free">cs</span><span class="main">)</span> <span class="main">&lt;</span> <span class="main">∞</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> is_path2_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">metis</span> Pinf_add_right antisym less_extended_simps<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span> not_less add.commute<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> is_path2_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> weight_append<span class="main">)</span> <span class="main">(</span><span class="operator">rule</span> add_lt_infI<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="Bellman_Ford-is_path_eq"><span class="command">lemma</span></span> is_path_eq<span class="main">:</span>
  <span class="quoted"><span class="quoted">"is_path <span class="free">xs</span> <span class="main">⟷</span> is_path2 <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> is_path_def is_path2_def <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1" id="Bellman_Ford-is_path_remove_cycle"><span class="command">lemma</span></span> is_path_remove_cycle<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"is_path <span class="main">(</span><span class="free">as</span> <span class="main">@</span> <span class="free">a</span> <span class="main">#</span> <span class="free">bs</span> <span class="main">@</span> <span class="free">a</span> <span class="main">#</span> <span class="free">cs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"is_path <span class="main">(</span><span class="free">as</span> <span class="main">@</span> <span class="free">a</span> <span class="main">#</span> <span class="free">cs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> is_path_eq <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> is_path2_remove_cycle<span class="main">)</span>

<span class="keyword1" id="Bellman_Ford-is_path_remove_cycle2"><span class="command">lemma</span></span> is_path_remove_cycle2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"is_path <span class="main">(</span><span class="free">as</span> <span class="main">@</span> <span class="free">t</span> <span class="main">#</span> <span class="free">cs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"is_path <span class="free">as</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> is_path_eq <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> is_path2_remove_cycle<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* private lemmas *)</span>

<span class="keyword1" id="Bellman_Ford-is_path_shorten"><span class="command">lemma</span></span> is_path_shorten<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"is_path <span class="main">(</span><span class="free">i</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">≤</span> <span class="free">n</span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="free">xs</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">≤</span> <span class="free">n</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">≠</span> <span class="free">i</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">xs</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"is_path <span class="main">(</span><span class="free">i</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">≤</span> <span class="free">n</span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="free">xs</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"length <span class="free">xs</span> <span class="main">&lt;</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"length <span class="free">xs</span> <span class="main">&lt;</span> <span class="free">n</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> that<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="free">xs</span> <span class="main">≥</span> <span class="free">n</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> assms<span class="main">(</span>1<span class="main">,</span>3<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="quoted">"length <span class="free">xs</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> less_induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> less
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span><span class="free">i</span> <span class="main">#</span> <span class="skolem">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span> <span class="main">&gt;</span> card <span class="main">(</span><span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">}</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> less.prems <span class="quoted"><span class="quoted">‹<span class="free">i</span> <span class="main">≤</span> <span class="free">n</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">t</span> <span class="main">≤</span> <span class="free">n</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="free">i</span> <span class="main">#</span> <span class="skolem">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a</span></span> <span class="skolem"><span class="skolem">as</span></span> <span class="skolem"><span class="skolem">bs</span></span> <span class="skolem"><span class="skolem">cs</span></span> <span class="keyword2"><span class="keyword">where</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">#</span> <span class="skolem">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span> <span class="main">=</span> <span class="skolem">as</span> <span class="main">@</span> <span class="skolem">a</span> <span class="main">#</span> <span class="skolem">bs</span> <span class="main">@</span> <span class="skolem">a</span> <span class="main">#</span> <span class="skolem">cs</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">elim</span> list_pidgeonhole<span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">ys</span></span> <span class="keyword2"><span class="keyword">where</span></span> ys<span class="main">:</span> <span class="quoted"><span class="quoted">"is_path <span class="main">(</span><span class="free">i</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"length <span class="skolem">ys</span> <span class="main">&lt;</span> length <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="free">i</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">atomize_elim</span>
      <span class="keyword1"><span class="command">using</span></span> *
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> path_eq_cycleE<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> Nil_Nil
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="free">t</span> <span class="main">≠</span> <span class="free">i</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">ys</span><span class="main">.</span> is_path <span class="main">(</span><span class="free">i</span> <span class="main">#</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">∧</span> length <span class="bound">ys</span> <span class="main">&lt;</span> length <span class="skolem">xs</span> <span class="main">∧</span> set <span class="main">(</span><span class="free">i</span> <span class="main">#</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">}</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Nil_Cons <span class="skolem">cs'</span><span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">ys</span><span class="main">.</span> is_path <span class="main">(</span><span class="free">i</span> <span class="main">#</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">∧</span> length <span class="bound">ys</span> <span class="main">&lt;</span> length <span class="skolem">xs</span> <span class="main">∧</span> set <span class="main">(</span><span class="free">i</span> <span class="main">#</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">}</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹set <span class="main">(</span><span class="free">i</span> <span class="main">#</span> <span class="skolem">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">}</span>›</span></span> <span class="quoted"><span class="quoted">‹is_path <span class="main">(</span><span class="free">i</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>›</span></span> is_path_remove_cycle<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">[]</span>"</span></span><span class="main">]</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="skolem">cs'</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons_Nil <span class="skolem">as'</span><span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">ys</span><span class="main">.</span> is_path <span class="main">(</span><span class="free">i</span> <span class="main">#</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">∧</span> length <span class="bound">ys</span> <span class="main">&lt;</span> length <span class="skolem">xs</span> <span class="main">∧</span> set <span class="main">(</span><span class="free">i</span> <span class="main">#</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">}</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹set <span class="main">(</span><span class="free">i</span> <span class="main">#</span> <span class="skolem">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">}</span>›</span></span> <span class="quoted"><span class="quoted">‹is_path <span class="main">(</span><span class="free">i</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>›</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="skolem">as'</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> is_path_remove_cycle2<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons_Cons <span class="skolem">as'</span> <span class="skolem">cs'</span><span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">ys</span><span class="main">.</span> is_path <span class="main">(</span><span class="free">i</span> <span class="main">#</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">∧</span> length <span class="bound">ys</span> <span class="main">&lt;</span> length <span class="skolem">xs</span> <span class="main">∧</span> set <span class="main">(</span><span class="free">i</span> <span class="main">#</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">}</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹set <span class="main">(</span><span class="free">i</span> <span class="main">#</span> <span class="skolem">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">}</span>›</span></span> <span class="quoted"><span class="quoted">‹is_path <span class="main">(</span><span class="free">i</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>›</span></span> is_path_remove_cycle<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">#</span> <span class="skolem">as'</span>"</span></span><span class="main">]</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted">"<span class="skolem">as'</span> <span class="main">@</span> <span class="skolem">a</span> <span class="main">#</span> <span class="skolem">cs'</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≤</span> length <span class="skolem">ys</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> that less<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Bellman_Ford-reaches_non_inf_path"><span class="command">lemma</span></span> reaches_non_inf_path<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"reaches <span class="free">i</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">≤</span> <span class="free">n</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">≤</span> <span class="free">n</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"OPT <span class="free">n</span> <span class="free">i</span> <span class="main">&lt;</span> <span class="main">∞</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">=</span> <span class="free">i</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="free">i</span> <span class="main">≤</span> <span class="free">n</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">t</span> <span class="main">≤</span> <span class="free">n</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"OPT <span class="free">n</span> <span class="free">i</span> <span class="main">≤</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> OPT_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> Min_le <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> finite_lists_length_le2<span class="main"><span class="main">[</span></span><span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> less_linear <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> zero_extended_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>1<span class="main">)</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xs</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"is_path <span class="main">(</span><span class="free">i</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">≤</span> <span class="free">n</span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">xs</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> reaches_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xs</span></span> <span class="keyword2"><span class="keyword">where</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"is_path <span class="main">(</span><span class="free">i</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">≤</span> <span class="free">n</span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">xs</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"length <span class="skolem">xs</span> <span class="main">&lt;</span> <span class="free">n</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">t</span> <span class="main">≠</span> <span class="free">i</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">t</span> <span class="main">≤</span> <span class="free">n</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> is_path_shorten<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"weight <span class="main">(</span><span class="free">i</span> <span class="main">#</span> <span class="skolem">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span> <span class="main">&lt;</span> <span class="main">∞</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> is_path_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> xs<span class="main">(</span>2-<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> OPT_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">elim</span> order.strict_trans1<span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
       <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> setcompr_eq_image finite_lists_length_le2<span class="main"><span class="main">[</span></span><span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Bellman_Ford-OPT_sink_le_0"><span class="command">lemma</span></span> OPT_sink_le_0<span class="main">:</span>
  <span class="quoted"><span class="quoted">"OPT <span class="free">i</span> <span class="free">t</span> <span class="main">≤</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> OPT_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> finite_lists_length_le2<span class="main"><span class="main">[</span></span><span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Bellman_Ford-is_path_appendD"><span class="command">lemma</span></span> is_path_appendD<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"is_path <span class="main">(</span><span class="free">as</span> <span class="main">@</span> <span class="free">a</span> <span class="main">#</span> <span class="free">bs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"is_path <span class="main">(</span><span class="free">a</span> <span class="main">#</span> <span class="free">bs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms weight_append<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">as</span></span> <span class="quoted"><span class="free">a</span></span> <span class="quoted"><span class="quoted">"<span class="free">bs</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> is_path_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="main">(</span><span class="operator">metis</span> Pinf_add_right add.commute less_extended_simps<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span> not_less_iff_gr_or_eq<span class="main">)</span>

<span class="keyword1" id="Bellman_Ford-has_negative_cycleI"><span class="command">lemma</span></span> has_negative_cycleI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="free">a</span> <span class="main">#</span> <span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"weight <span class="main">(</span><span class="free">a</span> <span class="main">#</span> <span class="free">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">a</span><span class="main">]</span><span class="main">)</span> <span class="main">&lt;</span> <span class="main">0</span>"</span></span> <span class="quoted"><span class="quoted">"is_path <span class="main">(</span><span class="free">a</span> <span class="main">#</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted">has_negative_cycle</span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> has_negative_cycle_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Bellman_Ford-OPT_cases2"><span class="command">lemma</span></span> OPT_cases2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="main">(</span>path<span class="main">)</span> <span class="free">xs</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">≠</span> <span class="free">t</span>"</span></span> <span class="quoted"><span class="quoted">"OPT <span class="free">i</span> <span class="free">v</span> <span class="main">≠</span> <span class="main">∞</span>"</span></span> <span class="quoted"><span class="quoted">"OPT <span class="free">i</span> <span class="free">v</span> <span class="main">=</span> weight <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="free">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"length <span class="free">xs</span> <span class="main">+</span> <span class="main">1</span> <span class="main">≤</span> <span class="free">i</span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="free">xs</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">}</span>"</span></span>
  <span class="main">|</span> <span class="main">(</span>unreachable<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">≠</span> <span class="free">t</span>"</span></span> <span class="quoted"><span class="quoted">"OPT <span class="free">i</span> <span class="free">v</span> <span class="main">=</span> <span class="main">∞</span>"</span></span>
  <span class="main">|</span> <span class="main">(</span>sink<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">=</span> <span class="free">t</span>"</span></span> <span class="quoted"><span class="quoted">"OPT <span class="free">i</span> <span class="free">v</span> <span class="main">≤</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> OPT_def
  <span class="keyword1"><span class="command">using</span></span> Min_in<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">{</span>weight <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="bound">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span> <span class="main">|</span><span class="bound">xs</span><span class="main">.</span> length <span class="bound">xs</span> <span class="main">+</span> <span class="main">1</span> <span class="main">≤</span> <span class="free">i</span> <span class="main">∧</span> set <span class="bound">xs</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">}</span><span class="main">}</span>
    <span class="main">∪</span> <span class="main">{</span><span class="keyword1">if</span> <span class="free">t</span> <span class="main">=</span> <span class="free">v</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> <span class="main">∞</span><span class="main">}</span>"</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">=</span> <span class="free">t</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> finite_lists_length_le2<span class="main"><span class="main">[</span></span><span class="operator">simplified</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>

<span class="keyword1" id="Bellman_Ford-shortest_le_OPT"><span class="command">lemma</span></span> shortest_le_OPT<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">≤</span> <span class="free">n</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"shortest <span class="free">v</span> <span class="main">≤</span> OPT <span class="free">i</span> <span class="free">v</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> OPT_def shortest_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> Min_Inf<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> setcompr_eq_image finite_lists_length_le2<span class="main"><span class="main">[</span></span><span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> Inf_superset_mono<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> W_wellformed<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound"><span class="bound">i</span></span> <span class="main">≤</span> <span class="free">n</span><span class="main">.</span> <span class="main">∀</span><span class="bound"><span class="bound">j</span></span> <span class="main">≤</span> <span class="free">n</span><span class="main">.</span> <span class="free">W</span> <span class="bound">i</span> <span class="bound">j</span> <span class="main">&gt;</span> <span class="main">-∞</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">≤</span> <span class="free">n</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Bellman_Ford-weight_not_minfI"><span class="command">lemma</span></span> weight_not_minfI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">-∞</span> <span class="main">&lt;</span> weight <span class="free">xs</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"set <span class="free">xs</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">using</span></span> W_wellformed <span class="quoted"><span class="quoted">‹<span class="free">t</span> <span class="main">≤</span> <span class="free">n</span>›</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> induct_list012<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> add_gt_minfI <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> zero_extended_def<span class="main">)</span>

<span class="keyword1" id="Bellman_Ford-OPT_not_minfI"><span class="command">lemma</span></span> OPT_not_minfI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"OPT <span class="free">n</span> <span class="free">i</span> <span class="main">&gt;</span> <span class="main">-∞</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">≤</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"OPT <span class="free">n</span> <span class="free">i</span> <span class="main">∈</span>
    <span class="main">{</span>weight <span class="main">(</span><span class="free">i</span> <span class="main">#</span> <span class="bound">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span> <span class="main">|</span><span class="bound">xs</span><span class="main">.</span> length <span class="bound">xs</span> <span class="main">+</span> <span class="main">1</span> <span class="main">≤</span> <span class="free">n</span> <span class="main">∧</span> set <span class="bound">xs</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">}</span><span class="main">}</span> <span class="main">∪</span> <span class="main">{</span><span class="keyword1">if</span> <span class="free">t</span> <span class="main">=</span> <span class="free">i</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> <span class="main">∞</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> OPT_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Min_in<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> setcompr_eq_image finite_lists_length_le2<span class="main"><span class="main">[</span></span><span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> that <span class="quoted"><span class="quoted">‹<span class="free">t</span> <span class="main">≤</span> <span class="free">n</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> weight_not_minfI <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> zero_extended_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> detects_cycle<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted">has_negative_cycle</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound"><span class="bound">i</span></span> <span class="main">≤</span> <span class="free">n</span><span class="main">.</span> OPT <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="bound">i</span> <span class="main">&lt;</span> OPT <span class="free">n</span> <span class="bound">i</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="quoted"><span class="quoted">‹<span class="free">t</span> <span class="main">≤</span> <span class="free">n</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xs</span></span> <span class="skolem"><span class="skolem">a</span></span> <span class="skolem"><span class="skolem">ys</span></span> <span class="keyword2"><span class="keyword">where</span></span> cycle<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">≤</span> <span class="free">n</span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">xs</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">ys</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">}</span>"</span></span>
    <span class="quoted"><span class="quoted">"weight <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">xs</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">a</span><span class="main">]</span><span class="main">)</span> <span class="main">&lt;</span> <span class="main">0</span>"</span></span> <span class="quoted"><span class="quoted">"is_path <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> has_negative_cycle_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"reaches <span class="skolem">a</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> reaches_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> reaches<span class="main">:</span> <span class="quoted"><span class="quoted">"reaches <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> set <span class="skolem">xs</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> that <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">as</span></span> <span class="skolem"><span class="skolem">bs</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> <span class="skolem">as</span> <span class="main">@</span> <span class="skolem">x</span> <span class="main">#</span> <span class="skolem">bs</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">atomize_elim</span> <span class="main">(</span><span class="operator">rule</span> split_list<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> cycle <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"weight <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">bs</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">a</span><span class="main">]</span><span class="main">)</span> <span class="main">&lt;</span> <span class="main">∞</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> weight_append<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">#</span> <span class="skolem">as</span>"</span></span> <span class="quoted"><span class="skolem">x</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">bs</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">a</span><span class="main">]</span>"</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="main">(</span><span class="operator">metis</span> Pinf_add_right Pinf_le add.commute less_eq_extended.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> not_less<span class="main">)</span>

    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹reaches <span class="skolem">a</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">cs</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"local.weight <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">cs</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span> <span class="main">&lt;</span> <span class="main">∞</span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">cs</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> reaches_def is_path_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> reaches_def is_path_def
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">a</span> <span class="main">≤</span> <span class="free">n</span>›</span></span> weight_append<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">#</span> <span class="skolem">bs</span>"</span></span> <span class="quoted"><span class="skolem">a</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">cs</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span>"</span></span><span class="main">]</span> cycle<span class="main">(</span>2<span class="main">)</span> <span class="quoted"><span class="quoted">‹<span class="skolem">xs</span> <span class="main">=</span> <span class="main">_</span>›</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted">"<span class="skolem">bs</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">a</span><span class="main">]</span> <span class="main">@</span> <span class="skolem">cs</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> add_lt_infI<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?S</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"sum_list <span class="main">(</span>map <span class="main">(</span>OPT <span class="free">n</span><span class="main">)</span> <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">xs</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">a</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">≤</span> <span class="free">n</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">≤</span> <span class="free">n</span>"</span></span> <span class="quoted"><span class="quoted">"OPT <span class="free">n</span> <span class="skolem">v</span> <span class="main">+</span> <span class="free">W</span> <span class="skolem">u</span> <span class="skolem">v</span> <span class="main">&lt;</span> OPT <span class="free">n</span> <span class="skolem">u</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">atomize_elim</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> ccontr<span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">∄</span><span class="bound">u</span> <span class="bound">v</span><span class="main">.</span> <span class="bound">u</span> <span class="main">≤</span> <span class="free">n</span> <span class="main">∧</span> <span class="bound">v</span> <span class="main">≤</span> <span class="free">n</span> <span class="main">∧</span> OPT <span class="free">n</span> <span class="bound">v</span> <span class="main">+</span> <span class="free">W</span> <span class="bound">u</span> <span class="bound">v</span> <span class="main">&lt;</span> OPT <span class="free">n</span> <span class="bound">u</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?S</span> <span class="main">≤</span> <span class="var">?S</span> <span class="main">+</span> weight <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">xs</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">a</span><span class="main">]</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> cycle<span class="main">(</span>1-3<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> fold_sum_aux<span class="main"><span class="keyword3">;</span></span> <span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> subset_eq<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?S</span> <span class="main">&gt;</span> <span class="main">-∞</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> cycle<span class="main">(</span>1-4<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> sum_list_not_minfI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> OPT_not_minfI<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?S</span> <span class="main">&lt;</span> <span class="main">∞</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> reaches <span class="quoted"><span class="quoted">‹<span class="free">t</span> <span class="main">≤</span> <span class="free">n</span>›</span></span> cycle<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> sum_list_not_infI<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> reaches_non_inf_path <span class="quoted"><span class="quoted">‹reaches <span class="skolem">a</span>›</span></span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> subset_eq<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"weight <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">xs</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">a</span><span class="main">]</span><span class="main">)</span> <span class="main">≥</span> <span class="main">0</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_add_same_cancel1<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹weight <span class="main">_</span> <span class="main">&lt;</span> <span class="main">0</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span>
       <span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="skolem">u</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span>
        <span class="operator">auto</span> 4 4 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> Min.coboundedI min.strict_coboundedI2 <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> order.strict_trans1<span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span>
          <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> OPT_Suc<span class="main"><span class="main">[</span></span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="free">t</span> <span class="main">≤</span> <span class="free">n</span>›</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">corollary</span></span> bf_detects_cycle<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted">has_negative_cycle</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound"><span class="bound">i</span></span> <span class="main">≤</span> <span class="free">n</span><span class="main">.</span> bf <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="bound">i</span> <span class="main">&lt;</span> bf <span class="free">n</span> <span class="bound">i</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> detects_cycle<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> bf_correct<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="free">t</span> <span class="main">≤</span> <span class="free">n</span>›</span></span><span class="main">]</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1" id="Bellman_Ford-shortest_cases"><span class="command">lemma</span></span> shortest_cases<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">≤</span> <span class="free">n</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="main">(</span>path<span class="main">)</span> <span class="free">xs</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"shortest <span class="free">v</span> <span class="main">=</span> weight <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="free">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="free">xs</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">}</span>"</span></span>
  <span class="main">|</span> <span class="main">(</span>sink<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">=</span> <span class="free">t</span>"</span></span> <span class="quoted"><span class="quoted">"shortest <span class="free">v</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="main">|</span> <span class="main">(</span>unreachable<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">≠</span> <span class="free">t</span>"</span></span> <span class="quoted"><span class="quoted">"shortest <span class="free">v</span> <span class="main">=</span> <span class="main">∞</span>"</span></span>
  <span class="main">|</span> <span class="main">(</span>negative_cycle<span class="main">)</span> <span class="quoted"><span class="quoted">"shortest <span class="free">v</span> <span class="main">=</span> <span class="main">-∞</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="main">∃</span><span class="bound">xs</span><span class="main">.</span> set <span class="bound">xs</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">}</span> <span class="main">∧</span> weight <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="bound">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span> <span class="main">&lt;</span> Fin <span class="bound">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?S</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span>weight <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="bound">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span> <span class="main">|</span> <span class="bound">xs</span><span class="main">.</span> set <span class="bound">xs</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">}</span><span class="main">}</span> <span class="main">∪</span> <span class="main">{</span><span class="keyword1">if</span> <span class="free">t</span> <span class="main">=</span> <span class="free">v</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> <span class="main">∞</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?S</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> Minf_lowest<span class="main">:</span> <span class="quoted">False</span> <span class="keyword2"><span class="keyword">if</span></span>  <span class="quoted"><span class="quoted">"<span class="main">-∞</span> <span class="main">&lt;</span> <span class="skolem">a</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">-∞</span> <span class="main">=</span> <span class="skolem">a</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">a</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"int extended"</span></span>
    <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"shortest <span class="free">v</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Fin <span class="skolem">x</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">-∞</span> <span class="main">∉</span> <span class="var">?S</span>"</span></span> <span class="quoted"><span class="quoted">"bdd_below <span class="main">(</span>Fin <span class="main">-`</span> <span class="var">?S</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="var">?S</span> <span class="main">≠</span> <span class="main">{</span><span class="main">∞</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> Inf <span class="main">(</span>Fin <span class="main">-`</span> <span class="var">?S</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> shortest_def Inf_extended_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> this<span class="main">(</span>1-3<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> Fin <span class="main">-`</span> <span class="var">?S</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">=</span> <span class="main">_</span>›</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> Inf_int_in<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> zero_extended_def<span class="main">)</span>
        <span class="main">(</span><span class="operator">smt</span> empty_iff extended.exhaust insertI2 mem_Collect_eq vimage_eq<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹shortest <span class="free">v</span> <span class="main">=</span> <span class="main">_</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> vimage_eq <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> that<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> Pinf
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?S</span> <span class="main">≠</span> <span class="main">{}</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">≠</span> <span class="free">v</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> shortest_def Inf_extended_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">_</span> <span class="main">=</span> <span class="main">∞</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> that<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> Minf
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?S</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="var">?S</span> <span class="main">≠</span> <span class="main">{</span><span class="main">∞</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">-∞</span> <span class="main">∈</span> <span class="var">?S</span> <span class="main">∨</span> <span class="main">¬</span> bdd_below <span class="main">(</span>Fin <span class="main">-`</span> <span class="var">?S</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> shortest_def Inf_extended_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> this<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="main">∃</span><span class="bound">xs</span><span class="main">.</span> set <span class="bound">xs</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">}</span> <span class="main">∧</span> weight <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="bound">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span> <span class="main">&lt;</span> Fin <span class="bound">x</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">-∞</span> <span class="main">∈</span> <span class="var">?S</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> weight_not_minfI <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span>
        <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">v</span> <span class="main">≤</span> <span class="free">n</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">t</span> <span class="main">≤</span> <span class="free">n</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> Minf_lowest<span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> bdd_below <span class="main">(</span>Fin <span class="main">-`</span> <span class="var">?S</span><span class="main">)</span>"</span></span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span>
        <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted">int</span>
        <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?m</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"min <span class="skolem">x</span> <span class="main">(</span><span class="main">-</span><span class="main">1</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> bdd_below <span class="main">_</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">m</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"Fin <span class="skolem">m</span> <span class="main">∈</span> <span class="var">?S</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">&lt;</span> <span class="var">?m</span>"</span></span>
          <span class="keyword1"><span class="command">unfolding</span></span> bdd_below_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">drule</span> spec<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted">"<span class="var">?m</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main">)</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">xs</span><span class="main">.</span> set <span class="bound">xs</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">}</span> <span class="main">∧</span> weight <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="bound">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span> <span class="main">&lt;</span> Fin <span class="skolem">x</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> zero_extended_def<span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> less_extended_simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹shortest <span class="free">v</span> <span class="main">=</span> <span class="main">_</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> that<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Bellman_Ford-simple_paths"><span class="command">lemma</span></span> simple_paths<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> has_negative_cycle"</span></span> <span class="quoted"><span class="quoted">"weight <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="free">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span> <span class="main">&lt;</span> <span class="main">∞</span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="free">xs</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">≤</span> <span class="free">n</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">ys</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"weight <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="free">ys</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span> <span class="main">≤</span> weight <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="free">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="free">ys</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"length <span class="free">ys</span> <span class="main">&lt;</span> <span class="free">n</span>"</span></span> <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">=</span> <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2-<span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">atomize_elim</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">induction</span> <span class="quoted"><span class="quoted">"length <span class="free">xs</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> less_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>less <span class="skolem">ys</span><span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> ys <span class="main">=</span> less.prems<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> IH <span class="main">=</span> less.hyps
  <span class="keyword1"><span class="command">have</span></span> path<span class="main">:</span> <span class="quoted"><span class="quoted">"is_path <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> is_path_def not_less_iff_gr_or_eq ys<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"length <span class="skolem">ys</span> <span class="main">≥</span> <span class="free">n</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">with</span></span> ys <span class="quoted"><span class="quoted">‹<span class="free">v</span> <span class="main">≤</span> <span class="free">n</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">t</span> <span class="main">≤</span> <span class="free">n</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a</span></span> <span class="skolem"><span class="skolem">as</span></span> <span class="skolem"><span class="skolem">bs</span></span> <span class="skolem"><span class="skolem">cs</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">#</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span> <span class="main">=</span> <span class="skolem">as</span> <span class="main">@</span> <span class="skolem">a</span> <span class="main">#</span> <span class="skolem">bs</span> <span class="main">@</span> <span class="skolem">a</span> <span class="main">#</span> <span class="skolem">cs</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> list_pidgeonhole<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">#</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">}</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> path_eq_cycleE<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> Nil_Nil
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Nil_Cons <span class="skolem">cs'</span><span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"weight <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> weight <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">bs</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">a</span><span class="main">]</span><span class="main">)</span> <span class="main">+</span> weight <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">cs'</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> weight_append<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">#</span> <span class="skolem">bs</span>"</span></span> <span class="quoted"><span class="skolem">a</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">cs'</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span>"</span></span><span class="main"><span class="main">,</span></span> <span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"weight <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">bs</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">a</span><span class="main">]</span><span class="main">)</span> <span class="main">&lt;</span> <span class="main">0</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True
        <span class="keyword1"><span class="command">with</span></span> Nil_Cons <span class="quoted"><span class="quoted">‹set <span class="skolem">ys</span> <span class="main">⊆</span> <span class="main">_</span>›</span></span> path <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> has_negative_cycleI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="skolem">a</span></span> <span class="quoted"><span class="skolem">bs</span></span> <span class="quoted"><span class="skolem">ys</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"weight <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">bs</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">a</span><span class="main">]</span><span class="main">)</span> <span class="main">≥</span> <span class="main">0</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">with</span></span> * ys <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"weight <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">cs'</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span> <span class="main">≤</span> weight <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> add_mono not_le <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
        <span class="keyword1"><span class="command">with</span></span> Nil_Cons <span class="quoted"><span class="quoted">‹length <span class="skolem">ys</span> <span class="main">≥</span> <span class="free">n</span>›</span></span> ys <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command">using</span></span> IH<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">cs'</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="main">(</span><span class="operator">meson</span> le_less_trans order_trans<span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons_Nil <span class="skolem">as'</span><span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> ys <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"weight <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> weight <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="skolem">as'</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span> <span class="main">+</span> weight <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">bs</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">a</span><span class="main">]</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> weight_append<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">#</span> <span class="skolem">as'</span>"</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">bs</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"weight <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">bs</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">a</span><span class="main">]</span><span class="main">)</span> <span class="main">&lt;</span> <span class="main">0</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True
        <span class="keyword1"><span class="command">with</span></span> Cons_Nil <span class="quoted"><span class="quoted">‹set <span class="skolem">ys</span> <span class="main">⊆</span> <span class="main">_</span>›</span></span> path assms<span class="main">(</span>1<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command">using</span></span> is_path_appendD<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">#</span> <span class="skolem">as'</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> has_negative_cycleI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="skolem">a</span></span> <span class="quoted"><span class="skolem">bs</span></span> <span class="quoted"><span class="skolem">bs</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"weight <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">bs</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">a</span><span class="main">]</span><span class="main">)</span> <span class="main">≥</span> <span class="main">0</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">with</span></span> * ys<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"weight <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="skolem">as'</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span> <span class="main">≤</span> weight <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> add_left_mono <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
        <span class="keyword1"><span class="command">with</span></span> Cons_Nil <span class="quoted"><span class="quoted">‹length <span class="skolem">ys</span> <span class="main">≥</span> <span class="free">n</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">v</span> <span class="main">≤</span> <span class="free">n</span>›</span></span> ys <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command">using</span></span> IH<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">as'</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="main">(</span><span class="operator">meson</span> le_less_trans order_trans<span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons_Cons <span class="skolem">as'</span> <span class="skolem">cs'</span><span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> ys <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span>
        <span class="quoted"><span class="quoted">"weight <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> weight <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="skolem">as'</span> <span class="main">@</span> <span class="skolem">a</span> <span class="main">#</span> <span class="skolem">cs'</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span> <span class="main">+</span> weight <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">bs</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">a</span><span class="main">]</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span>
          weight_append<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">#</span> <span class="skolem">as'</span>"</span></span> <span class="quoted"><span class="skolem">a</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">bs</span> <span class="main">@</span> <span class="skolem">a</span> <span class="main">#</span> <span class="skolem">cs'</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span>"</span></span><span class="main">]</span>
          weight_append<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">#</span> <span class="skolem">bs</span>"</span></span> <span class="quoted"><span class="skolem">a</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">cs'</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span>"</span></span><span class="main">]</span>
          weight_append<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">#</span> <span class="skolem">as'</span>"</span></span> <span class="quoted"><span class="skolem">a</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">cs'</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span>"</span></span><span class="main">]</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">algebra_simps</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"weight <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">bs</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">a</span><span class="main">]</span><span class="main">)</span> <span class="main">&lt;</span> <span class="main">0</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True
        <span class="keyword1"><span class="command">with</span></span> Cons_Cons <span class="quoted"><span class="quoted">‹set <span class="skolem">ys</span> <span class="main">⊆</span> <span class="main">_</span>›</span></span> path assms<span class="main">(</span>1<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command">using</span></span> is_path_appendD<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">#</span> <span class="skolem">as'</span>"</span></span><span class="main">]</span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> has_negative_cycleI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="skolem">a</span></span> <span class="quoted"><span class="skolem">bs</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">bs</span> <span class="main">@</span> <span class="skolem">a</span> <span class="main">#</span> <span class="skolem">cs'</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"weight <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">bs</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">a</span><span class="main">]</span><span class="main">)</span> <span class="main">≥</span> <span class="main">0</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">with</span></span> * ys <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"weight <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="skolem">as'</span> <span class="main">@</span> <span class="skolem">a</span> <span class="main">#</span> <span class="skolem">cs'</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span> <span class="main">≤</span> weight <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> add_left_mono <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
        <span class="keyword1"><span class="command">with</span></span> Cons_Cons <span class="quoted"><span class="quoted">‹<span class="free">v</span> <span class="main">≤</span> <span class="free">n</span>›</span></span> ys <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command">using</span></span> is_path_remove_cycle2 IH<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="skolem">as'</span> <span class="main">@</span> <span class="skolem">a</span> <span class="main">#</span> <span class="skolem">cs'</span>"</span></span><span class="main">]</span>
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="main">(</span><span class="operator">meson</span> le_less_trans order_trans<span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹set <span class="skolem">ys</span> <span class="main">⊆</span> <span class="main">_</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> shorter_than_OPT_n_has_negative_cycle<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"shortest <span class="free">v</span> <span class="main">&lt;</span> OPT <span class="free">n</span> <span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">≤</span> <span class="free">n</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted">has_negative_cycle</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">ys</span></span> <span class="keyword2"><span class="keyword">where</span></span> ys<span class="main">:</span>
    <span class="quoted"><span class="quoted">"weight <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span> <span class="main">&lt;</span> OPT <span class="free">n</span> <span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">ys</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> OPT_cases2<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">v</span></span> <span class="quoted"><span class="free">n</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> shortest_cases<span class="main"><span class="main">[</span></span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="free">v</span> <span class="main">≤</span> <span class="free">n</span>›</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> uminus_extended.cases<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> less_extended_simps<span class="main">(</span>2<span class="main">)</span> less_trans <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> less_eq_extended.elims<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> less_extended_def zero_extended_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">=</span> <span class="free">t</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">with</span></span> ys <span class="quoted"><span class="quoted">‹<span class="free">t</span> <span class="main">≤</span> <span class="free">n</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> OPT_sink_le_0<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">n</span></span><span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> has_negative_cycle_def is_path_def
      <span class="keyword1"><span class="command">using</span></span> less_extended_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> has_negative_cycle"</span></span>
      <span class="keyword1"><span class="command">with</span></span> False False ys <span class="quoted"><span class="quoted">‹<span class="free">v</span> <span class="main">≤</span> <span class="free">n</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xs</span></span> <span class="keyword2"><span class="keyword">where</span></span>
        <span class="quoted"><span class="quoted">"weight <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="skolem">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span> <span class="main">≤</span> weight <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">xs</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"length <span class="skolem">xs</span> <span class="main">&lt;</span> <span class="free">n</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> less_extended_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> simple_paths<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">v</span></span> <span class="quoted"><span class="skolem">ys</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"OPT <span class="free">n</span> <span class="free">v</span> <span class="main">≤</span> weight <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="skolem">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> OPT_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> Min_le<span class="main">)</span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">_</span> <span class="main">≤</span> weight <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹weight <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="main">[</span><span class="free">t</span><span class="main">]</span><span class="main">)</span> <span class="main">&lt;</span> OPT <span class="free">n</span> <span class="free">v</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">corollary</span></span> detects_cycle_has_negative_cycle<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"OPT <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="free">v</span> <span class="main">&lt;</span> OPT <span class="free">n</span> <span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">≤</span> <span class="free">n</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted">has_negative_cycle</span>
  <span class="keyword1"><span class="command">using</span></span> assms shortest_le_OPT<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">v</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">+</span> <span class="main">1</span>"</span></span><span class="main">]</span> shorter_than_OPT_n_has_negative_cycle<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">v</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">corollary</span></span> bellman_ford_detects_cycle<span class="main">:</span>
  <span class="quoted"><span class="quoted">"has_negative_cycle <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound"><span class="bound">v</span></span> <span class="main">≤</span> <span class="free">n</span><span class="main">.</span> OPT <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="bound">v</span> <span class="main">&lt;</span> OPT <span class="free">n</span> <span class="bound">v</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> detects_cycle_has_negative_cycle detects_cycle <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">corollary</span></span> bellman_ford_shortest_paths<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> has_negative_cycle"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound"><span class="bound">v</span></span> <span class="main">≤</span> <span class="free">n</span><span class="main">.</span> bf <span class="free">n</span> <span class="bound">v</span> <span class="main">=</span> shortest <span class="bound">v</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"OPT <span class="free">n</span> <span class="skolem">v</span> <span class="main">≤</span> shortest <span class="skolem">v</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">≤</span> <span class="free">n</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">v</span>
    <span class="keyword1"><span class="command">using</span></span> that assms shorter_than_OPT_n_has_negative_cycle<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">v</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> bf_correct<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="free">t</span> <span class="main">≤</span> <span class="free">n</span>›</span></span><span class="main">,</span> <span class="operator">symmetric</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">safe</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> order.antisym<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> shortest_le_OPT<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Bellman_Ford-OPT_mono"><span class="command">lemma</span></span> OPT_mono<span class="main">:</span>
  <span class="quoted"><span class="quoted">"OPT <span class="free">m</span> <span class="free">v</span> <span class="main">≤</span> OPT <span class="free">n</span> <span class="free">v</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">‹<span class="free">v</span> <span class="main">≤</span> <span class="free">n</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">n</span> <span class="main">≤</span> <span class="free">m</span>›</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> OPT_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> Min_antimono<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">corollary</span></span> bf_fix<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> has_negative_cycle"</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">≥</span> <span class="free">n</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound"><span class="bound">v</span></span> <span class="main">≤</span> <span class="free">n</span><span class="main">.</span> bf <span class="free">m</span> <span class="bound">v</span> <span class="main">=</span> bf <span class="free">n</span> <span class="bound">v</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> allI impI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">≤</span> <span class="free">n</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">v</span> <span class="main">≤</span> <span class="free">n</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">n</span> <span class="main">≤</span> <span class="free">m</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"shortest <span class="skolem">v</span> <span class="main">≤</span> OPT <span class="free">m</span> <span class="skolem">v</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> shortest_le_OPT<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">v</span> <span class="main">≤</span> <span class="free">n</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">n</span> <span class="main">≤</span> <span class="free">m</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"OPT <span class="free">m</span> <span class="skolem">v</span> <span class="main">≤</span> OPT <span class="free">n</span> <span class="skolem">v</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> OPT_mono<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">v</span> <span class="main">≤</span> <span class="free">n</span>›</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"OPT <span class="free">n</span> <span class="skolem">v</span> <span class="main">≤</span> shortest <span class="skolem">v</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> shorter_than_OPT_n_has_negative_cycle<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">v</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bf <span class="free">m</span> <span class="skolem">v</span> <span class="main">=</span> bf <span class="free">n</span> <span class="skolem">v</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> bf_correct<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="free">t</span> <span class="main">≤</span> <span class="free">n</span>›</span></span><span class="main">,</span> <span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Bellman_Ford-bellman_ford_correct'"><span class="command">lemma</span></span> bellman_ford_correct'<span class="main">:</span>
  <span class="quoted"><span class="quoted">"bf<span class="hidden">⇩</span><sub>m</sub>.crel_vs <span class="main">(=)</span> <span class="main">(</span><span class="keyword1">if</span> has_negative_cycle <span class="keyword1">then</span> None <span class="keyword1">else</span> Some <span class="main">(</span>map shortest <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">+</span><span class="main">1</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> bellman_ford"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">include</span></span> state_monad_syntax app_syntax
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?l</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="keyword1">if</span> has_negative_cycle <span class="keyword1">then</span> None <span class="keyword1">else</span> Some <span class="main">(</span>map shortest <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">]</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?r</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="main">(</span><span class="main">λ</span><span class="bound">ys</span><span class="main">.</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">xs</span> <span class="main">=</span> <span class="bound">ys</span> <span class="keyword1">then</span> Some <span class="bound">xs</span> <span class="keyword1">else</span> None<span class="main">)</span><span class="main">)</span>
    <span class="main">$</span> <span class="main">(</span>map <span class="main">$</span> <span class="main">⟪</span>bf <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span><span class="main">⟫</span> <span class="main">$</span> <span class="main">⟪</span><span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">]</span><span class="main">⟫</span><span class="main">)</span><span class="main">)</span> <span class="main">$</span> <span class="main">(</span>map <span class="main">$</span> <span class="main">⟪</span>bf <span class="free">n</span><span class="main">⟫</span> <span class="main">$</span> <span class="main">⟪</span><span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">]</span><span class="main">⟫</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">note</span></span> crel_bf<span class="hidden">⇩</span><sub>m</sub>' <span class="main">=</span> bf<span class="hidden">⇩</span><sub>m</sub>.crel<span class="main">[</span><span class="operator">unfolded</span> bf<span class="hidden">⇩</span><sub>m</sub>.consistentDP_def<span class="main">,</span> <span class="operator">THEN</span> rel_funD<span class="main">,</span>
      <span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">m</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">m</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">for</span></span></span> <span class="skolem">m</span> <span class="skolem">x</span> <span class="skolem">y</span><span class="main">,</span> <span class="operator">unfolded</span> prod.case<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?l</span> <span class="main">=</span> <span class="var">?r</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span> <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword">del</span></span><span class="main">]</span> <span class="main">=</span> bf_simps
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span> <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword">add</span></span><span class="main">]</span> <span class="main">=</span>
      bf_fix<span class="main">[</span><span class="operator">rule_format</span><span class="main">,</span> <span class="operator">symmetric</span><span class="main">]</span> bellman_ford_shortest_paths<span class="main">[</span><span class="operator">rule_format</span><span class="main">,</span> <span class="operator">symmetric</span><span class="main">]</span>
    <span class="keyword1"><span class="command">unfolding</span></span> Wrap_def App_def <span class="keyword1"><span class="command">using</span></span> bf_detects_cycle <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> nat_le_cases<span class="main">)</span>
  <span class="comment1">― ‹Slightly transform the goal, then apply parametric reasoning like usual.›</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="comment1">― ‹Roughly ›</span>
    <span class="keyword1"><span class="command">unfolding</span></span> bellman_ford_alt_def <span class="quoted"><span class="quoted">‹<span class="var">?l</span> <span class="main">=</span> <span class="var">?r</span>›</span></span> <span class="comment1">― ‹Obtain parametric form.›</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> bf<span class="hidden">⇩</span><sub>m</sub>.crel_vs_bind_ignore<span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="comment1">― ‹Drop bind.›</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> bottom_up.consistent_crel_vs_iterate_state<span class="main"><span class="main">[</span></span><span class="operator">OF</span> bf<span class="hidden">⇩</span><sub>m</sub>.crel<span class="main"><span class="main">,</span></span> <span class="operator">folded</span> iter_bf_def<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> Transfer.Rel_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="comment1">― ‹Setup typical goal for automated reasoner.›</span>
    <span class="comment1">― ‹We need to reason manually because we are not in the context where <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>bf<span class="hidden">⇩</span><sub>m</sub>›</span></span> was defined.›</span>
    <span class="comment1">― ‹This is roughly what <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">method</span> "memoize_prover_match_step"<span class="antiquote">}</span></span>/<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>Transform_Tactic.step_tac›</span></span> does.›</span>
    <span class="keyword1"><span class="command">ML_prf</span></span> <span class="quoted">‹<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span>›</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">tactic</span> <span class="quoted">‹<span class="entity">Transform_Tactic.solve_relator_tac</span> <span class="entity">ctxt</span> <span class="inner_numeral">1</span>›</span>
          <span class="main"><span class="keyword3">|</span></span> <span class="operator">rule</span> HOL.refl
          <span class="main"><span class="keyword3">|</span></span> <span class="operator">rule</span> <span class="dynamic"><span class="dynamic">bf<span class="hidden">⇩</span><sub>m</sub>.dp_match_rule</span></span>
          <span class="main"><span class="keyword3">|</span></span> <span class="operator">rule</span> bf<span class="hidden">⇩</span><sub>m</sub>.crel_vs_return_ext
          <span class="main"><span class="keyword3">|</span></span> <span class="main">(</span><span class="operator">subst</span> Rel_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> crel_bf<span class="hidden">⇩</span><sub>m</sub>'<span class="main">)</span>
          <span class="main"><span class="keyword3">|</span></span> <span class="operator">tactic</span> <span class="quoted">‹<span class="entity">Transform_Tactic.transfer_raw_tac</span> <span class="entity">ctxt</span> <span class="inner_numeral">1</span>›</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> bellman_ford_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"fst <span class="main">(</span>run_state bellman_ford Mapping.empty<span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> has_negative_cycle <span class="keyword1">then</span> None <span class="keyword1">else</span> Some <span class="main">(</span>map shortest <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">+</span><span class="main">1</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> bf<span class="hidden">⇩</span><sub>m</sub>.cmem_empty bellman_ford_correct'<span class="main">[</span><span class="operator">unfolded</span> bf<span class="hidden">⇩</span><sub>m</sub>.crel_vs_def<span class="main">,</span> <span class="operator">rule_format</span><span class="main">,</span> <span class="operator">of</span> <span class="quoted">Mapping.empty</span><span class="main">]</span>
  <span class="keyword1"><span class="command">unfolding</span></span> bf<span class="hidden">⇩</span><sub>m</sub>.crel_vs_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Wellformedness *)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Final Node *)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Bellman Ford *)</span>



<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Extracting an Executable Constant for the Imperative Implementation›</span></span>

<span class="keyword1"><span class="command">ground_function</span></span> <span class="main">(</span>prove_termination<span class="main">)</span> <span class="entity">bf<span class="hidden">⇩</span><sub>h</sub>'_impl</span><span class="main">:</span> bf<span class="hidden">⇩</span><sub>h</sub>'.simps

<span class="keyword1" id="Bellman_Ford-bf"><span class="command">lemma</span></span> bf<span class="hidden">⇩</span><sub>h</sub>'_impl_def<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">n</span> <span class="main">::</span> <span class="quoted">nat</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">mem</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat ref <span class="main">×</span> nat ref <span class="main">×</span> int extended option array ref <span class="main">×</span> int extended option array ref"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> mem_is_init<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">mem</span> <span class="main">=</span> result_of <span class="main">(</span>init_state <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">1</span> <span class="main">0</span><span class="main">)</span> Heap.empty"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"bf<span class="hidden">⇩</span><sub>h</sub>'_impl <span class="free">n</span> <span class="free">w</span> <span class="free">t</span> <span class="free">mem</span> <span class="main">=</span> bf<span class="hidden">⇩</span><sub>h</sub>' <span class="free">n</span> <span class="free">w</span> <span class="free">t</span> <span class="free">mem</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"bf<span class="hidden">⇩</span><sub>h</sub>'_impl <span class="free">n</span> <span class="free">w</span> <span class="free">t</span> <span class="free">mem</span> <span class="skolem">i</span> <span class="skolem">j</span> <span class="main">=</span> bf<span class="hidden">⇩</span><sub>h</sub>' <span class="free">n</span> <span class="free">w</span> <span class="free">t</span> <span class="free">mem</span> <span class="skolem">i</span> <span class="skolem">j</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">i</span> <span class="skolem">j</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> bf<span class="hidden">⇩</span><sub>h</sub>'.induct<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mem_is_init<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span>
        <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bf<span class="hidden">⇩</span><sub>h</sub>'.simps<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mem_is_init<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">solve_cong</span> <span class="operator">simp</span>
       <span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">iter_bf_heap</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="free"><span class="bound"><span class="entity">mem</span></span></span> <span class="main">=</span> iterator_defs.iter_heap
      <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span>
      <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">then</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="bound">x</span> <span class="main">+</span> <span class="main">1</span><span class="main">,</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span>
      <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> bf<span class="hidden">⇩</span><sub>h</sub>'_impl <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="free"><span class="bound"><span class="entity">mem</span></span></span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Bellman_Ford-iter_bf_heap_unfold"><span class="command">lemma</span></span> iter_bf_heap_unfold<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"iter_bf_heap <span class="free">n</span> <span class="free">w</span> <span class="free">t</span> <span class="free">mem</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span> <span class="main">(</span><span class="bound">i</span><span class="main">,</span> <span class="bound">j</span><span class="main">)</span><span class="main">.</span>
    <span class="main">(</span><span class="keyword1">if</span> <span class="bound">i</span> <span class="main">≤</span> <span class="free">n</span> <span class="main">∧</span> <span class="bound">j</span> <span class="main">≤</span> <span class="free">n</span>
     <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
            bf<span class="hidden">⇩</span><sub>h</sub>'_impl <span class="free">n</span> <span class="free">w</span> <span class="free">t</span> <span class="free">mem</span> <span class="bound">i</span> <span class="bound">j</span><span class="main">;</span>
            iter_bf_heap <span class="free">n</span> <span class="free">w</span> <span class="free">t</span> <span class="free">mem</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">j</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="keyword1">then</span> <span class="main">(</span><span class="bound">i</span><span class="main">,</span> <span class="bound">j</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="bound">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">,</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span>
          <span class="main">}</span>
     <span class="keyword1">else</span> Heap_Monad.return <span class="main">()</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> iter_bf_heap_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span> <span class="main">(</span><span class="operator">safe</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> iter_heap_unfold<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">bf_impl</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">mem</span> <span class="main">←</span> <span class="main">(</span>init_state <span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">(</span><span class="main">1</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">(</span><span class="main">0</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">::</span>
      <span class="main">(</span>nat ref <span class="main">×</span> nat ref <span class="main">×</span> int extended option array ref <span class="main">×</span> int extended option array ref<span class="main">)</span> Heap<span class="main">)</span><span class="main">;</span>
    iter_bf_heap <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="bound">mem</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="main">0</span><span class="main">)</span><span class="main">;</span>
    bf<span class="hidden">⇩</span><sub>h</sub>'_impl <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="bound">mem</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">j</span></span></span>
  <span class="main">}</span>"</span></span>

<span class="keyword1" id="Bellman_Ford-bf_impl_correct"><span class="command">lemma</span></span> bf_impl_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"bf <span class="free">n</span> <span class="free">w</span> <span class="free">t</span> <span class="free">i</span> <span class="free">j</span> <span class="main">=</span> result_of <span class="main">(</span>bf_impl <span class="free">n</span> <span class="free">w</span> <span class="free">t</span> <span class="free">i</span> <span class="free">j</span><span class="main">)</span> Heap.empty"</span></span>
  <span class="keyword1"><span class="command">using</span></span> memoized_empty<span class="main">[</span><span class="operator">OF</span> HOL.refl<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">w</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">i</span><span class="main">,</span> <span class="free">j</span><span class="main">)</span>"</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>
        execute_bind_success<span class="main"><span class="main">[</span></span><span class="operator">OF</span> succes_init_state<span class="main"><span class="main">]</span></span> bf_impl_def bf<span class="hidden">⇩</span><sub>h</sub>'_impl_def iter_bf_heap_def
      <span class="main">)</span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Test Cases›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">G<span class="hidden">⇩</span><sub>1</sub>_list</span> <span class="main">=</span> <span class="main">[</span><span class="main">[</span><span class="main">(</span><span class="main">1</span> <span class="main">::</span> nat<span class="main">,</span><span class="main">-</span><span class="numeral">6</span> <span class="main">::</span> int<span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="numeral">2</span><span class="main">,</span><span class="numeral">4</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="numeral">3</span><span class="main">,</span><span class="numeral">5</span><span class="main">)</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="numeral">3</span><span class="main">,</span><span class="numeral">10</span><span class="main">)</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="numeral">3</span><span class="main">,</span><span class="numeral">2</span><span class="main">)</span><span class="main">]</span><span class="main">,</span> <span class="main">[]</span><span class="main">]</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">G<span class="hidden">⇩</span><sub>2</sub>_list</span> <span class="main">=</span> <span class="main">[</span><span class="main">[</span><span class="main">(</span><span class="main">1</span> <span class="main">::</span> nat<span class="main">,</span><span class="main">-</span><span class="numeral">6</span> <span class="main">::</span> int<span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="numeral">2</span><span class="main">,</span><span class="numeral">4</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="numeral">3</span><span class="main">,</span><span class="numeral">5</span><span class="main">)</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="numeral">3</span><span class="main">,</span><span class="numeral">10</span><span class="main">)</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="numeral">3</span><span class="main">,</span><span class="numeral">2</span><span class="main">)</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span><span class="main">)</span><span class="main">]</span><span class="main">]</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">G<span class="hidden">⇩</span><sub>3</sub>_list</span> <span class="main">=</span> <span class="main">[</span><span class="main">[</span><span class="main">(</span><span class="main">1</span> <span class="main">::</span> nat<span class="main">,</span><span class="main">-</span><span class="main">1</span> <span class="main">::</span> int<span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="numeral">2</span><span class="main">,</span><span class="numeral">2</span><span class="main">)</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="numeral">2</span><span class="main">,</span><span class="numeral">5</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="numeral">3</span><span class="main">,</span><span class="numeral">4</span><span class="main">)</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="numeral">3</span><span class="main">,</span><span class="numeral">2</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="numeral">4</span><span class="main">,</span><span class="numeral">3</span><span class="main">)</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="numeral">2</span><span class="main">,</span><span class="main">-</span><span class="numeral">2</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="numeral">4</span><span class="main">,</span><span class="numeral">2</span><span class="main">)</span><span class="main">]</span><span class="main">,</span> <span class="main">[]</span><span class="main">]</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">G<span class="hidden">⇩</span><sub>4</sub>_list</span> <span class="main">=</span> <span class="main">[</span><span class="main">[</span><span class="main">(</span><span class="main">1</span> <span class="main">::</span> nat<span class="main">,</span><span class="main">-</span><span class="main">1</span> <span class="main">::</span> int<span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="numeral">2</span><span class="main">,</span><span class="numeral">2</span><span class="main">)</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="numeral">2</span><span class="main">,</span><span class="numeral">5</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="numeral">3</span><span class="main">,</span><span class="numeral">4</span><span class="main">)</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="numeral">3</span><span class="main">,</span><span class="numeral">2</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="numeral">4</span><span class="main">,</span><span class="numeral">3</span><span class="main">)</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="numeral">2</span><span class="main">,</span><span class="main">-</span><span class="numeral">3</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="numeral">4</span><span class="main">,</span><span class="numeral">2</span><span class="main">)</span><span class="main">]</span><span class="main">,</span> <span class="main">[]</span><span class="main">]</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">graph_of</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">=</span> case_option <span class="main">∞</span> <span class="main">(</span>Fin <span class="keyword1">o</span> snd<span class="main">)</span> <span class="main">(</span>List.find <span class="main">(</span><span class="main">λ</span> <span class="bound">p</span><span class="main">.</span> fst <span class="bound">p</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">!!</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">test_bf</span> <span class="main">=</span> bf_impl <span class="numeral">3</span> <span class="main">(</span>graph_of <span class="main">(</span>IArray G<span class="hidden">⇩</span><sub>1</sub>_list<span class="main">)</span><span class="main">)</span> <span class="numeral">3</span> <span class="numeral">3</span> <span class="main">0</span>"</span></span>

<span class="keyword1"><span class="command">code_reflect</span></span> Test <span class="keyword2"><span class="keyword">functions</span></span> test_bf

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹One can see a trace of the calls to the memory in the output›</span></span>
<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹Test.test_bf <span class="main">(</span><span class="main">)</span>›</span>

<span class="keyword1" id="Bellman_Ford-bottom_up_alt"><span class="command">lemma</span></span> bottom_up_alt<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"bf <span class="free">n</span> <span class="free">W</span> <span class="free">t</span> <span class="free">i</span> <span class="free">j</span> <span class="main">=</span>
     fst <span class="main">(</span>run_state
      <span class="main">(</span>iter_bf <span class="free">n</span> <span class="free">W</span> <span class="free">t</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="main">0</span><span class="main">)</span> <span class="main">⤜</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> bf<span class="hidden">⇩</span><sub>m</sub>' <span class="free">n</span> <span class="free">W</span> <span class="free">t</span> <span class="free">i</span> <span class="free">j</span><span class="main">)</span><span class="main">)</span>
      Mapping.empty<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> bf_bottom_up <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">bf_ia</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">W</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">W'</span> <span class="main">=</span> graph_of <span class="main">(</span>IArray <span class="free"><span class="bound"><span class="entity">W</span></span></span><span class="main">)</span> <span class="keyword1">in</span>
    fst <span class="main">(</span>run_state
      <span class="main">(</span>iter_bf <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="bound">W'</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">)</span> <span class="main">⤜</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> bf<span class="hidden">⇩</span><sub>m</sub>' <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="bound">W'</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">)</span><span class="main">)</span>
      Mapping.empty<span class="main">)</span>
  <span class="main">)</span>"</span></span>

<span class="comment1">― ‹Component tests.›</span>
<span class="keyword1"><span class="command">lemma</span></span>
  <span class="quoted"><span class="quoted">"fst <span class="main">(</span>run_state <span class="main">(</span>bf<span class="hidden">⇩</span><sub>m</sub>' <span class="numeral">3</span> <span class="main">(</span>graph_of <span class="main">(</span>IArray G<span class="hidden">⇩</span><sub>1</sub>_list<span class="main">)</span><span class="main">)</span> <span class="numeral">3</span> <span class="numeral">3</span> <span class="main">0</span><span class="main">)</span> Mapping.empty<span class="main">)</span> <span class="main">=</span> <span class="numeral">4</span>"</span></span>
  <span class="quoted"><span class="quoted">"bf <span class="numeral">3</span> <span class="main">(</span>graph_of <span class="main">(</span>IArray G<span class="hidden">⇩</span><sub>1</sub>_list<span class="main">)</span><span class="main">)</span> <span class="numeral">3</span> <span class="numeral">3</span> <span class="main">0</span> <span class="main">=</span> <span class="numeral">4</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span><span class="main"><span class="keyword3">+</span></span>

<span class="comment1">― ‹Regular test cases.›</span>
<span class="keyword1"><span class="command">lemma</span></span>
  <span class="quoted"><span class="quoted">"fst <span class="main">(</span>run_state <span class="main">(</span>bellman_ford <span class="numeral">3</span> <span class="main">(</span>graph_of <span class="main">(</span>IArray G<span class="hidden">⇩</span><sub>1</sub>_list<span class="main">)</span><span class="main">)</span> <span class="numeral">3</span><span class="main">)</span> Mapping.empty<span class="main">)</span> <span class="main">=</span> Some <span class="main">[</span><span class="numeral">4</span><span class="main">,</span> <span class="numeral">10</span><span class="main">,</span> <span class="numeral">2</span><span class="main">,</span> <span class="main">0</span><span class="main">]</span>"</span></span>
  <span class="quoted"><span class="quoted">"fst <span class="main">(</span>run_state <span class="main">(</span>bellman_ford <span class="numeral">4</span> <span class="main">(</span>graph_of <span class="main">(</span>IArray G<span class="hidden">⇩</span><sub>3</sub>_list<span class="main">)</span><span class="main">)</span> <span class="numeral">4</span><span class="main">)</span> Mapping.empty<span class="main">)</span> <span class="main">=</span> Some <span class="main">[</span><span class="numeral">4</span><span class="main">,</span> <span class="numeral">5</span><span class="main">,</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">1</span><span class="main">,</span> <span class="main">0</span><span class="main">]</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span><span class="main"><span class="keyword3">+</span></span>

<span class="comment1">― ‹Test detection of negative cycles.›</span>
<span class="keyword1"><span class="command">lemma</span></span>
  <span class="quoted"><span class="quoted">"fst <span class="main">(</span>run_state <span class="main">(</span>bellman_ford <span class="numeral">3</span> <span class="main">(</span>graph_of <span class="main">(</span>IArray G<span class="hidden">⇩</span><sub>2</sub>_list<span class="main">)</span><span class="main">)</span> <span class="numeral">3</span><span class="main">)</span> Mapping.empty<span class="main">)</span> <span class="main">=</span> None"</span></span>
  <span class="quoted"><span class="quoted">"fst <span class="main">(</span>run_state <span class="main">(</span>bellman_ford <span class="numeral">4</span> <span class="main">(</span>graph_of <span class="main">(</span>IArray G<span class="hidden">⇩</span><sub>4</sub>_list<span class="main">)</span><span class="main">)</span> <span class="numeral">4</span><span class="main">)</span> Mapping.empty<span class="main">)</span> <span class="main">=</span> None"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Theory *)</span></pre>
</div><div id="Heap_Default">
<div class="head">
<h1>Theory Heap_Default</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> Heap_Default
  <span class="keyword2"><span class="keyword">imports</span></span>
    <a href="#Heap_Main">Heap_Main</a>
    <span class="quoted">"<a href="#Index">../Index</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">locale</span></span> dp_consistency_heap_default <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">bound</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span> <span class="main">::</span> <span class="main">{</span>index<span class="main">,</span> heap<span class="main">}</span> bound"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">mem</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span><span class="main">::</span>heap option array"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">dp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'v</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> idx<span class="main">:</span> bounded_index <span class="quoted"><span class="free">bound</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> dp_consistency_heap
  <span class="keyword2"><span class="keyword">where</span></span> P<span class="main">=</span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">heap</span><span class="main">.</span> Array.length <span class="bound">heap</span> <span class="free">mem</span> <span class="main">=</span> idx.size"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> lookup<span class="main">=</span><span class="quoted"><span class="quoted">"mem_lookup idx.size idx.checked_idx <span class="free">mem</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> update<span class="main">=</span><span class="quoted"><span class="quoted">"mem_update idx.size idx.checked_idx <span class="free">mem</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> dp_consistency_heap.intro<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> mem_heap_correct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> idx.checked_idx_injective<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">empty</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> empty<span class="main">:</span> <span class="quoted"><span class="quoted">"map_of_heap <span class="free">empty</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> Map.empty"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> len<span class="main">:</span> <span class="quoted"><span class="quoted">"Array.length <span class="free">empty</span> <span class="free">mem</span> <span class="main">=</span> idx.size"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> consistent<span class="main">:</span> dp_consistency_heap_empty
  <span class="keyword2"><span class="keyword">where</span></span> P<span class="main">=</span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">heap</span><span class="main">.</span> Array.length <span class="bound">heap</span> <span class="free">mem</span> <span class="main">=</span> idx.size"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> lookup<span class="main">=</span><span class="quoted"><span class="quoted">"mem_lookup idx.size idx.checked_idx <span class="free">mem</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> update<span class="main">=</span><span class="quoted"><span class="quoted">"mem_update idx.size idx.checked_idx <span class="free">mem</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">rule</span> len empty<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> memoizedI <span class="main">=</span> consistent.memoized
<span class="keyword1"><span class="command">lemmas</span></span> successI <span class="main">=</span> consistent.memoized_success

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Heap_Default-mem_empty_empty"><span class="command">lemma</span></span> mem_empty_empty<span class="main">:</span>
  <span class="quoted"><span class="quoted">"map_of_heap <span class="main">(</span>heap_of <span class="main">(</span>mem_empty idx.size <span class="main">::</span> <span class="tfree">'v</span> option array Heap<span class="main">)</span> Heap.empty<span class="main">)</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> Map.empty"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">mem</span> <span class="main">=</span> result_of <span class="main">(</span>mem_empty idx.size<span class="main">)</span> Heap.empty"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> map_emptyI <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>
      that length_mem_empty Let_def nth_mem_empty mem_lookup_def heap_mem_defs.map_of_heap_def
      <span class="main">)</span>

<span class="keyword1" id="Heap_Default-memoized_empty"><span class="command">lemma</span></span> memoized_empty<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">dp</span> <span class="free">x</span> <span class="main">=</span> result_of <span class="main">(</span><span class="main">(</span>mem_empty idx.size <span class="main">::</span> <span class="tfree">'v</span> option array Heap<span class="main">)</span> <span class="main">⤜</span> <span class="main">(</span><span class="main">λ</span><span class="bound">mem</span><span class="main">.</span> <span class="free">dp<span class="hidden">⇩</span><sub>T</sub></span> <span class="bound">mem</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span> Heap.empty"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"consistentDP <span class="main">(</span><span class="free">dp<span class="hidden">⇩</span><sub>T</sub></span> <span class="free">mem</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">mem</span> <span class="main">=</span> result_of <span class="main">(</span>mem_empty idx.size<span class="main">)</span> Heap.empty"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> execute_bind_success<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> memoizedI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ _ that<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> mem_empty_empty<span class="main">[</span><span class="operator">OF</span> that<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> that<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> length_mem_empty<span class="main">)</span>

<span class="keyword1" id="Heap_Default-init_success"><span class="command">lemma</span></span> init_success<span class="main">:</span>
  <span class="quoted"><span class="quoted">"success <span class="main">(</span><span class="main">(</span>mem_empty idx.size <span class="main">::</span> <span class="tfree">'v</span> option array Heap<span class="main">)</span> <span class="main">⤜</span> <span class="main">(</span><span class="main">λ</span><span class="bound">mem</span><span class="main">.</span> <span class="free">dp<span class="hidden">⇩</span><sub>T</sub></span> <span class="bound">mem</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span> Heap.empty"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"consistentDP <span class="main">(</span><span class="free">dp<span class="hidden">⇩</span><sub>T</sub></span> <span class="free">mem</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">mem</span> <span class="main">=</span> result_of <span class="main">(</span>mem_empty idx.size<span class="main">)</span> Heap.empty"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> success_bind_I<span class="main"><span class="main">[</span></span><span class="operator">OF</span> success_empty<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> execute_result_ofD<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> execute_heap_ofD<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> mem_empty_empty that <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> length_mem_empty <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> successI<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Knapsack">
<div class="head">
<h1>Theory Knapsack</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The Knapsack Problem›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Knapsack
  <span class="keyword2"><span class="keyword">imports</span></span>
    <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/Code_Target_Numeral.html">HOL-Library.Code_Target_Numeral</a>"</span>
    <span class="quoted">"<a href="#State_Main">../state_monad/State_Main</a>"</span> 
    <span class="quoted">"<a href="#Heap_Default">../heap_monad/Heap_Default</a>"</span>
    <a href="#Example_Misc">Example_Misc</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Definitions›</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="comment1">(* Subset Sum *)</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">w</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="comment1">(* Knapsack *)</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">v</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">knapsack</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">knapsack</span> <span class="main">0</span> <span class="free"><span class="bound"><span class="entity">W</span></span></span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">knapsack</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">W</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">W</span></span></span> <span class="main">&lt;</span> <span class="free">w</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span>
    <span class="keyword1">then</span> <span class="free">knapsack</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">W</span></span></span>
    <span class="keyword1">else</span> max <span class="main">(</span><span class="free">knapsack</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">W</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free">v</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="main">+</span> <span class="free">knapsack</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">W</span></span></span> <span class="main">-</span> <span class="free">w</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">no_notation</span></span> fun_app_lifted <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">.</span>"</span> 999<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The correctness proof closely follows Kleinberg <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>&amp;›</span></span></span></span> Tardos: "Algorithm Design",
  chapter "Dynamic Programming" <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> "Kleinberg-Tardos"<span class="antiquote"><span class="antiquote">}</span></span></span></span>
›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">OPT</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">W</span></span></span> <span class="main">=</span> Max <span class="main">{</span><span class="main">∑</span> <span class="bound">i</span> <span class="main">∈</span> <span class="bound">S</span><span class="main">.</span> <span class="free">v</span> <span class="bound">i</span> <span class="main">|</span> <span class="bound">S</span><span class="main">.</span> <span class="bound">S</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">1</span><span class="main">..</span><span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">}</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∑</span> <span class="bound">i</span> <span class="main">∈</span> <span class="bound">S</span><span class="main">.</span> <span class="free">w</span> <span class="bound">i</span><span class="main">)</span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">W</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1" id="Knapsack-OPT_0"><span class="command">lemma</span></span> OPT_0<span class="main">:</span>
  <span class="quoted"><span class="quoted">"OPT <span class="main">0</span> <span class="free">W</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> OPT_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Functional Correctness›</span></span>

<span class="keyword1" id="Knapsack-Max_add_left"><span class="command">lemma</span></span> Max_add_left<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">::</span> nat<span class="main">)</span> <span class="main">+</span> Max <span class="free">S</span> <span class="main">=</span> Max <span class="main">(</span><span class="main">(</span><span class="main">(+)</span> <span class="free">x</span><span class="main">)</span> <span class="main">`</span> <span class="free">S</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?A</span> <span class="main">=</span> <span class="var">?B</span>"</span></span><span class="main">)</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">S</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">S</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?A</span> <span class="main">≤</span> <span class="var">?B</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> Min.boundedI<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?B</span> <span class="main">≤</span> <span class="var">?A</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> Min.boundedI<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Knapsack-OPT_Suc"><span class="command">lemma</span></span> OPT_Suc<span class="main">:</span>
  <span class="quoted"><span class="quoted">"OPT <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="free">W</span> <span class="main">=</span> <span class="main">(</span>
    <span class="keyword1">if</span> <span class="free">W</span> <span class="main">&lt;</span> <span class="free">w</span> <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span>
    <span class="keyword1">then</span> OPT <span class="free">i</span> <span class="free">W</span>
    <span class="keyword1">else</span> max<span class="main">(</span><span class="free">v</span> <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="main">+</span> OPT <span class="free">i</span> <span class="main">(</span><span class="free">W</span> <span class="main">-</span> <span class="free">w</span> <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>OPT <span class="free">i</span> <span class="free">W</span><span class="main">)</span>
  <span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> OPT_in<span class="main">:</span> <span class="quoted"><span class="quoted">"OPT <span class="skolem">n</span> <span class="skolem">W</span> <span class="main">∈</span> <span class="main">{</span><span class="main">∑</span> <span class="bound">i</span> <span class="main">∈</span> <span class="bound">S</span><span class="main">.</span> <span class="free">v</span> <span class="bound">i</span> <span class="main">|</span> <span class="bound">S</span><span class="main">.</span> <span class="bound">S</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">1</span><span class="main">..</span><span class="skolem">n</span><span class="main">}</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∑</span> <span class="bound">i</span> <span class="main">∈</span> <span class="bound">S</span><span class="main">.</span> <span class="free">w</span> <span class="bound">i</span><span class="main">)</span> <span class="main">≤</span> <span class="skolem">W</span><span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">n</span> <span class="skolem">W</span>
    <span class="keyword1"><span class="command">unfolding</span></span> OPT_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> Max_in<span class="main"><span class="keyword3">;</span></span> <span class="operator">force</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> OPT_in<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"Suc <span class="free">i</span>"</span></span> <span class="quoted"><span class="free">W</span></span><span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">S</span></span> <span class="keyword2"><span class="keyword">where</span></span> S<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="skolem">S</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">1</span><span class="main">..</span>Suc <span class="free">i</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"sum <span class="free">w</span> <span class="skolem">S</span> <span class="main">≤</span> <span class="free">W</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"OPT <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="free">W</span> <span class="main">=</span> sum <span class="free">v</span> <span class="skolem">S</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"OPT <span class="free">i</span> <span class="free">W</span> <span class="main">≤</span> OPT <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="free">W</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> OPT_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> Max_mono<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="main">+</span> OPT <span class="free">i</span> <span class="main">(</span><span class="free">W</span> <span class="main">-</span> <span class="free">w</span> <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> OPT <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="free">W</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="main">≤</span> <span class="free">W</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"
      <span class="free">v</span> <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="main">+</span> sum <span class="free">v</span> <span class="skolem">S</span> <span class="main">=</span> sum <span class="free">v</span> <span class="main">(</span><span class="skolem">S</span> <span class="main">∪</span> <span class="main">{</span>Suc <span class="free">i</span><span class="main">}</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="skolem">S</span> <span class="main">∪</span> <span class="main">{</span>Suc <span class="free">i</span><span class="main">}</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">1</span><span class="main">..</span>Suc <span class="free">i</span><span class="main">}</span>
      <span class="main">∧</span> sum <span class="free">w</span> <span class="main">(</span><span class="skolem">S</span> <span class="main">∪</span> <span class="main">{</span>Suc <span class="free">i</span><span class="main">}</span><span class="main">)</span> <span class="main">≤</span> <span class="free">W</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">S</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">1</span><span class="main">..</span><span class="free">i</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"sum <span class="free">w</span> <span class="skolem">S</span> <span class="main">≤</span> <span class="free">W</span> <span class="main">-</span> <span class="free">w</span> <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">S</span>
      <span class="keyword1"><span class="command">using</span></span> that <span class="quoted"><span class="quoted">‹<span class="free">w</span> <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="main">≤</span> <span class="free">W</span>›</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> sum.insert_if <span class="main"><span class="keyword3">|</span></span> <span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_subset<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ finite_atLeastAtMost<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> OPT_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> Max_add_left<span class="main"><span class="keyword3">;</span></span>
          <span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> Max_mono finite_subset<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ finite_atLeastAtMost<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> *
         <span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">≥</span> <span class="var">?rhs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">from</span></span> S <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"sum <span class="free">v</span> <span class="skolem">S</span> <span class="main">≤</span> OPT <span class="free">i</span> <span class="free">W</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"Suc <span class="free">i</span> <span class="main">∉</span> <span class="skolem">S</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> OPT_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> atLeastAtMostSuc_conv <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Max_ge<span class="main">)</span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"sum <span class="free">v</span> <span class="skolem">S</span> <span class="main">≤</span> OPT <span class="free">i</span> <span class="free">W</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">W</span> <span class="main">&lt;</span> <span class="free">w</span> <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> *<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> ccontr<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"Suc <span class="free">i</span> <span class="main">∈</span> <span class="skolem">S</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"sum <span class="free">w</span> <span class="skolem">S</span> <span class="main">≥</span> <span class="free">w</span> <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> S<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> sum.remove<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_subset<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ finite_atLeastAtMost<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="free">W</span> <span class="main">&lt;</span> <span class="main">_</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">_</span> <span class="main">≤</span> <span class="free">W</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span>
    <span class="quoted"><span class="quoted">"OPT <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="free">W</span> <span class="main">≤</span> max<span class="main">(</span><span class="free">v</span> <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="main">+</span> OPT <span class="free">i</span> <span class="main">(</span><span class="free">W</span> <span class="main">-</span> <span class="free">w</span> <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>OPT <span class="free">i</span> <span class="free">W</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="main">≤</span> <span class="free">W</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"Suc <span class="free">i</span> <span class="main">∈</span> <span class="skolem">S</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
      <span class="quoted"><span class="quoted">"sum <span class="free">v</span> <span class="skolem">S</span> <span class="main">=</span> <span class="free">v</span> <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="main">+</span> sum <span class="free">v</span> <span class="main">(</span><span class="skolem">S</span> <span class="main">-</span> <span class="main">{</span>Suc <span class="free">i</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"sum <span class="free">w</span> <span class="skolem">S</span> <span class="main">=</span> <span class="free">w</span> <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="main">+</span> sum <span class="free">w</span> <span class="main">(</span><span class="skolem">S</span> <span class="main">-</span> <span class="main">{</span>Suc <span class="free">i</span><span class="main">}</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> S<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_subset<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ finite_atLeastAtMost<span class="main"><span class="main">]</span></span> sum.remove<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"OPT <span class="free">i</span> <span class="main">(</span><span class="free">W</span> <span class="main">-</span> <span class="free">w</span> <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span><span class="main">)</span> <span class="main">≥</span> sum <span class="free">v</span> <span class="main">(</span><span class="skolem">S</span> <span class="main">-</span> <span class="main">{</span>Suc <span class="free">i</span><span class="main">}</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> OPT_def <span class="keyword1"><span class="command">using</span></span> S <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Max_ge<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> *<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">≤</span> <span class="var">?rhs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?lhs</span> <span class="main">≥</span> <span class="var">?rhs</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> knapsack_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"OPT <span class="free">n</span> <span class="free">W</span> <span class="main">=</span> knapsack <span class="free">n</span> <span class="free">W</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">W</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> OPT_0 OPT_Suc<span class="main">)</span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Functional Memoization›</span></span>

<span class="keyword1"><span class="command">memoize_fun</span></span> knapsack<span class="hidden">⇩</span><sub>m</sub><span class="main">:</span> <span class="quoted">knapsack</span> <span class="keyword2"><span class="keyword">with_memory</span></span> dp_consistency_mapping <span class="keyword1"><span class="command">monadifies</span></span> <span class="main">(</span>state<span class="main">)</span> knapsack.simps

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Generated Definitions›</span></span>
<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> state_monad_syntax <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">thm</span></span> knapsack<span class="hidden">⇩</span><sub>m</sub>'.simps knapsack<span class="hidden">⇩</span><sub>m</sub>_def
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Correspondence Proof›</span></span>
<span class="keyword1"><span class="command">memoize_correct</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">memoize_prover</span>
<span class="keyword1"><span class="command">print_theorems</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> knapsack<span class="hidden">⇩</span><sub>m</sub>.memoized_correct


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Imperative Memoization›</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">fixes</span></span>
  <span class="free">mem</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat option array"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">n</span> <span class="free">W</span> <span class="main">::</span> <span class="quoted">nat</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">memoize_fun</span></span> knapsack<span class="hidden">⇩</span><sub>T</sub><span class="main">:</span> <span class="quoted">knapsack</span>
  <span class="keyword2"><span class="keyword">with_memory</span></span> dp_consistency_heap_default <span class="keyword2"><span class="keyword">where</span></span> bound <span class="main">=</span> <span class="quoted"><span class="quoted">"Bound <span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="main">0</span><span class="main">)</span> <span class="main">(</span><span class="free">n</span><span class="main">,</span> <span class="free">W</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> mem<span class="main">=</span><span class="quoted"><span class="quoted">"<span class="free">mem</span>"</span></span>
  <span class="keyword1"><span class="command">monadifies</span></span> <span class="main">(</span>heap<span class="main">)</span> knapsack.simps

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> heap_monad_syntax <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">thm</span></span> knapsack<span class="hidden">⇩</span><sub>T</sub>'.simps knapsack<span class="hidden">⇩</span><sub>T</sub>_def
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">memoize_correct</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">memoize_prover</span>

<span class="keyword1"><span class="command">lemmas</span></span> memoized_empty <span class="main">=</span> knapsack<span class="hidden">⇩</span><sub>T</sub>.memoized_empty

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Fixed array *)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Adding Memory Initialization›</span></span>
<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">includes</span></span> heap_monad_syntax
  <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span> <span class="main">=</span> knapsack<span class="hidden">⇩</span><sub>T</sub>'.simps
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">knapsack<span class="hidden">⇩</span><sub>h</sub></span> <span class="main">≡</span> <span class="main">λ</span> <span class="bound">i</span> <span class="bound">j</span><span class="main">.</span> Heap_Monad.bind <span class="main">(</span>mem_empty <span class="main">(</span><span class="bound">i</span> <span class="main">*</span> <span class="bound">j</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">mem</span><span class="main">.</span> knapsack<span class="hidden">⇩</span><sub>T</sub>' <span class="bound">mem</span> <span class="bound">i</span> <span class="bound">j</span> <span class="bound">i</span> <span class="bound">j</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> memoized_empty' <span class="main">=</span> memoized_empty<span class="main">[</span>
      <span class="operator">of</span> <span class="quoted"><span class="free">mem</span></span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">W</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">m</span><span class="main">.</span> <span class="main">λ</span><span class="main">(</span><span class="bound">i</span><span class="main">,</span><span class="bound">j</span><span class="main">)</span><span class="main">.</span> knapsack<span class="hidden">⇩</span><sub>T</sub>' <span class="bound">m</span> <span class="free">n</span> <span class="free">W</span> <span class="bound">i</span> <span class="bound">j</span>"</span></span><span class="main">,</span>
      <span class="operator">OF</span> knapsack<span class="hidden">⇩</span><sub>T</sub>.crel<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">mem</span></span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">W</span></span><span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">n</span><span class="main">,</span> <span class="free">W</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">for</span></span></span> <span class="free">mem</span> <span class="free">n</span> <span class="free">W</span>
    <span class="main">]</span>

<span class="keyword1" id="Knapsack-knapsack_heap"><span class="command">lemma</span></span> knapsack_heap<span class="main">:</span>
  <span class="quoted"><span class="quoted">"knapsack <span class="free">n</span> <span class="free">W</span> <span class="main">=</span> result_of <span class="main">(</span>knapsack<span class="hidden">⇩</span><sub>h</sub> <span class="free">n</span> <span class="free">W</span><span class="main">)</span> Heap.empty"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> knapsack<span class="hidden">⇩</span><sub>h</sub>_def <span class="keyword1"><span class="command">using</span></span> memoized_empty'<span class="main">[</span><span class="operator">of</span> <span class="main">_</span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">W</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> index_size_defs<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Knapsack *)</span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">su</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">su</span> <span class="main">0</span> <span class="free"><span class="bound"><span class="entity">W</span></span></span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">su</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">W</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">W</span></span></span> <span class="main">&lt;</span> <span class="free">w</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span>
    <span class="keyword1">then</span> <span class="free">su</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">W</span></span></span>
    <span class="keyword1">else</span> max <span class="main">(</span><span class="free">su</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">W</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free">w</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="main">+</span> <span class="free">su</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">W</span></span></span> <span class="main">-</span> <span class="free">w</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Knapsack-su_knapsack"><span class="command">lemma</span></span> su_knapsack<span class="main">:</span>
  <span class="quoted"><span class="quoted">"su <span class="free">n</span> <span class="free">W</span> <span class="main">=</span> knapsack <span class="free">w</span> <span class="free">n</span> <span class="free">W</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">W</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Knapsack-su_correct"><span class="command">lemma</span></span> su_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Max <span class="main">{</span><span class="main">∑</span> <span class="bound">i</span> <span class="main">∈</span> <span class="bound">S</span><span class="main">.</span> <span class="free">w</span> <span class="bound">i</span> <span class="main">|</span> <span class="bound">S</span><span class="main">.</span> <span class="bound">S</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">1</span><span class="main">..</span><span class="free">n</span><span class="main">}</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∑</span> <span class="bound">i</span> <span class="main">∈</span> <span class="bound">S</span><span class="main">.</span> <span class="free">w</span> <span class="bound">i</span><span class="main">)</span> <span class="main">≤</span> <span class="free">W</span><span class="main">}</span> <span class="main">=</span> su <span class="free">n</span> <span class="free">W</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> su_knapsack knapsack_correct<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> OPT_def <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Memoization›</span></span>

<span class="keyword1"><span class="command">memoize_fun</span></span> su<span class="hidden">⇩</span><sub>m</sub><span class="main">:</span> <span class="quoted">su</span> <span class="keyword2"><span class="keyword">with_memory</span></span> dp_consistency_mapping <span class="keyword1"><span class="command">monadifies</span></span> <span class="main">(</span>state<span class="main">)</span> su.simps

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Generated Definitions›</span></span>
<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> state_monad_syntax <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">thm</span></span> su<span class="hidden">⇩</span><sub>m</sub>'.simps su<span class="hidden">⇩</span><sub>m</sub>_def
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Correspondence Proof›</span></span>
<span class="keyword1"><span class="command">memoize_correct</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">memoize_prover</span>
<span class="keyword1"><span class="command">print_theorems</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> su<span class="hidden">⇩</span><sub>m</sub>.memoized_correct

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Subset Sum *)</span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Regression Test›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">knapsack_test</span> <span class="main">=</span> <span class="main">(</span>knapsack<span class="hidden">⇩</span><sub>h</sub> <span class="main">(</span><span class="main">λ</span> <span class="bound">i</span><span class="main">.</span> <span class="main">[</span><span class="numeral">2</span><span class="main">,</span><span class="numeral">3</span><span class="main">,</span><span class="numeral">4</span><span class="main">]</span> <span class="main">!</span> <span class="main">(</span><span class="bound">i</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">i</span><span class="main">.</span> <span class="main">[</span><span class="numeral">2</span><span class="main">,</span><span class="numeral">3</span><span class="main">,</span><span class="numeral">4</span><span class="main">]</span> <span class="main">!</span> <span class="main">(</span><span class="bound">i</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span> <span class="numeral">3</span> <span class="numeral">8</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">code_reflect</span></span> Test <span class="keyword2"><span class="keyword">functions</span></span> knapsack_test

<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹Test.knapsack_test <span class="main">(</span><span class="main">)</span>›</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Theory *)</span>
</pre>
</div><div id="Counting_Tiles">
<div class="head">
<h1>Theory Counting_Tiles</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> Counting_Tiles
  <span class="keyword2"><span class="keyword">imports</span></span>
    <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/Code_Target_Numeral.html">HOL-Library.Code_Target_Numeral</a>"</span>
    <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/Product_Lexorder.html">HOL-Library.Product_Lexorder</a>"</span>
    <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/RBT_Mapping.html">HOL-Library.RBT_Mapping</a>"</span>
    <span class="quoted">"<a href="#State_Main">../state_monad/State_Main</a>"</span> 
    <a href="#Example_Misc">Example_Misc</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹A Counting Problem›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  This formalization contains verified solutions for Project Euler problems
    <span class="antiquoted"><span class="antiquoted">▪</span></span> <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>#›</span></span></span></span>114 (<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">🌐</span></span>‹https://projecteuler.net/problem=114›</span></span>) and
    <span class="antiquoted"><span class="antiquoted">▪</span></span> <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>#›</span></span></span></span>115 (<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">🌐</span></span>‹https://projecteuler.net/problem=115›</span></span>).

  This is the problem description for <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>#›</span></span></span></span>115:
  \begin{quote}
  A row measuring n units in length has red blocks with a minimum length of m units placed on it,
  such that any two red blocks (which are allowed to be different lengths) are separated
  by at least one black square.
  Let the fill-count function, F(m, n), represent the number of ways that a row can be filled.

  For example, F(3, 29) = 673135 and F(3, 30) = 1089155.

  That is, for m = 3, it can be seen that n = 30 is the smallest value for which the fill-count
  function first exceeds one million.
  In the same way, for m = 10, it can be verified that F(10, 56) = 880711 and F(10, 57) = 1148904,
  so n = 57 is the least value for which the fill-count function first exceeds one million.

  For m = 50, find the least value of n for which the fill-count function first exceeds one million.
  \end{quote}
›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Misc›</span></span>

<span class="comment1">(* Duplicate from Refine_Misc with slightly nicer proof *)</span>
<span class="keyword1" id="Counting_Tiles-lists_of_len_fin1"><span class="command">lemma</span></span> lists_of_len_fin1<span class="main">:</span>
  <span class="quoted"><span class="quoted">"finite <span class="main">(</span>lists <span class="free">A</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">l</span><span class="main">.</span> length <span class="bound">l</span> <span class="main">=</span> <span class="free">n</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lists <span class="free">A</span> <span class="main">∩</span> <span class="main">{</span> <span class="bound">l</span><span class="main">.</span> length <span class="bound">l</span> <span class="main">=</span> Suc <span class="skolem">n</span> <span class="main">}</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span><span class="main">.</span> <span class="bound">a</span><span class="main">#</span><span class="bound">l</span><span class="main">)</span> <span class="main">`</span> <span class="main">(</span><span class="free">A</span> <span class="main">×</span> <span class="main">(</span>lists <span class="free">A</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">l</span><span class="main">.</span> length <span class="bound">l</span> <span class="main">=</span> <span class="skolem">n</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> length_Suc_conv<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> Suc <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">…</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="comment1">(* Duplicate from Refine_Misc *)</span>
<span class="keyword1" id="Counting_Tiles-disjE1"><span class="command">lemma</span></span> disjE1<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">∨</span> <span class="free">B</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">A</span> <span class="main">⟹</span> <span class="free">P</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">¬</span> <span class="free">A</span> <span class="main">⟹</span> <span class="free">B</span> <span class="main">⟹</span> <span class="free">P</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">P</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Problem Specification›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Colors›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> color <span class="main">=</span> R <span class="main">|</span> B

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Direct natural definition of a valid line›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">m</span> <span class="main">::</span> <span class="quoted">nat</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">inductive</span></span> <span class="entity">valid</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">valid</span> <span class="main">[]</span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">valid</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">⟹</span> <span class="free">valid</span> <span class="main">(</span>B <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">valid</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">⟹</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">≥</span> <span class="free">m</span> <span class="main">⟹</span> <span class="free">valid</span> <span class="main">(</span>replicate <span class="free"><span class="bound"><span class="entity">n</span></span></span> R <span class="main">@</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Definition of the fill-count function›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">F</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> card <span class="main">{</span><span class="bound">l</span><span class="main">.</span> length <span class="bound">l</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">∧</span> valid <span class="bound">l</span><span class="main">}</span>"</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Combinatorial Identities›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This alternative variant helps us to prove the split lemma below.›</span></span>
<span class="keyword1"><span class="command">inductive</span></span> <span class="entity">valid'</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">valid'</span> <span class="main">[]</span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">≥</span> <span class="free">m</span> <span class="main">⟹</span> <span class="free">valid'</span> <span class="main">(</span>replicate <span class="free"><span class="bound"><span class="entity">n</span></span></span> R<span class="main">)</span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">valid'</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">⟹</span> <span class="free">valid'</span> <span class="main">(</span>B <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">valid'</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">⟹</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">≥</span> <span class="free">m</span> <span class="main">⟹</span> <span class="free">valid'</span> <span class="main">(</span>replicate <span class="free"><span class="bound"><span class="entity">n</span></span></span> R <span class="main">@</span> B <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Counting_Tiles-valid_valid'"><span class="command">lemma</span></span> valid_valid'<span class="main">:</span>
  <span class="quoted"><span class="quoted">"valid <span class="free">l</span> <span class="main">⟹</span> valid' <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> valid.induct<span class="main">)</span>
     <span class="main">(</span><span class="operator">auto</span> 4 4 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> valid'.intros <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> valid'.cases
       <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> replicate_add<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> append_assoc<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span>
     <span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> valid_red <span class="main">=</span> valid.intros<span class="main">(</span>3<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> valid.intros<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>

<span class="keyword1" id="Counting_Tiles-valid'_valid"><span class="command">lemma</span></span> valid'_valid<span class="main">:</span>
  <span class="quoted"><span class="quoted">"valid' <span class="free">l</span> <span class="main">⟹</span> valid <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> valid'.induct<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> valid.intros valid_red<span class="main">)</span>

<span class="keyword1" id="Counting_Tiles-valid_eq_valid'"><span class="command">lemma</span></span> valid_eq_valid'<span class="main">:</span>
  <span class="quoted"><span class="quoted">"valid' <span class="free">l</span> <span class="main">=</span> valid <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> valid_valid' valid'_valid <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Additional Facts on Replicate›</span></span>

<span class="keyword1" id="Counting_Tiles-replicate_iff"><span class="command">lemma</span></span> replicate_iff<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span>length <span class="free">l</span><span class="main">.</span> <span class="free">l</span> <span class="main">!</span> <span class="bound">i</span> <span class="main">=</span> R<span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">n</span><span class="main">.</span> <span class="free">l</span> <span class="main">=</span> replicate <span class="bound">n</span> R<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>full_types<span class="main"><span class="main">)</span></span> in_set_conv_nth replicate_eqI<span class="main">)</span>

<span class="keyword1" id="Counting_Tiles-replicate_iff2"><span class="command">lemma</span></span> replicate_iff2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span><span class="free">n</span><span class="main">.</span> <span class="free">l</span> <span class="main">!</span> <span class="bound">i</span> <span class="main">=</span> R<span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">l'</span><span class="main">.</span> <span class="free">l</span> <span class="main">=</span> replicate <span class="free">n</span> R <span class="main">@</span> <span class="bound">l'</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> list_eq_iff_nth_eq nth_append <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted">"drop <span class="free">n</span> <span class="free">l</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Counting_Tiles-replicate_Cons_eq"><span class="command">lemma</span></span> replicate_Cons_eq<span class="main">:</span>
  <span class="quoted"><span class="quoted">"replicate <span class="free">n</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span> <span class="main">#</span> <span class="free">ys</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">n'</span><span class="main">.</span> <span class="free">n</span> <span class="main">=</span> Suc <span class="bound">n'</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span> <span class="main">∧</span> replicate <span class="bound">n'</span> <span class="free">x</span> <span class="main">=</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span> <span class="operator">auto</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Main Case Analysis on <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>@term valid›</span></span></span></span>›</span></span>

<span class="keyword1" id="Counting_Tiles-valid_split"><span class="command">lemma</span></span> valid_split<span class="main">:</span>
  <span class="quoted"><span class="quoted">"valid <span class="free">l</span> <span class="main">⟷</span>
    <span class="free">l</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">∨</span>
    <span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="main">0</span> <span class="main">=</span> B <span class="main">∧</span> valid <span class="main">(</span>tl <span class="free">l</span><span class="main">)</span><span class="main">)</span> <span class="main">∨</span>
    length <span class="free">l</span> <span class="main">≥</span> <span class="free">m</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span> <span class="bound"><span class="bound">i</span></span> <span class="main">&lt;</span> length <span class="free">l</span><span class="main">.</span> <span class="free">l</span> <span class="main">!</span> <span class="bound">i</span> <span class="main">=</span> R<span class="main">)</span> <span class="main">∨</span>
    <span class="main">(</span><span class="main">∃</span> <span class="bound"><span class="bound">j</span></span> <span class="main">&lt;</span> length <span class="free">l</span><span class="main">.</span> <span class="bound">j</span> <span class="main">≥</span> <span class="free">m</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span> <span class="bound"><span class="bound">i</span></span> <span class="main">&lt;</span> <span class="bound">j</span><span class="main">.</span> <span class="free">l</span> <span class="main">!</span> <span class="bound">i</span> <span class="main">=</span> R<span class="main">)</span> <span class="main">∧</span> <span class="free">l</span> <span class="main">!</span> <span class="bound">j</span> <span class="main">=</span> B <span class="main">∧</span> valid <span class="main">(</span>drop <span class="main">(</span><span class="bound">j</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="free">l</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> valid_eq_valid'<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">erule</span> valid'.cases<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nth_append nth_Cons <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> nat.splits<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> valid'.intros <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> replicate_iff <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> disjE1<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> valid'.intros <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> neq_Nil_conv<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> replicate_iff2<span class="main"><span class="keyword3">;</span></span> <span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> valid'.intros <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> neq_Nil_conv nth_append<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Base cases›</span></span>

<span class="keyword1" id="Counting_Tiles-valid_line_just_B"><span class="command">lemma</span></span> valid_line_just_B<span class="main">:</span>
  <span class="quoted"><span class="quoted">"valid <span class="main">(</span>replicate <span class="free">n</span> B<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> valid.intros<span class="main">)</span>

<span class="keyword1" id="Counting_Tiles-F_base_0_aux"><span class="command">lemma</span></span> F_base_0_aux<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">l</span><span class="main">.</span> <span class="bound">l</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">∧</span> valid <span class="bound">l</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="main">[]</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> valid.intros<span class="main">)</span>

<span class="keyword1" id="Counting_Tiles-F_base_0"><span class="command">lemma</span></span> F_base_0<span class="main">:</span> <span class="quoted"><span class="quoted">"F <span class="main">0</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> F_base_0_aux F_def<span class="main">)</span>

<span class="keyword1" id="Counting_Tiles-F_base_aux"><span class="command">lemma</span></span> F_base_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">l</span><span class="main">.</span> length <span class="bound">l</span><span class="main">=</span><span class="free">n</span> <span class="main">∧</span> valid <span class="bound">l</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span>replicate <span class="free">n</span> B<span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">&lt;</span> <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">with</span></span> Suc.prems <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> valid.intros <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> valid.cases<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">with</span></span> Suc.prems <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
      <span class="keyword1"><span class="command">using</span></span> Suc.IH
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> valid.cases<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> valid.intros <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> valid.cases<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Counting_Tiles-F_base_1"><span class="command">lemma</span></span> F_base_1<span class="main">:</span>
  <span class="quoted"><span class="quoted">"F <span class="free">n</span> <span class="main">=</span> <span class="main">1</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">&lt;</span> <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> F_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> F_base_aux<span class="main">)</span>

<span class="keyword1" id="Counting_Tiles-valid_m_Rs"><span class="command">lemma</span></span> valid_m_Rs <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"valid <span class="main">(</span>replicate <span class="free">m</span> R<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> valid_red<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">m</span></span><span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Counting_Tiles-F_base_aux_2"><span class="command">lemma</span></span> F_base_aux_2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">l</span><span class="main">.</span> length <span class="bound">l</span><span class="main">=</span><span class="free">m</span> <span class="main">∧</span> valid <span class="bound">l</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span>replicate <span class="free">m</span> R<span class="main">,</span> replicate <span class="free">m</span> B<span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_line_just_B<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> Counting_Tiles.valid.cases<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> xs
    <span class="keyword1"><span class="command">using</span></span> F_base_aux<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"length <span class="skolem">xs</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> <span class="main">[]</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Counting_Tiles-F_base_2"><span class="command">lemma</span></span> F_base_2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"F <span class="free">m</span> <span class="main">=</span> <span class="numeral">2</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> F_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> F_base_aux_2<span class="main">)</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The recursion case›</span></span>

<span class="keyword1" id="Counting_Tiles-finite_valid_length"><span class="command">lemma</span></span> finite_valid_length<span class="main">:</span>
  <span class="quoted"><span class="quoted">"finite <span class="main">{</span><span class="bound">l</span><span class="main">.</span> length <span class="bound">l</span> <span class="main">=</span> <span class="free">n</span> <span class="main">∧</span> valid <span class="bound">l</span><span class="main">}</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"finite <span class="var">?S</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?S</span> <span class="main">⊆</span> lists <span class="main">{</span>R<span class="main">,</span> B<span class="main">}</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">l</span><span class="main">.</span> length <span class="bound">l</span> <span class="main">=</span> <span class="free">n</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> color.exhaust<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">…</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> lists_of_len_fin1<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Counting_Tiles-valid_line_aux"><span class="command">lemma</span></span> valid_line_aux<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">l</span><span class="main">.</span> length <span class="bound">l</span> <span class="main">=</span> <span class="free">n</span> <span class="main">∧</span> valid <span class="bound">l</span><span class="main">}</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?S</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> valid_line_just_B<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">n</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>

<span class="keyword1" id="Counting_Tiles-replicate_unequal_aux"><span class="command">lemma</span></span> replicate_unequal_aux<span class="main">:</span>
  <span class="quoted"><span class="quoted">"replicate <span class="free">x</span> R <span class="main">@</span> B <span class="main">#</span> <span class="free">l</span> <span class="main">≠</span> replicate <span class="free">y</span> R <span class="main">@</span> B <span class="main">#</span> <span class="free">l'</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?l</span> <span class="main">≠</span> <span class="var">?r</span>"</span></span><span class="main">)</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">‹<span class="free">x</span> <span class="main">&lt;</span> <span class="free">y</span>›</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">l</span> <span class="free">l'</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?l</span> <span class="main">!</span> <span class="free">x</span> <span class="main">=</span> B"</span></span> <span class="quoted"><span class="quoted">"<span class="var">?r</span> <span class="main">!</span> <span class="free">x</span> <span class="main">=</span> R"</span></span>
    <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nth_append<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Counting_Tiles-valid_prepend_B_iff"><span class="command">lemma</span></span> valid_prepend_B_iff<span class="main">:</span>
  <span class="quoted"><span class="quoted">"valid <span class="main">(</span>B <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟷</span> valid <span class="free">xs</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> valid.intros <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> valid.cases <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Cons_replicate_eq Cons_eq_append_conv<span class="main">)</span>

<span class="keyword1" id="Counting_Tiles-F_rec"><span class="command">lemma</span></span> F_rec<span class="main">:</span> <span class="quoted"><span class="quoted">"F <span class="free">n</span> <span class="main">=</span> F <span class="main">(</span><span class="free">n</span><span class="main">-</span><span class="main">1</span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span> <span class="main">+</span> <span class="main">(</span><span class="main">∑</span><span class="bound">i</span><span class="main">=</span><span class="free">m</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">.</span> F <span class="main">(</span><span class="free">n</span><span class="main">-</span><span class="bound">i</span><span class="main">-</span><span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">‹<span class="free">n</span><span class="main">&gt;</span><span class="free">m</span>›</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">l</span><span class="main">.</span> length <span class="bound">l</span> <span class="main">=</span> <span class="free">n</span> <span class="main">∧</span> valid <span class="bound">l</span><span class="main">}</span>
          <span class="main">=</span> <span class="main">{</span><span class="bound">l</span><span class="main">.</span> length <span class="bound">l</span> <span class="main">=</span> <span class="free">n</span> <span class="main">∧</span> valid <span class="main">(</span>tl <span class="bound">l</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">l</span><span class="main">!</span><span class="main">0</span><span class="main">=</span>B<span class="main">}</span>
          <span class="main">∪</span> <span class="main">{</span><span class="bound">l</span><span class="main">.</span> length <span class="bound">l</span> <span class="main">=</span> <span class="free">n</span> <span class="main">∧</span>
              <span class="main">(</span><span class="main">∃</span> <span class="bound">i</span><span class="main">.</span> <span class="bound">i</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="main">∧</span> <span class="bound">i</span> <span class="main">≥</span> <span class="free">m</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span> <span class="bound"><span class="bound">k</span></span> <span class="main">&lt;</span> <span class="bound">i</span><span class="main">.</span> <span class="bound">l</span><span class="main">!</span><span class="bound">k</span> <span class="main">=</span> R<span class="main">)</span> <span class="main">∧</span> <span class="bound">l</span><span class="main">!</span><span class="bound">i</span> <span class="main">=</span> B <span class="main">∧</span> valid <span class="main">(</span>drop <span class="main">(</span><span class="bound">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="bound">l</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>
          <span class="main">∪</span> <span class="main">{</span><span class="bound">l</span><span class="main">.</span> length <span class="bound">l</span> <span class="main">=</span> <span class="free">n</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span><span class="free">n</span><span class="main">.</span> <span class="bound">l</span><span class="main">!</span><span class="bound">i</span><span class="main">=</span>R<span class="main">)</span><span class="main">}</span>
          "</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?A</span> <span class="main">=</span> <span class="var">?B</span> <span class="main">∪</span> <span class="var">?D</span> <span class="main">∪</span> <span class="var">?C</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">n</span> <span class="main">&gt;</span> <span class="free">m</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> valid_split<span class="main">)</span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?B1</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(#)</span> B<span class="main">)</span> <span class="main">`</span> <span class="main">{</span><span class="bound">l</span><span class="main">.</span> length <span class="bound">l</span> <span class="main">=</span> <span class="free">n</span> <span class="main">-</span> Suc <span class="main">0</span> <span class="main">∧</span> valid <span class="bound">l</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="free">n</span> <span class="main">&gt;</span> <span class="free">m</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?B</span> <span class="main">=</span> <span class="var">?B1</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> l
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">l</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_prepend_B_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"card <span class="var">?B1</span> <span class="main">=</span> F <span class="main">(</span><span class="free">n</span><span class="main">-</span><span class="main">1</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> F_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> card_image<span class="main">)</span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?C</span> <span class="main">=</span> <span class="main">{</span>replicate <span class="free">n</span> R<span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nth_equalityI<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"card <span class="main">{</span>replicate <span class="free">n</span> R<span class="main">}</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?D1</span></span></span><span class="main">=</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋃</span> <span class="bound">i</span> <span class="main">∈</span> <span class="main">{</span><span class="free">m</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">}</span><span class="main">.</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">l</span><span class="main">.</span> replicate <span class="bound">i</span> R <span class="main">@</span> B <span class="main">#</span> <span class="bound">l</span><span class="main">)</span><span class="main">`</span> <span class="main">{</span><span class="bound">l</span><span class="main">.</span> length <span class="bound">l</span> <span class="main">=</span> <span class="free">n</span> <span class="main">-</span> <span class="bound">i</span> <span class="main">-</span> <span class="main">1</span> <span class="main">∧</span> valid <span class="bound">l</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?D</span> <span class="main">=</span>
        <span class="main">(</span><span class="main">⋃</span><span class="bound">i</span> <span class="main">∈</span> <span class="main">{</span><span class="free">m</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">}</span><span class="main">.</span> <span class="main">{</span><span class="bound">l</span><span class="main">.</span> length <span class="bound">l</span> <span class="main">=</span> <span class="free">n</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span> <span class="bound"><span class="bound">k</span></span> <span class="main">&lt;</span> <span class="bound">i</span><span class="main">.</span> <span class="bound">l</span><span class="main">!</span><span class="bound">k</span> <span class="main">=</span> R<span class="main">)</span> <span class="main">∧</span> <span class="bound">l</span><span class="main">!</span><span class="bound">i</span> <span class="main">=</span> B <span class="main">∧</span> valid <span class="main">(</span>drop <span class="main">(</span><span class="bound">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="bound">l</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">l</span><span class="main">.</span> length <span class="bound">l</span> <span class="main">=</span> <span class="free">n</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span> <span class="bound"><span class="bound">k</span></span> <span class="main">&lt;</span> <span class="skolem">i</span><span class="main">.</span> <span class="bound">l</span><span class="main">!</span><span class="bound">k</span> <span class="main">=</span> R<span class="main">)</span> <span class="main">∧</span> <span class="bound">l</span><span class="main">!</span><span class="skolem">i</span> <span class="main">=</span> B <span class="main">∧</span> valid <span class="main">(</span>drop <span class="main">(</span><span class="skolem">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="bound">l</span><span class="main">)</span><span class="main">}</span>
              <span class="main">=</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">l</span><span class="main">.</span> replicate <span class="skolem">i</span> R <span class="main">@</span> B <span class="main">#</span> <span class="bound">l</span><span class="main">)</span><span class="main">`</span> <span class="main">{</span><span class="bound">l</span><span class="main">.</span> length <span class="bound">l</span> <span class="main">=</span> <span class="free">n</span> <span class="main">-</span> <span class="skolem">i</span> <span class="main">-</span> <span class="main">1</span> <span class="main">∧</span> valid <span class="bound">l</span><span class="main">}</span>"</span></span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> <span class="free">n</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">i</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> l
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> image_eqI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted">"drop <span class="main"><span class="main">(</span></span><span class="skolem"><span class="skolem">i</span></span> <span class="main"><span class="main">+</span></span> <span class="main"><span class="main">1</span></span><span class="main"><span class="main">)</span></span> <span class="skolem"><span class="skolem">l</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> nth_equalityI<span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> that
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> nat.split <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nth_Cons nth_append<span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> add_diff_inverse_nat <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fastforce</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nth_append<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> D_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?D</span> <span class="main">=</span> <span class="var">?D1</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?D</span> <span class="main">=</span> <span class="main">_</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">have</span></span> inj<span class="main">:</span> <span class="quoted"><span class="quoted">"inj_on <span class="main">(</span><span class="main">λ</span><span class="bound">l</span><span class="main">.</span> replicate <span class="skolem">x</span> R <span class="main">@</span> B <span class="main">#</span> <span class="bound">l</span><span class="main">)</span> <span class="main">{</span><span class="bound">l</span><span class="main">.</span> length <span class="bound">l</span> <span class="main">=</span> <span class="free">n</span> <span class="main">-</span> Suc <span class="skolem">x</span> <span class="main">∧</span> valid <span class="bound">l</span><span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span>
    <span class="keyword1"><span class="command">unfolding</span></span> inj_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">l</span><span class="main">.</span> replicate <span class="skolem">x</span> R <span class="main">@</span> B <span class="main">#</span> <span class="bound">l</span><span class="main">)</span> <span class="main">`</span> <span class="main">{</span><span class="bound">l</span><span class="main">.</span> length <span class="bound">l</span> <span class="main">=</span> <span class="free">n</span> <span class="main">-</span> Suc <span class="skolem">x</span> <span class="main">∧</span> valid <span class="bound">l</span><span class="main">}</span> <span class="main">∩</span>
         <span class="main">(</span><span class="main">λ</span><span class="bound">l</span><span class="main">.</span> replicate <span class="skolem">y</span> R <span class="main">@</span> B <span class="main">#</span> <span class="bound">l</span><span class="main">)</span> <span class="main">`</span> <span class="main">{</span><span class="bound">l</span><span class="main">.</span> length <span class="bound">l</span> <span class="main">=</span> <span class="free">n</span> <span class="main">-</span> Suc <span class="skolem">y</span> <span class="main">∧</span> valid <span class="bound">l</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">≤</span> <span class="skolem">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">&lt;</span> <span class="free">n</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">y</span>
    <span class="keyword1"><span class="command">using</span></span> that replicate_unequal_aux<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>›</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">have</span></span> 3<span class="main">:</span> <span class="quoted"><span class="quoted">"card <span class="var">?D1</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">i</span><span class="main">=</span><span class="free">m</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">.</span> F <span class="main">(</span><span class="free">n</span><span class="main">-</span><span class="bound">i</span><span class="main">-</span><span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">subst</span> card_Union_disjoint<span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> 1
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> pairwise_def disjnt_def
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">clarsimp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> prems<span class="main">:</span> <span class="main">(</span>1 <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> prems <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> linorder_cases<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">x</span></span></span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">y</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> *<span class="main"><span class="keyword3">;</span></span> <span class="operator">assumption</span><span class="main">)</span>
         <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> Int_commute<span class="main"><span class="keyword3">;</span></span> <span class="operator">rule</span> *<span class="main"><span class="keyword3">;</span></span> <span class="operator">assumption</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> 3
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">subst</span> sum.reindex<span class="main"><span class="keyword3">,</span></span> <span class="operator">unfold</span> inj_on_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">clarsimp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> prems<span class="main">:</span> <span class="main">(</span>1 <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> *<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">y</span></span> <span class="quoted"><span class="skolem">x</span></span><span class="main">]</span> *<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">x</span></span> <span class="quoted"><span class="skolem">y</span></span><span class="main">]</span> valid_line_aux<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">-</span> Suc <span class="skolem">x</span>"</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> linorder_cases<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">x</span></span></span></span></span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">y</span></span></span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> 2
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> F_def card_image<span class="main"><span class="main">[</span></span><span class="operator">OF</span> inj<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_subset<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ finite_valid_length<span class="main"><span class="main">]</span></span><span class="main">)</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> F_def<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?A</span> <span class="main">=</span> <span class="main">_</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?B</span> <span class="main">=</span> <span class="main">_</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?C</span> <span class="main">=</span> <span class="main">_</span>›</span></span> D_eq
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> card_Un_disjoint<span class="main">)</span>
      <span class="comment1">(* Finiteness *)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_subset<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ finite_valid_length<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
      <span class="comment1">(* Disjointness *)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
      <span class="keyword1"><span class="command">using</span></span> Cons_replicate_eq<span class="main">[</span><span class="operator">of</span> <span class="quoted">B</span> <span class="main">_</span> <span class="quoted"><span class="free">n</span></span> <span class="quoted">R</span><span class="main">]</span> replicate_unequal_aux <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> card_Un_disjoint<span class="main">)</span>
      <span class="comment1">(* Finiteness *)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_subset<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ finite_valid_length<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
      <span class="comment1">(* Disjointness &amp; final rewriting *)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> 1 2 3 <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">m</span> <span class="main">&gt;</span> <span class="main">0</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Cons_replicate_eq Cons_eq_append_conv<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Computing the Fill-Count Function›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">lcount</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lcount</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="main">(</span>
    <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">&lt;</span> <span class="free">m</span> <span class="keyword1">then</span> <span class="main">1</span>
    <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="free">m</span> <span class="keyword1">then</span> <span class="numeral">2</span>
    <span class="keyword1">else</span> <span class="free">lcount</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span> <span class="main">+</span> <span class="main">(</span><span class="main">∑</span><span class="bound">i</span> <span class="main">←</span> <span class="main">[</span><span class="free">m</span><span class="main">..&lt;</span><span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">]</span><span class="main">.</span> <span class="free">lcount</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">-</span> <span class="bound">i</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span>
  <span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span> <span class="main">=</span> lcount.simps

<span class="keyword1" id="Counting_Tiles-lcount_correct"><span class="command">lemma</span></span> lcount_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lcount <span class="free">n</span> <span class="main">=</span> F <span class="free">n</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> less_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>less <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="free">m</span> <span class="main">&gt;</span> <span class="main">0</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lcount.simps F_base_0<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> lcount.simps<span class="main">)</span>
      <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less.IH F_base_1 F_base_2 F_rec interv_sum_list_conv_sum_set_nat<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Memoization›</span></span>

<span class="keyword1"><span class="command">memoize_fun</span></span> lcount<span class="hidden">⇩</span><sub>m</sub><span class="main">:</span> <span class="quoted">lcount</span> <span class="keyword2"><span class="keyword">with_memory</span></span> dp_consistency_mapping <span class="keyword1"><span class="command">monadifies</span></span> <span class="main">(</span>state<span class="main">)</span> lcount.simps

<span class="keyword1"><span class="command">memoize_correct</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">memoize_prover</span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> lcount<span class="hidden">⇩</span><sub>m</sub>.memoized_correct

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Fixed block size *)</span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Problem solutions›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Example and solution for problem <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>#›</span></span></span></span>114›</span></span>
<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"lcount <span class="numeral">3</span> <span class="numeral">7</span>"</span></span>
<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"lcount <span class="numeral">3</span> <span class="numeral">50</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Examples for problem <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>#›</span></span></span></span>115›</span></span>
<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"lcount <span class="numeral">3</span> <span class="numeral">29</span>"</span></span>
<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"lcount <span class="numeral">3</span> <span class="numeral">30</span>"</span></span>
<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"lcount <span class="numeral">10</span> <span class="numeral">56</span>"</span></span>
<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"lcount <span class="numeral">10</span> <span class="numeral">57</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Binary search for the solution of problem <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>#›</span></span></span></span>115›</span></span>
<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"lcount <span class="numeral">50</span> <span class="numeral">100</span>"</span></span>
<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"lcount <span class="numeral">50</span> <span class="numeral">150</span>"</span></span>
<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"lcount <span class="numeral">50</span> <span class="numeral">163</span>"</span></span>
<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"lcount <span class="numeral">50</span> <span class="numeral">166</span>"</span></span>
<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"lcount <span class="numeral">50</span> <span class="numeral">167</span>"</span></span>
<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"lcount <span class="numeral">50</span> <span class="numeral">168</span>"</span></span> <span class="comment1">― ‹The solution›</span>
<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"lcount <span class="numeral">50</span> <span class="numeral">169</span>"</span></span>
<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"lcount <span class="numeral">50</span> <span class="numeral">175</span>"</span></span>
<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"lcount <span class="numeral">50</span> <span class="numeral">200</span>"</span></span>
<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"lcount <span class="numeral">50</span> <span class="numeral">300</span>"</span></span>
<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"lcount <span class="numeral">50</span> <span class="numeral">500</span>"</span></span>
<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"lcount <span class="numeral">50</span> <span class="numeral">1000</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We prove that 168 is the solution for problem <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>#›</span></span></span></span>115›</span></span>
<span class="keyword1"><span class="command">theorem</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">LEAST</span> <span class="bound">n</span><span class="main">.</span> F <span class="numeral">50</span> <span class="bound">n</span> <span class="main">&gt;</span> <span class="numeral">1000000</span><span class="main">)</span> <span class="main">=</span> <span class="numeral">168</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lcount <span class="numeral">50</span> <span class="numeral">168</span> <span class="main">&gt;</span> <span class="numeral">1000000</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">n</span> <span class="main">∈</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="numeral">168</span><span class="main">}</span><span class="main">.</span> lcount <span class="numeral">50</span> <span class="bound">n</span> <span class="main">&lt;</span> <span class="numeral">1000000</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> Least_equality<span class="main"><span class="keyword3">;</span></span> <span class="operator">rule</span> ccontr<span class="main"><span class="keyword3">;</span></span> <span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> not_le lcount_correct<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="CYK">
<div class="head">
<h1>Theory CYK</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"The CYK Algorithm"</span></span>

<span class="keyword1"><span class="command">theory</span></span> CYK
<span class="keyword2"><span class="keyword">imports</span></span>
  <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/IArray.html">HOL-Library.IArray</a>"</span>
  <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/Code_Target_Numeral.html">HOL-Library.Code_Target_Numeral</a>"</span>
  <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/Product_Lexorder.html">HOL-Library.Product_Lexorder</a>"</span>
  <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/RBT_Mapping.html">HOL-Library.RBT_Mapping</a>"</span>
  <span class="quoted">"<a href="#State_Main">../state_monad/State_Main</a>"</span>
  <span class="quoted">"<a href="#Heap_Default">../heap_monad/Heap_Default</a>"</span>
  <a href="#Example_Misc">Example_Misc</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Misc›</span></span>

<span class="keyword1" id="CYK-append_iff_take_drop"><span class="command">lemma</span></span> append_iff_take_drop<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">=</span> <span class="free">u</span><span class="main">@</span><span class="free">v</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">k</span> <span class="main">∈</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span>length <span class="free">w</span><span class="main">}</span><span class="main">.</span> <span class="free">u</span> <span class="main">=</span> take <span class="bound">k</span> <span class="free">w</span> <span class="main">∧</span> <span class="free">v</span> <span class="main">=</span> drop <span class="bound">k</span> <span class="free">w</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>full_types<span class="main"><span class="main">)</span></span> append_eq_conv_conj append_take_drop_id atLeastAtMost_iff le0 le_add1 length_append<span class="main">)</span> 

<span class="keyword1" id="CYK-append_iff_take_drop1"><span class="command">lemma</span></span> append_iff_take_drop1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">⟹</span> <span class="free">v</span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">⟹</span>
  <span class="free">w</span> <span class="main">=</span> <span class="free">u</span><span class="main">@</span><span class="free">v</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">k</span> <span class="main">∈</span> <span class="main">{</span><span class="main">1</span><span class="main">..</span>length <span class="free">w</span> <span class="main">-</span> <span class="main">1</span><span class="main">}</span><span class="main">.</span> <span class="free">u</span> <span class="main">=</span> take <span class="bound">k</span> <span class="free">w</span> <span class="main">∧</span> <span class="free">v</span> <span class="main">=</span> drop <span class="bound">k</span> <span class="free">w</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> append_iff_take_drop<span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Definitions›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="main">(</span><span class="tfree">'n</span><span class="main">,</span> <span class="tfree">'t</span><span class="main">)</span> rhs <span class="main">=</span> NN <span class="tfree"><span class="quoted"><span class="tfree">'n</span></span></span> <span class="tfree"><span class="quoted"><span class="tfree">'n</span></span></span> <span class="main">|</span> T <span class="tfree"><span class="quoted"><span class="tfree">'t</span></span></span> 

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'n</span><span class="main">,</span> <span class="tfree">'t</span><span class="main">)</span> prods <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'n</span> <span class="main">×</span> <span class="main">(</span><span class="tfree">'n</span><span class="main">,</span> <span class="tfree">'t</span><span class="main">)</span> rhs<span class="main">)</span> list"</span></span>

<span class="keyword1"><span class="command">context</span></span>
<span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">P</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'n</span> <span class="main">::</span> heap<span class="main">,</span> <span class="tfree">'t</span><span class="main">)</span> prods"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">inductive</span></span> <span class="entity">yield</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'n</span> <span class="main">⇒</span> <span class="tfree">'t</span> list <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">,</span> T <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="main">∈</span> set <span class="free">P</span> <span class="main">⟹</span> <span class="free">yield</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">]</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">,</span> NN <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="free"><span class="bound"><span class="entity">C</span></span></span><span class="main">)</span> <span class="main">∈</span> set <span class="free">P</span><span class="main">;</span> <span class="free">yield</span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">;</span> <span class="free">yield</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">yield</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">@</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="CYK-yield_not_Nil"><span class="command">lemma</span></span> yield_not_Nil<span class="main">:</span> <span class="quoted"><span class="quoted">"yield <span class="free">A</span> <span class="free">w</span> <span class="main">⟹</span> <span class="free">w</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> yield.induct<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="CYK-yield_eq1"><span class="command">lemma</span></span> yield_eq1<span class="main">:</span>
  <span class="quoted"><span class="quoted">"yield <span class="free">A</span> <span class="main">[</span><span class="free">a</span><span class="main">]</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">A</span><span class="main">,</span> T <span class="free">a</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">P</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?L</span> <span class="main">=</span> <span class="var">?R</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?L</span></span></span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?R</span></span></span> 
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">A</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">a</span><span class="main">]</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">a</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> yield.induct<span class="main">)</span>
      <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> yield_not_Nil append_eq_Cons_conv<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> yield.intros<span class="main">)</span>

<span class="keyword1" id="CYK-yield_eq2"><span class="command">lemma</span></span> yield_eq2<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"length <span class="free">w</span> <span class="main">&gt;</span> <span class="main">1</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"yield <span class="free">A</span> <span class="free">w</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">B</span> <span class="bound">u</span> <span class="bound">C</span> <span class="bound">v</span><span class="main">.</span> yield <span class="bound">B</span> <span class="bound">u</span> <span class="main">∧</span> yield <span class="bound">C</span> <span class="bound">v</span> <span class="main">∧</span> <span class="free">w</span> <span class="main">=</span> <span class="bound">u</span><span class="main">@</span><span class="bound">v</span> <span class="main">∧</span> <span class="main">(</span><span class="free">A</span><span class="main">,</span> NN <span class="bound">B</span> <span class="bound">C</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">P</span><span class="main">)</span>"</span></span>
       <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?L</span> <span class="main">=</span> <span class="var">?R</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?L</span></span></span> <span class="keyword1"><span class="command">from</span></span> this assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?R</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> yield.induct<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?R</span></span></span> <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?L</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> yield.intros<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">"CYK on Lists"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">cyk</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'t</span> list <span class="main">⇒</span> <span class="tfree">'n</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">cyk</span> <span class="main">[]</span> <span class="main">=</span> <span class="main">[]</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">cyk</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="bound">A</span> <span class="main">.</span> <span class="main">(</span>A<span class="main">,</span> T a'<span class="main">)</span> <span class="main">&lt;-</span> <span class="free">P</span><span class="main">,</span> <span class="bound">a'</span><span class="main">=</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">]</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">cyk</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">=</span>
  <span class="main">[</span><span class="bound">A</span><span class="main">.</span> k <span class="main">&lt;-</span> <span class="main">[</span><span class="main">1</span><span class="main">..&lt;</span>length <span class="free"><span class="bound"><span class="entity">w</span></span></span><span class="main">]</span><span class="main">,</span> B <span class="main">&lt;-</span> <span class="free">cyk</span> <span class="main">(</span>take <span class="bound">k</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span><span class="main">)</span><span class="main">,</span> C <span class="main">&lt;-</span> <span class="free">cyk</span> <span class="main">(</span>drop <span class="bound">k</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span><span class="main">)</span><span class="main">,</span> <span class="main">(</span>A<span class="main">,</span> NN B' C'<span class="main">)</span> <span class="main">&lt;-</span> <span class="free">P</span><span class="main">,</span> <span class="bound">B'</span> <span class="main">=</span> <span class="bound">B</span><span class="main">,</span> <span class="bound">C'</span> <span class="main">=</span> <span class="bound">C</span><span class="main">]</span>"</span></span>

<span class="keyword1" id="CYK-set_cyk_simp2"><span class="command">lemma</span></span> set_cyk_simp2<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="free">w</span> <span class="main">≥</span> <span class="numeral">2</span> <span class="main">⟹</span> set<span class="main">(</span>cyk <span class="free">w</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="main">⋃</span><span class="bound">k</span> <span class="main">∈</span> <span class="main">{</span><span class="main">1</span><span class="main">..</span>length <span class="free">w</span> <span class="main">-</span> <span class="main">1</span><span class="main">}</span><span class="main">.</span> <span class="main">⋃</span><span class="bound">B</span> <span class="main">∈</span> set<span class="main">(</span>cyk <span class="main">(</span>take <span class="bound">k</span> <span class="free">w</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> <span class="main">⋃</span><span class="bound">C</span> <span class="main">∈</span> set<span class="main">(</span>cyk <span class="main">(</span>drop <span class="bound">k</span> <span class="free">w</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> <span class="main">{</span><span class="bound">A</span><span class="main">.</span> <span class="main">(</span><span class="bound">A</span><span class="main">,</span> NN <span class="bound">B</span> <span class="bound">C</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">P</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">w</span></span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> _ w'
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="skolem">w'</span></span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
 <span class="keyword1"><span class="command">using</span></span> le_Suc_eq le_simps<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> drop_Suc_Cons le_Suc_eq le_antisym not_le take_Suc_Cons<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">declare</span></span> cyk.simps<span class="main">(</span>3<span class="main">)</span><span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>

<span class="keyword1" id="CYK-cyk_correct"><span class="command">lemma</span></span> cyk_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"set<span class="main">(</span>cyk <span class="free">w</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound">N</span><span class="main">.</span> yield <span class="bound">N</span> <span class="free">w</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">w</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> cyk.induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 1 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> yield_not_Nil<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> 2 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> yield_eq1<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>3 <span class="skolem">v</span> <span class="skolem">vb</span> <span class="skolem">vc</span><span class="main">)</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?w</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">#</span> <span class="skolem">vb</span> <span class="main">#</span> <span class="skolem">vc</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set<span class="main">(</span>cyk <span class="var">?w</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">k</span><span class="main">∈</span><span class="main">{</span><span class="main">1</span><span class="main">..</span>length <span class="var">?w</span><span class="main">-</span><span class="main">1</span><span class="main">}</span><span class="main">.</span> <span class="main">{</span><span class="bound">N</span><span class="main">.</span> <span class="main">∃</span><span class="bound">A</span> <span class="bound">B</span><span class="main">.</span> <span class="main">(</span><span class="bound">N</span><span class="main">,</span> NN <span class="bound">A</span> <span class="bound">B</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">P</span> <span class="main">∧</span>
             yield <span class="bound">A</span> <span class="main">(</span>take <span class="bound">k</span> <span class="var">?w</span><span class="main">)</span> <span class="main">∧</span> yield <span class="bound">B</span> <span class="main">(</span>drop <span class="bound">k</span> <span class="var">?w</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span><span class="quoted">"3.IH"</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span>upt_Suc<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">{</span><span class="bound">N</span><span class="main">.</span> <span class="main">∃</span><span class="bound">A</span> <span class="bound">B</span><span class="main">.</span> <span class="main">(</span><span class="bound">N</span><span class="main">,</span> NN <span class="bound">A</span> <span class="bound">B</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">P</span> <span class="main">∧</span>
              <span class="main">(</span><span class="main">∃</span><span class="bound">u</span> <span class="bound">v</span><span class="main">.</span> yield <span class="bound">A</span> <span class="bound">u</span> <span class="main">∧</span> yield <span class="bound">B</span> <span class="bound">v</span> <span class="main">∧</span> <span class="var">?w</span> <span class="main">=</span> <span class="bound">u</span><span class="main">@</span><span class="bound">v</span><span class="main">)</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> append_iff_take_drop1 yield_not_Nil<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">{</span><span class="bound">N</span><span class="main">.</span> yield <span class="bound">N</span> <span class="var">?w</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> yield_eq2<span class="main">[</span><span class="operator">of</span> <span class="var"><span class="quoted"><span class="var">?w</span></span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">"CYK on Lists and Index"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">cyk2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'t</span> list <span class="main">⇒</span> nat <span class="main">*</span> nat <span class="main">⇒</span> <span class="tfree">'n</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">cyk2</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span><span class="main">0</span><span class="main">)</span> <span class="main">=</span> <span class="main">[]</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">cyk2</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span>Suc <span class="main">0</span><span class="main">)</span> <span class="main">=</span> <span class="main">[</span><span class="bound">A</span> <span class="main">.</span> <span class="main">(</span>A<span class="main">,</span> T a<span class="main">)</span> <span class="main">&lt;-</span> <span class="free">P</span><span class="main">,</span> <span class="bound">a</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span><span class="main">!</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">]</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">cyk2</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span>
<span class="main">[</span><span class="bound">A</span><span class="main">.</span> k <span class="main">&lt;-</span> <span class="main">[</span><span class="main">1</span><span class="main">..&lt;</span><span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">]</span><span class="main">,</span> B <span class="main">&lt;-</span> <span class="free">cyk2</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span><span class="bound">k</span><span class="main">)</span><span class="main">,</span> C <span class="main">&lt;-</span> <span class="free">cyk2</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">+</span><span class="bound">k</span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">-</span><span class="bound">k</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span>A<span class="main">,</span> NN B' C'<span class="main">)</span> <span class="main">&lt;-</span> <span class="free">P</span><span class="main">,</span> <span class="bound">B'</span> <span class="main">=</span> <span class="bound">B</span><span class="main">,</span> <span class="bound">C'</span> <span class="main">=</span> <span class="bound">C</span><span class="main">]</span>"</span></span>

<span class="keyword1" id="CYK-set_aux"><span class="command">lemma</span></span> set_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋃</span><span class="bound">xb</span><span class="main">∈</span>set <span class="free">P</span><span class="main">.</span> <span class="main">{</span><span class="bound">A</span><span class="main">.</span> <span class="main">(</span><span class="bound">A</span><span class="main">,</span> NN <span class="free">B</span> <span class="free">C</span><span class="main">)</span> <span class="main">=</span> <span class="bound">xb</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound">A</span><span class="main">.</span> <span class="main">(</span><span class="bound">A</span><span class="main">,</span> NN <span class="free">B</span> <span class="free">C</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">P</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="CYK-cyk2_eq_cyk"><span class="command">lemma</span></span> cyk2_eq_cyk<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">i</span><span class="main">+</span><span class="free">n</span> <span class="main">≤</span> length <span class="free">w</span> <span class="main">⟹</span> set<span class="main">(</span>cyk2 <span class="free">w</span> <span class="main">(</span><span class="free">i</span><span class="main">,</span><span class="free">n</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> set<span class="main">(</span>cyk <span class="main">(</span>take <span class="free">n</span> <span class="main">(</span>drop <span class="free">i</span> <span class="free">w</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">w</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">i</span><span class="main">,</span><span class="free">n</span><span class="main">)</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">i</span></span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> cyk2.induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 1 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> 2 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted">"2.prems"</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hd_drop_conv_nth take_Suc<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>3 <span class="skolem">w</span> <span class="skolem">i</span> <span class="skolem">m</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted">"3.prems"</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> 3<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>2<span class="main"><span class="main">)</span></span> min.absorb1 min.absorb2 drop_take atLeastLessThanSuc_atLeastAtMost set_aux
         <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span>upt_Suc <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> SUP_cong_simp<span class="main">)</span>
      <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> add.commute<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">CYK</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">=</span>  <span class="main">(</span><span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="main">∈</span> set<span class="main">(</span>cyk2 <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">(</span><span class="main">0</span><span class="main">,</span> length <span class="free"><span class="bound"><span class="entity">w</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">theorem</span></span> CYK_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"CYK <span class="free">S</span> <span class="free">w</span> <span class="main">=</span> yield <span class="free">S</span> <span class="free">w</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> CYK_def cyk2_eq_cyk cyk_correct<span class="main">)</span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">"CYK With Index Function"</span></span>

<span class="keyword1"><span class="command">context</span></span>
<span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">w</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="tfree">'t</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">cyk_ix</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">*</span> nat <span class="main">⇒</span> <span class="tfree">'n</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">cyk_ix</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span><span class="main">0</span><span class="main">)</span> <span class="main">=</span> <span class="main">[]</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">cyk_ix</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span>Suc <span class="main">0</span><span class="main">)</span> <span class="main">=</span> <span class="main">[</span><span class="bound">A</span> <span class="main">.</span> <span class="main">(</span>A<span class="main">,</span> T a<span class="main">)</span> <span class="main">&lt;-</span> <span class="free">P</span><span class="main">,</span> <span class="bound">a</span> <span class="main">=</span> <span class="free">w</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">]</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">cyk_ix</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span>
  <span class="main">[</span><span class="bound">A</span><span class="main">.</span> k <span class="main">&lt;-</span> <span class="main">[</span><span class="main">1</span><span class="main">..&lt;</span><span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">]</span><span class="main">,</span> B <span class="main">&lt;-</span> <span class="free">cyk_ix</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span><span class="bound">k</span><span class="main">)</span><span class="main">,</span> C <span class="main">&lt;-</span> <span class="free">cyk_ix</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">+</span><span class="bound">k</span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">-</span><span class="bound">k</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span>A<span class="main">,</span> NN B' C'<span class="main">)</span> <span class="main">&lt;-</span> <span class="free">P</span><span class="main">,</span> <span class="bound">B'</span> <span class="main">=</span> <span class="bound">B</span><span class="main">,</span> <span class="bound">C'</span> <span class="main">=</span> <span class="bound">C</span><span class="main">]</span>"</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Correctness Proof›</span></span>

<span class="keyword1" id="CYK-cyk_ix_simp2"><span class="command">lemma</span></span> cyk_ix_simp2<span class="main">:</span> <span class="quoted"><span class="quoted">"set<span class="main">(</span>cyk_ix <span class="main">(</span><span class="free">i</span><span class="main">,</span>Suc<span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="main">⋃</span><span class="bound">k</span> <span class="main">∈</span> <span class="main">{</span><span class="main">1</span><span class="main">..</span>Suc <span class="free">n</span><span class="main">}</span><span class="main">.</span> <span class="main">⋃</span><span class="bound">B</span> <span class="main">∈</span> set<span class="main">(</span>cyk_ix <span class="main">(</span><span class="free">i</span><span class="main">,</span><span class="bound">k</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> <span class="main">⋃</span><span class="bound">C</span> <span class="main">∈</span> set<span class="main">(</span>cyk_ix <span class="main">(</span><span class="free">i</span><span class="main">+</span><span class="bound">k</span><span class="main">,</span><span class="free">n</span><span class="main">+</span><span class="numeral">2</span><span class="main">-</span><span class="bound">k</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> <span class="main">{</span><span class="bound">A</span><span class="main">.</span> <span class="main">(</span><span class="bound">A</span><span class="main">,</span> NN <span class="bound">B</span> <span class="bound">C</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">P</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> atLeastLessThanSuc_atLeastAtMost set_aux <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> upt_Suc<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> cyk_ix.simps<span class="main">(</span>3<span class="main">)</span><span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">slice</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">≡</span> map <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">..&lt;</span><span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">]</span>"</span></span>

<span class="keyword1" id="CYK-slice_append_iff_take_drop1"><span class="command">lemma</span></span> slice_append_iff_take_drop1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">⟹</span> <span class="free">v</span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">⟹</span>
  slice <span class="free">w</span> <span class="free">i</span> <span class="free">j</span> <span class="main">=</span> <span class="free">u</span> <span class="main">@</span> <span class="free">v</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">k</span><span class="main">.</span> <span class="main">1</span> <span class="main">≤</span> <span class="bound">k</span> <span class="main">∧</span> <span class="bound">k</span> <span class="main">≤</span> <span class="free">j</span><span class="main">-</span><span class="free">i</span><span class="main">-</span><span class="main">1</span> <span class="main">∧</span> slice <span class="free">w</span> <span class="free">i</span> <span class="main">(</span><span class="free">i</span> <span class="main">+</span> <span class="bound">k</span><span class="main">)</span> <span class="main">=</span> <span class="free">u</span> <span class="main">∧</span> slice <span class="free">w</span> <span class="main">(</span><span class="free">i</span> <span class="main">+</span> <span class="bound">k</span><span class="main">)</span> <span class="free">j</span> <span class="main">=</span> <span class="free">v</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> append_iff_take_drop1<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> take_map drop_map Bex_def<span class="main">)</span>

<span class="keyword1" id="CYK-cyk_ix_correct"><span class="command">lemma</span></span> cyk_ix_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"set<span class="main">(</span>cyk_ix <span class="main">(</span><span class="free">i</span><span class="main">,</span><span class="free">n</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound">N</span><span class="main">.</span> yield <span class="bound">N</span> <span class="main">(</span>slice <span class="free">w</span> <span class="free">i</span> <span class="main">(</span><span class="free">i</span><span class="main">+</span><span class="free">n</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">i</span><span class="main">,</span><span class="free">n</span><span class="main">)</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">i</span></span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> cyk_ix.induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 1 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> yield_not_Nil<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> 2 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> yield_eq1<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>3 <span class="skolem">i</span> <span class="skolem">m</span><span class="main">)</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?n</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"Suc<span class="main">(</span>Suc <span class="skolem">m</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?w</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"slice <span class="free">w</span> <span class="skolem">i</span> <span class="main">(</span><span class="skolem">i</span><span class="main">+</span><span class="var">?n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set<span class="main">(</span>cyk_ix <span class="main">(</span><span class="skolem">i</span><span class="main">,</span><span class="var">?n</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">k</span><span class="main">∈</span><span class="main">{</span><span class="main">1</span><span class="main">..</span>Suc <span class="skolem">m</span><span class="main">}</span><span class="main">.</span> <span class="main">{</span><span class="bound">N</span><span class="main">.</span> <span class="main">∃</span><span class="bound">A</span> <span class="bound">B</span><span class="main">.</span> <span class="main">(</span><span class="bound">N</span><span class="main">,</span> NN <span class="bound">A</span> <span class="bound">B</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">P</span> <span class="main">∧</span>
             yield <span class="bound">A</span> <span class="main">(</span>slice <span class="free">w</span> <span class="skolem">i</span> <span class="main">(</span><span class="skolem">i</span><span class="main">+</span><span class="bound">k</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> yield <span class="bound">B</span> <span class="main">(</span>slice <span class="free">w</span> <span class="main">(</span><span class="skolem">i</span><span class="main">+</span><span class="bound">k</span><span class="main">)</span> <span class="main">(</span><span class="skolem">i</span><span class="main">+</span><span class="var">?n</span><span class="main">)</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> 3 cyk_ix_simp2 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> upt_Suc<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">{</span><span class="bound">N</span><span class="main">.</span> <span class="main">∃</span><span class="bound">A</span> <span class="bound">B</span><span class="main">.</span> <span class="main">(</span><span class="bound">N</span><span class="main">,</span> NN <span class="bound">A</span> <span class="bound">B</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">P</span> <span class="main">∧</span>
              <span class="main">(</span><span class="main">∃</span><span class="bound">u</span> <span class="bound">v</span><span class="main">.</span> yield <span class="bound">A</span> <span class="bound">u</span> <span class="main">∧</span> yield <span class="bound">B</span> <span class="bound">v</span> <span class="main">∧</span> slice <span class="free">w</span> <span class="skolem">i</span> <span class="main">(</span><span class="skolem">i</span><span class="main">+</span><span class="var">?n</span><span class="main">)</span> <span class="main">=</span> <span class="bound">u</span><span class="main">@</span><span class="bound">v</span><span class="main">)</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> upt_Suc <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> slice_append_iff_take_drop1 yield_not_Nil <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> conj_cong<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">{</span><span class="bound">N</span><span class="main">.</span> yield <span class="bound">N</span> <span class="var">?w</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> yield_eq2<span class="main">[</span><span class="operator">of</span> <span class="var"><span class="quoted"><span class="var">?w</span></span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Functional Memoization›</span></span>

<span class="keyword1"><span class="command">memoize_fun</span></span> cyk_ix<span class="hidden">⇩</span><sub>m</sub><span class="main">:</span> <span class="quoted">cyk_ix</span> <span class="keyword2"><span class="keyword">with_memory</span></span> dp_consistency_mapping <span class="keyword1"><span class="command">monadifies</span></span> <span class="main">(</span>state<span class="main">)</span> cyk_ix.simps
<span class="keyword1"><span class="command">thm</span></span> cyk_ix<span class="hidden">⇩</span><sub>m</sub>'.simps

<span class="keyword1"><span class="command">memoize_correct</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">memoize_prover</span>
<span class="keyword1"><span class="command">print_theorems</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> cyk_ix<span class="hidden">⇩</span><sub>m</sub>.memoized_correct


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Imperative Memoization›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">n</span> <span class="main">::</span> <span class="quoted">nat</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">mem</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'n</span> list option array"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">memoize_fun</span></span> cyk_ix<span class="hidden">⇩</span><sub>h</sub><span class="main">:</span> <span class="quoted">cyk_ix</span>
  <span class="keyword2"><span class="keyword">with_memory</span></span> dp_consistency_heap_default <span class="keyword2"><span class="keyword">where</span></span> bound <span class="main">=</span> <span class="quoted"><span class="quoted">"Bound <span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="main">0</span><span class="main">)</span> <span class="main">(</span><span class="free">n</span><span class="main">,</span> <span class="free">n</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> mem<span class="main">=</span><span class="quoted"><span class="quoted">"<span class="free">mem</span>"</span></span>
  <span class="keyword1"><span class="command">monadifies</span></span> <span class="main">(</span>heap<span class="main">)</span> cyk_ix.simps

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> heap_monad_syntax <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">thm</span></span> cyk_ix<span class="hidden">⇩</span><sub>h</sub>'.simps cyk_ix<span class="hidden">⇩</span><sub>h</sub>_def
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">memoize_correct</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">memoize_prover</span>

<span class="keyword1"><span class="command">lemmas</span></span> memoized_empty <span class="main">=</span> cyk_ix<span class="hidden">⇩</span><sub>h</sub>.memoized_empty

<span class="keyword1"><span class="command">lemmas</span></span> init_success <span class="main">=</span> cyk_ix<span class="hidden">⇩</span><sub>h</sub>.init_success

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Fixed array *)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">cyk_ix_impl</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span><span class="bound">mem</span> <span class="main">←</span> mem_empty <span class="main">(</span><span class="free">n</span> <span class="main">*</span> <span class="free">n</span><span class="main">)</span><span class="main">;</span> cyk_ix<span class="hidden">⇩</span><sub>h</sub>' <span class="bound">mem</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1" id="CYK-cyk_ix_impl_success"><span class="command">lemma</span></span> cyk_ix_impl_success<span class="main">:</span>
  <span class="quoted"><span class="quoted">"success <span class="main">(</span>cyk_ix_impl <span class="free">i</span> <span class="free">j</span><span class="main">)</span> Heap.empty"</span></span>
  <span class="keyword1"><span class="command">using</span></span> init_success<span class="main">[</span><span class="operator">of</span> <span class="main">_</span> <span class="quoted">cyk_ix<span class="hidden">⇩</span><sub>h</sub>'</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">i</span><span class="main">,</span> <span class="free">j</span><span class="main">)</span>"</span></span><span class="main">,</span> <span class="operator">OF</span> cyk_ix<span class="hidden">⇩</span><sub>h</sub>.crel<span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cyk_ix_impl_def index_size_defs<span class="main">)</span>

<span class="keyword1" id="CYK-min_wpl_heap"><span class="command">lemma</span></span> min_wpl_heap<span class="main">:</span>
  <span class="quoted"><span class="quoted">"cyk_ix <span class="main">(</span><span class="free">i</span><span class="main">,</span> <span class="free">j</span><span class="main">)</span> <span class="main">=</span> result_of <span class="main">(</span>cyk_ix_impl <span class="free">i</span> <span class="free">j</span><span class="main">)</span> Heap.empty"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> cyk_ix_impl_def
  <span class="keyword1"><span class="command">using</span></span> memoized_empty<span class="main">[</span><span class="operator">of</span> <span class="main">_</span> <span class="quoted">cyk_ix<span class="hidden">⇩</span><sub>h</sub>'</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">i</span><span class="main">,</span> <span class="free">j</span><span class="main">)</span>"</span></span><span class="main">,</span> <span class="operator">OF</span> cyk_ix<span class="hidden">⇩</span><sub>h</sub>.crel<span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> index_size_defs<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Bound *)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Index *)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">CYK_ix</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span>  <span class="main">(</span><span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="main">∈</span> set<span class="main">(</span>cyk_ix <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">theorem</span></span> CYK_ix_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"CYK_ix <span class="free">S</span> <span class="free">w</span> <span class="free">n</span> <span class="main">=</span> yield <span class="free">S</span> <span class="main">(</span>slice <span class="free">w</span> <span class="main">0</span> <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> CYK_ix_def cyk_ix_correct<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">cyk_list</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">=</span> cyk_ix <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">!</span> <span class="bound">i</span><span class="main">)</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span>length <span class="free"><span class="bound"><span class="entity">w</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">CYK_ix_impl</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span><span class="bound">R</span> <span class="main">←</span> cyk_ix_impl <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">0</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">;</span> return <span class="main">(</span><span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="main">∈</span> set <span class="bound">R</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1" id="CYK-CYK_ix_impl_correct"><span class="command">lemma</span></span> CYK_ix_impl_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"result_of <span class="main">(</span>CYK_ix_impl <span class="free">S</span> <span class="free">w</span> <span class="free">n</span><span class="main">)</span> Heap.empty <span class="main">=</span> yield <span class="free">S</span> <span class="main">(</span>slice <span class="free">w</span> <span class="main">0</span> <span class="free">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> CYK_ix_impl_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> execute_bind_success<span class="main"><span class="main">[</span></span><span class="operator">OF</span> cyk_ix_impl_success<span class="main"><span class="main">]</span></span>
        min_wpl_heap<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> CYK_ix_correct CYK_ix_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span>
     <span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Fixed Productions *)</span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Functional Test Case›</span></span>

<span class="keyword1"><span class="command">value</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">let</span> <span class="bound">P</span> <span class="main">=</span> <span class="main">[</span><span class="main">(</span><span class="main">0</span><span class="main">::</span>int<span class="main">,</span> NN <span class="main">1</span> <span class="numeral">2</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span> NN <span class="numeral">2</span> <span class="numeral">3</span><span class="main">)</span><span class="main">,</span>
            <span class="main">(</span><span class="main">1</span><span class="main">,</span> NN <span class="numeral">2</span> <span class="main">1</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">1</span><span class="main">,</span> T <span class="main">(</span><span class="keyword1">CHR</span> <span class="inner_quoted">''a''</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
            <span class="main">(</span><span class="numeral">2</span><span class="main">,</span> NN <span class="numeral">3</span> <span class="numeral">3</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="numeral">2</span><span class="main">,</span> T <span class="main">(</span><span class="keyword1">CHR</span> <span class="inner_quoted">''b''</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
            <span class="main">(</span><span class="numeral">3</span><span class="main">,</span> NN <span class="main">1</span> <span class="numeral">2</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="numeral">3</span><span class="main">,</span> T <span class="main">(</span><span class="keyword1">CHR</span> <span class="inner_quoted">''a''</span><span class="main">)</span><span class="main">)</span><span class="main">]</span>
  <span class="keyword1">in</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">w</span><span class="main">.</span> cyk2 <span class="bound">P</span> <span class="bound">w</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span>length <span class="bound">w</span><span class="main">)</span><span class="main">)</span> <span class="main">[</span><span class="inner_quoted">''baaba''</span><span class="main">,</span> <span class="inner_quoted">''baba''</span><span class="main">]</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">value</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">let</span> <span class="bound">P</span> <span class="main">=</span> <span class="main">[</span><span class="main">(</span><span class="main">0</span><span class="main">::</span>int<span class="main">,</span> NN <span class="main">1</span> <span class="numeral">2</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span> NN <span class="numeral">2</span> <span class="numeral">3</span><span class="main">)</span><span class="main">,</span>
            <span class="main">(</span><span class="main">1</span><span class="main">,</span> NN <span class="numeral">2</span> <span class="main">1</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">1</span><span class="main">,</span> T <span class="main">(</span><span class="keyword1">CHR</span> <span class="inner_quoted">''a''</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
            <span class="main">(</span><span class="numeral">2</span><span class="main">,</span> NN <span class="numeral">3</span> <span class="numeral">3</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="numeral">2</span><span class="main">,</span> T <span class="main">(</span><span class="keyword1">CHR</span> <span class="inner_quoted">''b''</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
            <span class="main">(</span><span class="numeral">3</span><span class="main">,</span> NN <span class="main">1</span> <span class="numeral">2</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="numeral">3</span><span class="main">,</span> T <span class="main">(</span><span class="keyword1">CHR</span> <span class="inner_quoted">''a''</span><span class="main">)</span><span class="main">)</span><span class="main">]</span>
  <span class="keyword1">in</span> map <span class="main">(</span>cyk_list <span class="bound">P</span><span class="main">)</span> <span class="main">[</span><span class="inner_quoted">''baaba''</span><span class="main">,</span> <span class="inner_quoted">''baba''</span><span class="main">]</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">cyk_ia</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">a</span> <span class="main">=</span> IArray <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="keyword1">in</span> cyk_ix <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="bound">a</span> <span class="main">!!</span> <span class="bound">i</span><span class="main">)</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span>length <span class="free"><span class="bound"><span class="entity">w</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">value</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">let</span> <span class="bound">P</span> <span class="main">=</span> <span class="main">[</span><span class="main">(</span><span class="main">0</span><span class="main">::</span>int<span class="main">,</span> NN <span class="main">1</span> <span class="numeral">2</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span> NN <span class="numeral">2</span> <span class="numeral">3</span><span class="main">)</span><span class="main">,</span>
            <span class="main">(</span><span class="main">1</span><span class="main">,</span> NN <span class="numeral">2</span> <span class="main">1</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">1</span><span class="main">,</span> T <span class="main">(</span><span class="keyword1">CHR</span> <span class="inner_quoted">''a''</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
            <span class="main">(</span><span class="numeral">2</span><span class="main">,</span> NN <span class="numeral">3</span> <span class="numeral">3</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="numeral">2</span><span class="main">,</span> T <span class="main">(</span><span class="keyword1">CHR</span> <span class="inner_quoted">''b''</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
            <span class="main">(</span><span class="numeral">3</span><span class="main">,</span> NN <span class="main">1</span> <span class="numeral">2</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="numeral">3</span><span class="main">,</span> T <span class="main">(</span><span class="keyword1">CHR</span> <span class="inner_quoted">''a''</span><span class="main">)</span><span class="main">)</span><span class="main">]</span>
  <span class="keyword1">in</span> map <span class="main">(</span>cyk_ia <span class="bound">P</span><span class="main">)</span> <span class="main">[</span><span class="inner_quoted">''baaba''</span><span class="main">,</span> <span class="inner_quoted">''baba''</span><span class="main">]</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Imperative Test Case›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">cyk_ia'</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">a</span> <span class="main">=</span> IArray <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="keyword1">in</span> cyk_ix_impl <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="bound">a</span> <span class="main">!!</span> <span class="bound">i</span><span class="main">)</span> <span class="main">(</span>length <span class="free"><span class="bound"><span class="entity">w</span></span></span><span class="main">)</span> <span class="main">0</span> <span class="main">(</span>length <span class="free"><span class="bound"><span class="entity">w</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">test</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">P</span> <span class="main">=</span> <span class="main">[</span><span class="main">(</span><span class="main">0</span><span class="main">::</span>int<span class="main">,</span> NN <span class="main">1</span> <span class="numeral">2</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span> NN <span class="numeral">2</span> <span class="numeral">3</span><span class="main">)</span><span class="main">,</span>
            <span class="main">(</span><span class="main">1</span><span class="main">,</span> NN <span class="numeral">2</span> <span class="main">1</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">1</span><span class="main">,</span> T <span class="main">(</span><span class="keyword1">CHR</span> <span class="inner_quoted">''a''</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
            <span class="main">(</span><span class="numeral">2</span><span class="main">,</span> NN <span class="numeral">3</span> <span class="numeral">3</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="numeral">2</span><span class="main">,</span> T <span class="main">(</span><span class="keyword1">CHR</span> <span class="inner_quoted">''b''</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
            <span class="main">(</span><span class="numeral">3</span><span class="main">,</span> NN <span class="main">1</span> <span class="numeral">2</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="numeral">3</span><span class="main">,</span> T <span class="main">(</span><span class="keyword1">CHR</span> <span class="inner_quoted">''a''</span><span class="main">)</span><span class="main">)</span><span class="main">]</span>
  <span class="keyword1">in</span> map <span class="main">(</span>cyk_ia' <span class="bound">P</span><span class="main">)</span> <span class="main">[</span><span class="inner_quoted">''baaba''</span><span class="main">,</span> <span class="inner_quoted">''baba''</span><span class="main">]</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">code_reflect</span></span> Test <span class="keyword2"><span class="keyword">functions</span></span> test

<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹List.map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">f</span> <span class="main">=&gt;</span> <span class="entity">f</span> <span class="main">(</span><span class="main">)</span><span class="main">)</span> Test.test›</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Min_Ed_Dist0">
<div class="head">
<h1>Theory Min_Ed_Dist0</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Minimum Edit Distance"</span></span>

<span class="keyword1"><span class="command">theory</span></span> Min_Ed_Dist0
<span class="keyword2"><span class="keyword">imports</span></span>
  <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/IArray.html">HOL-Library.IArray</a>"</span>
  <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/Code_Target_Numeral.html">HOL-Library.Code_Target_Numeral</a>"</span>
  <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/Product_Lexorder.html">HOL-Library.Product_Lexorder</a>"</span>
  <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/RBT_Mapping.html">HOL-Library.RBT_Mapping</a>"</span>
  <span class="quoted">"<a href="#State_Main">../state_monad/State_Main</a>"</span>
  <span class="quoted">"<a href="#Heap_Main">../heap_monad/Heap_Main</a>"</span>
  <a href="#Example_Misc">Example_Misc</a>
  <span class="quoted">"<a href="#Tracing">../util/Tracing</a>"</span>
  <span class="quoted">"<a href="#Ground_Function">../util/Ground_Function</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">"Misc"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">"Executable argmin"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">argmin</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>order<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">argmin</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">]</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">argmin</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">m</span> <span class="main">=</span> <span class="free">argmin</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">as</span></span></span> <span class="keyword1">in</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">m</span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="keyword1">else</span> <span class="bound">m</span><span class="main">)</span>"</span></span>
<span class="comment1">(* end rm *)</span>

<span class="comment1">(* Ex: Optimization of argmin *)</span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">argmin2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>order<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">*</span> <span class="tfree">'b</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">argmin2</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">]</span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">argmin2</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">fa</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">;</span> <span class="main">(</span><span class="bound">am</span><span class="main">,</span><span class="bound">m</span><span class="main">)</span> <span class="main">=</span> <span class="free">argmin2</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">as</span></span></span> <span class="keyword1">in</span> <span class="keyword1">if</span> <span class="bound">fa</span> <span class="main">≤</span> <span class="bound">m</span> <span class="keyword1">then</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">,</span> <span class="bound">fa</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="bound">am</span><span class="main">,</span><span class="bound">m</span><span class="main">)</span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">"Edit Distance"</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="tfree">'a</span> ed <span class="main">=</span> Copy <span class="main">|</span> Repl <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="main">|</span> Ins <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="main">|</span> Del

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">edit</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> ed list <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">edit</span> <span class="main">(</span>Copy <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">es</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free">edit</span> <span class="free"><span class="bound"><span class="entity">es</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">edit</span> <span class="main">(</span>Repl <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">es</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">#</span> <span class="free">edit</span> <span class="free"><span class="bound"><span class="entity">es</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">edit</span> <span class="main">(</span>Ins <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">es</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">#</span> <span class="free">edit</span> <span class="free"><span class="bound"><span class="entity">es</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">edit</span> <span class="main">(</span>Del <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">es</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">edit</span> <span class="free"><span class="bound"><span class="entity">es</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">edit</span> <span class="main">(</span>Copy <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">es</span></span></span><span class="main">)</span> <span class="main">[]</span> <span class="main">=</span> <span class="free">edit</span> <span class="free"><span class="bound"><span class="entity">es</span></span></span> <span class="main">[]</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">edit</span> <span class="main">(</span>Repl <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">es</span></span></span><span class="main">)</span> <span class="main">[]</span> <span class="main">=</span> <span class="free">edit</span> <span class="free"><span class="bound"><span class="entity">es</span></span></span> <span class="main">[]</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">edit</span> <span class="main">(</span>Del <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">es</span></span></span><span class="main">)</span> <span class="main">[]</span> <span class="main">=</span> <span class="free">edit</span> <span class="free"><span class="bound"><span class="entity">es</span></span></span> <span class="main">[]</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">edit</span> <span class="main">[]</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">cost</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">cost</span> <span class="free"><span class="bound"><span class="entity">es</span></span></span> <span class="main">≡</span> length <span class="main">[</span><span class="bound">e</span> <span class="main">&lt;-</span> <span class="free"><span class="bound"><span class="entity">es</span></span></span><span class="main">.</span> <span class="bound">e</span> <span class="main">≠</span> Copy<span class="main">]</span>"</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">"Minimum Edit Sequence"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">min_eds</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> ed list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">min_eds</span> <span class="main">[]</span> <span class="main">[]</span> <span class="main">=</span> <span class="main">[]</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">min_eds</span> <span class="main">[]</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="main">=</span> Ins <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free">min_eds</span> <span class="main">[]</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">min_eds</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">[]</span> <span class="main">=</span> Del <span class="main">#</span> <span class="free">min_eds</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">[]</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">min_eds</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="main">=</span>
  argmin cost <span class="main">[</span>Ins <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free">min_eds</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">,</span> Del <span class="main">#</span> <span class="free">min_eds</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span><span class="main">,</span>
     <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">then</span> Copy <span class="keyword1">else</span> Repl <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">#</span> <span class="free">min_eds</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">]</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"min_eds <span class="inner_quoted">''vintner''</span> <span class="inner_quoted">''writers''</span> <span class="main">=</span>
  <span class="main">[</span>Ins <span class="keyword1">CHR</span> <span class="inner_quoted">''w''</span><span class="main">,</span> Repl <span class="keyword1">CHR</span> <span class="inner_quoted">''r''</span><span class="main">,</span> Copy<span class="main">,</span> Del<span class="main">,</span> Copy<span class="main">,</span> Del<span class="main">,</span> Copy<span class="main">,</span> Copy<span class="main">,</span> Ins <span class="keyword1">CHR</span> <span class="inner_quoted">''s''</span><span class="main">]</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="comment1">(*
value "min_eds ''madagascar'' ''bananas''"

value "min_eds ''madagascaram'' ''banananas''"
*)</span>
<span class="keyword1" id="Min_Ed_Dist0-min_eds_correct"><span class="command">lemma</span></span> min_eds_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"edit <span class="main">(</span>min_eds <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="free">xs</span> <span class="main">=</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> min_eds.induct<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Min_Ed_Dist0-min_eds_same"><span class="command">lemma</span></span> min_eds_same<span class="main">:</span> <span class="quoted"><span class="quoted">"min_eds <span class="free">xs</span> <span class="free">xs</span> <span class="main">=</span> replicate <span class="main">(</span>length <span class="free">xs</span><span class="main">)</span> Copy"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Min_Ed_Dist0-min_eds_eq_Nil_iff"><span class="command">lemma</span></span> min_eds_eq_Nil_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"min_eds <span class="free">xs</span> <span class="free">ys</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">⟷</span> <span class="free">xs</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">∧</span> <span class="free">ys</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> min_eds.induct<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Min_Ed_Dist0-min_eds_Nil"><span class="command">lemma</span></span> min_eds_Nil<span class="main">:</span> <span class="quoted"><span class="quoted">"min_eds <span class="main">[]</span> <span class="free">ys</span> <span class="main">=</span> map Ins <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Min_Ed_Dist0-min_eds_Nil2"><span class="command">lemma</span></span> min_eds_Nil2<span class="main">:</span> <span class="quoted"><span class="quoted">"min_eds <span class="free">xs</span> <span class="main">[]</span> <span class="main">=</span> replicate <span class="main">(</span>length <span class="free">xs</span><span class="main">)</span> Del"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Min_Ed_Dist0-if_edit_Nil2"><span class="command">lemma</span></span> if_edit_Nil2<span class="main">:</span> <span class="quoted"><span class="quoted">"edit <span class="free">es</span> <span class="main">(</span><span class="main">[]</span><span class="main">::</span><span class="tfree">'a</span> list<span class="main">)</span> <span class="main">=</span> <span class="free">ys</span> <span class="main">⟹</span> length <span class="free">ys</span> <span class="main">≤</span> cost <span class="free">es</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">es</span></span> <span class="quoted"><span class="quoted">"<span class="main">[]</span><span class="main">::</span><span class="tfree">'a</span> list"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> edit.induct<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Min_Ed_Dist0-if_edit_eq_Nil"><span class="command">lemma</span></span> if_edit_eq_Nil<span class="main">:</span> <span class="quoted"><span class="quoted">"edit <span class="free">es</span> <span class="free">xs</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">⟹</span> length <span class="free">xs</span> <span class="main">≤</span> cost <span class="free">es</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">es</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> edit.induct<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Min_Ed_Dist0-min_eds_minimal"><span class="command">lemma</span></span> min_eds_minimal<span class="main">:</span> <span class="quoted"><span class="quoted">"edit <span class="free">es</span> <span class="free">xs</span> <span class="main">=</span> <span class="free">ys</span> <span class="main">⟹</span> cost<span class="main">(</span>min_eds <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">≤</span> cost <span class="free">es</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">es</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> min_eds.induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 1 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> 2 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> min_eds_Nil <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> if_edit_Nil2<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> 3
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> min_eds_Nil2 <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> if_edit_eq_Nil<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> 4
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">es</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted">"4.prems"</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> min_eds_same<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="main">(</span>Cons <span class="skolem">e</span> <span class="skolem">es'</span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">e</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> Copy
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted">"4.prems"</span> <span class="quoted">"4.IH"</span><span class="main">(</span>3<span class="main">)</span><span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">es'</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Repl <span class="skolem">a</span><span class="main">)</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted">"4.prems"</span> <span class="quoted">"4.IH"</span><span class="main">(</span>3<span class="main">)</span><span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">es'</span></span><span class="main">]</span>
        <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">simp_depth_limit</span><span class="main"><span class="main">=</span></span>1<span class="main">]</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Ins <span class="skolem">a</span><span class="main">)</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted">"4.prems"</span> <span class="quoted">"4.IH"</span><span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">es'</span></span><span class="main">]</span>
        <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">simp_depth_limit</span><span class="main"><span class="main">=</span></span>1<span class="main">]</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> Del
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted">"4.prems"</span> <span class="quoted">"4.IH"</span><span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">es'</span></span><span class="main">]</span>
        <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">simp_depth_limit</span><span class="main"><span class="main">=</span></span>1<span class="main">]</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">"Computing the Minimum Edit Distance"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">min_ed</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">min_ed</span> <span class="main">[]</span> <span class="main">[]</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">min_ed</span> <span class="main">[]</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span> <span class="main">+</span> <span class="free">min_ed</span> <span class="main">[]</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">min_ed</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">[]</span> <span class="main">=</span> <span class="main">1</span> <span class="main">+</span> <span class="free">min_ed</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">[]</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">min_ed</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="main">=</span>
  Min <span class="main">{</span><span class="main">1</span> <span class="main">+</span> <span class="free">min_ed</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">,</span> <span class="main">1</span> <span class="main">+</span> <span class="free">min_ed</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> <span class="main">1</span><span class="main">)</span> <span class="main">+</span> <span class="free">min_ed</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1" id="Min_Ed_Dist0-min_ed_min_eds"><span class="command">lemma</span></span> min_ed_min_eds<span class="main">:</span> <span class="quoted"><span class="quoted">"min_ed <span class="free">xs</span> <span class="free">ys</span> <span class="main">=</span> cost<span class="main">(</span>min_eds <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> min_ed.induct<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"min_ed <span class="inner_quoted">''madagascar''</span> <span class="inner_quoted">''bananas''</span> <span class="main">=</span> <span class="numeral">6</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="comment1">(*
value "min_ed ''madagascaram'' ''banananas''"
*)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">"Exercise: Optimization of the Copy case"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">min_eds2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> ed list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">min_eds2</span> <span class="main">[]</span> <span class="main">[]</span> <span class="main">=</span> <span class="main">[]</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">min_eds2</span> <span class="main">[]</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="main">=</span> Ins <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free">min_eds2</span> <span class="main">[]</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">min_eds2</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">[]</span> <span class="main">=</span> Del <span class="main">#</span> <span class="free">min_eds2</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">[]</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">min_eds2</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">then</span> Copy <span class="main">#</span> <span class="free">min_eds2</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span>
   <span class="keyword1">else</span> argmin cost
     <span class="main">[</span>Ins <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free">min_eds2</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">,</span> Del <span class="main">#</span> <span class="free">min_eds2</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span><span class="main">,</span> Repl <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free">min_eds2</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">]</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"min_eds2 <span class="inner_quoted">''madagascar''</span> <span class="inner_quoted">''bananas''</span>"</span></span>

<span class="keyword1" id="Min_Ed_Dist0-cost_Copy_Del"><span class="command">lemma</span></span> cost_Copy_Del<span class="main">:</span> <span class="quoted"><span class="quoted">"cost<span class="main">(</span>min_eds <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">≤</span> cost <span class="main">(</span>min_eds <span class="free">xs</span> <span class="main">(</span><span class="free">x</span><span class="main">#</span><span class="free">ys</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> min_eds.induct<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> filter_True filter_False <span class="quasi_keyword">split</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Min_Ed_Dist0-cost_Copy_Ins"><span class="command">lemma</span></span> cost_Copy_Ins<span class="main">:</span> <span class="quoted"><span class="quoted">"cost<span class="main">(</span>min_eds <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">≤</span> cost <span class="main">(</span>min_eds <span class="main">(</span><span class="free">x</span><span class="main">#</span><span class="free">xs</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> min_eds.induct<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> filter_True filter_False <span class="quasi_keyword">split</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"cost<span class="main">(</span>min_eds2 <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> cost<span class="main">(</span>min_eds <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> min_eds2.induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>4 <span class="skolem">x</span> <span class="skolem">xs</span> <span class="skolem">y</span> <span class="skolem">ys</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> if_split<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> Suc_eq_plus1 Suc_leI cost_Copy_Del cost_Copy_Ins le_imp_less_Suc le_neq_implies_less not_less<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> Suc_eq_plus1 cost_Copy_Del le_antisym<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Suc_eq_plus1 cost_Copy_Ins le_antisym<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"min_eds2 <span class="free">xs</span> <span class="free">ys</span> <span class="main">=</span> min_eds <span class="free">xs</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">oops</span></span>
<span class="comment1">(* Not proveable because Copy comes last in min_eds but first in min_eds2.
   Can reorder, but the proof still requires the same two lemmas cost_*_* above.
*)</span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">"Indexing"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">"Indexing lists"</span></span>

<span class="keyword1"><span class="command">context</span></span>
<span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list"</span></span>
<span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">m</span> <span class="free">n</span> <span class="main">::</span> <span class="quoted">nat</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">function</span></span> <span class="main">(</span>sequential<span class="main">)</span>
  <span class="entity">min_ed_ix'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">*</span> nat <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">min_ed_ix'</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">≥</span> <span class="free">m</span> <span class="keyword1">then</span>
     <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">≥</span> <span class="free">n</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> <span class="main">1</span> <span class="main">+</span> <span class="free">min_ed_ix'</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">+</span><span class="main">1</span><span class="main">)</span> <span class="keyword1">else</span>
   <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">≥</span> <span class="free">n</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="main">+</span> <span class="free">min_ed_ix'</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">+</span><span class="main">1</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">)</span>
   <span class="keyword1">else</span>
   Min <span class="main">{</span><span class="main">1</span> <span class="main">+</span> <span class="free">min_ed_ix'</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">+</span><span class="main">1</span><span class="main">)</span><span class="main">,</span> <span class="main">1</span> <span class="main">+</span> <span class="free">min_ed_ix'</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">+</span><span class="main">1</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">)</span><span class="main">,</span>
       <span class="main">(</span><span class="keyword1">if</span> <span class="free">xs</span><span class="main">!</span><span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">=</span> <span class="free">ys</span><span class="main">!</span><span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> <span class="main">1</span><span class="main">)</span> <span class="main">+</span> <span class="free">min_ed_ix'</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">+</span><span class="main">1</span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">+</span><span class="main">1</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">pat_completeness</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">termination</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">relation</span> <span class="quoted"><span class="quoted">"measure<span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">i</span><span class="main">,</span><span class="bound">j</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">m</span> <span class="main">-</span> <span class="bound">i</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="free">n</span> <span class="main">-</span> <span class="bound">j</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>


<span class="keyword1"><span class="command">declare</span></span> min_ed_ix'.simps<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Min_Ed_Dist0-min_ed_ix'_min_ed"><span class="command">lemma</span></span> min_ed_ix'_min_ed<span class="main">:</span>
  <span class="quoted"><span class="quoted">"min_ed_ix' <span class="free">xs</span> <span class="free">ys</span> <span class="main">(</span>length <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>length <span class="free">ys</span><span class="main">)</span> <span class="main">(</span><span class="free">i</span><span class="main">,</span> <span class="free">j</span><span class="main">)</span> <span class="main">=</span> min_ed <span class="main">(</span>drop <span class="free">i</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>drop <span class="free">j</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">i</span><span class="main">,</span><span class="free">j</span><span class="main">)</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">i</span></span> <span class="quoted"><span class="free">j</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> min_ed_ix'.induct<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"length <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"length <span class="free">ys</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> min_ed_ix'.simps<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Cons_nth_drop_Suc<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">"Indexing functions"</span></span>

<span class="keyword1"><span class="command">context</span></span>
<span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
<span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">m</span> <span class="free">n</span> <span class="main">::</span> <span class="quoted">nat</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">function</span></span> <span class="main">(</span>sequential<span class="main">)</span>
  <span class="entity">min_ed_ix</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">×</span> nat <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">min_ed_ix</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">≥</span> <span class="free">m</span> <span class="keyword1">then</span>
     <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">≥</span> <span class="free">n</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> <span class="free">n</span><span class="main">-</span><span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="keyword1">else</span>
   <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">≥</span> <span class="free">n</span> <span class="keyword1">then</span> <span class="free">m</span><span class="main">-</span><span class="free"><span class="bound"><span class="entity">i</span></span></span>
   <span class="keyword1">else</span>
   min_list <span class="main">[</span><span class="main">1</span> <span class="main">+</span> <span class="free">min_ed_ix</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">+</span><span class="main">1</span><span class="main">)</span><span class="main">,</span> <span class="main">1</span> <span class="main">+</span> <span class="free">min_ed_ix</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">+</span><span class="main">1</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">)</span><span class="main">,</span>
       <span class="main">(</span><span class="keyword1">if</span> <span class="free">xs</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">=</span> <span class="free">ys</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> <span class="main">1</span><span class="main">)</span> <span class="main">+</span> <span class="free">min_ed_ix</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">+</span><span class="main">1</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">+</span><span class="main">1</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">pat_completeness</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">termination</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">relation</span> <span class="quoted"><span class="quoted">"measure<span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">i</span><span class="main">,</span><span class="bound">j</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">m</span> <span class="main">-</span> <span class="bound">i</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="free">n</span> <span class="main">-</span> <span class="bound">j</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Functional Memoization›</span></span>

<span class="keyword1"><span class="command">memoize_fun</span></span> min_ed_ix<span class="hidden">⇩</span><sub>m</sub><span class="main">:</span> <span class="quoted">min_ed_ix</span> <span class="keyword2"><span class="keyword">with_memory</span></span> dp_consistency_mapping <span class="keyword1"><span class="command">monadifies</span></span> <span class="main">(</span>state<span class="main">)</span> min_ed_ix.simps
<span class="keyword1"><span class="command">thm</span></span> min_ed_ix<span class="hidden">⇩</span><sub>m</sub>'.simps

<span class="keyword1"><span class="command">memoize_correct</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">memoize_prover</span>
<span class="keyword1"><span class="command">print_theorems</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> min_ed_ix<span class="hidden">⇩</span><sub>m</sub>.memoized_correct

<span class="keyword1"><span class="command">declare</span></span> min_ed_ix.simps<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Imperative Memoization›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">mem</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat ref <span class="main">×</span> nat ref <span class="main">×</span> nat option array ref <span class="main">×</span> nat option array ref"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> mem_is_init<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">mem</span> <span class="main">=</span> result_of <span class="main">(</span>init_state <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="free">m</span> <span class="main">(</span><span class="free">m</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span> Heap.empty"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> iterator
  <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="free">m</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">≤</span> <span class="free">n</span> <span class="main">∧</span> <span class="bound">x</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">y</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="bound">x</span> <span class="main">-</span> <span class="main">1</span><span class="main">,</span> <span class="free">n</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">m</span> <span class="main">-</span> <span class="bound">x</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="free">n</span> <span class="main">-</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> table_iterator_down<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"dp_consistency_heap_array_pair' <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> fst snd id <span class="free">m</span> <span class="main">(</span><span class="free">m</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="free">mem</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mem_is_init injective_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"dp_consistency_heap_array_pair_iterator <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> fst snd id <span class="free">m</span> <span class="main">(</span><span class="free">m</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="free">mem</span>
   <span class="main">(</span><span class="main">λ</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">y</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="bound">x</span> <span class="main">-</span> <span class="main">1</span><span class="main">,</span> <span class="free">n</span><span class="main">)</span><span class="main">)</span>
   <span class="main">(</span><span class="main">λ</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">m</span> <span class="main">-</span> <span class="bound">x</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="free">n</span> <span class="main">-</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>
   <span class="main">(</span><span class="main">λ</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="free">m</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">≤</span> <span class="free">n</span> <span class="main">∧</span> <span class="bound">x</span> <span class="main">&gt;</span> <span class="main">0</span><span class="main">)</span>
  "</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mem_is_init injective_def<span class="main">)</span>

<span class="keyword1"><span class="command">memoize_fun</span></span> min_ed_ix<span class="hidden">⇩</span><sub>h</sub><span class="main">:</span> <span class="quoted">min_ed_ix</span>
  <span class="keyword2"><span class="keyword">with_memory</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">default_proof</span></span><span class="main">)</span> dp_consistency_heap_array_pair_iterator
  <span class="keyword2"><span class="keyword">where</span></span> size <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> key1<span class="main">=</span><span class="quoted"><span class="quoted">"fst <span class="main">::</span> nat <span class="main">×</span> nat <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">and</span></span> key2<span class="main">=</span><span class="quoted"><span class="quoted">"snd <span class="main">::</span> nat <span class="main">×</span> nat <span class="main">⇒</span> nat"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> k1<span class="main">=</span><span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">::</span> nat"</span></span> <span class="keyword2"><span class="keyword">and</span></span> k2<span class="main">=</span><span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">+</span> <span class="main">1</span> <span class="main">::</span> nat"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> to_index <span class="main">=</span> <span class="quoted"><span class="quoted">"id <span class="main">::</span> nat <span class="main">⇒</span> nat"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> mem <span class="main">=</span> <span class="quoted"><span class="free">mem</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> cnt <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="free">m</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">≤</span> <span class="free">n</span> <span class="main">∧</span> <span class="bound">x</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> nxt <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="main">(</span><span class="bound">x</span><span class="main">::</span>nat<span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">y</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="bound">x</span> <span class="main">-</span> <span class="main">1</span><span class="main">,</span> <span class="free">n</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> sizef <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">m</span> <span class="main">-</span> <span class="bound">x</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="free">n</span> <span class="main">-</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">monadifies</span></span> <span class="main">(</span>heap<span class="main">)</span> min_ed_ix.simps

<span class="keyword1"><span class="command">memoize_correct</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">memoize_prover</span>

<span class="keyword1"><span class="command">lemmas</span></span> memoized_empty <span class="main">=</span>
  min_ed_ix<span class="hidden">⇩</span><sub>h</sub>.memoized_empty<span class="main">[</span><span class="operator">OF</span> min_ed_ix<span class="hidden">⇩</span><sub>h</sub>.consistent_DP_iter_and_compute<span class="main"><span class="main">[</span></span><span class="operator">OF</span> min_ed_ix<span class="hidden">⇩</span><sub>h</sub>.crel<span class="main"><span class="main">]</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> iter_heap_unfold <span class="main">=</span> iter_heap_unfold

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Fixed Memory *)</span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Test Cases›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">slice</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">≡</span> map <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">..&lt;</span><span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">]</span>"</span></span>

<span class="keyword1" id="Min_Ed_Dist0-min_ed_Nil1"><span class="command">lemma</span></span> min_ed_Nil1<span class="main">:</span> <span class="quoted"><span class="quoted">"min_ed <span class="main">[]</span> <span class="free">ys</span> <span class="main">=</span> length <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Min_Ed_Dist0-min_ed_Nil2"><span class="command">lemma</span></span> min_ed_Nil2<span class="main">:</span> <span class="quoted"><span class="quoted">"min_ed <span class="free">xs</span> <span class="main">[]</span> <span class="main">=</span> length <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="comment1">(* prove correctness of min_ed_ix directly ? *)</span>
<span class="keyword1" id="Min_Ed_Dist0-min_ed_ix_min_ed"><span class="command">lemma</span></span> min_ed_ix_min_ed<span class="main">:</span> <span class="quoted"><span class="quoted">"min_ed_ix <span class="free">xs</span> <span class="free">ys</span> <span class="free">m</span> <span class="free">n</span> <span class="main">(</span><span class="free">i</span><span class="main">,</span><span class="free">j</span><span class="main">)</span> <span class="main">=</span> min_ed <span class="main">(</span>slice <span class="free">xs</span> <span class="free">i</span> <span class="free">m</span><span class="main">)</span> <span class="main">(</span>slice <span class="free">ys</span> <span class="free">j</span> <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">i</span><span class="main">,</span><span class="free">j</span><span class="main">)</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">i</span></span> <span class="quoted"><span class="free">j</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> min_ed_ix.induct<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">m</span></span> <span class="quoted"><span class="free">n</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> min_ed_ix.simps upt_conv_Cons min_ed_Nil1 min_ed_Nil2 Suc_diff_Suc<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Functional Test Cases›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">min_ed_list</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">=</span> min_ed_ix <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">!</span><span class="bound">i</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">!</span><span class="bound">i</span><span class="main">)</span> <span class="main">(</span>length <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">(</span>length <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="main">0</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"min_ed_list <span class="inner_quoted">''madagascar''</span> <span class="inner_quoted">''bananas''</span> <span class="main">=</span> <span class="numeral">6</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">min_ed_ia</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">a</span> <span class="main">=</span> IArray <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">;</span> <span class="bound">b</span> <span class="main">=</span> IArray <span class="free"><span class="bound"><span class="entity">ys</span></span></span>
  <span class="keyword1">in</span> min_ed_ix <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="bound">a</span><span class="main">!!</span><span class="bound">i</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="bound">b</span><span class="main">!!</span><span class="bound">i</span><span class="main">)</span> <span class="main">(</span>length <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">(</span>length <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="main">0</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"min_ed_ia <span class="inner_quoted">''madagascar''</span> <span class="inner_quoted">''bananas''</span> <span class="main">=</span> <span class="numeral">6</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>



<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Extracting an Executable Constant for the Imperative Implementation›</span></span>

<span class="keyword1"><span class="command">ground_function</span></span> <span class="entity">min_ed_ix<span class="hidden">⇩</span><sub>h</sub>'_impl</span><span class="main">:</span> min_ed_ix<span class="hidden">⇩</span><sub>h</sub>'.simps
<span class="keyword1"><span class="command">termination</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">relation</span> <span class="quoted"><span class="quoted">"measure<span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="bound">ys</span><span class="main">,</span> <span class="bound">m</span><span class="main">,</span> <span class="bound">n</span><span class="main">,</span> <span class="bound">mem</span><span class="main">,</span> <span class="bound">i</span><span class="main">,</span> <span class="bound">j</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">m</span> <span class="main">-</span> <span class="bound">i</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="bound">n</span> <span class="main">-</span> <span class="bound">j</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword">del</span></span><span class="main">]</span> <span class="main">=</span> min_ed_ix<span class="hidden">⇩</span><sub>h</sub>'_impl.simps min_ed_ix<span class="hidden">⇩</span><sub>h</sub>'.simps

<span class="keyword1" id="Min_Ed_Dist0-min_ed_ix"><span class="command">lemma</span></span> min_ed_ix<span class="hidden">⇩</span><sub>h</sub>'_impl_def<span class="main">:</span>
  <span class="keyword2"><span class="keyword">includes</span></span> heap_monad_syntax
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">m</span> <span class="free">n</span> <span class="main">::</span> <span class="quoted">nat</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">mem</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat ref <span class="main">×</span> nat ref <span class="main">×</span> nat option array ref <span class="main">×</span> nat option array ref"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> mem_is_init<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">mem</span> <span class="main">=</span> result_of <span class="main">(</span>init_state <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="free">m</span> <span class="main">(</span><span class="free">m</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span> Heap.empty"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"min_ed_ix<span class="hidden">⇩</span><sub>h</sub>'_impl <span class="free">xs</span> <span class="free">ys</span> <span class="free">m</span> <span class="free">n</span> <span class="free">mem</span> <span class="main">=</span> min_ed_ix<span class="hidden">⇩</span><sub>h</sub>' <span class="free">xs</span> <span class="free">ys</span> <span class="free">m</span> <span class="free">n</span> <span class="free">mem</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"min_ed_ix<span class="hidden">⇩</span><sub>h</sub>'_impl <span class="free">xs</span> <span class="free">ys</span> <span class="free">m</span> <span class="free">n</span> <span class="free">mem</span> <span class="main">(</span><span class="skolem">i</span><span class="main">,</span> <span class="skolem">j</span><span class="main">)</span> <span class="main">=</span> min_ed_ix<span class="hidden">⇩</span><sub>h</sub>' <span class="free">xs</span> <span class="free">ys</span> <span class="free">m</span> <span class="free">n</span> <span class="free">mem</span> <span class="main">(</span><span class="skolem">i</span><span class="main">,</span> <span class="skolem">j</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">i</span> <span class="skolem">j</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> min_ed_ix<span class="hidden">⇩</span><sub>h</sub>'.induct<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mem_is_init<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> min_ed_ix<span class="hidden">⇩</span><sub>h</sub>'_impl.simps<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> min_ed_ix<span class="hidden">⇩</span><sub>h</sub>'.simps<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mem_is_init<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">solve_cong</span> <span class="operator">simp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">iter_min_ed_ix</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">mem</span></span></span> <span class="main">=</span> iterator_defs.iter_heap
    <span class="main">(</span><span class="main">λ</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">∧</span> <span class="bound">x</span> <span class="main">&gt;</span> <span class="main">0</span><span class="main">)</span>
    <span class="main">(</span><span class="main">λ</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">y</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="bound">x</span> <span class="main">-</span> <span class="main">1</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span><span class="main">)</span>
    <span class="main">(</span>min_ed_ix<span class="hidden">⇩</span><sub>h</sub>'_impl <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">mem</span></span></span><span class="main">)</span>
  "</span></span>

<span class="keyword1" id="Min_Ed_Dist0-iter_min_ed_ix_unfold"><span class="command">lemma</span></span> iter_min_ed_ix_unfold<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"iter_min_ed_ix <span class="free">xs</span> <span class="free">ys</span> <span class="free">m</span> <span class="free">n</span> <span class="free">mem</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span> <span class="main">(</span><span class="bound">i</span><span class="main">,</span> <span class="bound">j</span><span class="main">)</span><span class="main">.</span>
    <span class="main">(</span><span class="keyword1">if</span> <span class="bound">i</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="main">∧</span> <span class="bound">i</span> <span class="main">≤</span> <span class="free">m</span> <span class="main">∧</span> <span class="bound">j</span> <span class="main">≤</span> <span class="free">n</span>
     <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
            min_ed_ix<span class="hidden">⇩</span><sub>h</sub>'_impl <span class="free">xs</span> <span class="free">ys</span> <span class="free">m</span> <span class="free">n</span> <span class="free">mem</span> <span class="main">(</span><span class="bound">i</span><span class="main">,</span> <span class="bound">j</span><span class="main">)</span><span class="main">;</span>
            iter_min_ed_ix <span class="free">xs</span> <span class="free">ys</span> <span class="free">m</span> <span class="free">n</span> <span class="free">mem</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">j</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">(</span><span class="bound">i</span><span class="main">,</span> <span class="bound">j</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="bound">i</span> <span class="main">-</span> <span class="main">1</span><span class="main">,</span> <span class="free">n</span><span class="main">)</span><span class="main">)</span>
          <span class="main">}</span>
     <span class="keyword1">else</span> Heap_Monad.return <span class="main">()</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> iter_min_ed_ix_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span> <span class="main">(</span><span class="operator">safe</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> iter_heap_unfold<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">min_ed_ix_impl</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">mem</span> <span class="main">←</span> <span class="main">(</span>init_state <span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">::</span>nat<span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">::</span>
      <span class="main">(</span>nat ref <span class="main">×</span> nat ref <span class="main">×</span> nat option array ref <span class="main">×</span> nat option array ref<span class="main">)</span> Heap<span class="main">)</span><span class="main">;</span>
    iter_min_ed_ix <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="bound">mem</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span><span class="main">;</span>
    min_ed_ix<span class="hidden">⇩</span><sub>h</sub>'_impl <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="bound">mem</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1" id="Min_Ed_Dist0-bf_impl_correct"><span class="command">lemma</span></span> bf_impl_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"min_ed_ix <span class="free">xs</span> <span class="free">ys</span> <span class="free">m</span> <span class="free">n</span> <span class="main">(</span><span class="free">i</span><span class="main">,</span> <span class="free">j</span><span class="main">)</span> <span class="main">=</span> result_of <span class="main">(</span>min_ed_ix_impl <span class="free">xs</span> <span class="free">ys</span> <span class="free">m</span> <span class="free">n</span> <span class="free">i</span> <span class="free">j</span><span class="main">)</span> Heap.empty"</span></span>
  <span class="keyword1"><span class="command">using</span></span> memoized_empty<span class="main">[</span><span class="operator">OF</span> HOL.refl<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quoted"><span class="free">m</span></span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">i</span><span class="main">,</span> <span class="free">j</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">(</span><span class="free">m</span><span class="main">,</span> <span class="free">n</span><span class="main">)</span>"</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>
      execute_bind_success<span class="main"><span class="main">[</span></span><span class="operator">OF</span> succes_init_state<span class="main"><span class="main">]</span></span> min_ed_ix_impl_def min_ed_ix<span class="hidden">⇩</span><sub>h</sub>'_impl_def
      iter_min_ed_ix_def
     <span class="main">)</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Imperative Test Case›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">min_ed_ia<span class="hidden">⇩</span><sub>h</sub></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">a</span> <span class="main">=</span> IArray <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">;</span> <span class="bound">b</span> <span class="main">=</span> IArray <span class="free"><span class="bound"><span class="entity">ys</span></span></span>
  <span class="keyword1">in</span> min_ed_ix_impl <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="bound">a</span><span class="main">!!</span><span class="bound">i</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="bound">b</span><span class="main">!!</span><span class="bound">i</span><span class="main">)</span> <span class="main">(</span>length <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">(</span>length <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="main">0</span> <span class="main">0</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">test_case</span> <span class="main">=</span> min_ed_ia<span class="hidden">⇩</span><sub>h</sub> <span class="inner_quoted">''madagascar''</span> <span class="inner_quoted">''bananas''</span>"</span></span>

<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">min_ed_ix</span></span> <span class="keyword2"><span class="keyword">in</span></span> SML <span class="keyword2"><span class="keyword">module_name</span></span> Test

<span class="keyword1"><span class="command">code_reflect</span></span> Test <span class="keyword2"><span class="keyword">functions</span></span> test_case

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹One can see a trace of the calls to the memory in the output›</span></span>
<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹Test.test_case <span class="main">(</span><span class="main">)</span>›</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="OptBST">
<div class="head">
<h1>Theory OptBST</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Optimal Binary Search Trees›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The material presented in this section just contains a simple and non-optimal version
(cubic instead of quadratic in the number of keys).
It can now be viewed to be superseded by the AFP entry <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Optimal_BST›</span></span></span></span>.
It is kept here as a more easily understandable example and for archival purposes.
›</span></span>

<span class="keyword1"><span class="command">theory</span></span> OptBST
<span class="keyword2"><span class="keyword">imports</span></span>
  <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/Tree.html">HOL-Library.Tree</a>"</span>
  <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/Code_Target_Numeral.html">HOL-Library.Code_Target_Numeral</a>"</span>
  <span class="quoted">"<a href="#State_Main">../state_monad/State_Main</a>"</span> 
  <span class="quoted">"<a href="#Heap_Default">../heap_monad/Heap_Default</a>"</span>
  <a href="#Example_Misc">Example_Misc</a>
  <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/Product_Lexorder.html">HOL-Library.Product_Lexorder</a>"</span>
  <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/RBT_Mapping.html">HOL-Library.RBT_Mapping</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>argmin›</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>argmin›</span></span></span></span> iterates over a list and returns the rightmost element
that minimizes a given function:›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">argmin</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">::</span>linorder<span class="main">)</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">argmin</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="main">[]</span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">else</span>
   <span class="keyword1">let</span> <span class="bound">m</span> <span class="main">=</span> <span class="free">argmin</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">in</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">m</span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">else</span> <span class="bound">m</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Note that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">arg_min_list</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is similar but returns the leftmost element.›</span></span>

<span class="keyword1" id="OptBST-argmin_forall"><span class="command">lemma</span></span> argmin_forall<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">∈</span>set <span class="free">xs</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span>argmin <span class="free">f</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>

<span class="keyword1" id="OptBST-argmin_Min"><span class="command">lemma</span></span> argmin_Min<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">(</span>argmin <span class="free">f</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> Min <span class="main">(</span><span class="free">f</span> <span class="main">`</span> set <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> min_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> antisym<span class="main">)</span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Misc›</span></span>

<span class="keyword1" id="OptBST-upto_join"><span class="command">lemma</span></span> upto_join<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">i</span> <span class="main">≤</span> <span class="free">j</span><span class="main">;</span> <span class="free">j</span> <span class="main">≤</span> <span class="free">k</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">[</span><span class="free">i</span><span class="main">..</span><span class="free">j</span><span class="main">-</span><span class="main">1</span><span class="main">]</span> <span class="main">@</span> <span class="free">j</span> <span class="main">#</span> <span class="main">[</span><span class="free">j</span><span class="main">+</span><span class="main">1</span><span class="main">..</span><span class="free">k</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="free">i</span><span class="main">..</span><span class="free">k</span><span class="main">]</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> upto_rec1 upto_split1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="OptBST-atLeastAtMost_split"><span class="command">lemma</span></span> atLeastAtMost_split<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">i</span><span class="main">..</span><span class="free">j</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="free">i</span><span class="main">..</span><span class="free">k</span><span class="main">}</span> <span class="main">∪</span> <span class="main">{</span><span class="free">k</span><span class="main">+</span><span class="main">1</span><span class="main">..</span><span class="free">j</span><span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">≤</span> <span class="free">k</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">≤</span> <span class="free">j</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">i</span> <span class="free">j</span> <span class="free">k</span> <span class="main">::</span> <span class="quoted">int</span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="OptBST-atLeastAtMost_split_insert"><span class="command">lemma</span></span> atLeastAtMost_split_insert<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">i</span><span class="main">..</span><span class="free">k</span><span class="main">}</span> <span class="main">=</span> insert <span class="free">k</span> <span class="main">{</span><span class="free">i</span><span class="main">..</span><span class="free">k</span><span class="main">-</span><span class="main">1</span><span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">≥</span> <span class="free">i</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">i</span> <span class="main">::</span> <span class="quoted">int</span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Definitions›</span></span>

<span class="keyword1"><span class="command">context</span></span>
<span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">W</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"int <span class="main">⇒</span> int <span class="main">⇒</span> nat"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">wpl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"int <span class="main">⇒</span> int <span class="main">⇒</span> int tree <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
   <span class="quoted"><span class="quoted">"<span class="free">wpl</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> Leaf <span class="main">=</span> <span class="main">0</span>"</span></span>
 <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">wpl</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">wpl</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">-</span><span class="main">1</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">+</span> <span class="free">wpl</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">+</span><span class="main">1</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">+</span> <span class="free">W</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">j</span></span></span>"</span></span>

<span class="keyword1"><span class="command">function</span></span> <span class="entity">min_wpl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"int <span class="main">⇒</span> int <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">min_wpl</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">&gt;</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="keyword1">then</span> <span class="main">0</span>
   <span class="keyword1">else</span> min_list <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">k</span><span class="main">.</span> <span class="free">min_wpl</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">(</span><span class="bound">k</span><span class="main">-</span><span class="main">1</span><span class="main">)</span> <span class="main">+</span> <span class="free">min_wpl</span> <span class="main">(</span><span class="bound">k</span><span class="main">+</span><span class="main">1</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">+</span> <span class="free">W</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">)</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">..</span><span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">]</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">termination</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">relation</span> <span class="quoted"><span class="quoted">"measure <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">i</span><span class="main">,</span><span class="bound">j</span><span class="main">)</span> <span class="main">.</span> nat<span class="main">(</span><span class="bound">j</span><span class="main">-</span><span class="bound">i</span><span class="main">+</span><span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">declare</span></span> min_wpl.simps<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>

<span class="keyword1"><span class="command">function</span></span> <span class="entity">opt_bst</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"int <span class="main">⇒</span> int <span class="main">⇒</span> int tree"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">opt_bst</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">&gt;</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="keyword1">then</span> Leaf <span class="keyword1">else</span> argmin <span class="main">(</span>wpl <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">)</span> <span class="main">[</span><span class="main">⟨</span><span class="free">opt_bst</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">(</span><span class="bound">k</span><span class="main">-</span><span class="main">1</span><span class="main">)</span><span class="main">,</span> <span class="bound">k</span><span class="main">,</span> <span class="free">opt_bst</span> <span class="main">(</span><span class="bound">k</span><span class="main">+</span><span class="main">1</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">⟩</span><span class="main">.</span> k <span class="main">←</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">..</span><span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">]</span><span class="main">]</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">termination</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">relation</span> <span class="quoted"><span class="quoted">"measure <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">i</span><span class="main">,</span><span class="bound">j</span><span class="main">)</span> <span class="main">.</span> nat<span class="main">(</span><span class="bound">j</span><span class="main">-</span><span class="bound">i</span><span class="main">+</span><span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">declare</span></span> opt_bst.simps<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Functional Memoization›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">n</span> <span class="main">::</span> <span class="quoted">nat</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">fixes</span></span>
  <span class="free">mem</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat option array"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">memoize_fun</span></span> min_wpl<span class="hidden">⇩</span><sub>T</sub><span class="main">:</span> <span class="quoted">min_wpl</span>
  <span class="keyword2"><span class="keyword">with_memory</span></span> dp_consistency_heap_default <span class="keyword2"><span class="keyword">where</span></span> bound <span class="main">=</span> <span class="quoted"><span class="quoted">"Bound <span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="main">0</span><span class="main">)</span> <span class="main">(</span>int <span class="free">n</span><span class="main">,</span> int <span class="free">n</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> mem<span class="main">=</span><span class="quoted"><span class="quoted">"<span class="free">mem</span>"</span></span>
  <span class="keyword1"><span class="command">monadifies</span></span> <span class="main">(</span>heap<span class="main">)</span> min_wpl.simps

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> heap_monad_syntax <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">thm</span></span> min_wpl<span class="hidden">⇩</span><sub>T</sub>'.simps min_wpl<span class="hidden">⇩</span><sub>T</sub>_def
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">memoize_correct</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">memoize_prover</span>

<span class="keyword1"><span class="command">lemmas</span></span> memoized_empty <span class="main">=</span> min_wpl<span class="hidden">⇩</span><sub>T</sub>.memoized_empty

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Fixed array *)</span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">includes</span></span> heap_monad_syntax
  <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span> <span class="main">=</span> min_wpl<span class="hidden">⇩</span><sub>T</sub>'.simps
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">min_wpl<span class="hidden">⇩</span><sub>h</sub></span> <span class="main">≡</span> <span class="main">λ</span> <span class="bound">i</span> <span class="bound">j</span><span class="main">.</span> Heap_Monad.bind <span class="main">(</span>mem_empty <span class="main">(</span><span class="free">n</span> <span class="main">*</span> <span class="free">n</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">mem</span><span class="main">.</span> min_wpl<span class="hidden">⇩</span><sub>T</sub>' <span class="bound">mem</span> <span class="bound">i</span> <span class="bound">j</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="OptBST-min_wpl_heap"><span class="command">lemma</span></span> min_wpl_heap<span class="main">:</span>
  <span class="quoted"><span class="quoted">"min_wpl <span class="free">i</span> <span class="free">j</span> <span class="main">=</span> result_of <span class="main">(</span>min_wpl<span class="hidden">⇩</span><sub>h</sub> <span class="free">i</span> <span class="free">j</span><span class="main">)</span> Heap.empty"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> min_wpl<span class="hidden">⇩</span><sub>h</sub>_def
  <span class="keyword1"><span class="command">using</span></span> memoized_empty<span class="main">[</span><span class="operator">of</span> <span class="main">_</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">m</span><span class="main">.</span> <span class="main">λ</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">.</span> min_wpl<span class="hidden">⇩</span><sub>T</sub>' <span class="bound">m</span> <span class="bound">a</span> <span class="bound">b</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">i</span><span class="main">,</span> <span class="free">j</span><span class="main">)</span>"</span></span><span class="main">,</span> <span class="operator">OF</span> min_wpl<span class="hidden">⇩</span><sub>T</sub>.crel<span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> index_size_defs<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Bound *)</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> state_monad_syntax <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">memoize_fun</span></span> min_wpl<span class="hidden">⇩</span><sub>m</sub><span class="main">:</span> <span class="quoted">min_wpl</span> <span class="keyword2"><span class="keyword">with_memory</span></span> dp_consistency_mapping <span class="keyword1"><span class="command">monadifies</span></span> <span class="main">(</span>state<span class="main">)</span> min_wpl.simps
<span class="keyword1"><span class="command">thm</span></span> min_wpl<span class="hidden">⇩</span><sub>m</sub>'.simps

<span class="keyword1"><span class="command">memoize_correct</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">memoize_prover</span>
<span class="keyword1"><span class="command">print_theorems</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> min_wpl<span class="hidden">⇩</span><sub>m</sub>.memoized_correct

<span class="keyword1"><span class="command">memoize_fun</span></span> opt_bst<span class="hidden">⇩</span><sub>m</sub><span class="main">:</span> <span class="quoted">opt_bst</span> <span class="keyword2"><span class="keyword">with_memory</span></span> dp_consistency_mapping <span class="keyword1"><span class="command">monadifies</span></span> <span class="main">(</span>state<span class="main">)</span> opt_bst.simps
<span class="keyword1"><span class="command">thm</span></span> opt_bst<span class="hidden">⇩</span><sub>m</sub>'.simps

<span class="keyword1"><span class="command">memoize_correct</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">memoize_prover</span>
<span class="keyword1"><span class="command">print_theorems</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> opt_bst<span class="hidden">⇩</span><sub>m</sub>.memoized_correct

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Correctness Proof›</span></span>

<span class="keyword1" id="OptBST-min_wpl_minimal"><span class="command">lemma</span></span> min_wpl_minimal<span class="main">:</span>
  <span class="quoted"><span class="quoted">"inorder <span class="free">t</span> <span class="main">=</span> <span class="main">[</span><span class="free">i</span><span class="main">..</span><span class="free">j</span><span class="main">]</span> <span class="main">⟹</span> min_wpl <span class="free">i</span> <span class="free">j</span> <span class="main">≤</span> wpl <span class="free">i</span> <span class="free">j</span> <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">i</span></span> <span class="quoted"><span class="free">j</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> wpl.induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">i</span> <span class="skolem">j</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> min_wpl.simps<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>2 <span class="skolem">i</span> <span class="skolem">j</span> <span class="skolem">l</span> <span class="skolem">k</span> <span class="skolem">r</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> 
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&gt;</span> <span class="skolem">j</span>"</span></span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> min_wpl.simps<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">arith</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="skolem">i</span> <span class="main">&gt;</span> <span class="skolem">j</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> kk_ij<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span><span class="main">∈</span>set<span class="main">[</span><span class="skolem">i</span><span class="main">..</span><span class="skolem">j</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> 2 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> set_inorder tree.set_intros<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
        
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?M</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">k</span><span class="main">.</span> min_wpl <span class="skolem">i</span> <span class="main">(</span><span class="bound">k</span><span class="main">-</span><span class="main">1</span><span class="main">)</span> <span class="main">+</span> min_wpl <span class="main">(</span><span class="bound">k</span><span class="main">+</span><span class="main">1</span><span class="main">)</span> <span class="skolem">j</span> <span class="main">+</span> <span class="free">W</span> <span class="skolem">i</span> <span class="skolem">j</span><span class="main">)</span> <span class="main">`</span> <span class="main">{</span><span class="skolem">i</span><span class="main">..</span><span class="skolem">j</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?w</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"min_wpl <span class="skolem">i</span> <span class="main">(</span><span class="skolem">k</span><span class="main">-</span><span class="main">1</span><span class="main">)</span> <span class="main">+</span> min_wpl <span class="main">(</span><span class="skolem">k</span><span class="main">+</span><span class="main">1</span><span class="main">)</span> <span class="skolem">j</span> <span class="main">+</span> <span class="free">W</span> <span class="skolem">i</span> <span class="skolem">j</span>"</span></span>
 
    <span class="keyword1"><span class="command">have</span></span> aux_min<span class="main">:</span><span class="quoted"><span class="quoted">"Min <span class="var">?M</span> <span class="main">≤</span> <span class="var">?w</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> Min_le<span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"finite <span class="var">?M</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?w</span> <span class="main">∈</span> <span class="var">?M</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> kk_ij <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>

    <span class="keyword1"><span class="command">have</span></span><span class="quoted"><span class="quoted">"inorder <span class="main">⟨</span><span class="skolem">l</span><span class="main">,</span><span class="skolem">k</span><span class="main">,</span><span class="skolem">r</span><span class="main">⟩</span> <span class="main">=</span> inorder <span class="skolem">l</span> <span class="main">@</span><span class="skolem">k</span><span class="main">#</span>inorder <span class="skolem">r</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> this <span class="keyword1"><span class="command">have</span></span> C<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">[</span><span class="skolem">i</span><span class="main">..</span><span class="skolem">j</span><span class="main">]</span> <span class="main">=</span> inorder <span class="skolem">l</span> <span class="main">@</span> <span class="skolem">k</span><span class="main">#</span>inorder <span class="skolem">r</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> 2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> D<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="skolem">i</span><span class="main">..</span><span class="skolem">j</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="skolem">i</span><span class="main">..</span><span class="skolem">k</span><span class="main">-</span><span class="main">1</span><span class="main">]</span><span class="main">@</span><span class="skolem">k</span><span class="main">#</span><span class="main">[</span><span class="skolem">k</span><span class="main">+</span><span class="main">1</span><span class="main">..</span><span class="skolem">j</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> kk_ij upto_rec1 upto_split1
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> atLeastAtMost_iff set_upto<span class="main">)</span> 

    <span class="keyword1"><span class="command">have</span></span> l_inorder<span class="main">:</span> <span class="quoted"><span class="quoted">"inorder <span class="skolem">l</span> <span class="main">=</span> <span class="main">[</span><span class="skolem">i</span><span class="main">..</span><span class="skolem">k</span><span class="main">-</span><span class="main">1</span><span class="main">]</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> C D append_Cons_eq_iff atLeastAtMost_iff set_upto<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> r_inorder<span class="main">:</span> <span class="quoted"><span class="quoted">"inorder <span class="skolem">r</span> <span class="main">=</span> <span class="main">[</span><span class="skolem">k</span><span class="main">+</span><span class="main">1</span><span class="main">..</span><span class="skolem">j</span><span class="main">]</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> C D append_Cons_eq_iff atLeastAtMost_iff set_upto<span class="main">)</span>

    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"min_wpl <span class="skolem">i</span> <span class="skolem">j</span> <span class="main">=</span> Min <span class="var">?M</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> min_wpl.simps min_list_Min<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">≤</span> <span class="var">?w</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> aux_min<span class="main">)</span>    
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">≤</span> wpl <span class="skolem">i</span> <span class="main">(</span><span class="skolem">k</span><span class="main">-</span><span class="main">1</span><span class="main">)</span> <span class="skolem">l</span> <span class="main">+</span> wpl <span class="main">(</span><span class="skolem">k</span><span class="main">+</span><span class="main">1</span><span class="main">)</span> <span class="skolem">j</span> <span class="skolem">r</span> <span class="main">+</span> <span class="free">W</span> <span class="skolem">i</span> <span class="skolem">j</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> l_inorder r_inorder <span class="quoted">"2.IH"</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> wpl <span class="skolem">i</span> <span class="skolem">j</span> <span class="main">⟨</span><span class="skolem">l</span><span class="main">,</span><span class="skolem">k</span><span class="main">,</span><span class="skolem">r</span><span class="main">⟩</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="OptBST-opt_bst_correct"><span class="command">lemma</span></span> opt_bst_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"inorder <span class="main">(</span>opt_bst <span class="free">i</span> <span class="free">j</span><span class="main">)</span> <span class="main">=</span> <span class="main">[</span><span class="free">i</span><span class="main">..</span><span class="free">j</span><span class="main">]</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">i</span></span> <span class="quoted"><span class="free">j</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> opt_bst.induct<span class="main">)</span>
     <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> opt_bst.simps upto_join <span class="main"><span class="keyword3">|</span></span> <span class="operator">rule</span> argmin_forall<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="OptBST-wpl_opt_bst"><span class="command">lemma</span></span> wpl_opt_bst<span class="main">:</span> <span class="quoted"><span class="quoted">"wpl <span class="free">i</span> <span class="free">j</span> <span class="main">(</span>opt_bst <span class="free">i</span> <span class="free">j</span><span class="main">)</span> <span class="main">=</span> min_wpl <span class="free">i</span> <span class="free">j</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">i</span></span> <span class="quoted"><span class="free">j</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> min_wpl.induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">i</span> <span class="skolem">j</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&gt;</span> <span class="skolem">j</span>"</span></span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> min_wpl.simps opt_bst.simps<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> *<span class="main">[</span><span class="operator">arith</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="skolem">i</span> <span class="main">&gt;</span> <span class="skolem">j</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?ts</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">⟨</span>opt_bst <span class="skolem">i</span> <span class="main">(</span><span class="bound">k</span><span class="main">-</span><span class="main">1</span><span class="main">)</span><span class="main">,</span> <span class="bound">k</span><span class="main">,</span> opt_bst <span class="main">(</span><span class="bound">k</span><span class="main">+</span><span class="main">1</span><span class="main">)</span> <span class="skolem">j</span><span class="main">⟩</span><span class="main">.</span> k <span class="main">&lt;-</span> <span class="main">[</span><span class="skolem">i</span><span class="main">..</span><span class="skolem">j</span><span class="main">]</span><span class="main">]</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?M</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">k</span><span class="main">.</span> min_wpl <span class="skolem">i</span> <span class="main">(</span><span class="bound">k</span><span class="main">-</span><span class="main">1</span><span class="main">)</span> <span class="main">+</span> min_wpl <span class="main">(</span><span class="bound">k</span><span class="main">+</span><span class="main">1</span><span class="main">)</span> <span class="skolem">j</span> <span class="main">+</span> <span class="free">W</span> <span class="skolem">i</span> <span class="skolem">j</span><span class="main">)</span> <span class="main">`</span> <span class="main">{</span><span class="skolem">i</span><span class="main">..</span><span class="skolem">j</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?ts</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> upto.simps<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"wpl <span class="skolem">i</span> <span class="skolem">j</span> <span class="main">(</span>opt_bst <span class="skolem">i</span> <span class="skolem">j</span><span class="main">)</span> <span class="main">=</span> wpl <span class="skolem">i</span> <span class="skolem">j</span> <span class="main">(</span>argmin <span class="main">(</span>wpl <span class="skolem">i</span> <span class="skolem">j</span><span class="main">)</span> <span class="var">?ts</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> opt_bst.simps<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> Min <span class="main">(</span>wpl <span class="skolem">i</span> <span class="skolem">j</span> <span class="main">`</span> <span class="main">(</span>set <span class="var">?ts</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> argmin_Min<span class="main"><span class="main">[</span></span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="var">?ts</span> <span class="main">≠</span> <span class="main">[]</span>›</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> Min <span class="var">?M</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> arg_cong<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">Min</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"wpl <span class="skolem">i</span> <span class="skolem">j</span> <span class="main">`</span> <span class="main">(</span>set <span class="var">?ts</span><span class="main">)</span> <span class="main">=</span> <span class="var">?M</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Bex_def image_iff 1<span class="main"><span class="main">[</span></span><span class="operator">OF</span> *<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> min_wpl <span class="skolem">i</span> <span class="skolem">j</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> min_wpl.simps min_list_Min<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="OptBST-opt_bst_is_optimal"><span class="command">lemma</span></span> opt_bst_is_optimal<span class="main">:</span>
  <span class="quoted"><span class="quoted">"inorder <span class="free">t</span> <span class="main">=</span> <span class="main">[</span><span class="free">i</span><span class="main">..</span><span class="free">j</span><span class="main">]</span> <span class="main">⟹</span> wpl <span class="free">i</span> <span class="free">j</span> <span class="main">(</span>opt_bst <span class="free">i</span> <span class="free">j</span><span class="main">)</span> <span class="main">≤</span> wpl <span class="free">i</span> <span class="free">j</span> <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> min_wpl_minimal wpl_opt_bst<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Weight function *)</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Access Frequencies›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Usually, the problem is phrased in terms of access frequencies.
We now give an interpretation of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">wpl</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in this view and show that we have actually computed
the right thing.›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="comment1">― ‹We are given a range <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>[i..j]›</span></span> of integer keys with access frequencies <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>p›</span></span>.
  These can be thought of as a probability distribution but are not required to represent one.
  This model assumes that the tree will contain all keys in the range <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>[i..j]›</span></span>.
  See <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>Optimal_BST›</span></span> for a model with missing keys.
  ›</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"int <span class="main">⇒</span> nat"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">― ‹The <span class="antiquoted"><span class="operator">∗</span>‹weighted path path length›</span> (or <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>cost›</span></span>) of a tree.›</span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">cost</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"int tree <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">cost</span> Leaf <span class="main">=</span> <span class="main">0</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">cost</span> <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> sum <span class="free">p</span> <span class="main">(</span>set_tree <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="main">+</span> <span class="free">cost</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">+</span> <span class="free">p</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">+</span> <span class="free">cost</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">+</span> sum <span class="free">p</span> <span class="main">(</span>set_tree <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span>"</span></span>

<span class="comment1">― ‹Deriving a weight function from <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>p›</span></span>.›</span>
<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">W</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">W</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">=</span> sum <span class="free">p</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">..</span><span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">}</span>"</span></span>

<span class="comment1">― ‹We will use this later for computing <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>W›</span></span> efficiently.›</span>
<span class="keyword1" id="OptBST-W_rec"><span class="command">lemma</span></span> W_rec<span class="main">:</span>
  <span class="quoted"><span class="quoted">"W <span class="free">i</span> <span class="free">j</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">j</span> <span class="main">≥</span> <span class="free">i</span> <span class="keyword1">then</span> W <span class="free">i</span> <span class="main">(</span><span class="free">j</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">+</span> <span class="free">p</span> <span class="free">j</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> W_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> atLeastAtMost_split_insert<span class="main">)</span>

<span class="comment1">― ‹The weight function correctly implements costs.›</span>
<span class="keyword1" id="OptBST-inorder_wpl_correct"><span class="command">lemma</span></span> inorder_wpl_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"inorder <span class="free">t</span> <span class="main">=</span> <span class="main">[</span><span class="free">i</span><span class="main">..</span><span class="free">j</span><span class="main">]</span> <span class="main">⟹</span> wpl W <span class="free">i</span> <span class="free">j</span> <span class="free">t</span> <span class="main">=</span> cost <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">i</span></span> <span class="quoted"><span class="free">j</span></span><span class="main">)</span>
<span class="keyword3"><span class="command">case</span></span> Leaf
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Node <span class="skolem">l</span> <span class="skolem">k</span> <span class="skolem">r</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹inorder <span class="main">⟨</span><span class="skolem">l</span><span class="main">,</span> <span class="skolem">k</span><span class="main">,</span> <span class="skolem">r</span><span class="main">⟩</span> <span class="main">=</span> <span class="main">[</span><span class="skolem">i</span><span class="main">..</span><span class="skolem">j</span><span class="main">]</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">≤</span> <span class="skolem">k</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span> <span class="main">≤</span> <span class="skolem">j</span>"</span></span>
     <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">metis</span> atLeastAtMost_iff in_set_conv_decomp set_upto<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
   <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">i</span> <span class="main">≤</span> <span class="skolem">k</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">k</span> <span class="main">≤</span> <span class="skolem">j</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"inorder <span class="skolem">l</span> <span class="main">=</span> <span class="main">[</span><span class="skolem">i</span><span class="main">..</span><span class="skolem">k</span><span class="main">-</span><span class="main">1</span><span class="main">]</span>"</span></span> <span class="quoted"><span class="quoted">"inorder <span class="skolem">r</span> <span class="main">=</span> <span class="main">[</span><span class="skolem">k</span><span class="main">+</span><span class="main">1</span><span class="main">..</span><span class="skolem">j</span><span class="main">]</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹inorder <span class="main">⟨</span><span class="skolem">l</span><span class="main">,</span> <span class="skolem">k</span><span class="main">,</span> <span class="skolem">r</span><span class="main">⟩</span> <span class="main">=</span> <span class="main">[</span><span class="skolem">i</span><span class="main">..</span><span class="skolem">j</span><span class="main">]</span>›</span></span><span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> upto_split3 append_Cons_eq_iff<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Node.IH<span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> W_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> atLeastAtMost_split<span class="main">)</span>
       <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sum.union_disjoint atLeastAtMost_split_insert <span class="quasi_keyword">flip</span><span class="main"><span class="main">:</span></span> set_inorder<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The optimal binary search tree has minimal cost among all binary search trees.›</span></span>
<span class="keyword1" id="OptBST-opt_bst_has_optimal_cost"><span class="command">lemma</span></span> opt_bst_has_optimal_cost<span class="main">:</span>
  <span class="quoted"><span class="quoted">"inorder <span class="free">t</span> <span class="main">=</span> <span class="main">[</span><span class="free">i</span><span class="main">..</span><span class="free">j</span><span class="main">]</span> <span class="main">⟹</span> cost <span class="main">(</span>opt_bst W <span class="free">i</span> <span class="free">j</span><span class="main">)</span> <span class="main">≤</span> cost <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> inorder_wpl_correct opt_bst_is_optimal opt_bst_correct <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The function <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">min_wpl</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> correctly computes the minimal cost among all binary search trees:
  <span class="antiquoted"><span class="antiquoted">▪</span></span> Its cost is a lower bound for the cost of all binary search trees
  <span class="antiquoted"><span class="antiquoted">▪</span></span> Its cost actually corresponds to an optimal binary search tree
›</span></span>
<span class="keyword1" id="OptBST-min_wpl_minimal_cost"><span class="command">lemma</span></span> min_wpl_minimal_cost<span class="main">:</span>
  <span class="quoted"><span class="quoted">"inorder <span class="free">t</span> <span class="main">=</span> <span class="main">[</span><span class="free">i</span><span class="main">..</span><span class="free">j</span><span class="main">]</span> <span class="main">⟹</span> min_wpl W <span class="free">i</span> <span class="free">j</span> <span class="main">≤</span> cost <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> inorder_wpl_correct min_wpl_minimal <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>

<span class="keyword1" id="OptBST-min_wpl_tree"><span class="command">lemma</span></span> min_wpl_tree<span class="main">:</span>
  <span class="quoted"><span class="quoted">"cost <span class="main">(</span>opt_bst W <span class="free">i</span> <span class="free">j</span><span class="main">)</span> <span class="main">=</span> min_wpl W <span class="free">i</span> <span class="free">j</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> wpl_opt_bst opt_bst_correct inorder_wpl_correct <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>


<span class="keyword1"><span class="command">paragraph</span></span> <span class="quoted"><span class="plain_text">‹An alternative view of costs.›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">depth</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> tree <span class="main">⇒</span> nat extended"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">depth</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> Leaf <span class="main">=</span> <span class="main">∞</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">depth</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> min <span class="main">(</span><span class="free">depth</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free">depth</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">the_fin</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">the_fin</span> <span class="main">(</span>Fin <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span> <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">the_fin</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> undefined"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">cost'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"int tree <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">cost'</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">=</span> sum <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> the_fin <span class="main">(</span>depth <span class="bound">x</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span> <span class="main">*</span> <span class="free">p</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span>set_tree <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"the_fin <span class="main">1</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> one_extended_def<span class="main">)</span>

<span class="keyword1" id="OptBST-set_tree_depth"><span class="command">lemma</span></span> set_tree_depth<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∉</span> set_tree <span class="free">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"depth <span class="free">x</span> <span class="free">t</span> <span class="main">=</span> <span class="main">∞</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="OptBST-depth_inf_iff"><span class="command">lemma</span></span> depth_inf_iff<span class="main">:</span>
  <span class="quoted"><span class="quoted">"depth <span class="free">x</span> <span class="free">t</span> <span class="main">=</span> <span class="main">∞</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">∉</span> set_tree <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> one_extended_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> t1 k t2
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"depth <span class="free">x</span> <span class="skolem">t1</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="quoted">"depth <span class="free">x</span> <span class="skolem">t2</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> t1 k t2
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"depth <span class="free">x</span> <span class="skolem">t1</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="quoted">"depth <span class="free">x</span> <span class="skolem">t2</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> t1 k t2
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"depth <span class="free">x</span> <span class="skolem">t1</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="quoted">"depth <span class="free">x</span> <span class="skolem">t2</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> t1 k t2
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"depth <span class="free">x</span> <span class="skolem">t1</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="quoted">"depth <span class="free">x</span> <span class="skolem">t2</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="OptBST-depth_not_neg_inf"><span class="command">lemma</span></span> depth_not_neg_inf<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"depth <span class="free">x</span> <span class="free">t</span> <span class="main">=</span> <span class="main">-∞</span> <span class="main">⟷</span> False"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> one_extended_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> t1 k t2
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"depth <span class="free">x</span> <span class="skolem">t1</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="quoted">"depth <span class="free">x</span> <span class="skolem">t2</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="OptBST-depth_FinD"><span class="command">lemma</span></span> depth_FinD<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> set_tree <span class="free">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">d</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"depth <span class="free">x</span> <span class="free">t</span> <span class="main">=</span> Fin <span class="free">d</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"depth <span class="free">x</span> <span class="free">t</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> depth_inf_iff<span class="main">)</span>

<span class="keyword1" id="OptBST-cost'_Leaf"><span class="command">lemma</span></span> cost'_Leaf<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"cost' Leaf <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> cost'_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="OptBST-cost'_Node"><span class="command">lemma</span></span> cost'_Node<span class="main">:</span>
  <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>inorder <span class="main">⟨</span><span class="free">l</span><span class="main">,</span> <span class="free">x</span><span class="main">,</span> <span class="free">r</span><span class="main">⟩</span><span class="main">)</span> <span class="main">⟹</span>
  cost' <span class="main">⟨</span><span class="free">l</span><span class="main">,</span> <span class="free">x</span><span class="main">,</span> <span class="free">r</span><span class="main">⟩</span> <span class="main">=</span> sum <span class="free">p</span> <span class="main">(</span>set_tree <span class="free">l</span><span class="main">)</span> <span class="main">+</span> cost' <span class="free">l</span> <span class="main">+</span> <span class="free">p</span> <span class="free">x</span> <span class="main">+</span> cost' <span class="free">r</span> <span class="main">+</span> sum <span class="free">p</span> <span class="main">(</span>set_tree <span class="free">r</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> cost'_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> sum.union_disjoint<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> sum.cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> HOL.refl<span class="main"><span class="main">,</span></span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> h <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span>the_fin <span class="main">(</span>depth <span class="bound">x</span> <span class="free">l</span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">*</span> <span class="free">p</span> <span class="bound">x</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> k
    <span class="keyword1"><span class="command">using</span></span> set_tree_depth <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> one_extended_def <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> depth_FinD<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> sum.cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> HOL.refl<span class="main"><span class="main">,</span></span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> h <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span>the_fin <span class="main">(</span>depth <span class="bound">x</span> <span class="free">r</span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">*</span> <span class="free">p</span> <span class="bound">x</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">using</span></span> set_tree_depth <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> one_extended_def <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> depth_FinD<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sum.distrib<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="comment1">― ‹The two variants coincide›</span>
<span class="keyword1" id="OptBST-weight_correct"><span class="command">lemma</span></span> weight_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>inorder <span class="free">t</span><span class="main">)</span> <span class="main">⟹</span> cost' <span class="free">t</span> <span class="main">=</span> cost <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">t</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cost'_Node<span class="main">)</span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Memoizing Weights›</span></span>

<span class="keyword1"><span class="command">function</span></span> <span class="entity">W_fun</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">W_fun</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">&gt;</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> <span class="free">W_fun</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">+</span> <span class="free">p</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">termination</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">relation</span> <span class="quoted"><span class="quoted">"measure <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">i</span><span class="main">::</span>int<span class="main">,</span> <span class="bound">j</span><span class="main">::</span>int<span class="main">)</span><span class="main">.</span> nat <span class="main">(</span><span class="bound">j</span> <span class="main">-</span> <span class="bound">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="OptBST-W_fun_correct"><span class="command">lemma</span></span> W_fun_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"W_fun <span class="free">i</span> <span class="free">j</span> <span class="main">=</span> W <span class="free">i</span> <span class="free">j</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> W_fun.induct<span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> W_def atLeastAtMost_split_insert<span class="main">)</span>

<span class="keyword1"><span class="command">memoize_fun</span></span> W<span class="hidden">⇩</span><sub>m</sub><span class="main">:</span> <span class="quoted">W_fun</span>
  <span class="keyword2"><span class="keyword">with_memory</span></span>  dp_consistency_mapping
  <span class="keyword1"><span class="command">monadifies</span></span> <span class="main">(</span>state<span class="main">)</span> W_fun.simps

<span class="keyword1"><span class="command">memoize_correct</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">memoize_prover</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">compute_W</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> snd <span class="main">(</span>run_state <span class="main">(</span>State_Main.map<span class="hidden">⇩</span><sub>T</sub>' <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> W<span class="hidden">⇩</span><sub>m</sub>' <span class="bound">i</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">[</span><span class="main">0</span><span class="main">..</span><span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">]</span><span class="main">)</span> Mapping.empty<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">notation</span></span> W<span class="hidden">⇩</span><sub>m</sub>.crel_vs <span class="main">(</span><span class="quoted">"<span class="keyword1">crel</span>"</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> W<span class="hidden">⇩</span><sub>m</sub>_crel <span class="main">=</span> W<span class="hidden">⇩</span><sub>m</sub>.crel<span class="main">[</span><span class="operator">unfolded</span> W<span class="hidden">⇩</span><sub>m</sub>.consistentDP_def<span class="main">,</span> <span class="operator">THEN</span> rel_funD<span class="main">,</span>
      <span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">m</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">m</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">for</span></span></span> <span class="free">m</span> <span class="free">x</span> <span class="free">y</span><span class="main">,</span> <span class="operator">unfolded</span> prod.case<span class="main">]</span>

<span class="keyword1" id="OptBST-compute_W_correct"><span class="command">lemma</span></span> compute_W_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Mapping.lookup <span class="main">(</span>compute_W <span class="free">n</span><span class="main">)</span> <span class="main">(</span><span class="free">i</span><span class="main">,</span> <span class="free">j</span><span class="main">)</span> <span class="main">=</span> Some <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"W <span class="free">i</span> <span class="free">j</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">include</span></span> state_monad_syntax app_syntax lifting_syntax
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?p</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"State_Main.map<span class="hidden">⇩</span><sub>T</sub>' <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> W<span class="hidden">⇩</span><sub>m</sub>' <span class="bound">i</span> <span class="free">n</span><span class="main">)</span> <span class="main">[</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">]</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?q</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"map <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> W <span class="bound">i</span> <span class="free">n</span><span class="main">)</span> <span class="main">[</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">]</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?q</span> <span class="main">=</span> map <span class="main">$</span> <span class="main">⟪</span><span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> W_fun <span class="bound">i</span> <span class="free">n</span><span class="main">)</span><span class="main">⟫</span> <span class="main">$</span> <span class="main">⟪</span><span class="main">[</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">]</span><span class="main">⟫</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> Wrap_def App_def W_fun_correct <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?p</span> <span class="main">=</span> State_Main.map<span class="hidden">⇩</span><sub>T</sub> <span class="main">.</span> <span class="main">⟨</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> W<span class="hidden">⇩</span><sub>m</sub>' <span class="bound">i</span> <span class="free">n</span><span class="main">⟩</span> <span class="main">.</span> <span class="main">⟨</span><span class="main">[</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">]</span><span class="main">⟩</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> State_Monad_Ext.fun_app_lifted_def State_Main.map<span class="hidden">⇩</span><sub>T</sub>_def bind_left_identity <span class="keyword1"><span class="command">..</span></span>
  <span class="comment1">― ‹Not forgetting to write <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span>  <span class="quoted">"list_all2 <span class="main">(=)</span>"</span><span class="antiquote">}</span></span> instead of <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="main">(=)</span>"</span><span class="antiquote">}</span></span> was the tricky part.›</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"W<span class="hidden">⇩</span><sub>m</sub>.crel_vs <span class="main">(</span>list_all2 <span class="main">(=)</span><span class="main">)</span> <span class="var">?q</span> <span class="var">?p</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?p</span> <span class="main">=</span> <span class="main">_</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?q</span> <span class="main">=</span> <span class="main">_</span>›</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> Transfer.Rel_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">memoize_prover_match_step</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> Rel_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> W<span class="hidden">⇩</span><sub>m</sub>_crel<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> HOL.refl<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"W<span class="hidden">⇩</span><sub>m</sub>.cmem <span class="main">(</span>compute_W <span class="free">n</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> compute_W_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">elim</span> W<span class="hidden">⇩</span><sub>m</sub>.crel_vs_elim<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ W<span class="hidden">⇩</span><sub>m</sub>.cmem_empty<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> W<span class="hidden">⇩</span><sub>m</sub>'.simps<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> W_fun_correct<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">elim</span> W<span class="hidden">⇩</span><sub>m</sub>.cmem_elim<span class="main">)</span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">min_wpl'</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">≡</span>
  <span class="keyword1">let</span>
    <span class="bound">M</span> <span class="main">=</span> compute_W <span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">;</span>
    <span class="bound">W</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span> <span class="bound">j</span><span class="main">.</span> <span class="keyword1">case</span> Mapping.lookup <span class="bound">M</span> <span class="main">(</span><span class="bound">i</span><span class="main">,</span> <span class="bound">j</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> W <span class="bound">i</span> <span class="bound">j</span> <span class="main">|</span> Some <span class="bound">x</span> <span class="main">⇒</span> <span class="bound">x</span><span class="main">)</span>
  <span class="keyword1">in</span> min_wpl <span class="bound">W</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">j</span></span></span>"</span></span>

<span class="keyword1" id="OptBST-W_compute"><span class="command">lemma</span></span> W_compute<span class="main">:</span> <span class="quoted"><span class="quoted">"W <span class="free">i</span> <span class="free">j</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> Mapping.lookup <span class="main">(</span>compute_W <span class="free">n</span><span class="main">)</span> <span class="main">(</span><span class="free">i</span><span class="main">,</span> <span class="free">j</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> W <span class="free">i</span> <span class="free">j</span> <span class="main">|</span> Some <span class="bound">x</span> <span class="main">⇒</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> compute_W_correct <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1" id="OptBST-min_wpl'_correct"><span class="command">lemma</span></span> min_wpl'_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"min_wpl' <span class="free">i</span> <span class="free">j</span> <span class="main">=</span> min_wpl W <span class="free">i</span> <span class="free">j</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> W_compute <span class="keyword1"><span class="command">unfolding</span></span> min_wpl'_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">opt_bst'</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">≡</span>
  <span class="keyword1">let</span>
    <span class="bound">M</span> <span class="main">=</span> compute_W <span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">;</span>
    <span class="bound">W</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span> <span class="bound">j</span><span class="main">.</span> <span class="keyword1">case</span> Mapping.lookup <span class="bound">M</span> <span class="main">(</span><span class="bound">i</span><span class="main">,</span> <span class="bound">j</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> W <span class="bound">i</span> <span class="bound">j</span> <span class="main">|</span> Some <span class="bound">x</span> <span class="main">⇒</span> <span class="bound">x</span><span class="main">)</span>
  <span class="keyword1">in</span> opt_bst <span class="bound">W</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">j</span></span></span>"</span></span>

<span class="keyword1" id="OptBST-opt_bst'_correct"><span class="command">lemma</span></span> opt_bst'_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"opt_bst' <span class="free">i</span> <span class="free">j</span> <span class="main">=</span> opt_bst W <span class="free">i</span> <span class="free">j</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> W_compute <span class="keyword1"><span class="command">unfolding</span></span> opt_bst'_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* fixed p *)</span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Test Case›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Functional Implementations›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"min_wpl <span class="main">(</span><span class="main">λ</span><span class="bound">i</span> <span class="bound">j</span><span class="main">.</span> nat<span class="main">(</span><span class="bound">i</span><span class="main">+</span><span class="bound">j</span><span class="main">)</span><span class="main">)</span> <span class="main">0</span> <span class="numeral">4</span> <span class="main">=</span> <span class="numeral">10</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"opt_bst <span class="main">(</span><span class="main">λ</span><span class="bound">i</span> <span class="bound">j</span><span class="main">.</span> nat<span class="main">(</span><span class="bound">i</span><span class="main">+</span><span class="bound">j</span><span class="main">)</span><span class="main">)</span> <span class="main">0</span> <span class="numeral">4</span> <span class="main">=</span> <span class="main">⟨</span><span class="main">⟨</span><span class="main">⟨</span><span class="main">⟨</span><span class="main">⟨</span><span class="main">⟨⟩</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="main">⟨⟩</span><span class="main">⟩</span><span class="main">,</span> <span class="main">1</span><span class="main">,</span> <span class="main">⟨⟩</span><span class="main">⟩</span><span class="main">,</span> <span class="numeral">2</span><span class="main">,</span> <span class="main">⟨⟩</span><span class="main">⟩</span><span class="main">,</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">⟨⟩</span><span class="main">⟩</span><span class="main">,</span> <span class="numeral">4</span><span class="main">,</span> <span class="main">⟨⟩</span><span class="main">⟩</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Using Frequencies›</span></span>
<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">list_to_p</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">::</span>int<span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">-</span> <span class="main">1</span> <span class="main">≥</span> <span class="main">0</span> <span class="main">∧</span> nat <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">&lt;</span> length <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">!</span> nat <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ex_p_1</span> <span class="main">=</span> <span class="main">[</span><span class="numeral">10</span><span class="main">,</span> <span class="numeral">30</span><span class="main">,</span> <span class="numeral">15</span><span class="main">,</span> <span class="numeral">25</span><span class="main">,</span> <span class="numeral">20</span><span class="main">]</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">opt_tree_1</span> <span class="main">=</span>
  <span class="main">⟨</span>
    <span class="main">⟨</span>
      <span class="main">⟨</span><span class="main">⟨⟩</span><span class="main">,</span> <span class="main">1</span><span class="main">::</span>int<span class="main">,</span> <span class="main">⟨⟩</span><span class="main">⟩</span><span class="main">,</span>
      <span class="numeral">2</span><span class="main">,</span>
      <span class="main">⟨</span><span class="main">⟨⟩</span><span class="main">,</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">⟨⟩</span><span class="main">⟩</span>
    <span class="main">⟩</span><span class="main">,</span>
    <span class="numeral">4</span><span class="main">,</span>
    <span class="main">⟨</span><span class="main">⟨⟩</span><span class="main">,</span> <span class="numeral">5</span><span class="main">,</span> <span class="main">⟨⟩</span><span class="main">⟩</span>
  <span class="main">⟩</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"opt_bst' <span class="main">(</span>list_to_p ex_p_1<span class="main">)</span> <span class="main">1</span> <span class="numeral">5</span> <span class="main">=</span> opt_tree_1"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Imperative Implementation›</span></span>

<span class="keyword1"><span class="command">code_thms</span></span> <span class="quoted"><span class="quoted">min_wpl</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">min_wpl_test</span> <span class="main">=</span> min_wpl<span class="hidden">⇩</span><sub>h</sub> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span> <span class="bound">j</span><span class="main">.</span> nat<span class="main">(</span><span class="bound">i</span><span class="main">+</span><span class="bound">j</span><span class="main">)</span><span class="main">)</span> <span class="numeral">4</span> <span class="main">0</span> <span class="numeral">4</span>"</span></span>

<span class="keyword1"><span class="command">code_reflect</span></span> Test <span class="keyword2"><span class="keyword">functions</span></span> min_wpl_test

<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹Test.min_wpl_test <span class="main">(</span><span class="main">)</span>›</span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="Longest_Common_Subsequence">
<div class="head">
<h1>Theory Longest_Common_Subsequence</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Longest Common Subsequence›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Longest_Common_Subsequence
  <span class="keyword2"><span class="keyword">imports</span></span>
    <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/Sublist.html">HOL-Library.Sublist</a>"</span>
    <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/IArray.html">HOL-Library.IArray</a>"</span>
    <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/Code_Target_Numeral.html">HOL-Library.Code_Target_Numeral</a>"</span>
    <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/Product_Lexorder.html">HOL-Library.Product_Lexorder</a>"</span>
    <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/RBT_Mapping.html">HOL-Library.RBT_Mapping</a>"</span>
    <span class="quoted">"<a href="#State_Main">../state_monad/State_Main</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Misc›</span></span>

<span class="comment1">(* TODO: Move *)</span>
<span class="keyword1" id="Longest_Common_Subsequence-finite_subseq"><span class="command">lemma</span></span> finite_subseq<span class="main">:</span>
  <span class="quoted"><span class="quoted">"finite <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> subseq <span class="bound">xs</span> <span class="free">ys</span><span class="main">}</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"finite <span class="var">?S</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?S</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> set <span class="bound">xs</span> <span class="main">⊆</span> set <span class="free">ys</span> <span class="main">∧</span> length <span class="bound">xs</span> <span class="main">≤</span> length <span class="free">ys</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> list_emb_set <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> list_emb_length<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">…</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> finite_lists_length_le finite_set<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Longest_Common_Subsequence-subseq_singleton_right"><span class="command">lemma</span></span> subseq_singleton_right<span class="main">:</span>
  <span class="quoted"><span class="quoted">"subseq <span class="free">xs</span> <span class="main">[</span><span class="free">x</span><span class="main">]</span> <span class="main">=</span> <span class="main">(</span><span class="free">xs</span> <span class="main">=</span> <span class="main">[</span><span class="free">x</span><span class="main">]</span> <span class="main">∨</span> <span class="free">xs</span> <span class="main">=</span> <span class="main">[]</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> subseq_append_le_same_iff<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted">"<span class="main">[]</span>"</span></span><span class="main"><span class="main">,</span></span> <span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Longest_Common_Subsequence-subseq_append_single_right"><span class="command">lemma</span></span> subseq_append_single_right<span class="main">:</span>
  <span class="quoted"><span class="quoted">"subseq <span class="free">xs</span> <span class="main">(</span><span class="free">ys</span> <span class="main">@</span> <span class="main">[</span><span class="free">x</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="main">∃</span> <span class="bound">xs'</span><span class="main">.</span> subseq <span class="bound">xs'</span> <span class="free">ys</span> <span class="main">∧</span> <span class="free">xs</span> <span class="main">=</span> <span class="bound">xs'</span> <span class="main">@</span> <span class="main">[</span><span class="free">x</span><span class="main">]</span><span class="main">)</span> <span class="main">∨</span> subseq <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> subseq_append_iff subseq_singleton_right<span class="main">)</span>

<span class="comment1">(* TODO: Move, generalize *)</span>
<span class="keyword1" id="Longest_Common_Subsequence-Max_nat_plus"><span class="command">lemma</span></span> Max_nat_plus<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Max <span class="main">(</span><span class="main">(</span><span class="main">(+)</span> <span class="free">n</span><span class="main">)</span> <span class="main">`</span> <span class="free">S</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">n</span> <span class="main">::</span> nat<span class="main">)</span> <span class="main">+</span> Max <span class="free">S</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">S</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">S</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Max_ge Max_in Max_eqI<span class="main">)</span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Definitions›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">A</span> <span class="free">B</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">lcs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lcs</span> <span class="main">0</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">lcs</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">0</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">lcs</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">A</span><span class="main">!</span><span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">=</span> <span class="free">B</span><span class="main">!</span><span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="keyword1">then</span> <span class="main">1</span> <span class="main">+</span> <span class="free">lcs</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="keyword1">else</span> max <span class="main">(</span><span class="free">lcs</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">lcs</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">OPT</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">=</span> Max <span class="main">{</span>length <span class="bound">xs</span> <span class="main">|</span> <span class="bound">xs</span><span class="main">.</span> subseq <span class="bound">xs</span> <span class="main">(</span>take <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free">A</span><span class="main">)</span> <span class="main">∧</span> subseq <span class="bound">xs</span> <span class="main">(</span>take <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="free">B</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1" id="Longest_Common_Subsequence-finite_OPT"><span class="command">lemma</span></span> finite_OPT<span class="main">:</span>
  <span class="quoted"><span class="quoted">"finite <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> subseq <span class="bound">xs</span> <span class="main">(</span>take <span class="free">i</span> <span class="free">A</span><span class="main">)</span> <span class="main">∧</span> subseq <span class="bound">xs</span> <span class="main">(</span>take <span class="free">j</span> <span class="free">B</span><span class="main">)</span><span class="main">}</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"finite <span class="var">?S</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?S</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> subseq <span class="bound">xs</span> <span class="main">(</span>take <span class="free">i</span> <span class="free">A</span><span class="main">)</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">…</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> finite_subseq<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Correctness Proof›</span></span>
<span class="keyword1" id="Longest_Common_Subsequence-non_empty_OPT"><span class="command">lemma</span></span> non_empty_OPT<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">xs</span><span class="main">.</span> subseq <span class="bound">xs</span> <span class="main">(</span>take <span class="free">i</span> <span class="free">A</span><span class="main">)</span> <span class="main">∧</span> subseq <span class="bound">xs</span> <span class="main">(</span>take <span class="free">j</span> <span class="free">B</span><span class="main">)</span><span class="main">}</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Longest_Common_Subsequence-OPT_0_left"><span class="command">lemma</span></span> OPT_0_left<span class="main">:</span>
  <span class="quoted"><span class="quoted">"OPT <span class="main">0</span> <span class="free">j</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> OPT_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> subseq_append_le_same_iff<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted">"<span class="main">[]</span>"</span></span><span class="main"><span class="main">,</span></span> <span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Longest_Common_Subsequence-OPT_0_right"><span class="command">lemma</span></span> OPT_0_right<span class="main">:</span>
  <span class="quoted"><span class="quoted">"OPT <span class="free">i</span> <span class="main">0</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> OPT_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> subseq_append_le_same_iff<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted">"<span class="main">[]</span>"</span></span><span class="main"><span class="main">,</span></span> <span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Longest_Common_Subsequence-OPT_rec1"><span class="command">lemma</span></span> OPT_rec1<span class="main">:</span>
  <span class="quoted"><span class="quoted">"OPT <span class="main">(</span><span class="free">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">(</span><span class="free">j</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span> <span class="main">+</span> OPT <span class="free">i</span> <span class="free">j</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?l</span> <span class="main">=</span> <span class="var">?r</span>"</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span><span class="main">!</span><span class="free">i</span> <span class="main">=</span> <span class="free">B</span><span class="main">!</span><span class="free">j</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&lt;</span> length <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">j</span> <span class="main">&lt;</span> length <span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?S</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span>length <span class="bound">xs</span> <span class="main">|</span><span class="bound">xs</span><span class="main">.</span> subseq <span class="bound">xs</span> <span class="main">(</span>take <span class="main">(</span><span class="free">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="free">A</span><span class="main">)</span> <span class="main">∧</span> subseq <span class="bound">xs</span> <span class="main">(</span>take <span class="main">(</span><span class="free">j</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="free">B</span><span class="main">)</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?R</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span>length <span class="bound">xs</span> <span class="main">+</span> <span class="main">1</span> <span class="main">|</span><span class="bound">xs</span><span class="main">.</span> subseq <span class="bound">xs</span> <span class="main">(</span>take <span class="free">i</span> <span class="free">A</span><span class="main">)</span> <span class="main">∧</span> subseq <span class="bound">xs</span> <span class="main">(</span>take <span class="free">j</span> <span class="free">B</span><span class="main">)</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?S</span> <span class="main">=</span> <span class="main">{</span>length <span class="bound">xs</span> <span class="main">|</span> <span class="bound">xs</span><span class="main">.</span> subseq <span class="bound">xs</span> <span class="main">(</span>take <span class="free">i</span> <span class="free">A</span><span class="main">)</span> <span class="main">∧</span> subseq <span class="bound">xs</span> <span class="main">(</span>take <span class="free">j</span> <span class="free">B</span><span class="main">)</span><span class="main">}</span>
    <span class="main">∪</span> <span class="main">{</span>length <span class="bound">xs</span> <span class="main">|</span> <span class="bound">xs</span><span class="main">.</span> <span class="main">∃</span> <span class="bound">ys</span><span class="main">.</span> subseq <span class="bound">ys</span> <span class="main">(</span>take <span class="free">i</span> <span class="free">A</span><span class="main">)</span> <span class="main">∧</span> subseq <span class="bound">ys</span> <span class="main">(</span>take <span class="free">j</span> <span class="free">B</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">xs</span> <span class="main">=</span> <span class="bound">ys</span> <span class="main">@</span> <span class="main">[</span><span class="free">B</span><span class="main">!</span><span class="free">i</span><span class="main">]</span><span class="main">}</span>
    "</span></span>
    <span class="keyword1"><span class="command">using</span></span> that
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> take_Suc_conv_app_nth<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> subseq_append_single_right<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> length_append_singleton list_emb_prefix subseq_append<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">{</span>length <span class="bound">xs</span> <span class="main">|</span> <span class="bound">xs</span><span class="main">.</span> subseq <span class="bound">xs</span> <span class="main">(</span>take <span class="free">i</span> <span class="free">A</span><span class="main">)</span> <span class="main">∧</span> subseq <span class="bound">xs</span> <span class="main">(</span>take <span class="free">j</span> <span class="free">B</span><span class="main">)</span><span class="main">}</span>
    <span class="main">∪</span> <span class="main">{</span>length <span class="bound">xs</span> <span class="main">+</span> <span class="main">1</span> <span class="main">|</span> <span class="bound">xs</span><span class="main">.</span> subseq <span class="bound">xs</span> <span class="main">(</span>take <span class="free">i</span> <span class="free">A</span><span class="main">)</span> <span class="main">∧</span> subseq <span class="bound">xs</span> <span class="main">(</span>take <span class="free">j</span> <span class="free">B</span><span class="main">)</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Max <span class="main">…</span> <span class="main">=</span> Max <span class="var">?R</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> finite_OPT <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> Max_eq_if<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?l</span> <span class="main">=</span> <span class="var">?r</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> OPT_def
    <span class="keyword1"><span class="command">using</span></span> finite_OPT non_empty_OPT
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> Max_nat_plus<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> image_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> arg_cong<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted">Max</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Longest_Common_Subsequence-OPT_rec2"><span class="command">lemma</span></span> OPT_rec2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"OPT <span class="main">(</span><span class="free">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">(</span><span class="free">j</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">=</span> max <span class="main">(</span>OPT <span class="free">i</span> <span class="main">(</span><span class="free">j</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>OPT <span class="main">(</span><span class="free">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="free">j</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?l</span> <span class="main">=</span> <span class="var">?r</span>"</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span><span class="main">!</span><span class="free">i</span> <span class="main">≠</span> <span class="free">B</span><span class="main">!</span><span class="free">j</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&lt;</span> length <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">j</span> <span class="main">&lt;</span> length <span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span>length <span class="bound">xs</span> <span class="main">|</span><span class="bound">xs</span><span class="main">.</span> subseq <span class="bound">xs</span> <span class="main">(</span>take <span class="main">(</span><span class="free">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="free">A</span><span class="main">)</span> <span class="main">∧</span> subseq <span class="bound">xs</span> <span class="main">(</span>take <span class="main">(</span><span class="free">j</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="free">B</span><span class="main">)</span><span class="main">}</span>
    <span class="main">=</span> <span class="main">{</span>length <span class="bound">xs</span> <span class="main">|</span><span class="bound">xs</span><span class="main">.</span> subseq <span class="bound">xs</span> <span class="main">(</span>take <span class="free">i</span> <span class="free">A</span><span class="main">)</span> <span class="main">∧</span> subseq <span class="bound">xs</span> <span class="main">(</span>take <span class="main">(</span><span class="free">j</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="free">B</span><span class="main">)</span><span class="main">}</span>
    <span class="main">∪</span> <span class="main">{</span>length <span class="bound">xs</span> <span class="main">|</span><span class="bound">xs</span><span class="main">.</span> subseq <span class="bound">xs</span> <span class="main">(</span>take <span class="main">(</span><span class="free">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="free">A</span><span class="main">)</span> <span class="main">∧</span> subseq <span class="bound">xs</span> <span class="main">(</span>take <span class="free">j</span> <span class="free">B</span><span class="main">)</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> subseq_append_single_right take_Suc_conv_app_nth<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> finite_OPT non_empty_OPT <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?l</span> <span class="main">=</span> <span class="var">?r</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> OPT_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span> <span class="main">(</span><span class="operator">rule</span> Max_Un<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Longest_Common_Subsequence-lcs_correct'"><span class="command">lemma</span></span> lcs_correct'<span class="main">:</span>
  <span class="quoted"><span class="quoted">"OPT <span class="free">i</span> <span class="free">j</span> <span class="main">=</span> lcs <span class="free">i</span> <span class="free">j</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">≤</span> length <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">j</span> <span class="main">≤</span> length <span class="free">B</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that OPT_rec1 OPT_rec2 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">i</span></span> <span class="quoted"><span class="free">j</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lcs.induct<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> OPT_0_left OPT_0_right<span class="main">)</span>

<span class="keyword1"><span class="command">theorem</span></span> lcs_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Max <span class="main">{</span>length <span class="bound">xs</span> <span class="main">|</span> <span class="bound">xs</span><span class="main">.</span> subseq <span class="bound">xs</span> <span class="free">A</span> <span class="main">∧</span> subseq <span class="bound">xs</span> <span class="free">B</span><span class="main">}</span> <span class="main">=</span> lcs <span class="main">(</span>length <span class="free">A</span><span class="main">)</span> <span class="main">(</span>length <span class="free">B</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> OPT_def lcs_correct'<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Fixed Lists *)</span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Functional Memoization›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">A</span> <span class="free">B</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> iarray"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">lcs_ia</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lcs_ia</span> <span class="main">0</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">lcs_ia</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">0</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">lcs_ia</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">)</span> <span class="main">=</span>
    <span class="main">(</span><span class="keyword1">if</span> <span class="free">A</span><span class="main">!!</span><span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">=</span> <span class="free">B</span><span class="main">!!</span><span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="keyword1">then</span> <span class="main">1</span> <span class="main">+</span> <span class="free">lcs_ia</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="keyword1">else</span> max <span class="main">(</span><span class="free">lcs_ia</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">lcs_ia</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Longest_Common_Subsequence-lcs_lcs_ia"><span class="command">lemma</span></span> lcs_lcs_ia<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lcs <span class="free">xs</span> <span class="free">ys</span> <span class="free">i</span> <span class="free">j</span> <span class="main">=</span> lcs_ia <span class="free">i</span> <span class="free">j</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">=</span> IArray <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">=</span> IArray <span class="free">ys</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">i</span></span> <span class="quoted"><span class="free">j</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lcs_ia.induct<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> that<span class="main">)</span>

<span class="keyword1"><span class="command">memoize_fun</span></span> lcs<span class="hidden">⇩</span><sub>m</sub><span class="main">:</span> <span class="quoted">lcs_ia</span> <span class="keyword2"><span class="keyword">with_memory</span></span> dp_consistency_mapping <span class="keyword1"><span class="command">monadifies</span></span> <span class="main">(</span>state<span class="main">)</span> lcs_ia.simps

<span class="keyword1"><span class="command">memoize_correct</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">memoize_prover</span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> lcs<span class="hidden">⇩</span><sub>m</sub>.memoized_correct

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Test Case›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">lcs<span class="hidden">⇩</span><sub>a</sub></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lcs<span class="hidden">⇩</span><sub>a</sub></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">A</span> <span class="main">=</span> IArray <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">;</span> <span class="bound">B</span> <span class="main">=</span> IArray <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="keyword1">in</span> lcs_ia <span class="bound">A</span> <span class="bound">B</span> <span class="main">(</span>length <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">(</span>length <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Longest_Common_Subsequence-lcs"><span class="command">lemma</span></span> lcs<span class="hidden">⇩</span><sub>a</sub>_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lcs <span class="free">xs</span> <span class="free">ys</span> <span class="main">(</span>length <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>length <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> lcs<span class="hidden">⇩</span><sub>a</sub> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> lcs<span class="hidden">⇩</span><sub>a</sub>_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lcs_lcs_ia<span class="main">)</span>

<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"lcs<span class="hidden">⇩</span><sub>a</sub> <span class="inner_quoted">''ABCDGH''</span> <span class="inner_quoted">''AEDFHR''</span>"</span></span>

<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"lcs<span class="hidden">⇩</span><sub>a</sub> <span class="inner_quoted">''AGGTAB''</span> <span class="inner_quoted">''GXTXAYB''</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Theory *)</span>
</pre>
</div><div id="All_Examples">
<div class="head">
<h1>Theory All_Examples</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> All_Examples
  <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="#Bellman_Ford">Bellman_Ford</a>
  <a href="#Knapsack">Knapsack</a>
  <a href="#Counting_Tiles">Counting_Tiles</a>
  <a href="#CYK">CYK</a>
  <a href="#Min_Ed_Dist0">Min_Ed_Dist0</a>
  <a href="#OptBST">OptBST</a>
  <a href="#Longest_Common_Subsequence">Longest_Common_Subsequence</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div>