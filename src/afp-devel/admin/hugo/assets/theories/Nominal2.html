<div id="Nominal2_Base">
<div class="head">
<h1>Theory Nominal2_Base</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Nominal2_Base
    Authors:    Christian Urban, Brian Huffman, Cezary Kaliszyk

    Basic definitions and lemma infrastructure for
    Nominal Isabelle.
*)</span>
<span class="keyword1"><span class="command">theory</span></span> Nominal2_Base
<span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/Infinite_Set.html">HOL-Library.Infinite_Set</a>"</span>
        <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/Multiset.html">HOL-Library.Multiset</a>"</span>
        <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/FSet.html">HOL-Library.FSet</a>"</span>
        <a href="../../finfun/theories/#FinFun">FinFun.FinFun</a>
<span class="keyword2"><span class="keyword">keywords</span></span>
  <span class="quoted">"atom_decl"</span> <span class="quoted">"equivariance"</span> <span class="main">::</span> thy_decl
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">typedef_overloaded</span><span class="main">]</span><span class="main">]</span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Atoms and Sorts›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A simple implementation for <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>atom_sorts›</span></span></span></span> is strings.›</span></span>
<span class="comment1">(* types atom_sort = string *)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹To deal with Church-like binding we use trees of
  strings as sorts.›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> atom_sort <span class="main">=</span> Sort <span class="quoted"><span class="quoted">"string"</span></span> <span class="quoted"><span class="quoted">"atom_sort list"</span></span>

<span class="keyword1"><span class="command">datatype</span></span> atom <span class="main">=</span> Atom <span class="quoted">atom_sort</span> <span class="quoted">nat</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Basic projection function.›</span></span>

<span class="keyword1"><span class="command">primrec</span></span>
  <span class="entity">sort_of</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"atom <span class="main">⇒</span> atom_sort"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">sort_of</span> <span class="main">(</span>Atom <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span>
  <span class="entity">nat_of</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"atom <span class="main">⇒</span> nat"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">nat_of</span> <span class="main">(</span>Atom <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span>"</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹There are infinitely many atoms of each sort.›</span></span>
<span class="keyword1" id="Nominal2_Base-INFM_sort_of_eq"><span class="command">lemma</span></span> INFM_sort_of_eq<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">INFM</span> <span class="bound">a</span><span class="main">.</span> sort_of <span class="bound">a</span> <span class="main">=</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">INFM</span> <span class="bound">i</span><span class="main">.</span> sort_of <span class="main">(</span>Atom <span class="free">s</span> <span class="bound">i</span><span class="main">)</span> <span class="main">=</span> <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"inj <span class="main">(</span>Atom <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inj_on_def<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">INFM</span> <span class="bound">a</span><span class="main">.</span> sort_of <span class="bound">a</span> <span class="main">=</span> <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> INFM_inj<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Base-infinite_sort_of_eq"><span class="command">lemma</span></span> infinite_sort_of_eq<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"infinite <span class="main">{</span><span class="bound">a</span><span class="main">.</span> sort_of <span class="bound">a</span> <span class="main">=</span> <span class="free">s</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> INFM_sort_of_eq <span class="keyword1"><span class="command">unfolding</span></span> INFM_iff_infinite <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1" id="Nominal2_Base-atom_infinite"><span class="command">lemma</span></span> atom_infinite <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"infinite <span class="main">(</span>UNIV <span class="main">::</span> atom set<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> subset_UNIV infinite_sort_of_eq
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> infinite_super<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-obtain_atom"><span class="command">lemma</span></span> obtain_atom<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">X</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"atom set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> X<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">a</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">∉</span> <span class="free">X</span>"</span></span> <span class="quoted"><span class="quoted">"sort_of <span class="free">a</span> <span class="main">=</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> X <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">MOST</span> <span class="bound">a</span><span class="main">.</span> <span class="bound">a</span> <span class="main">∉</span> <span class="free">X</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> MOST_iff_cofinite <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">with</span></span> INFM_sort_of_eq
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">INFM</span> <span class="bound">a</span><span class="main">.</span> sort_of <span class="bound">a</span> <span class="main">=</span> <span class="free">s</span> <span class="main">∧</span> <span class="bound">a</span> <span class="main">∉</span> <span class="free">X</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> INFM_conjI<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∉</span> <span class="free">X</span>"</span></span> <span class="quoted"><span class="quoted">"sort_of <span class="skolem">a</span> <span class="main">=</span> <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> INFM_E<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Base-atom_components_eq_iff"><span class="command">lemma</span></span> atom_components_eq_iff<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">a</span> <span class="free">b</span> <span class="main">::</span> <span class="quoted">atom</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">=</span> <span class="free">b</span> <span class="main">⟷</span> sort_of <span class="free">a</span> <span class="main">=</span> sort_of <span class="free">b</span> <span class="main">∧</span> nat_of <span class="free">a</span> <span class="main">=</span> nat_of <span class="free">b</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">a</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">induct</span> <span class="quoted"><span class="free">b</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Sort-Respecting Permutations›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">perm</span> <span class="main">≡</span> <span class="main">{</span><span class="bound">f</span><span class="main">.</span> bij <span class="bound">f</span> <span class="main">∧</span> finite <span class="main">{</span><span class="bound">a</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">a</span> <span class="main">≠</span> <span class="bound">a</span><span class="main">}</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">a</span><span class="main">.</span> sort_of <span class="main">(</span><span class="bound">f</span> <span class="bound">a</span><span class="main">)</span> <span class="main">=</span> sort_of <span class="bound">a</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">typedef</span></span> perm <span class="main">=</span> <span class="quoted"><span class="quoted">"perm"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"id <span class="main">∈</span> perm"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> perm_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Base-permI"><span class="command">lemma</span></span> permI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"bij <span class="free">f</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">MOST</span> <span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">x</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">a</span><span class="main">.</span> sort_of <span class="main">(</span><span class="free">f</span> <span class="bound">a</span><span class="main">)</span> <span class="main">=</span> sort_of <span class="bound">a</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">∈</span> perm"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> perm_def MOST_iff_cofinite <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-perm_is_bij"><span class="command">lemma</span></span> perm_is_bij<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">∈</span> perm <span class="main">⟹</span> bij <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> perm_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-perm_is_finite"><span class="command">lemma</span></span> perm_is_finite<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">∈</span> perm <span class="main">⟹</span> finite <span class="main">{</span><span class="bound">a</span><span class="main">.</span> <span class="free">f</span> <span class="bound">a</span> <span class="main">≠</span> <span class="bound">a</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> perm_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-perm_is_sort_respecting"><span class="command">lemma</span></span> perm_is_sort_respecting<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">∈</span> perm <span class="main">⟹</span> sort_of <span class="main">(</span><span class="free">f</span> <span class="free">a</span><span class="main">)</span> <span class="main">=</span> sort_of <span class="free">a</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> perm_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-perm_MOST"><span class="command">lemma</span></span> perm_MOST<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">∈</span> perm <span class="main">⟹</span> <span class="keyword1">MOST</span> <span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> perm_def MOST_iff_cofinite <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-perm_id"><span class="command">lemma</span></span> perm_id<span class="main">:</span> <span class="quoted"><span class="quoted">"id <span class="main">∈</span> perm"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> perm_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-perm_comp"><span class="command">lemma</span></span> perm_comp<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> f<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">∈</span> perm"</span></span> <span class="keyword2"><span class="keyword">and</span></span> g<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">∈</span> perm"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">∘</span> <span class="free">g</span><span class="main">)</span> <span class="main">∈</span> perm"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> permI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> bij_comp<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> perm_is_bij <span class="main"><span class="main">[</span></span><span class="operator">OF</span> g<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> perm_is_bij <span class="main"><span class="main">[</span></span><span class="operator">OF</span> f<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> MOST_rev_mp <span class="main"><span class="main">[</span></span><span class="operator">OF</span> perm_MOST <span class="main"><span class="main">[</span></span><span class="operator">OF</span> g<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> MOST_rev_mp <span class="main"><span class="main">[</span></span><span class="operator">OF</span> perm_MOST <span class="main"><span class="main">[</span></span><span class="operator">OF</span> f<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> perm_is_sort_respecting <span class="main"><span class="main">[</span></span><span class="operator">OF</span> f<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> perm_is_sort_respecting <span class="main"><span class="main">[</span></span><span class="operator">OF</span> g<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Nominal2_Base-perm_inv"><span class="command">lemma</span></span> perm_inv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> f<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">∈</span> perm"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>inv <span class="free">f</span><span class="main">)</span> <span class="main">∈</span> perm"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> permI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> bij_imp_bij_inv<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> perm_is_bij <span class="main"><span class="main">[</span></span><span class="operator">OF</span> f<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> MOST_mono <span class="main"><span class="main">[</span></span><span class="operator">OF</span> perm_MOST <span class="main"><span class="main">[</span></span><span class="operator">OF</span> f<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> subst<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> inv_f_f<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> bij_is_inj <span class="main"><span class="main">[</span></span><span class="operator">OF</span> perm_is_bij <span class="main"><span class="main">[</span></span><span class="operator">OF</span> f<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> perm_is_sort_respecting <span class="main"><span class="main">[</span></span><span class="operator">OF</span> f<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> sym<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> trans<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> surj_f_inv_f <span class="main"><span class="main">[</span></span><span class="operator">OF</span> bij_is_surj <span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> perm_is_bij <span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> f<span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Nominal2_Base-bij_Rep_perm"><span class="command">lemma</span></span> bij_Rep_perm<span class="main">:</span> <span class="quoted"><span class="quoted">"bij <span class="main">(</span>Rep_perm <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> Rep_perm <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">p</span></span><span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> perm_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-finite_Rep_perm"><span class="command">lemma</span></span> finite_Rep_perm<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">{</span><span class="bound">a</span><span class="main">.</span> Rep_perm <span class="free">p</span> <span class="bound">a</span> <span class="main">≠</span> <span class="bound">a</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> Rep_perm <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">p</span></span><span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> perm_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-sort_of_Rep_perm"><span class="command">lemma</span></span> sort_of_Rep_perm<span class="main">:</span> <span class="quoted"><span class="quoted">"sort_of <span class="main">(</span>Rep_perm <span class="free">p</span> <span class="free">a</span><span class="main">)</span> <span class="main">=</span> sort_of <span class="free">a</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> Rep_perm <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">p</span></span><span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> perm_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-Rep_perm_ext"><span class="command">lemma</span></span> Rep_perm_ext<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Rep_perm <span class="free">p1</span> <span class="main">=</span> Rep_perm <span class="free">p2</span> <span class="main">⟹</span> <span class="free">p1</span> <span class="main">=</span> <span class="free">p2</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff Rep_perm_inject <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span> perm <span class="main">::</span> <span class="quoted">size</span> <span class="keyword1"><span class="command">..</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Permutations form a (multiplicative) group›</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> perm <span class="main">::</span> <span class="quoted">group_add</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">=</span> Abs_perm id"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">-</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> Abs_perm <span class="main">(</span>inv <span class="main">(</span>Rep_perm <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">+</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">=</span> Abs_perm <span class="main">(</span>Rep_perm <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∘</span> Rep_perm <span class="free"><span class="bound"><span class="entity">q</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free"><span class="bound"><span class="entity">p1</span></span></span><span class="main">::</span>perm<span class="main">)</span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">p2</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">p1</span></span></span> <span class="main">+</span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">p2</span></span></span>"</span></span>

<span class="keyword1" id="Nominal2_Base-Rep_perm_0"><span class="command">lemma</span></span> Rep_perm_0<span class="main">:</span> <span class="quoted"><span class="quoted">"Rep_perm <span class="main">0</span> <span class="main">=</span> id"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> zero_perm_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_perm_inverse perm_id<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-Rep_perm_add"><span class="command">lemma</span></span> Rep_perm_add<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Rep_perm <span class="main">(</span><span class="free">p1</span> <span class="main">+</span> <span class="free">p2</span><span class="main">)</span> <span class="main">=</span> Rep_perm <span class="free">p1</span> <span class="main">∘</span> Rep_perm <span class="free">p2</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> plus_perm_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_perm_inverse perm_comp Rep_perm<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-Rep_perm_uminus"><span class="command">lemma</span></span> Rep_perm_uminus<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Rep_perm <span class="main">(</span><span class="main">-</span> <span class="free">p</span><span class="main">)</span> <span class="main">=</span> inv <span class="main">(</span>Rep_perm <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> uminus_perm_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_perm_inverse perm_inv Rep_perm<span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
<span class="keyword1"><span class="command">unfolding</span></span> Rep_perm_inject <span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
<span class="keyword1"><span class="command">unfolding</span></span> minus_perm_def
<span class="keyword1"><span class="command">unfolding</span></span> Rep_perm_add
<span class="keyword1"><span class="command">unfolding</span></span> Rep_perm_uminus
<span class="keyword1"><span class="command">unfolding</span></span> Rep_perm_0
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_assoc inv_o_cancel <span class="main"><span class="main">[</span></span><span class="operator">OF</span> bij_is_inj <span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> bij_Rep_perm<span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Implementation of swappings›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">swap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"atom <span class="main">⇒</span> atom <span class="main">⇒</span> perm"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">'(</span>_ <span class="keyword1">⇌</span> _<span class="keyword1">')</span>"</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">(</span></span><span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main"><span class="free">⇌</span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main"><span class="free">)</span></span> <span class="main">=</span>
    Abs_perm <span class="main">(</span><span class="keyword1">if</span> sort_of <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">=</span> sort_of <span class="free"><span class="bound"><span class="entity">b</span></span></span>
              <span class="keyword1">then</span> <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">=</span> <span class="bound">c</span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">=</span> <span class="bound">c</span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="keyword1">else</span> <span class="bound">c</span><span class="main">)</span>
              <span class="keyword1">else</span> id<span class="main">)</span>"</span></span>

<span class="keyword1" id="Nominal2_Base-Rep_perm_swap"><span class="command">lemma</span></span> Rep_perm_swap<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Rep_perm <span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">b</span><span class="main">)</span> <span class="main">=</span>
    <span class="main">(</span><span class="keyword1">if</span> sort_of <span class="free">a</span> <span class="main">=</span> sort_of <span class="free">b</span>
     <span class="keyword1">then</span> <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> <span class="keyword1">if</span> <span class="free">a</span> <span class="main">=</span> <span class="bound">c</span> <span class="keyword1">then</span> <span class="free">b</span> <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free">b</span> <span class="main">=</span> <span class="bound">c</span> <span class="keyword1">then</span> <span class="free">a</span> <span class="keyword1">else</span> <span class="bound">c</span><span class="main">)</span>
     <span class="keyword1">else</span> id<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> swap_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> Abs_perm_inverse<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> permI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> bij_def inj_on_def surj_def<span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> MOST_rev_mp <span class="main"><span class="main">[</span></span><span class="operator">OF</span> MOST_neq<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">a</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> MOST_rev_mp <span class="main"><span class="main">[</span></span><span class="operator">OF</span> MOST_neq<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">b</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemmas</span></span> Rep_perm_simps <span class="main">=</span>
  Rep_perm_0
  Rep_perm_add
  Rep_perm_uminus
  Rep_perm_swap

<span class="keyword1" id="Nominal2_Base-swap_different_sorts"><span class="command">lemma</span></span> swap_different_sorts <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"sort_of <span class="free">a</span> <span class="main">≠</span> sort_of <span class="free">b</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">b</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Rep_perm_ext<span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Rep_perm_simps<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-swap_cancel"><span class="command">lemma</span></span> swap_cancel<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">b</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">b</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">b</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="free">b</span> <span class="main">⇌</span> <span class="free">a</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> Rep_perm_ext<span class="main">)</span>
     <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Rep_perm_simps fun_eq_iff<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-swap_self"><span class="command">lemma</span></span> swap_self <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">a</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Rep_perm_ext<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Rep_perm_simps fun_eq_iff<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-minus_swap"><span class="command">lemma</span></span> minus_swap <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">-</span> <span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">b</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">b</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> minus_unique <span class="main"><span class="main">[</span></span><span class="operator">OF</span> swap_cancel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-swap_commute"><span class="command">lemma</span></span> swap_commute<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">b</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">b</span> <span class="main">⇌</span> <span class="free">a</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Rep_perm_ext<span class="main">)</span>
     <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Rep_perm_swap fun_eq_iff<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-swap_triple"><span class="command">lemma</span></span> swap_triple<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">≠</span> <span class="free">b</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">≠</span> <span class="free">b</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"sort_of <span class="free">a</span> <span class="main">=</span> sort_of <span class="free">b</span>"</span></span> <span class="quoted"><span class="quoted">"sort_of <span class="free">b</span> <span class="main">=</span> sort_of <span class="free">c</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">c</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="free">b</span> <span class="main">⇌</span> <span class="free">c</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">c</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">b</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule_tac</span> Rep_perm_ext<span class="main">)</span>
     <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Rep_perm_simps fun_eq_iff<span class="main">)</span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Permutation Types›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Infix syntax for <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>permute›</span></span></span></span> has higher precedence than
  addition, but lower than unary minus.
›</span></span>

<span class="keyword1"><span class="command">class</span></span> pt <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free"><span class="free"><span class="free">permute</span></span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"perm <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="main">(</span><span class="quoted">"_ <span class="keyword1"><span class="keyword1"><span class="keyword1">∙</span></span></span> _"</span> <span class="main">[</span>76<span class="main">,</span> 75<span class="main">]</span> 75<span class="main">)</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> permute_zero <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main"><span class="free">∙</span></span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> permute_plus <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">+</span> <span class="free">q</span><span class="main">)</span> <span class="main"><span class="free">∙</span></span> <span class="free">x</span> <span class="main">=</span> <span class="free">p</span> <span class="main"><span class="free">∙</span></span> <span class="main">(</span><span class="free">q</span> <span class="main"><span class="free">∙</span></span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Nominal2_Base-permute_diff"><span class="command">lemma</span></span> permute_diff <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">-</span> <span class="free">q</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="main">-</span> <span class="free">q</span> <span class="main">∙</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> permute_plus <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="quoted">"<span class="main">-</span> <span class="free">q</span>"</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-permute_minus_cancel"><span class="command">lemma</span></span> permute_minus_cancel <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">-</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">-</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> permute_plus <span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Nominal2_Base-permute_swap_cancel"><span class="command">lemma</span></span> permute_swap_cancel <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> permute_plus <span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> swap_cancel<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-permute_swap_cancel2"><span class="command">lemma</span></span> permute_swap_cancel2 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="main">(</span><span class="free">b</span> <span class="main">⇌</span> <span class="free">a</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> permute_plus <span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> swap_commute<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-inj_permute"><span class="command">lemma</span></span> inj_permute <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"inj <span class="main">(</span>permute <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> inj_on_inverseI<span class="main">)</span>
     <span class="main">(</span><span class="operator">rule</span> permute_minus_cancel<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-surj_permute"><span class="command">lemma</span></span> surj_permute <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"surj <span class="main">(</span>permute <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> surjI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> permute_minus_cancel<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-bij_permute"><span class="command">lemma</span></span> bij_permute <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"bij <span class="main">(</span>permute <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> bijI <span class="main"><span class="main">[</span></span><span class="operator">OF</span> inj_permute surj_permute<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-inv_permute"><span class="command">lemma</span></span> inv_permute<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"inv <span class="main">(</span>permute <span class="free">p</span><span class="main">)</span> <span class="main">=</span> permute <span class="main">(</span><span class="main">-</span> <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> inv_equality<span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-permute_minus"><span class="command">lemma</span></span> permute_minus<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"permute <span class="main">(</span><span class="main">-</span> <span class="free">p</span><span class="main">)</span> <span class="main">=</span> inv <span class="main">(</span>permute <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inv_permute<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-permute_eq_iff"><span class="command">lemma</span></span> permute_eq_iff <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">y</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> inj_permute <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> inj_eq<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Permutations for atoms›</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> atom <span class="main">::</span> <span class="quoted">pt</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∙</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">=</span> <span class="main">(</span>Rep_perm <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span>"</span></span>

<span class="keyword1"><span class="command">instance</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_atom_def Rep_perm_simps<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Nominal2_Base-sort_of_permute"><span class="command">lemma</span></span> sort_of_permute <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sort_of <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">a</span><span class="main">)</span> <span class="main">=</span> sort_of <span class="free">a</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> permute_atom_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> sort_of_Rep_perm<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-swap_atom"><span class="command">lemma</span></span> swap_atom<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">c</span> <span class="main">=</span>
           <span class="main">(</span><span class="keyword1">if</span> sort_of <span class="free">a</span> <span class="main">=</span> sort_of <span class="free">b</span>
            <span class="keyword1">then</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">c</span> <span class="main">=</span> <span class="free">a</span> <span class="keyword1">then</span> <span class="free">b</span> <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free">c</span> <span class="main">=</span> <span class="free">b</span> <span class="keyword1">then</span> <span class="free">a</span> <span class="keyword1">else</span> <span class="free">c</span><span class="main">)</span> <span class="keyword1">else</span> <span class="free">c</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> permute_atom_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Rep_perm_swap<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-swap_atom_simps"><span class="command">lemma</span></span> swap_atom_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"sort_of <span class="free">a</span> <span class="main">=</span> sort_of <span class="free">b</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">a</span> <span class="main">=</span> <span class="free">b</span>"</span></span>
  <span class="quoted"><span class="quoted">"sort_of <span class="free">a</span> <span class="main">=</span> sort_of <span class="free">b</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">b</span> <span class="main">=</span> <span class="free">a</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">≠</span> <span class="free">a</span> <span class="main">⟹</span> <span class="free">c</span> <span class="main">≠</span> <span class="free">b</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">c</span> <span class="main">=</span> <span class="free">c</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> swap_atom <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Nominal2_Base-perm_eq_iff"><span class="command">lemma</span></span> perm_eq_iff<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p</span> <span class="free">q</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"perm"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">=</span> <span class="free">q</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">a</span><span class="main">::</span>atom<span class="main">.</span> <span class="free">p</span> <span class="main">∙</span> <span class="bound">a</span> <span class="main">=</span> <span class="free">q</span> <span class="main">∙</span> <span class="bound">a</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> permute_atom_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Rep_perm_ext ext<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Permutations for permutations›</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> perm <span class="main">::</span> <span class="quoted">pt</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∙</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">+</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span>"</span></span>

<span class="keyword1"><span class="command">instance</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_perm_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_perm_def <span class="dynamic"><span class="dynamic">algebra_simps</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Nominal2_Base-permute_self"><span class="command">lemma</span></span> permute_self<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="free">p</span> <span class="main">=</span> <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> permute_perm_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> add.assoc<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-pemute_minus_self"><span class="command">lemma</span></span> pemute_minus_self<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">-</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">p</span> <span class="main">=</span> <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> permute_perm_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> add.assoc<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Permutations for functions›</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> <span class="quoted">"fun"</span> <span class="main">::</span> <span class="main">(</span><span class="quoted">pt</span><span class="main">,</span> <span class="quoted">pt</span><span class="main">)</span> <span class="quoted">pt</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∙</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∙</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="main">-</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∙</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">instance</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_fun_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_fun_def minus_add<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Nominal2_Base-permute_fun_app_eq"><span class="command">lemma</span></span> permute_fun_app_eq<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">f</span><span class="main">)</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> permute_fun_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-permute_fun_comp"><span class="command">lemma</span></span> permute_fun_comp<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="free">f</span>  <span class="main">=</span> <span class="main">(</span>permute <span class="free">p</span><span class="main">)</span> <span class="keyword1">o</span> <span class="free">f</span> <span class="keyword1">o</span> <span class="main">(</span>permute <span class="main">(</span><span class="main">-</span><span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> comp_def permute_fun_def<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Permutations for booleans›</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> bool <span class="main">::</span> <span class="quoted">pt</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∙</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">::</span>bool<span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span>"</span></span>

<span class="keyword1"><span class="command">instance</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_bool_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Nominal2_Base-permute_boolE"><span class="command">lemma</span></span> permute_boolE<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">P</span><span class="main">::</span><span class="quoted"><span class="quoted">"bool"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="free">P</span> <span class="main">⟹</span> <span class="free">P</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_bool_def<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-permute_boolI"><span class="command">lemma</span></span> permute_boolI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">P</span><span class="main">::</span><span class="quoted"><span class="quoted">"bool"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">⟹</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">P</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_bool_def<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Permutations for sets›</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> <span class="quoted">"set"</span> <span class="main">::</span> <span class="main">(</span><span class="quoted">pt</span><span class="main">)</span> <span class="quoted">pt</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∙</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∙</span> <span class="bound">x</span> <span class="main">|</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">instance</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> permute_set_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Nominal2_Base-permute_set_eq"><span class="command">lemma</span></span> permute_set_eq<span class="main">:</span>
 <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="free">X</span> <span class="main">=</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="main">-</span> <span class="free">p</span> <span class="main">∙</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> permute_set_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> permute_minus_cancel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-permute_set_eq_image"><span class="command">lemma</span></span> permute_set_eq_image<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="free">X</span> <span class="main">=</span> permute <span class="free">p</span> <span class="main">`</span> <span class="free">X</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> permute_set_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Nominal2_Base-permute_set_eq_vimage"><span class="command">lemma</span></span> permute_set_eq_vimage<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="free">X</span> <span class="main">=</span> permute <span class="main">(</span><span class="main">-</span> <span class="free">p</span><span class="main">)</span> <span class="main">-`</span> <span class="free">X</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> permute_set_eq vimage_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-permute_finite"><span class="command">lemma</span></span> permute_finite <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">X</span><span class="main">)</span> <span class="main">=</span> finite <span class="free">X</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> permute_set_eq_vimage
  <span class="keyword1"><span class="command">using</span></span> bij_permute <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> finite_vimage_iff<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-swap_set_not_in"><span class="command">lemma</span></span> swap_set_not_in<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">∉</span> <span class="free">S</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">∉</span> <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">S</span> <span class="main">=</span> <span class="free">S</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> permute_set_def
  <span class="keyword1"><span class="command">using</span></span> a <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> swap_atom<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-swap_set_in"><span class="command">lemma</span></span> swap_set_in<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">∈</span> <span class="free">S</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">∉</span> <span class="free">S</span>"</span></span> <span class="quoted"><span class="quoted">"sort_of <span class="free">a</span> <span class="main">=</span> sort_of <span class="free">b</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">S</span> <span class="main">≠</span> <span class="free">S</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> permute_set_def
  <span class="keyword1"><span class="command">using</span></span> a <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> swap_atom<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-swap_set_in_eq"><span class="command">lemma</span></span> swap_set_in_eq<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">∈</span> <span class="free">S</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">∉</span> <span class="free">S</span>"</span></span> <span class="quoted"><span class="quoted">"sort_of <span class="free">a</span> <span class="main">=</span> sort_of <span class="free">b</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">S</span> <span class="main">=</span> <span class="main">(</span><span class="free">S</span> <span class="main">-</span> <span class="main">{</span><span class="free">a</span><span class="main">}</span><span class="main">)</span> <span class="main">∪</span> <span class="main">{</span><span class="free">b</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> permute_set_def
  <span class="keyword1"><span class="command">using</span></span> a <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> swap_atom<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-swap_set_both_in"><span class="command">lemma</span></span> swap_set_both_in<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">∈</span> <span class="free">S</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">∈</span> <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">S</span> <span class="main">=</span> <span class="free">S</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> permute_set_def
  <span class="keyword1"><span class="command">using</span></span> a <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> swap_atom<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-mem_permute_iff"><span class="command">lemma</span></span> mem_permute_iff<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">X</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">∈</span> <span class="free">X</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> permute_set_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Nominal2_Base-empty_eqvt"><span class="command">lemma</span></span> empty_eqvt<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">{}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> permute_set_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-insert_eqvt"><span class="command">lemma</span></span> insert_eqvt<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>insert <span class="free">x</span> <span class="free">A</span><span class="main">)</span> <span class="main">=</span> insert <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">A</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> permute_set_eq_image image_insert <span class="keyword1"><span class="command">..</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Permutations for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">unit</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> unit <span class="main">::</span> <span class="quoted">pt</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∙</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">::</span>unit<span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span>"</span></span>

<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_unit_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Permutations for products›</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> prod <span class="main">::</span> <span class="main">(</span><span class="quoted">pt</span><span class="main">,</span> <span class="quoted">pt</span><span class="main">)</span> <span class="quoted">pt</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">primrec</span></span>
  <span class="entity"><span class="class_parameter">permute_prod</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  Pair_eqvt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∙</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∙</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∙</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="operator">auto</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Permutations for sums›</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> sum <span class="main">::</span> <span class="main">(</span><span class="quoted">pt</span><span class="main">,</span> <span class="quoted">pt</span><span class="main">)</span> <span class="quoted">pt</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">primrec</span></span>
  <span class="entity"><span class="class_parameter">permute_sum</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  Inl_eqvt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∙</span> <span class="main">(</span>Inl <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> Inl <span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∙</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> Inr_eqvt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∙</span> <span class="main">(</span>Inr <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">=</span> Inr <span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∙</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">case_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> <span class="quoted"><span class="improper"><span class="quoted"><span class="improper">x</span></span></span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Permutations for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> list"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> list <span class="main">::</span> <span class="main">(</span><span class="quoted">pt</span><span class="main">)</span> <span class="quoted">pt</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">primrec</span></span>
  <span class="entity"><span class="class_parameter">permute_list</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  Nil_eqvt<span class="main">:</span>  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∙</span> <span class="main">[]</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
<span class="main">|</span> Cons_eqvt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∙</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∙</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∙</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>

<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> <span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper">x</span></span></span></span></span></span></span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Nominal2_Base-set_eqvt"><span class="command">lemma</span></span> set_eqvt<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>set <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> set <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> empty_eqvt insert_eqvt<span class="main">)</span>



<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Permutations for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> option"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> option <span class="main">::</span> <span class="main">(</span><span class="quoted">pt</span><span class="main">)</span> <span class="quoted">pt</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">primrec</span></span>
  <span class="entity"><span class="class_parameter">permute_option</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  None_eqvt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∙</span> None <span class="main">=</span> None"</span></span>
<span class="main">|</span> Some_eqvt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∙</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> Some <span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∙</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> <span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper">x</span></span></span></span></span></span></span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Permutations for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> multiset"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> multiset <span class="main">::</span> <span class="main">(</span><span class="quoted">pt</span><span class="main">)</span> <span class="quoted">pt</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∙</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="main">=</span> <span class="main">{#</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∙</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="main">#}</span>"</span></span>

<span class="keyword1"><span class="command">instance</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">M</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> multiset"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">p</span> <span class="skolem">q</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"perm"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">∙</span> <span class="skolem">M</span> <span class="main">=</span> <span class="skolem">M</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> permute_multiset_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">M</span></span></span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">p</span> <span class="main">+</span> <span class="skolem">q</span><span class="main">)</span> <span class="main">∙</span> <span class="skolem">M</span> <span class="main">=</span> <span class="skolem">p</span> <span class="main">∙</span> <span class="skolem">q</span> <span class="main">∙</span> <span class="skolem">M</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> permute_multiset_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">M</span></span></span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Nominal2_Base-permute_multiset"><span class="command">lemma</span></span> permute_multiset <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">M</span> <span class="free">N</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>pt<span class="main">)</span> multiset"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="main">{#}</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">{#}</span> <span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>pt<span class="main">)</span> multiset<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">∙</span> add_mset <span class="free">x</span> <span class="free">M</span><span class="main">)</span> <span class="main">=</span> add_mset <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">M</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">M</span> <span class="main">+</span> <span class="free">N</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">M</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">N</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> permute_multiset_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Permutations for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> fset"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> fset <span class="main">::</span> <span class="main">(</span><span class="quoted">pt</span><span class="main">)</span> <span class="quoted">pt</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> fset.lifting <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span>
  <span class="quoted">"<span class="class_parameter">permute_fset</span>"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"perm <span class="main">⇒</span> <span class="tfree">'a</span> fset <span class="main">⇒</span> <span class="tfree">'a</span> fset"</span></span>
<span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"permute <span class="main">::</span> perm <span class="main">⇒</span> <span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> fset.lifting <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">instance</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> fset"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">p</span> <span class="skolem">q</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"perm"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">∙</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">p</span> <span class="main">+</span> <span class="skolem">q</span><span class="main">)</span> <span class="main">∙</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">p</span> <span class="main">∙</span> <span class="skolem">q</span> <span class="main">∙</span> <span class="skolem">x</span>"</span></span>  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> fset.lifting
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1" id="Nominal2_Base-permute_fset"><span class="command">lemma</span></span> permute_fset <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">S</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>pt<span class="main">)</span> fset"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="main">{||}</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">{||}</span> <span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>pt<span class="main">)</span> fset<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">∙</span> finsert <span class="free">x</span> <span class="free">S</span><span class="main">)</span> <span class="main">=</span> finsert <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">S</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> empty_eqvt<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> insert_eqvt<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Nominal2_Base-fset_eqvt"><span class="command">lemma</span></span> fset_eqvt<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>fset <span class="free">S</span><span class="main">)</span> <span class="main">=</span> fset <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">S</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>
<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Permutations for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">,</span></span> <span class="tfree"><span class="tfree">'b</span></span><span class="main"><span class="main">)</span></span> finfun"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> finfun <span class="main">::</span> <span class="main">(</span><span class="quoted">pt</span><span class="main">,</span> <span class="quoted">pt</span><span class="main">)</span> <span class="quoted">pt</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span>
  <span class="class_parameter">permute_finfun</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"perm <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> finfun <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> finfun"</span></span>
<span class="keyword2"><span class="keyword">is</span></span>
  <span class="quoted"><span class="quoted">"permute <span class="main">::</span> perm <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_fun_comp<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> finfun_right_compose<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> finfun_left_compose<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">assumption</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">instance</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">transfer</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">transfer</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Permutations for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">char</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">nat</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">int</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> char <span class="main">::</span> <span class="quoted">pt</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∙</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">::</span>char<span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span>"</span></span>

<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_char_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> nat <span class="main">::</span> <span class="quoted">pt</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∙</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">::</span>nat<span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span>"</span></span>

<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_nat_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> int <span class="main">::</span> <span class="quoted">pt</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∙</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">::</span>int<span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span>"</span></span>

<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_int_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Pure types›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Pure types will have always empty support.›</span></span>

<span class="keyword1"><span class="command">class</span></span> pure <span class="main">=</span> pt <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> permute_pure<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Types <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">unit</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">bool</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> are pure.›</span></span>

<span class="keyword1"><span class="command">instance</span></span> unit <span class="main">::</span> <span class="quoted">pure</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">rule</span> permute_unit_def<span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span> bool <span class="main">::</span> <span class="quoted">pure</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">rule</span> permute_bool_def<span class="main">)</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Other type constructors preserve purity.›</span></span>

<span class="keyword1"><span class="command">instance</span></span> <span class="quoted">"fun"</span> <span class="main">::</span> <span class="main">(</span><span class="quoted">pure</span><span class="main">,</span> <span class="quoted">pure</span><span class="main">)</span> <span class="quoted">pure</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_fun_def permute_pure<span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span> set <span class="main">::</span> <span class="main">(</span><span class="quoted">pure</span><span class="main">)</span> <span class="quoted">pure</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_set_def permute_pure<span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span> prod <span class="main">::</span> <span class="main">(</span><span class="quoted">pure</span><span class="main">,</span> <span class="quoted">pure</span><span class="main">)</span> <span class="quoted">pure</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="improper"><span class="quoted"><span class="improper">x</span></span></span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_pure<span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span> sum <span class="main">::</span> <span class="main">(</span><span class="quoted">pure</span><span class="main">,</span> <span class="quoted">pure</span><span class="main">)</span> <span class="quoted">pure</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="improper"><span class="quoted"><span class="improper">x</span></span></span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_pure<span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span> list <span class="main">::</span> <span class="main">(</span><span class="quoted">pure</span><span class="main">)</span> <span class="quoted">pure</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="improper"><span class="quoted"><span class="improper">x</span></span></span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_pure<span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span> option <span class="main">::</span> <span class="main">(</span><span class="quoted">pure</span><span class="main">)</span> <span class="quoted">pure</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="improper"><span class="quoted"><span class="improper">x</span></span></span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_pure<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Types <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">char</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">nat</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">int</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">instance</span></span> char <span class="main">::</span> <span class="quoted">pure</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">rule</span> permute_char_def<span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span> nat <span class="main">::</span> <span class="quoted">pure</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">rule</span> permute_nat_def<span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span> int <span class="main">::</span> <span class="quoted">pure</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">rule</span> permute_int_def<span class="main">)</span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Infrastructure for Equivariance and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Perm_simp›</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Basic functions about permutations›</span></span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹nominal_basics.ML›</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Eqvt infrastructure›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Setup of the theorem attributes <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>eqvt›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>eqvt_raw›</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹nominal_thmdecls.ML›</span>


<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span> <span class="main">=</span>
  <span class="comment1">(* pt types *)</span>
  permute_prod.simps
  permute_list.simps
  permute_option.simps
  permute_sum.simps

  <span class="comment1">(* sets *)</span>
  empty_eqvt insert_eqvt set_eqvt

  <span class="comment1">(* fsets *)</span>
  permute_fset fset_eqvt

  <span class="comment1">(* multisets *)</span>
  permute_multiset

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>perm_simp›</span></span></span></span> infrastructure›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">unpermute</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> permute <span class="main">(</span><span class="main">-</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Nominal2_Base-eqvt_apply"><span class="command">lemma</span></span> eqvt_apply<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>pt <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>pt"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>pt"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">≡</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">f</span><span class="main">)</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> permute_fun_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-eqvt_lambda"><span class="command">lemma</span></span> eqvt_lambda<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>pt <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>pt"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="free">f</span> <span class="main">≡</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">f</span> <span class="main">(</span>unpermute <span class="free">p</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> permute_fun_def unpermute_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-eqvt_bound"><span class="command">lemma</span></span> eqvt_bound<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> unpermute <span class="free">p</span> <span class="free">x</span> <span class="main">≡</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> unpermute_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹provides <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>perm_simp›</span></span></span></span> methods›</span></span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹nominal_permeq.ML›</span>

<span class="keyword1"><span class="command">method_setup</span></span> perm_simp <span class="main">=</span>
 <span class="quoted">‹<span class="entity">Nominal_Permeq.args_parser</span> &gt;&gt; <span class="entity">Nominal_Permeq.perm_simp_meth</span>›</span>
 <span class="quoted">‹pushes permutations inside.›</span>

<span class="keyword1"><span class="command">method_setup</span></span> perm_strict_simp <span class="main">=</span>
 <span class="quoted">‹<span class="entity">Nominal_Permeq.args_parser</span> &gt;&gt; <span class="entity">Nominal_Permeq.perm_strict_simp_meth</span>›</span>
 <span class="quoted">‹pushes permutations inside, raises an error if it cannot solve all permutations.›</span>

<span class="keyword1"><span class="command">simproc_setup</span></span> perm_simproc <span class="main">(</span><span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="free">t</span>"</span></span><span class="main">)</span> <span class="main">=</span> <span class="quoted">‹<span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctrm</span> <span class="main">=&gt;</span>
  <span class="keyword2"><span class="keyword">case</span></span> Thm.term_of <span class="main">(</span>Thm.dest_arg <span class="entity">ctrm</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
    Free <span class="main">_</span> <span class="main">=&gt;</span> NONE
  <span class="main">|</span> Var <span class="main">_</span> <span class="main">=&gt;</span> NONE
  <span class="main">|</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> permute<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">_</span> $ <span class="main">_</span> <span class="main">=&gt;</span> NONE
  <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm</span> <span class="main">=</span> <span class="entity">Nominal_Permeq.eqvt_conv</span> <span class="entity">ctxt</span> <span class="entity">Nominal_Permeq.eqvt_strict_config</span> <span class="entity">ctrm</span>
          <span class="keyword3"><span class="keyword">handle</span></span> ERROR <span class="main">_</span> <span class="main">=&gt;</span> Thm.reflexive <span class="entity">ctrm</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="keyword2"><span class="keyword">if</span></span> Thm.is_reflexive <span class="entity">thm</span> <span class="keyword2"><span class="keyword">then</span></span> NONE <span class="keyword2"><span class="keyword">else</span></span> SOME<span class="main">(</span><span class="entity">thm</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
›</span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Equivariance for permutations and swapping›</span></span>

<span class="keyword1" id="Nominal2_Base-permute_eqvt"><span class="command">lemma</span></span> permute_eqvt<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">q</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">q</span><span class="main">)</span> <span class="main">∙</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> permute_perm_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="comment1">(* the normal version of this lemma would cause loops *)</span>
<span class="keyword1" id="Nominal2_Base-permute_eqvt_raw"><span class="command">lemma</span></span> permute_eqvt_raw <span class="main">[</span><span class="operator">eqvt_raw</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> permute <span class="main">≡</span> permute"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff permute_fun_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> permute_eqvt<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Nominal2_Base-zero_perm_eqvt"><span class="command">lemma</span></span> zero_perm_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="main">0</span><span class="main">::</span>perm<span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> permute_perm_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-add_perm_eqvt"><span class="command">lemma</span></span> add_perm_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p</span> <span class="free">p1</span> <span class="free">p2</span> <span class="main">::</span> <span class="quoted">perm</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">p1</span> <span class="main">+</span> <span class="free">p2</span><span class="main">)</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">p1</span> <span class="main">+</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">p2</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> permute_perm_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> perm_eq_iff<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-swap_eqvt"><span class="command">lemma</span></span> swap_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">b</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">a</span> <span class="main">⇌</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">b</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> permute_perm_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> swap_atom perm_eq_iff<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-uminus_eqvt"><span class="command">lemma</span></span> uminus_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p</span> <span class="free">q</span><span class="main">::</span><span class="quoted"><span class="quoted">"perm"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="main">-</span> <span class="free">q</span><span class="main">)</span> <span class="main">=</span> <span class="main">-</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">q</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> permute_perm_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> diff_add_eq_diff_diff_swap<span class="main">)</span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Equivariance of Logical Operators›</span></span>

<span class="keyword1" id="Nominal2_Base-eq_eqvt"><span class="command">lemma</span></span> eq_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">x</span> <span class="main">=</span> <span class="free">y</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> permute_eq_iff permute_bool_def <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1" id="Nominal2_Base-Not_eqvt"><span class="command">lemma</span></span> Not_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="main">¬</span> <span class="free">A</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">¬</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">A</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_bool_def<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-conj_eqvt"><span class="command">lemma</span></span> conj_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">A</span> <span class="main">∧</span> <span class="free">B</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">A</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">B</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_bool_def<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-imp_eqvt"><span class="command">lemma</span></span> imp_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">A</span> <span class="main">⟶</span> <span class="free">B</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">A</span><span class="main">)</span> <span class="main">⟶</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">B</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_bool_def<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> imp_eqvt<span class="main">[</span><span class="operator">folded</span> HOL.induct_implies_def<span class="main">,</span> <span class="operator">eqvt</span><span class="main">]</span>

<span class="keyword1" id="Nominal2_Base-all_eqvt"><span class="command">lemma</span></span> all_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">P</span><span class="main">)</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> All_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">perm_simp</span><span class="main">)</span> <span class="main">(</span><span class="operator">rule</span> refl<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> all_eqvt<span class="main">[</span><span class="operator">folded</span> HOL.induct_forall_def<span class="main">,</span> <span class="operator">eqvt</span><span class="main">]</span>

<span class="keyword1" id="Nominal2_Base-ex_eqvt"><span class="command">lemma</span></span> ex_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">P</span><span class="main">)</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Ex_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">perm_simp</span><span class="main">)</span> <span class="main">(</span><span class="operator">rule</span> refl<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-ex1_eqvt"><span class="command">lemma</span></span> ex1_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="main">∃!</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∃!</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">P</span><span class="main">)</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Ex1_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">perm_simp</span><span class="main">)</span> <span class="main">(</span><span class="operator">rule</span> refl<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-if_eqvt"><span class="command">lemma</span></span> if_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">b</span> <span class="keyword1">then</span> <span class="free">x</span> <span class="keyword1">else</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">b</span> <span class="keyword1">then</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">x</span> <span class="keyword1">else</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_fun_def permute_bool_def<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-True_eqvt"><span class="command">lemma</span></span> True_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> True <span class="main">=</span> True"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> permute_bool_def <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1" id="Nominal2_Base-False_eqvt"><span class="command">lemma</span></span> False_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> False <span class="main">=</span> False"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> permute_bool_def <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1" id="Nominal2_Base-disj_eqvt"><span class="command">lemma</span></span> disj_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">A</span> <span class="main">∨</span> <span class="free">B</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">A</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">B</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_bool_def<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-all_eqvt2"><span class="command">lemma</span></span> all_eqvt2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">P</span> <span class="main">(</span><span class="main">-</span> <span class="free">p</span> <span class="main">∙</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">perm_simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_minus_cancel<span class="main">)</span> <span class="main">(</span><span class="operator">rule</span> refl<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-ex_eqvt2"><span class="command">lemma</span></span> ex_eqvt2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">P</span> <span class="main">(</span><span class="main">-</span> <span class="free">p</span> <span class="main">∙</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">perm_simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_minus_cancel<span class="main">)</span> <span class="main">(</span><span class="operator">rule</span> refl<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-ex1_eqvt2"><span class="command">lemma</span></span> ex1_eqvt2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="main">∃!</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∃!</span><span class="bound">x</span><span class="main">.</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">P</span> <span class="main">(</span><span class="main">-</span> <span class="free">p</span> <span class="main">∙</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">perm_simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_minus_cancel<span class="main">)</span> <span class="main">(</span><span class="operator">rule</span> refl<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-the_eqvt"><span class="command">lemma</span></span> the_eqvt<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> unique<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃!</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="keyword1">THE</span> <span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">THE</span> <span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">P</span><span class="main">)</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> the1_equality <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> p<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">-</span><span class="free">p</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> permute_boolE<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">perm_simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_minus_cancel<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> unique<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> p<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">-</span><span class="free">p</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> permute_boolE<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">perm_simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_minus_cancel<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> theI'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> unique<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Nominal2_Base-the_eqvt2"><span class="command">lemma</span></span> the_eqvt2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> unique<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃!</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="keyword1">THE</span> <span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">THE</span> <span class="bound">x</span><span class="main">.</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">P</span> <span class="main">(</span><span class="main">-</span> <span class="free">p</span> <span class="main">∙</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> the1_equality <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> ex1_eqvt2<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_bool_def unique<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_bool_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> theI'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> unique<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Equivariance of Set operators›</span></span>

<span class="keyword1" id="Nominal2_Base-mem_eqvt"><span class="command">lemma</span></span> mem_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">x</span> <span class="main">∈</span> <span class="free">A</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">A</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> permute_bool_def permute_set_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-Collect_eqvt"><span class="command">lemma</span></span> Collect_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">P</span><span class="main">)</span> <span class="bound">x</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> permute_set_eq permute_fun_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> permute_bool_def<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-Bex_eqvt"><span class="command">lemma</span></span> Bex_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">S</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span> <span class="main">∈</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">S</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">P</span><span class="main">)</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Bex_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-Ball_eqvt"><span class="command">lemma</span></span> Ball_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">S</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">S</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">P</span><span class="main">)</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Ball_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-image_eqvt"><span class="command">lemma</span></span> image_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">f</span> <span class="main">`</span> <span class="free">A</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">f</span><span class="main">)</span> <span class="main">`</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">A</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> image_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-Image_eqvt"><span class="command">lemma</span></span> Image_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">R</span> <span class="main">``</span> <span class="free">A</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">R</span><span class="main">)</span> <span class="main">``</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">A</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Image_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-UNIV_eqvt"><span class="command">lemma</span></span> UNIV_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> UNIV <span class="main">=</span> UNIV"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> UNIV_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">perm_simp</span><span class="main">)</span> <span class="main">(</span><span class="operator">rule</span> refl<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-inter_eqvt"><span class="command">lemma</span></span> inter_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">A</span> <span class="main">∩</span> <span class="free">B</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">A</span><span class="main">)</span> <span class="main">∩</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">B</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Int_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-Inter_eqvt"><span class="command">lemma</span></span> Inter_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">⋂</span><span class="free">S</span> <span class="main">=</span> <span class="main">⋂</span><span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">S</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Inter_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-union_eqvt"><span class="command">lemma</span></span> union_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">A</span> <span class="main">∪</span> <span class="free">B</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">A</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">B</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Un_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-Union_eqvt"><span class="command">lemma</span></span> Union_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">⋃</span><span class="free">A</span> <span class="main">=</span> <span class="main">⋃</span><span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">A</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Union_eq
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">perm_simp</span> <span class="operator">rule</span>

<span class="keyword1" id="Nominal2_Base-Diff_eqvt"><span class="command">lemma</span></span> Diff_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">A</span> <span class="free">B</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>pt set"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">A</span> <span class="main">-</span> <span class="free">B</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">A</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">B</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> set_diff_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-Compl_eqvt"><span class="command">lemma</span></span> Compl_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">A</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>pt set"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="main">-</span> <span class="free">A</span><span class="main">)</span> <span class="main">=</span> <span class="main">-</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">A</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Compl_eq_Diff_UNIV <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-subset_eqvt"><span class="command">lemma</span></span> subset_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">S</span> <span class="main">⊆</span> <span class="free">T</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">S</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">T</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> subset_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-psubset_eqvt"><span class="command">lemma</span></span> psubset_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">S</span> <span class="main">⊂</span> <span class="free">T</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">S</span><span class="main">)</span> <span class="main">⊂</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">T</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> psubset_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-vimage_eqvt"><span class="command">lemma</span></span> vimage_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">f</span> <span class="main">-`</span> <span class="free">A</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">f</span><span class="main">)</span> <span class="main">-`</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">A</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> vimage_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-foldr_eqvt"><span class="command">lemma</span></span> foldr_eqvt<span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> foldr <span class="free">f</span> <span class="free">xs</span> <span class="main">=</span> foldr <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">f</span><span class="main">)</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">perm_simp</span> <span class="quasi_keyword">exclude</span><span class="main"><span class="main">:</span></span> foldr<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="comment1">(* FIXME: eqvt attribute *)</span>
<span class="keyword1" id="Nominal2_Base-Sigma_eqvt"><span class="command">lemma</span></span> Sigma_eqvt<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">X</span> <span class="main">×</span> <span class="free">Y</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">X</span><span class="main">)</span> <span class="main">×</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">Y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Sigma_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">perm_simp</span><span class="main">)</span> <span class="main">(</span><span class="operator">rule</span> refl<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  In order to prove that lfp is equivariant we need two
  auxiliary classes which specify that (&lt;=) and
  Inf are equivariant. Instances for bool and fun are
  given.
›</span></span>

<span class="keyword1"><span class="command">class</span></span> le_eqvt <span class="main">=</span> pt <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> le_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">x</span> <span class="main">≤</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="main">≤</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">y</span> <span class="main">::</span> <span class="tfree">'a</span> <span class="main">::</span> <span class="main">{</span>order<span class="main">,</span> pt<span class="main">}</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">class</span></span> inf_eqvt <span class="main">=</span> pt <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> inf_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>Inf <span class="free">X</span><span class="main">)</span> <span class="main">=</span> Inf <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">X</span> <span class="main">::</span> <span class="tfree">'a</span> <span class="main">::</span> <span class="main">{</span>complete_lattice<span class="main">,</span> pt<span class="main">}</span> set<span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> bool <span class="main">::</span> <span class="quoted">le_eqvt</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">instance</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
<span class="keyword1"><span class="command">unfolding</span></span> le_bool_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">perm_simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> refl<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> <span class="quoted">"fun"</span> <span class="main">::</span> <span class="main">(</span><span class="quoted">pt</span><span class="main">,</span> <span class="quoted">le_eqvt</span><span class="main">)</span> <span class="quoted">le_eqvt</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">instance</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
<span class="keyword1"><span class="command">unfolding</span></span> le_fun_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">perm_simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> refl<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> bool <span class="main">::</span> <span class="quoted">inf_eqvt</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">instance</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
<span class="keyword1"><span class="command">unfolding</span></span> Inf_bool_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">perm_simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> refl<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> <span class="quoted">"fun"</span> <span class="main">::</span> <span class="main">(</span><span class="quoted">pt</span><span class="main">,</span> <span class="quoted">inf_eqvt</span><span class="main">)</span> <span class="quoted">inf_eqvt</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">instance</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
<span class="keyword1"><span class="command">unfolding</span></span> Inf_fun_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">perm_simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> refl<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Nominal2_Base-lfp_eqvt"><span class="command">lemma</span></span> lfp_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">F</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>pt <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span><span class="main">{</span>inf_eqvt<span class="main">,</span> le_eqvt<span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>lfp <span class="free">F</span><span class="main">)</span> <span class="main">=</span> lfp <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">F</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> lfp_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-finite_eqvt"><span class="command">lemma</span></span> finite_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> finite <span class="free">A</span> <span class="main">=</span> finite <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> finite_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-fun_upd_eqvt"><span class="command">lemma</span></span> fun_upd_eqvt<span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">f</span><span class="main">(</span><span class="free">x</span> <span class="main">:=</span> <span class="free">y</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">f</span><span class="main">)</span><span class="main">(</span><span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="main">:=</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fun_upd_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-comp_eqvt"><span class="command">lemma</span></span> comp_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">f</span> <span class="main">∘</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">f</span><span class="main">)</span> <span class="main">∘</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">g</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> comp_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Equivariance for product operations›</span></span>

<span class="keyword1" id="Nominal2_Base-fst_eqvt"><span class="command">lemma</span></span> fst_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>fst <span class="free">x</span><span class="main">)</span> <span class="main">=</span> fst <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-snd_eqvt"><span class="command">lemma</span></span> snd_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>snd <span class="free">x</span><span class="main">)</span> <span class="main">=</span> snd <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-split_eqvt"><span class="command">lemma</span></span> split_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>case_prod <span class="free">P</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> case_prod <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">P</span><span class="main">)</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> split_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Equivariance for list operations›</span></span>

<span class="keyword1" id="Nominal2_Base-append_eqvt"><span class="command">lemma</span></span> append_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">xs</span><span class="main">)</span> <span class="main">@</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Nominal2_Base-rev_eqvt"><span class="command">lemma</span></span> rev_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>rev <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> rev <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> append_eqvt<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-map_eqvt"><span class="command">lemma</span></span> map_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>map <span class="free">f</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> map <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">f</span><span class="main">)</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-removeAll_eqvt"><span class="command">lemma</span></span> removeAll_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>removeAll <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> removeAll <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-filter_eqvt"><span class="command">lemma</span></span> filter_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>filter <span class="free">f</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> filter <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">f</span><span class="main">)</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> filter.simps permute_list.simps if_eqvt<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> permute_fun_app_eq<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Nominal2_Base-distinct_eqvt"><span class="command">lemma</span></span> distinct_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>distinct <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> distinct <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_bool_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> conj_eqvt Not_eqvt mem_eqvt set_eqvt<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Nominal2_Base-length_eqvt"><span class="command">lemma</span></span> length_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>length <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> length <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_pure<span class="main">)</span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Equivariance for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> option"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1" id="Nominal2_Base-map_option_eqvt"><span class="command">lemma</span></span> map_option_eqvt<span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>map_option <span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> map_option <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">f</span><span class="main">)</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Equivariance for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> fset"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> fset.lifting <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1" id="Nominal2_Base-in_fset_eqvt"><span class="command">lemma</span></span> in_fset_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">x</span> <span class="main">|∈|</span> <span class="free">S</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="main">|∈|</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">S</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-union_fset_eqvt"><span class="command">lemma</span></span> union_fset_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">S</span> <span class="main">|∪|</span> <span class="free">T</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">S</span><span class="main">)</span> <span class="main">|∪|</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">T</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">S</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-inter_fset_eqvt"><span class="command">lemma</span></span> inter_fset_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">S</span> <span class="main">|∩|</span> <span class="free">T</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">S</span><span class="main">)</span> <span class="main">|∩|</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">T</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-subset_fset_eqvt"><span class="command">lemma</span></span> subset_fset_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">S</span> <span class="main">|⊆|</span> <span class="free">T</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">S</span><span class="main">)</span> <span class="main">|⊆|</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">T</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-map_fset_eqvt"><span class="command">lemma</span></span> map_fset_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">f</span> <span class="main">|`|</span> <span class="free">S</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">f</span><span class="main">)</span> <span class="main">|`|</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">S</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Equivariance for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">,</span></span> <span class="tfree"><span class="tfree">'b</span></span><span class="main"><span class="main">)</span></span> finfun"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1" id="Nominal2_Base-finfun_update_eqvt"><span class="command">lemma</span></span> finfun_update_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>finfun_update <span class="free">f</span> <span class="free">a</span> <span class="free">b</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> finfun_update <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">f</span><span class="main">)</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">a</span><span class="main">)</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">b</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main">)</span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-finfun_const_eqvt"><span class="command">lemma</span></span> finfun_const_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>finfun_const <span class="free">b</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> finfun_const <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">b</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main">)</span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-finfun_apply_eqvt"><span class="command">lemma</span></span> finfun_apply_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>finfun_apply <span class="free">f</span> <span class="free">b</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> finfun_apply <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">f</span><span class="main">)</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">b</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main">)</span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Supp, Freshness and Supports›</span></span>

<span class="keyword1"><span class="command">context</span></span> pt
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">supp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> atom set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">supp</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound">a</span><span class="main">.</span> infinite <span class="main">{</span><span class="bound">b</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span> <span class="main">⇌</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≠</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">}</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">fresh</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"atom <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="quoted">"_ <span class="keyword1">♯</span> _"</span> <span class="main">[</span>55<span class="main">,</span> 55<span class="main">]</span> 55<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main"><span class="free">♯</span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">∉</span> supp <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Nominal2_Base-supp_conv_fresh"><span class="command">lemma</span></span> supp_conv_fresh<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="free">x</span> <span class="main">=</span> <span class="main">{</span><span class="bound">a</span><span class="main">.</span> <span class="main">¬</span> <span class="bound">a</span> <span class="main">♯</span> <span class="free">x</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fresh_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-swap_rel_trans"><span class="command">lemma</span></span> swap_rel_trans<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"sort_of <span class="free">a</span> <span class="main">=</span> sort_of <span class="free">b</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"sort_of <span class="free">b</span> <span class="main">=</span> sort_of <span class="free">c</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">c</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">b</span> <span class="main">⇌</span> <span class="free">c</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">=</span> <span class="free">b</span> <span class="main">∨</span> <span class="free">c</span> <span class="main">=</span> <span class="free">b</span>"</span></span>
  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="main">(</span><span class="free">a</span> <span class="main">=</span> <span class="free">b</span> <span class="main">∨</span> <span class="free">c</span> <span class="main">=</span> <span class="free">b</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">c</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="free">b</span> <span class="main">⇌</span> <span class="free">c</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">c</span><span class="main">)</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">c</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="free">b</span> <span class="main">⇌</span> <span class="free">c</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">c</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">b</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms * <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> swap_triple<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Base-swap_fresh_fresh"><span class="command">lemma</span></span> swap_fresh_fresh<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>     b<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">♯</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> asm<span class="main">:</span> <span class="quoted"><span class="quoted">"sort_of <span class="free">a</span> <span class="main">=</span> sort_of <span class="free">b</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">{</span><span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">≠</span> <span class="free">x</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">{</span><span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="free">b</span> <span class="main">⇌</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">≠</span> <span class="free">x</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> a b <span class="keyword1"><span class="command">unfolding</span></span> fresh_def supp_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="main">{</span><span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">≠</span> <span class="free">x</span><span class="main">}</span> <span class="main">∪</span> <span class="main">{</span><span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="free">b</span> <span class="main">⇌</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">≠</span> <span class="free">x</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">c</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="skolem">c</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">b</span> <span class="main">⇌</span> <span class="skolem">c</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="quoted"><span class="quoted">"sort_of <span class="skolem">c</span> <span class="main">=</span> sort_of <span class="free">b</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> obtain_atom<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> asm <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule_tac</span> swap_rel_trans<span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"sort_of <span class="free">a</span> <span class="main">≠</span> sort_of <span class="free">b</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹supp and fresh are equivariant›</span></span>


<span class="keyword1" id="Nominal2_Base-supp_eqvt"><span class="command">lemma</span></span> supp_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>supp <span class="free">x</span><span class="main">)</span> <span class="main">=</span> supp <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> supp_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-fresh_eqvt"><span class="command">lemma</span></span> fresh_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">a</span> <span class="main">♯</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">a</span><span class="main">)</span> <span class="main">♯</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fresh_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-fresh_permute_iff"><span class="command">lemma</span></span> fresh_permute_iff<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">a</span><span class="main">)</span> <span class="main">♯</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> fresh_eqvt<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> permute_bool_def<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fresh_permute_left"><span class="command">lemma</span></span> fresh_permute_left<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">⟷</span> <span class="main">-</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">-</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">a</span> <span class="main">♯</span> <span class="main">-</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> fresh_permute_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">-</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">-</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">-</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> fresh_permute_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹supports›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">supports</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"atom set <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">::</span>pt <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">supports</span>"</span> 80<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="keyword1"><span class="free">supports</span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> <span class="main">∀</span><span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span> <span class="main">∉</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="main">∧</span> <span class="bound">b</span> <span class="main">∉</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="main">⟶</span> <span class="main">(</span><span class="bound">a</span> <span class="main">⇌</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Nominal2_Base-supp_is_subset"><span class="command">lemma</span></span> supp_is_subset<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">S</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"atom set"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="free">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>pt"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">S</span> <span class="keyword1">supports</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>     a2<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>supp <span class="free">x</span><span class="main">)</span> <span class="main">⊆</span> <span class="free">S</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">⊆</span> <span class="free">S</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a</span></span> <span class="keyword2"><span class="keyword">where</span></span> b1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> supp <span class="free">x</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> b2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∉</span> <span class="free">S</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> a1 b2 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b</span><span class="main">.</span> <span class="bound">b</span> <span class="main">∉</span> <span class="free">S</span> <span class="main">⟶</span> <span class="main">(</span><span class="skolem">a</span> <span class="main">⇌</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> supports_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">b</span><span class="main">.</span> <span class="main">(</span><span class="skolem">a</span> <span class="main">⇌</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">≠</span> <span class="free">x</span><span class="main">}</span> <span class="main">⊆</span> <span class="free">S</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> a2 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">{</span><span class="bound">b</span><span class="main">.</span> <span class="main">(</span><span class="skolem">a</span> <span class="main">⇌</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">≠</span> <span class="free">x</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finite_subset<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∉</span> <span class="main">(</span>supp <span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> supp_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">with</span></span> b1 <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Base-supports_finite"><span class="command">lemma</span></span> supports_finite<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">S</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"atom set"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="free">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>pt"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">S</span> <span class="keyword1">supports</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>     a2<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>supp <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>supp <span class="free">x</span><span class="main">)</span> <span class="main">⊆</span> <span class="free">S</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> a1 a2 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> supp_is_subset<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>supp <span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> a2 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finite_subset<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Base-supp_supports"><span class="command">lemma</span></span> supp_supports<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>pt"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>supp <span class="free">x</span><span class="main">)</span> <span class="keyword1">supports</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> supports_def
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> strip<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">b</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∉</span> <span class="main">(</span>supp <span class="free">x</span><span class="main">)</span> <span class="main">∧</span> <span class="skolem">b</span> <span class="main">∉</span> <span class="main">(</span>supp <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">♯</span> <span class="free">x</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">♯</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_def<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span> <span class="main">⇌</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> swap_fresh_fresh<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Base-supports_fresh"><span class="command">lemma</span></span> supports_fresh<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>pt"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">S</span> <span class="keyword1">supports</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>     a2<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>     a3<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">∉</span> <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fresh_def
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>supp <span class="free">x</span><span class="main">)</span> <span class="main">⊆</span> <span class="free">S</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> a1 a2 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> supp_is_subset<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">∉</span> <span class="main">(</span>supp <span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> a3 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Base-supp_is_least_supports"><span class="command">lemma</span></span> supp_is_least_supports<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">S</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"atom set"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="free">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>pt"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span>  a1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">S</span> <span class="keyword1">supports</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>      a2<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>      a3<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">S'</span><span class="main">.</span> finite <span class="bound">S'</span> <span class="main">⟹</span> <span class="main">(</span><span class="bound">S'</span> <span class="keyword1">supports</span> <span class="free">x</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">S</span> <span class="main">⊆</span> <span class="bound">S'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>supp <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">S</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> equalityI<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>supp <span class="free">x</span><span class="main">)</span> <span class="main">⊆</span> <span class="free">S</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> a1 a2 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> supp_is_subset<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> a2 <span class="keyword1"><span class="command">have</span></span> fin<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>supp <span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> rev_finite_subset<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>supp <span class="free">x</span><span class="main">)</span> <span class="keyword1">supports</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> supp_supports<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> fin a3 <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">S</span> <span class="main">⊆</span> supp <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1" id="Nominal2_Base-subsetCI"><span class="command">lemma</span></span> subsetCI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">A</span> <span class="main">⟹</span> <span class="bound">x</span> <span class="main">∉</span> <span class="free">B</span> <span class="main">⟹</span> False<span class="main">)</span> <span class="main">⟹</span> <span class="free">A</span> <span class="main">⊆</span> <span class="free">B</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Nominal2_Base-finite_supp_unique"><span class="command">lemma</span></span> finite_supp_unique<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">S</span> <span class="keyword1">supports</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a2<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a3<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> <span class="main">⟦</span><span class="bound">a</span> <span class="main">∈</span> <span class="free">S</span><span class="main">;</span> <span class="bound">b</span> <span class="main">∉</span> <span class="free">S</span><span class="main">;</span> sort_of <span class="bound">a</span> <span class="main">=</span> sort_of <span class="bound">b</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="bound">a</span> <span class="main">⇌</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">≠</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>supp <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">S</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> a1 a2
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> supp_is_least_supports<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">S'</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"finite <span class="skolem">S'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">S'</span> <span class="keyword1">supports</span> <span class="free">x</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">S</span> <span class="main">⊆</span> <span class="skolem">S'</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> subsetCI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> <span class="free">S</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∉</span> <span class="skolem">S'</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="free">S</span> <span class="main">∪</span> <span class="skolem">S'</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹finite <span class="free">S</span>›</span></span> <span class="quoted"><span class="quoted">‹finite <span class="skolem">S'</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">b</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∉</span> <span class="free">S</span> <span class="main">∪</span> <span class="skolem">S'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"sort_of <span class="skolem">b</span> <span class="main">=</span> sort_of <span class="skolem">a</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> obtain_atom<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∉</span> <span class="free">S</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∉</span> <span class="skolem">S'</span>"</span></span>  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"sort_of <span class="skolem">a</span> <span class="main">=</span> sort_of <span class="skolem">b</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span> <span class="main">⇌</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">a</span> <span class="main">∉</span> <span class="skolem">S'</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">S'</span> <span class="keyword1">supports</span> <span class="free">x</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supports_def<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span> <span class="main">⇌</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">≠</span> <span class="free">x</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">a</span> <span class="main">∈</span> <span class="free">S</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">b</span> <span class="main">∉</span> <span class="free">S</span>›</span></span> <span class="quoted"><span class="quoted">‹sort_of <span class="skolem">a</span> <span class="main">=</span> sort_of <span class="skolem">b</span>›</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> a3<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"False"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Support w.r.t. relations›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  This definition is used for unquotient types, where
  alpha-equivalence does not coincide with equality.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">supp_rel</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound">a</span><span class="main">.</span> infinite <span class="main">{</span><span class="bound">b</span><span class="main">.</span> <span class="main">¬</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">(</span><span class="main">(</span><span class="bound">a</span> <span class="main">⇌</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">}</span><span class="main">}</span>"</span></span>



<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Finitely-supported types›</span></span>

<span class="keyword1"><span class="command">class</span></span> fs <span class="main">=</span> pt <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> finite_supp<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>supp <span class="free">x</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Nominal2_Base-pure_supp"><span class="command">lemma</span></span> pure_supp<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>pure"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="free">x</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> supp_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_pure<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-pure_fresh"><span class="command">lemma</span></span> pure_fresh<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>pure"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fresh_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pure_supp<span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span> pure <span class="main">&lt;</span> fs
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pure_supp<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span>  <span class="quoted"><span class="plain_text">‹Type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">atom</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is finitely-supported.›</span></span>

<span class="keyword1" id="Nominal2_Base-supp_atom"><span class="command">lemma</span></span> supp_atom<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="free">a</span> <span class="main">=</span> <span class="main">{</span><span class="free">a</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> finite_supp_unique<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supports_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Nominal2_Base-fresh_atom"><span class="command">lemma</span></span> fresh_atom<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="free">b</span> <span class="main">⟷</span> <span class="free">a</span> <span class="main">≠</span> <span class="free">b</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fresh_def supp_atom <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">instance</span></span> atom <span class="main">::</span> <span class="quoted">fs</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_atom<span class="main">)</span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">perm</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is finitely-supported.›</span></span>

<span class="keyword1" id="Nominal2_Base-perm_swap_eq"><span class="command">lemma</span></span> perm_swap_eq<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">p</span> <span class="main">=</span> <span class="free">p</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">b</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">b</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> permute_perm_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> add_diff_cancel minus_perm_def<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-supports_perm"><span class="command">lemma</span></span> supports_perm<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">a</span><span class="main">.</span> <span class="free">p</span> <span class="main">∙</span> <span class="bound">a</span> <span class="main">≠</span> <span class="bound">a</span><span class="main">}</span> <span class="keyword1">supports</span> <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> supports_def
  <span class="keyword1"><span class="command">unfolding</span></span> perm_swap_eq
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> swap_eqvt<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-finite_perm_lemma"><span class="command">lemma</span></span> finite_perm_lemma<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">{</span><span class="bound">a</span><span class="main">::</span>atom<span class="main">.</span> <span class="free">p</span> <span class="main">∙</span> <span class="bound">a</span> <span class="main">≠</span> <span class="bound">a</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> finite_Rep_perm <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">p</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">unfolding</span></span> permute_atom_def <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1" id="Nominal2_Base-supp_perm"><span class="command">lemma</span></span> supp_perm<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="free">p</span> <span class="main">=</span> <span class="main">{</span><span class="bound">a</span><span class="main">.</span> <span class="free">p</span> <span class="main">∙</span> <span class="bound">a</span> <span class="main">≠</span> <span class="bound">a</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> finite_supp_unique<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> supports_perm<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> finite_perm_lemma<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> perm_swap_eq swap_eqvt<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> perm_eq_iff swap_atom<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Nominal2_Base-fresh_perm"><span class="command">lemma</span></span> fresh_perm<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="free">p</span> <span class="main">⟷</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">a</span> <span class="main">=</span> <span class="free">a</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fresh_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_perm<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-supp_swap"><span class="command">lemma</span></span> supp_swap<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">b</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">a</span> <span class="main">=</span> <span class="free">b</span> <span class="main">∨</span> sort_of <span class="free">a</span> <span class="main">≠</span> sort_of <span class="free">b</span> <span class="keyword1">then</span> <span class="main">{}</span> <span class="keyword1">else</span> <span class="main">{</span><span class="free">a</span><span class="main">,</span> <span class="free">b</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> supp_perm swap_atom<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fresh_swap"><span class="command">lemma</span></span> fresh_swap<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="main">(</span><span class="free">b</span> <span class="main">⇌</span> <span class="free">c</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span>sort_of <span class="free">b</span> <span class="main">≠</span> sort_of <span class="free">c</span><span class="main">)</span> <span class="main">∨</span> <span class="free">b</span> <span class="main">=</span> <span class="free">c</span> <span class="main">∨</span> <span class="main">(</span><span class="free">a</span> <span class="main">♯</span> <span class="free">b</span> <span class="main">∧</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">c</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_def supp_swap supp_atom<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fresh_zero_perm"><span class="command">lemma</span></span> fresh_zero_perm<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="main">(</span><span class="main">0</span><span class="main">::</span>perm<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fresh_perm <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-supp_zero_perm"><span class="command">lemma</span></span> supp_zero_perm<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span><span class="main">0</span><span class="main">::</span>perm<span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> supp_perm <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-fresh_plus_perm"><span class="command">lemma</span></span> fresh_plus_perm<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p</span> <span class="free">q</span><span class="main">::</span><span class="quoted">perm</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="free">q</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="main">(</span><span class="free">p</span> <span class="main">+</span> <span class="free">q</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">unfolding</span></span> fresh_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> supp_perm<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-supp_plus_perm"><span class="command">lemma</span></span> supp_plus_perm<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p</span> <span class="free">q</span><span class="main">::</span><span class="quoted">perm</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span><span class="free">p</span> <span class="main">+</span> <span class="free">q</span><span class="main">)</span> <span class="main">⊆</span> supp <span class="free">p</span> <span class="main">∪</span> supp <span class="free">q</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> supp_perm<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fresh_minus_perm"><span class="command">lemma</span></span> fresh_minus_perm<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p</span><span class="main">::</span><span class="quoted">perm</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="main">(</span><span class="main">-</span> <span class="free">p</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fresh_def
  <span class="keyword1"><span class="command">unfolding</span></span> supp_perm
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">metis</span> permute_minus_cancel<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Nominal2_Base-supp_minus_perm"><span class="command">lemma</span></span> supp_minus_perm<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p</span><span class="main">::</span><span class="quoted">perm</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span><span class="main">-</span> <span class="free">p</span><span class="main">)</span> <span class="main">=</span> supp <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> supp_conv_fresh
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_minus_perm<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-plus_perm_eq"><span class="command">lemma</span></span> plus_perm_eq<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p</span> <span class="free">q</span><span class="main">::</span><span class="quoted"><span class="quoted">"perm"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> asm<span class="main">:</span> <span class="quoted"><span class="quoted">"supp <span class="free">p</span> <span class="main">∩</span> supp <span class="free">q</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">+</span> <span class="free">q</span> <span class="main">=</span> <span class="free">q</span> <span class="main">+</span> <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> perm_eq_iff
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span><span class="main">::</span><span class="quoted"><span class="quoted">"atom"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">+</span> <span class="free">q</span><span class="main">)</span> <span class="main">∙</span> <span class="skolem">a</span> <span class="main">=</span> <span class="main">(</span><span class="free">q</span> <span class="main">+</span> <span class="free">p</span><span class="main">)</span> <span class="main">∙</span> <span class="skolem">a</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∉</span> supp <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∉</span> supp <span class="free">q</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">+</span> <span class="free">q</span><span class="main">)</span> <span class="main">∙</span> <span class="skolem">a</span> <span class="main">=</span> <span class="main">(</span><span class="free">q</span> <span class="main">+</span> <span class="free">p</span><span class="main">)</span> <span class="main">∙</span> <span class="skolem">a</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_perm<span class="main">)</span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> supp <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∉</span> supp <span class="free">q</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="skolem">a</span> <span class="main">∈</span> supp <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_perm<span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="skolem">a</span> <span class="main">∉</span> supp <span class="free">q</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> asm <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> a <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">+</span> <span class="free">q</span><span class="main">)</span> <span class="main">∙</span> <span class="skolem">a</span> <span class="main">=</span> <span class="main">(</span><span class="free">q</span> <span class="main">+</span> <span class="free">p</span><span class="main">)</span> <span class="main">∙</span> <span class="skolem">a</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_perm<span class="main">)</span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∉</span> supp <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> supp <span class="free">q</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="main">∙</span> <span class="skolem">a</span> <span class="main">∈</span> supp <span class="free">q</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_perm<span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="main">∙</span> <span class="skolem">a</span> <span class="main">∉</span> supp <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> asm <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> a <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">+</span> <span class="free">q</span><span class="main">)</span> <span class="main">∙</span> <span class="skolem">a</span> <span class="main">=</span> <span class="main">(</span><span class="free">q</span> <span class="main">+</span> <span class="free">p</span><span class="main">)</span> <span class="main">∙</span> <span class="skolem">a</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_perm<span class="main">)</span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">+</span> <span class="free">q</span><span class="main">)</span> <span class="main">∙</span> <span class="skolem">a</span> <span class="main">=</span> <span class="main">(</span><span class="free">q</span> <span class="main">+</span> <span class="free">p</span><span class="main">)</span> <span class="main">∙</span> <span class="skolem">a</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> asm <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Base-supp_plus_perm_eq"><span class="command">lemma</span></span> supp_plus_perm_eq<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p</span> <span class="free">q</span><span class="main">::</span><span class="quoted">perm</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> asm<span class="main">:</span> <span class="quoted"><span class="quoted">"supp <span class="free">p</span> <span class="main">∩</span> supp <span class="free">q</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span><span class="free">p</span> <span class="main">+</span> <span class="free">q</span><span class="main">)</span> <span class="main">=</span> supp <span class="free">p</span> <span class="main">∪</span> supp <span class="free">q</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span><span class="main">::</span><span class="quoted"><span class="quoted">"atom"</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> supp <span class="free">p</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∉</span> supp <span class="free">q</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> asm <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> supp <span class="main">(</span><span class="free">p</span> <span class="main">+</span> <span class="free">q</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">a</span> <span class="main">∈</span> supp <span class="free">p</span>›</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_perm<span class="main">)</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span><span class="main">::</span><span class="quoted"><span class="quoted">"atom"</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> supp <span class="free">q</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∉</span> supp <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> asm <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> supp <span class="main">(</span><span class="free">q</span> <span class="main">+</span> <span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">a</span> <span class="main">∈</span> supp <span class="free">q</span>›</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_perm<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> supp <span class="main">(</span><span class="free">p</span> <span class="main">+</span> <span class="free">q</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> asm plus_perm_eq
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"supp <span class="free">p</span> <span class="main">∪</span> supp <span class="free">q</span> <span class="main">⊆</span> supp <span class="main">(</span><span class="free">p</span> <span class="main">+</span> <span class="free">q</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span><span class="free">p</span> <span class="main">+</span> <span class="free">q</span><span class="main">)</span> <span class="main">=</span> supp <span class="free">p</span> <span class="main">∪</span> supp <span class="free">q</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> supp_plus_perm
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Base-perm_eq_iff2"><span class="command">lemma</span></span> perm_eq_iff2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p</span> <span class="free">q</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"perm"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">=</span> <span class="free">q</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">a</span><span class="main">::</span>atom <span class="main">∈</span> supp <span class="free">p</span> <span class="main">∪</span> supp <span class="free">q</span><span class="main">.</span> <span class="free">p</span> <span class="main">∙</span> <span class="bound">a</span> <span class="main">=</span> <span class="free">q</span> <span class="main">∙</span> <span class="bound">a</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> perm_eq_iff
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="improper">a</span> <span class="main">♯</span> <span class="free">p</span> <span class="main">∧</span> <span class="improper">a</span> <span class="main">♯</span> <span class="free">q</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_perm<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">instance</span></span> perm <span class="main">::</span> <span class="quoted">fs</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_perm finite_perm_lemma<span class="main">)</span>



<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Finite Support instances for other types›</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> <span class="main"><span class="main">×</span></span> <span class="tfree"><span class="tfree">'b</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is finitely-supported.›</span></span>

<span class="keyword1" id="Nominal2_Base-supp_Pair"><span class="command">lemma</span></span> supp_Pair<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> supp <span class="free">x</span> <span class="main">∪</span> supp <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_def Collect_imp_eq Collect_neg_eq<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fresh_Pair"><span class="command">lemma</span></span> fresh_Pair<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">x</span> <span class="main">∧</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_def supp_Pair<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-supp_Unit"><span class="command">lemma</span></span> supp_Unit<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">()</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_def<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fresh_Unit"><span class="command">lemma</span></span> fresh_Unit<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="main">()</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_def supp_Unit<span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span> prod <span class="main">::</span> <span class="main">(</span><span class="quoted">fs</span><span class="main">,</span> <span class="quoted">fs</span><span class="main">)</span> <span class="quoted">fs</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_Pair finite_supp<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> <span class="main"><span class="main">+</span></span> <span class="tfree"><span class="tfree">'b</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is finitely supported›</span></span>

<span class="keyword1" id="Nominal2_Base-supp_Inl"><span class="command">lemma</span></span> supp_Inl<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span>Inl <span class="free">x</span><span class="main">)</span> <span class="main">=</span> supp <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_def<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-supp_Inr"><span class="command">lemma</span></span> supp_Inr<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span>Inr <span class="free">x</span><span class="main">)</span> <span class="main">=</span> supp <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_def<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fresh_Inl"><span class="command">lemma</span></span> fresh_Inl<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> Inl <span class="free">x</span> <span class="main">⟷</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_def supp_Inl<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fresh_Inr"><span class="command">lemma</span></span> fresh_Inr<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> Inr <span class="free">y</span> <span class="main">⟷</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_def supp_Inr<span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span> sum <span class="main">::</span> <span class="main">(</span><span class="quoted">fs</span><span class="main">,</span> <span class="quoted">fs</span><span class="main">)</span> <span class="quoted">fs</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_Inl supp_Inr finite_supp<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> option"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is finitely supported›</span></span>

<span class="keyword1" id="Nominal2_Base-supp_None"><span class="command">lemma</span></span> supp_None<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp None <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_def<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-supp_Some"><span class="command">lemma</span></span> supp_Some<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span>Some <span class="free">x</span><span class="main">)</span> <span class="main">=</span> supp <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_def<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fresh_None"><span class="command">lemma</span></span> fresh_None<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> None"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_def supp_None<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fresh_Some"><span class="command">lemma</span></span> fresh_Some<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> Some <span class="free">x</span> <span class="main">⟷</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_def supp_Some<span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span> option <span class="main">::</span> <span class="main">(</span><span class="quoted">fs</span><span class="main">)</span> <span class="quoted">fs</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="improper"><span class="quoted"><span class="improper">x</span></span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_None supp_Some finite_supp<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> list"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is finitely supported›</span></span>

<span class="keyword1" id="Nominal2_Base-supp_Nil"><span class="command">lemma</span></span> supp_Nil<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">[]</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_def<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fresh_Nil"><span class="command">lemma</span></span> fresh_Nil<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="main">[]</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_def supp_Nil<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-supp_Cons"><span class="command">lemma</span></span> supp_Cons<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> supp <span class="free">x</span> <span class="main">∪</span> supp <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_def Collect_imp_eq Collect_neg_eq<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fresh_Cons"><span class="command">lemma</span></span> fresh_Cons<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">x</span> <span class="main">∧</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_def supp_Cons<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-supp_append"><span class="command">lemma</span></span> supp_append<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> supp <span class="free">xs</span> <span class="main">∪</span> supp <span class="free">ys</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> supp_Nil supp_Cons<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fresh_append"><span class="command">lemma</span></span> fresh_append<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">xs</span> <span class="main">∧</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">ys</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_Nil fresh_Cons<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-supp_rev"><span class="command">lemma</span></span> supp_rev<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span>rev <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> supp <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> supp_append supp_Cons supp_Nil<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fresh_rev"><span class="command">lemma</span></span> fresh_rev<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> rev <span class="free">xs</span> <span class="main">⟷</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fresh_append fresh_Cons fresh_Nil<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-supp_removeAll"><span class="command">lemma</span></span> supp_removeAll<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span><span class="main">::</span><span class="quoted"><span class="quoted">"atom"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span>removeAll <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> supp <span class="free">xs</span> <span class="main">-</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> supp_Nil supp_Cons supp_atom<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-supp_of_atom_list"><span class="command">lemma</span></span> supp_of_atom_list<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">as</span><span class="main">::</span><span class="quoted"><span class="quoted">"atom list"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="free">as</span> <span class="main">=</span> set <span class="free">as</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">as</span></span><span class="main">)</span>
   <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_Nil supp_Cons supp_atom<span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span> list <span class="main">::</span> <span class="main">(</span><span class="quoted">fs</span><span class="main">)</span> <span class="quoted">fs</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="improper"><span class="quoted"><span class="improper">x</span></span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_Nil supp_Cons finite_supp<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Support and Freshness for Applications›</span></span>

<span class="keyword1" id="Nominal2_Base-fresh_conv_MOST"><span class="command">lemma</span></span> fresh_conv_MOST<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="free">x</span> <span class="main">⟷</span> <span class="main">(</span><span class="keyword1">MOST</span> <span class="bound">b</span><span class="main">.</span> <span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fresh_def supp_def
  <span class="keyword1"><span class="command">unfolding</span></span> MOST_iff_cofinite <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-fresh_fun_app"><span class="command">lemma</span></span> fresh_fun_app<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="free">f</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="free">f</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">unfolding</span></span> fresh_conv_MOST
  <span class="keyword1"><span class="command">unfolding</span></span> permute_fun_app_eq
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">elim</span> MOST_rev_mp<span class="main">)</span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-supp_fun_app"><span class="command">lemma</span></span> supp_fun_app<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span><span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">(</span>supp <span class="free">f</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>supp <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> fresh_fun_app
  <span class="keyword1"><span class="command">unfolding</span></span> fresh_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Equivariance Predicate <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>eqvt›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>eqvt_at›</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">eqvt</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> <span class="main">∀</span><span class="bound">p</span><span class="main">.</span> <span class="bound">p</span> <span class="main">∙</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span>"</span></span>

<span class="keyword1" id="Nominal2_Base-eqvt_boolI"><span class="command">lemma</span></span> eqvt_boolI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span><span class="main">::</span><span class="quoted"><span class="quoted">"bool"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"eqvt <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> eqvt_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_bool_def<span class="main">)</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹equivariance of a function at a given argument›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
 <span class="quoted"><span class="quoted">"<span class="free">eqvt_at</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> <span class="main">∀</span><span class="bound">p</span><span class="main">.</span> <span class="bound">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="bound">p</span> <span class="main">∙</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Nominal2_Base-eqvtI"><span class="command">lemma</span></span> eqvtI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">p</span><span class="main">.</span> <span class="bound">p</span> <span class="main">∙</span> <span class="free">f</span> <span class="main">≡</span> <span class="free">f</span><span class="main">)</span> <span class="main">⟹</span> eqvt <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> eqvt_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-eqvt_at_perm"><span class="command">lemma</span></span> eqvt_at_perm<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"eqvt_at <span class="free">f</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"eqvt_at <span class="free">f</span> <span class="main">(</span><span class="free">q</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">p</span><span class="main">::</span><span class="quoted"><span class="quoted">"perm"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">f</span> <span class="main">(</span><span class="free">q</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">p</span> <span class="main">∙</span> <span class="free">q</span> <span class="main">∙</span> <span class="main">(</span><span class="free">f</span> <span class="free">x</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eqvt_at_def<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">p</span> <span class="main">+</span> <span class="free">q</span><span class="main">)</span> <span class="main">∙</span> <span class="main">(</span><span class="free">f</span> <span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span><span class="main">(</span><span class="skolem">p</span> <span class="main">+</span> <span class="free">q</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> eqvt_at_def<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">f</span> <span class="main">(</span><span class="free">q</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">p</span> <span class="main">∙</span> <span class="free">q</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"eqvt_at <span class="free">f</span> <span class="main">(</span><span class="free">q</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> eqvt_at_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Base-supp_fun_eqvt"><span class="command">lemma</span></span> supp_fun_eqvt<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"eqvt <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="free">f</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> a
  <span class="keyword1"><span class="command">unfolding</span></span> eqvt_def
  <span class="keyword1"><span class="command">unfolding</span></span> supp_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-fresh_fun_eqvt"><span class="command">lemma</span></span> fresh_fun_eqvt<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"eqvt <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> a
  <span class="keyword1"><span class="command">unfolding</span></span> fresh_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_fun_eqvt<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fresh_fun_eqvt_app"><span class="command">lemma</span></span> fresh_fun_eqvt_app<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"eqvt <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="free">x</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">f</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> a <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"supp <span class="free">f</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_fun_eqvt<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="free">x</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">f</span> <span class="free">x</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> fresh_def
    <span class="keyword1"><span class="command">using</span></span> supp_fun_app <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Base-supp_fun_app_eqvt"><span class="command">lemma</span></span> supp_fun_app_eqvt<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"eqvt <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span><span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">⊆</span> supp <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> fresh_fun_eqvt_app<span class="main">[</span><span class="operator">OF</span> a<span class="main">]</span>
  <span class="keyword1"><span class="command">unfolding</span></span> fresh_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Nominal2_Base-supp_eqvt_at"><span class="command">lemma</span></span> supp_eqvt_at<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> asm<span class="main">:</span> <span class="quoted"><span class="quoted">"eqvt_at <span class="free">f</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>     fin<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>supp <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span><span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">⊆</span> supp <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> supp_is_subset<span class="main">)</span>
<span class="keyword1"><span class="command">unfolding</span></span> supports_def
<span class="keyword1"><span class="command">unfolding</span></span> fresh_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
<span class="keyword1"><span class="command">using</span></span> asm
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eqvt_at_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> swap_fresh_fresh<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> fin<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Nominal2_Base-finite_supp_eqvt_at"><span class="command">lemma</span></span> finite_supp_eqvt_at<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> asm<span class="main">:</span> <span class="quoted"><span class="quoted">"eqvt_at <span class="free">f</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>     fin<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>supp <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>supp <span class="main">(</span><span class="free">f</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> supp_eqvt_at<span class="main"><span class="main">[</span></span><span class="operator">OF</span> asm fin<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> fin<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Nominal2_Base-fresh_eqvt_at"><span class="command">lemma</span></span> fresh_eqvt_at<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> asm<span class="main">:</span> <span class="quoted"><span class="quoted">"eqvt_at <span class="free">f</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>     fin<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>supp <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>     fresh<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="free">f</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> fresh
<span class="keyword1"><span class="command">unfolding</span></span> fresh_def
<span class="keyword1"><span class="command">using</span></span> supp_eqvt_at<span class="main">[</span><span class="operator">OF</span> asm fin<span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹for handling of freshness of functions›</span></span>

<span class="keyword1"><span class="command">simproc_setup</span></span> fresh_fun_simproc <span class="main">(</span><span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="main">(</span><span class="free">f</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>pt <span class="main">⇒</span><span class="tfree">'b</span><span class="main">::</span>pt<span class="main">)</span>"</span></span><span class="main">)</span> <span class="main">=</span> <span class="quoted">‹<span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctrm</span> <span class="main">=&gt;</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> $ <span class="main">_</span> $ <span class="entity">f</span> <span class="main">=</span> Thm.term_of <span class="entity">ctrm</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="main">(</span>Term.add_frees <span class="entity">f</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> Term.add_vars <span class="entity">f</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
      <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="main">=&gt;</span> SOME<span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> fresh_fun_eqvt<span class="main">[</span><span class="operator">simplified</span> eqvt_def<span class="main">,</span> <span class="operator">THEN</span> Eq_TrueI<span class="main">]</span><span class="antiquote">}</span></span></span><span class="main">)</span>
    <span class="main">|</span> <span class="main">(</span><span class="entity">x</span>::<span class="main">_</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="main">=&gt;</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">argx</span> <span class="main">=</span> Free <span class="entity">x</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">absf</span> <span class="main">=</span> absfree <span class="entity">x</span> <span class="entity">f</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cty_inst</span> <span class="main">=</span>
          <span class="main">[</span>SOME <span class="main">(</span>Thm.ctyp_of <span class="entity">ctxt</span> <span class="main">(</span>fastype_of <span class="entity">argx</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> SOME <span class="main">(</span>Thm.ctyp_of <span class="entity">ctxt</span> <span class="main">(</span>fastype_of <span class="entity">f</span><span class="main">)</span><span class="main">)</span><span class="main">]</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctrm_inst</span> <span class="main">=</span> <span class="main">[</span>NONE<span class="main">,</span> SOME <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">absf</span><span class="main">)</span><span class="main">,</span> SOME <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">argx</span><span class="main">)</span><span class="main">]</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm</span> <span class="main">=</span> Thm.instantiate' <span class="entity">cty_inst</span> <span class="entity">ctrm_inst</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> fresh_fun_app<span class="antiquote">}</span></span></span>
      <span class="keyword2"><span class="keyword">in</span></span>
        SOME<span class="main">(</span><span class="entity">thm</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Eq_TrueI<span class="antiquote">}</span></span></span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="main">|</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> NONE
  <span class="keyword2"><span class="keyword">end</span></span>
›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹helper functions for <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>nominal_functions›</span></span></span></span>›</span></span>

<span class="keyword1" id="Nominal2_Base-THE_defaultI2"><span class="command">lemma</span></span> THE_defaultI2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃!</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="main">⟹</span> <span class="free">Q</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="main">(</span>THE_default <span class="free">d</span> <span class="free">P</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">iprover</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> assms THE_defaultI'<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-the_default_eqvt"><span class="command">lemma</span></span> the_default_eqvt<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> unique<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃!</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>THE_default <span class="free">d</span> <span class="free">P</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>THE_default <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">d</span><span class="main">)</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">P</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> THE_default1_equality <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> p<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">-</span><span class="free">p</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> permute_boolE<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ex1_eqvt<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> unique<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> p<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">-</span><span class="free">p</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> permute_boolE<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> subst<span class="main"><span class="main">[</span></span><span class="operator">OF</span> permute_fun_app_eq<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> THE_defaultI'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> unique<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Nominal2_Base-fundef_ex1_eqvt"><span class="command">lemma</span></span> fundef_ex1_eqvt<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>pt"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> f_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">==</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">::</span><span class="tfree">'a</span><span class="main">.</span> THE_default <span class="main">(</span><span class="free">d</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">G</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> eqvt<span class="main">:</span> <span class="quoted"><span class="quoted">"eqvt <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ex1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃!</span><span class="bound">y</span><span class="main">.</span> <span class="free">G</span> <span class="free">x</span> <span class="bound">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">f</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> f_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> the_default_eqvt<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> ex1<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> THE_default1_equality <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> p<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">-</span><span class="free">p</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> permute_boolE<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">perm_simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_minus_cancel<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> eqvt<span class="main">[</span><span class="operator">simplified</span> eqvt_def<span class="main">]</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> ex1<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> THE_defaultI2<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> p<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">-</span><span class="free">p</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> permute_boolE<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">perm_simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_minus_cancel<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> ex1<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">perm_simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> eqvt<span class="main">[</span><span class="operator">simplified</span> eqvt_def<span class="main">]</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Nominal2_Base-fundef_ex1_eqvt_at"><span class="command">lemma</span></span> fundef_ex1_eqvt_at<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>pt"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> f_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">==</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">::</span><span class="tfree">'a</span><span class="main">.</span> THE_default <span class="main">(</span><span class="free">d</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">G</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> eqvt<span class="main">:</span> <span class="quoted"><span class="quoted">"eqvt <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ex1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃!</span><span class="bound">y</span><span class="main">.</span> <span class="free">G</span> <span class="free">x</span> <span class="bound">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"eqvt_at <span class="free">f</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> eqvt_at_def
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> fundef_ex1_eqvt<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fundef_ex1_prop"><span class="command">lemma</span></span> fundef_ex1_prop<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>pt"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> f_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">==</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">::</span><span class="tfree">'a</span><span class="main">.</span> THE_default <span class="main">(</span><span class="free">d</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">G</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> P_all<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">G</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">x</span> <span class="bound">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ex1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃!</span><span class="bound">y</span><span class="main">.</span> <span class="free">G</span> <span class="free">x</span> <span class="bound">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">x</span> <span class="main">(</span><span class="free">f</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> f_def
  <span class="keyword1"><span class="command">using</span></span> ex1
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule_tac</span> ex1E<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> THE_defaultI2<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">blast</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> P_all<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">assumption</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Support of Finite Sets of Finitely Supported Elements›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹support and freshness for atom sets›</span></span>

<span class="keyword1" id="Nominal2_Base-supp_finite_atom_set"><span class="command">lemma</span></span> supp_finite_atom_set<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">S</span><span class="main">::</span><span class="quoted"><span class="quoted">"atom set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="free">S</span> <span class="main">=</span> <span class="free">S</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> finite_supp_unique<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supports_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> swap_set_not_in<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> assms<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> swap_set_in<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Nominal2_Base-supp_cofinite_atom_set"><span class="command">lemma</span></span> supp_cofinite_atom_set<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">S</span><span class="main">::</span><span class="quoted"><span class="quoted">"atom set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">-</span> <span class="free">S</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="free">S</span> <span class="main">=</span> <span class="main">(</span>UNIV <span class="main">-</span> <span class="free">S</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> finite_supp_unique<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supports_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> swap_set_both_in<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> assms<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> swap_commute<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> swap_set_in<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Nominal2_Base-fresh_finite_atom_set"><span class="command">lemma</span></span> fresh_finite_atom_set<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">S</span><span class="main">::</span><span class="quoted"><span class="quoted">"atom set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="free">S</span> <span class="main">⟷</span> <span class="free">a</span> <span class="main">∉</span> <span class="free">S</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fresh_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_finite_atom_set<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fresh_minus_atom_set"><span class="command">lemma</span></span> fresh_minus_atom_set<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">S</span><span class="main">::</span><span class="quoted"><span class="quoted">"atom set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="free">S</span> <span class="main">-</span> <span class="free">T</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">a</span> <span class="main">∉</span> <span class="free">T</span> <span class="main">⟶</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">S</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fresh_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> supp_finite_atom_set assms<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-Union_supports_set"><span class="command">lemma</span></span> Union_supports_set<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">S</span><span class="main">.</span> supp <span class="bound">x</span><span class="main">)</span> <span class="keyword1">supports</span> <span class="free">S</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">b</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">S</span><span class="main">.</span> <span class="main">(</span><span class="skolem">a</span> <span class="main">⇌</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∙</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">x</span> <span class="main">⟹</span> <span class="main">(</span><span class="skolem">a</span> <span class="main">⇌</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">S</span> <span class="main">=</span> <span class="free">S</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> permute_set_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">S</span><span class="main">.</span> supp <span class="bound">x</span><span class="main">)</span> <span class="keyword1">supports</span> <span class="free">S</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> supports_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> swap_fresh_fresh<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Base-Union_of_finite_supp_sets"><span class="command">lemma</span></span> Union_of_finite_supp_sets<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">S</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>fs set<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> fin<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="main">⋃</span><span class="bound">x</span><span class="main">∈</span><span class="free">S</span><span class="main">.</span> supp <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> fin <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> finite_supp<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-Union_included_in_supp"><span class="command">lemma</span></span> Union_included_in_supp<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">S</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>fs set<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> fin<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋃</span><span class="bound">x</span><span class="main">∈</span><span class="free">S</span><span class="main">.</span> supp <span class="bound">x</span><span class="main">)</span> <span class="main">⊆</span> supp <span class="free">S</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> eqvt<span class="main">:</span> <span class="quoted"><span class="quoted">"eqvt <span class="main">(</span><span class="main">λ</span><span class="bound">S</span><span class="main">.</span> <span class="main">⋃</span><span class="bound">x</span> <span class="main">∈</span> <span class="bound">S</span><span class="main">.</span> supp <span class="bound">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> eqvt_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋃</span><span class="bound">x</span><span class="main">∈</span><span class="free">S</span><span class="main">.</span> supp <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> supp <span class="main">(</span><span class="main">⋃</span><span class="bound">x</span><span class="main">∈</span><span class="free">S</span><span class="main">.</span> supp <span class="bound">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> supp_finite_atom_set<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">rule</span> Union_of_finite_supp_sets<span class="main"><span class="main">[</span></span><span class="operator">OF</span> fin<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">⊆</span> supp <span class="free">S</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> eqvt
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> supp_fun_app_eqvt<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋃</span><span class="bound">x</span><span class="main">∈</span><span class="free">S</span><span class="main">.</span> supp <span class="bound">x</span><span class="main">)</span> <span class="main">⊆</span> supp <span class="free">S</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Base-supp_of_finite_sets"><span class="command">lemma</span></span> supp_of_finite_sets<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">S</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>fs set<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> fin<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>supp <span class="free">S</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">x</span><span class="main">∈</span><span class="free">S</span><span class="main">.</span> supp <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> subset_antisym<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> supp_is_subset<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> Union_supports_set<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> Union_of_finite_supp_sets<span class="main"><span class="main">[</span></span><span class="operator">OF</span> fin<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> Union_included_in_supp<span class="main"><span class="main">[</span></span><span class="operator">OF</span> fin<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Nominal2_Base-finite_sets_supp"><span class="command">lemma</span></span> finite_sets_supp<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">S</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>fs set<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>supp <span class="free">S</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> supp_of_finite_sets Union_of_finite_supp_sets<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-supp_of_finite_union"><span class="command">lemma</span></span> supp_of_finite_union<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">S</span> <span class="free">T</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>fs<span class="main">)</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> fin1<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>     fin2<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">T</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span><span class="free">S</span> <span class="main">∪</span> <span class="free">T</span><span class="main">)</span> <span class="main">=</span> supp <span class="free">S</span> <span class="main">∪</span> supp <span class="free">T</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> fin1 fin2
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_of_finite_sets<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fresh_finite_union"><span class="command">lemma</span></span> fresh_finite_union<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">S</span> <span class="free">T</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>fs<span class="main">)</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> fin1<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>     fin2<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">T</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="main">(</span><span class="free">S</span> <span class="main">∪</span> <span class="free">T</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">S</span> <span class="main">∧</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">T</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fresh_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_of_finite_union<span class="main"><span class="main">[</span></span><span class="operator">OF</span> fin1 fin2<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-supp_of_finite_insert"><span class="command">lemma</span></span> supp_of_finite_insert<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">S</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>fs<span class="main">)</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> fin<span class="main">:</span>  <span class="quoted"><span class="quoted">"finite <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span>insert <span class="free">x</span> <span class="free">S</span><span class="main">)</span> <span class="main">=</span> supp <span class="free">x</span> <span class="main">∪</span> supp <span class="free">S</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> fin
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_of_finite_sets<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fresh_finite_insert"><span class="command">lemma</span></span> fresh_finite_insert<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">S</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>fs<span class="main">)</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> fin<span class="main">:</span>  <span class="quoted"><span class="quoted">"finite <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="main">(</span>insert <span class="free">x</span> <span class="free">S</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">x</span> <span class="main">∧</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">S</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> fin <span class="keyword1"><span class="command">unfolding</span></span> fresh_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_of_finite_insert<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-supp_set_empty"><span class="command">lemma</span></span> supp_set_empty<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">{}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> supp_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> empty_eqvt<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fresh_set_empty"><span class="command">lemma</span></span> fresh_set_empty<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_def supp_set_empty<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-supp_set"><span class="command">lemma</span></span> supp_set<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>fs<span class="main">)</span> list"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span>set <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> supp <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_set_empty supp_Nil<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_Cons supp_of_finite_insert<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Nominal2_Base-fresh_set"><span class="command">lemma</span></span> fresh_set<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>fs<span class="main">)</span> list"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="main">(</span>set <span class="free">xs</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fresh_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_set<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> multiset"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is finitely supported›</span></span>

<span class="keyword1" id="Nominal2_Base-set_mset_eqvt"><span class="command">lemma</span></span> set_mset_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>set_mset <span class="free">M</span><span class="main">)</span> <span class="main">=</span> set_mset <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">M</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">M</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> insert_eqvt empty_eqvt<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-supp_set_mset"><span class="command">lemma</span></span> supp_set_mset<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span>set_mset <span class="free">M</span><span class="main">)</span> <span class="main">⊆</span> supp <span class="free">M</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> supp_fun_app_eqvt<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> eqvt_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">perm_simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Nominal2_Base-Union_finite_multiset"><span class="command">lemma</span></span> Union_finite_multiset<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">M</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>fs multiset"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="main">⋃</span><span class="main">{</span>supp <span class="bound">x</span> <span class="main">|</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈#</span> <span class="free">M</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="main">⋃</span><span class="main">(</span>supp <span class="main">`</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈#</span> <span class="free">M</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">M</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Collect_imp_eq Collect_neg_eq finite_supp<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="main">⋃</span><span class="main">{</span>supp <span class="bound">x</span> <span class="main">|</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈#</span> <span class="free">M</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> image_Collect<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Base-Union_supports_multiset"><span class="command">lemma</span></span> Union_supports_multiset<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋃</span><span class="main">{</span>supp <span class="bound">x</span> <span class="main">|</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈#</span> <span class="free">M</span><span class="main">}</span> <span class="keyword1">supports</span> <span class="free">M</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> sw<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈#</span> <span class="free">M</span> <span class="main">⟹</span> <span class="main">(</span><span class="bound">a</span> <span class="main">⇌</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∙</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="bound">a</span> <span class="main">⇌</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">M</span> <span class="main">=</span> <span class="free">M</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> permute_multiset_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">M</span></span><span class="main">)</span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋃</span><span class="bound">x</span><span class="main">∈</span>set_mset <span class="free">M</span><span class="main">.</span> supp <span class="bound">x</span><span class="main">)</span> <span class="keyword1">supports</span> <span class="free">M</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> sw swap_fresh_fresh <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_def supports_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋃</span><span class="bound">x</span><span class="main">∈</span>set_mset <span class="free">M</span><span class="main">.</span> supp <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="main">{</span>supp <span class="bound">x</span> <span class="main">|</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈#</span> <span class="free">M</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋃</span><span class="main">{</span>supp <span class="bound">x</span> <span class="main">|</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈#</span> <span class="free">M</span><span class="main">}</span><span class="main">)</span> <span class="keyword1">supports</span> <span class="free">M</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Base-Union_included_multiset"><span class="command">lemma</span></span> Union_included_multiset<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">M</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>fs multiset<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋃</span><span class="main">{</span>supp <span class="bound">x</span> <span class="main">|</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈#</span> <span class="free">M</span><span class="main">}</span><span class="main">)</span> <span class="main">⊆</span> supp <span class="free">M</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋃</span><span class="main">{</span>supp <span class="bound">x</span> <span class="main">|</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈#</span> <span class="free">M</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">x</span> <span class="main">∈</span> set_mset <span class="free">M</span><span class="main">.</span> supp <span class="bound">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> supp <span class="main">(</span>set_mset <span class="free">M</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_of_finite_sets<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">" <span class="main">...</span> <span class="main">⊆</span> supp <span class="free">M</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> supp_set_mset<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋃</span><span class="main">{</span>supp <span class="bound">x</span> <span class="main">|</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈#</span> <span class="free">M</span><span class="main">}</span><span class="main">)</span> <span class="main">⊆</span> supp <span class="free">M</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Base-supp_of_multisets"><span class="command">lemma</span></span> supp_of_multisets<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">M</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>fs multiset<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>supp <span class="free">M</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="main">{</span>supp <span class="bound">x</span> <span class="main">|</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈#</span> <span class="free">M</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> subset_antisym<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> supp_is_subset<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> Union_supports_multiset<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> Union_finite_multiset<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> Union_included_multiset<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Nominal2_Base-multisets_supp_finite"><span class="command">lemma</span></span> multisets_supp_finite<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">M</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>fs multiset<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>supp <span class="free">M</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> supp_of_multisets Union_finite_multiset<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-supp_of_multiset_union"><span class="command">lemma</span></span> supp_of_multiset_union<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">M</span> <span class="free">N</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>fs<span class="main">)</span> multiset"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span><span class="free">M</span> <span class="main">+</span> <span class="free">N</span><span class="main">)</span> <span class="main">=</span> supp <span class="free">M</span> <span class="main">∪</span> supp <span class="free">N</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> supp_of_multisets<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-supp_empty_mset"><span class="command">lemma</span></span> supp_empty_mset <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">{#}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> supp_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">instance</span></span> multiset <span class="main">::</span> <span class="main">(</span><span class="quoted">fs</span><span class="main">)</span> <span class="quoted">fs</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">rule</span> multisets_supp_finite<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> fset"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is finitely supported›</span></span>

<span class="keyword1" id="Nominal2_Base-supp_fset"><span class="command">lemma</span></span> supp_fset <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span>fset <span class="free">S</span><span class="main">)</span> <span class="main">=</span> supp <span class="free">S</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> supp_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fset_eqvt fset_cong<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-supp_empty_fset"><span class="command">lemma</span></span> supp_empty_fset <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">{||}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> supp_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-fresh_empty_fset"><span class="command">lemma</span></span> fresh_empty_fset<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="main">{||}</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fresh_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-supp_finsert"><span class="command">lemma</span></span> supp_finsert <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>fs"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="free">S</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span> fset"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span>finsert <span class="free">x</span> <span class="free">S</span><span class="main">)</span> <span class="main">=</span> supp <span class="free">x</span> <span class="main">∪</span> supp <span class="free">S</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> supp_fset<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_of_finite_insert<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Nominal2_Base-fresh_finsert"><span class="command">lemma</span></span> fresh_finsert<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>fs"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="free">S</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span> fset"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> finsert <span class="free">x</span> <span class="free">S</span> <span class="main">⟷</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">x</span> <span class="main">∧</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">S</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fresh_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-fset_finite_supp"><span class="command">lemma</span></span> fset_finite_supp<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">S</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>fs<span class="main">)</span> fset"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>supp <span class="free">S</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">S</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finite_supp<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-supp_union_fset"><span class="command">lemma</span></span> supp_union_fset<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">S</span> <span class="free">T</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>fs fset"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span><span class="free">S</span> <span class="main">|∪|</span> <span class="free">T</span><span class="main">)</span> <span class="main">=</span> supp <span class="free">S</span> <span class="main">∪</span> supp <span class="free">T</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">S</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fresh_union_fset"><span class="command">lemma</span></span> fresh_union_fset<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">S</span> <span class="free">T</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>fs fset"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="free">S</span> <span class="main">|∪|</span> <span class="free">T</span> <span class="main">⟷</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">S</span> <span class="main">∧</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">T</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fresh_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_union_fset<span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span> fset <span class="main">::</span> <span class="main">(</span><span class="quoted">fs</span><span class="main">)</span> <span class="quoted">fs</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">rule</span> fset_finite_supp<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">,</span></span> <span class="tfree"><span class="tfree">'b</span></span><span class="main"><span class="main">)</span></span> finfun"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is finitely supported›</span></span>

<span class="keyword1" id="Nominal2_Base-fresh_finfun_const"><span class="command">lemma</span></span> fresh_finfun_const<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="main">(</span>finfun_const <span class="free">b</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">b</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_def supp_def<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fresh_finfun_update"><span class="command">lemma</span></span> fresh_finfun_update<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">a</span> <span class="main">♯</span> <span class="free">f</span><span class="main">;</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">x</span><span class="main">;</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">y</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">♯</span> finfun_update <span class="free">f</span> <span class="free">x</span> <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fresh_conv_MOST
  <span class="keyword1"><span class="command">unfolding</span></span> finfun_update_eqvt
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">elim</span> MOST_rev_mp<span class="main">)</span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-supp_finfun_const"><span class="command">lemma</span></span> supp_finfun_const<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span>finfun_const <span class="free">b</span><span class="main">)</span> <span class="main">=</span> supp<span class="main">(</span><span class="free">b</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_def<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-supp_finfun_update"><span class="command">lemma</span></span> supp_finfun_update<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span>finfun_update <span class="free">f</span> <span class="free">x</span> <span class="free">y</span><span class="main">)</span> <span class="main">⊆</span> supp<span class="main">(</span><span class="free">f</span><span class="main">,</span> <span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> fresh_finfun_update
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fresh_def supp_Pair<span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span> finfun <span class="main">::</span> <span class="main">(</span><span class="quoted">fs</span><span class="main">,</span> <span class="quoted">fs</span><span class="main">)</span> <span class="quoted">fs</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="improper"><span class="quoted"><span class="improper">x</span></span></span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> finfun_weak_induct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_finfun_const finite_supp<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> supp_finfun_update<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_Pair finite_supp<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Freshness and Fresh-Star›</span></span>

<span class="keyword1" id="Nominal2_Base-fresh_Unit_elim"><span class="command">lemma</span></span> fresh_Unit_elim<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">♯</span> <span class="main">()</span> <span class="main">⟹</span> <span class="keyword1">PROP</span> <span class="free">C</span><span class="main">)</span> <span class="main">≡</span> <span class="keyword1">PROP</span> <span class="free">C</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_Unit<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fresh_Pair_elim"><span class="command">lemma</span></span> fresh_Pair_elim<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">♯</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">⟹</span> <span class="keyword1">PROP</span> <span class="free">C</span><span class="main">)</span> <span class="main">≡</span> <span class="main">(</span><span class="free">a</span> <span class="main">♯</span> <span class="free">x</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">y</span> <span class="main">⟹</span> <span class="keyword1">PROP</span> <span class="free">C</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">rule</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_Pair<span class="main">)</span>

<span class="comment1">(* this rule needs to be added before the fresh_prodD is *)</span>
<span class="comment1">(* added to the simplifier with mksimps                  *)</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="free">x1</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">x2</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">♯</span> <span class="main">(</span><span class="free">x1</span><span class="main">,</span> <span class="free">x2</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_Pair<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fresh_PairD"><span class="command">lemma</span></span> fresh_PairD<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_Pair<span class="main">)</span>

<span class="keyword1"><span class="command">declaration</span></span> <span class="quoted">‹<span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span>
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mksimps_pairs</span> <span class="main">=</span> <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Nominal2_Base.fresh<span class="antiquote">}</span></span><span class="main">,</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> fresh_PairD<span class="antiquote">}</span></span></span><span class="main">)</span> :: <span class="entity">mksimps_pairs</span>
<span class="keyword2"><span class="keyword">in</span></span>
  <span class="entity">Simplifier.map_ss</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ss</span> <span class="main">=&gt;</span> <span class="entity">Simplifier.set_mksimps</span> <span class="main">(</span><span class="entity">mksimps</span> <span class="entity">mksimps_pairs</span><span class="main">)</span> <span class="entity">ss</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>
›</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The fresh-star generalisation of fresh is used in strong
  induction principles.›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">fresh_star</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"atom set <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">::</span>pt <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="quoted">"_ <span class="keyword1">♯*</span> _"</span> <span class="main">[</span>80<span class="main">,</span>80<span class="main">]</span> 80<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">as</span></span></span> <span class="main"><span class="free">♯*</span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> <span class="main">∀</span><span class="bound">a</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">.</span> <span class="bound">a</span> <span class="main">♯</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>

<span class="keyword1" id="Nominal2_Base-fresh_star_supp_conv"><span class="command">lemma</span></span> fresh_star_supp_conv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="free">x</span> <span class="main">♯*</span> <span class="free">y</span> <span class="main">⟹</span> supp <span class="free">y</span> <span class="main">♯*</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fresh_star_def fresh_def<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fresh_star_perm_set_conv"><span class="command">lemma</span></span> fresh_star_perm_set_conv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p</span><span class="main">::</span><span class="quoted"><span class="quoted">"perm"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> fresh<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">as</span> <span class="main">♯*</span> <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>     fin<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">as</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="free">p</span> <span class="main">♯*</span> <span class="free">as</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> fresh_star_supp_conv<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_finite_atom_set fin fresh<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Nominal2_Base-fresh_star_atom_set_conv"><span class="command">lemma</span></span> fresh_star_atom_set_conv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> fresh<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">as</span> <span class="main">♯*</span> <span class="free">bs</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>     fin<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">as</span>"</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">bs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">bs</span> <span class="main">♯*</span> <span class="free">as</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> fresh
<span class="keyword1"><span class="command">unfolding</span></span> fresh_star_def fresh_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> supp_finite_atom_set fin<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-atom_fresh_star_disjoint"><span class="command">lemma</span></span> atom_fresh_star_disjoint<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> fin<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">bs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">as</span> <span class="main">♯*</span> <span class="free">bs</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">as</span> <span class="main">∩</span> <span class="free">bs</span> <span class="main">=</span> <span class="main">{}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">unfolding</span></span> fresh_star_def fresh_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> supp_finite_atom_set fin<span class="main">)</span>


<span class="keyword1" id="Nominal2_Base-fresh_star_Pair"><span class="command">lemma</span></span> fresh_star_Pair<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">as</span> <span class="main">♯*</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">as</span> <span class="main">♯*</span> <span class="free">x</span> <span class="main">∧</span> <span class="free">as</span> <span class="main">♯*</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fresh_star_def fresh_Pair<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fresh_star_list"><span class="command">lemma</span></span> fresh_star_list<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">as</span> <span class="main">♯*</span> <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">as</span> <span class="main">♯*</span> <span class="free">xs</span> <span class="main">∧</span> <span class="free">as</span> <span class="main">♯*</span> <span class="free">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="free">as</span> <span class="main">♯*</span> <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">as</span> <span class="main">♯*</span> <span class="free">x</span> <span class="main">∧</span> <span class="free">as</span> <span class="main">♯*</span> <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="free">as</span> <span class="main">♯*</span> <span class="main">[]</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fresh_star_def fresh_Nil fresh_Cons fresh_append<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fresh_star_set"><span class="command">lemma</span></span> fresh_star_set<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">xs</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>fs<span class="main">)</span> list"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">as</span> <span class="main">♯*</span> set <span class="free">xs</span> <span class="main">⟷</span> <span class="free">as</span> <span class="main">♯*</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fresh_star_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_set<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fresh_star_singleton"><span class="command">lemma</span></span> fresh_star_singleton<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">a</span><span class="main">::</span><span class="quoted"><span class="quoted">"atom"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">as</span> <span class="main">♯*</span> <span class="main">{</span><span class="free">a</span><span class="main">}</span> <span class="main">⟷</span> <span class="free">as</span> <span class="main">♯*</span> <span class="free">a</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_star_def fresh_finite_insert fresh_set_empty<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fresh_star_fset"><span class="command">lemma</span></span> fresh_star_fset<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">xs</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>fs<span class="main">)</span> list"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">as</span> <span class="main">♯*</span> fset <span class="free">S</span> <span class="main">⟷</span> <span class="free">as</span> <span class="main">♯*</span> <span class="free">S</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_star_def fresh_def<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fresh_star_Un"><span class="command">lemma</span></span> fresh_star_Un<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">as</span> <span class="main">∪</span> <span class="free">bs</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">as</span> <span class="main">♯*</span> <span class="free">x</span> <span class="main">∧</span> <span class="free">bs</span> <span class="main">♯*</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fresh_star_def<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fresh_star_insert"><span class="command">lemma</span></span> fresh_star_insert<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>insert <span class="free">a</span> <span class="free">as</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span> <span class="main">♯</span> <span class="free">x</span> <span class="main">∧</span> <span class="free">as</span> <span class="main">♯*</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fresh_star_def<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fresh_star_Un_elim"><span class="command">lemma</span></span> fresh_star_Un_elim<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">as</span> <span class="main">∪</span> <span class="free">bs</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">x</span> <span class="main">⟹</span> <span class="keyword1">PROP</span> <span class="free">C</span><span class="main">)</span> <span class="main">≡</span> <span class="main">(</span><span class="free">as</span> <span class="main">♯*</span> <span class="free">x</span> <span class="main">⟹</span> <span class="free">bs</span> <span class="main">♯*</span> <span class="free">x</span> <span class="main">⟹</span> <span class="keyword1">PROP</span> <span class="free">C</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fresh_star_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule</span> meta_mp<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Nominal2_Base-fresh_star_insert_elim"><span class="command">lemma</span></span> fresh_star_insert_elim<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>insert <span class="free">a</span> <span class="free">as</span> <span class="main">♯*</span> <span class="free">x</span> <span class="main">⟹</span> <span class="keyword1">PROP</span> <span class="free">C</span><span class="main">)</span> <span class="main">≡</span> <span class="main">(</span><span class="free">a</span> <span class="main">♯</span> <span class="free">x</span> <span class="main">⟹</span> <span class="free">as</span> <span class="main">♯*</span> <span class="free">x</span> <span class="main">⟹</span> <span class="keyword1">PROP</span> <span class="free">C</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fresh_star_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">rule</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_star_def<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fresh_star_empty_elim"><span class="command">lemma</span></span> fresh_star_empty_elim<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">{}</span> <span class="main">♯*</span> <span class="free">x</span> <span class="main">⟹</span> <span class="keyword1">PROP</span> <span class="free">C</span><span class="main">)</span> <span class="main">≡</span> <span class="keyword1">PROP</span> <span class="free">C</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_star_def<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fresh_star_Unit_elim"><span class="command">lemma</span></span> fresh_star_Unit_elim<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">♯*</span> <span class="main">()</span> <span class="main">⟹</span> <span class="keyword1">PROP</span> <span class="free">C</span><span class="main">)</span> <span class="main">≡</span> <span class="keyword1">PROP</span> <span class="free">C</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_star_def fresh_Unit<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fresh_star_Pair_elim"><span class="command">lemma</span></span> fresh_star_Pair_elim<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">♯*</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">⟹</span> <span class="keyword1">PROP</span> <span class="free">C</span><span class="main">)</span> <span class="main">≡</span> <span class="main">(</span><span class="free">a</span> <span class="main">♯*</span> <span class="free">x</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">♯*</span> <span class="free">y</span> <span class="main">⟹</span> <span class="keyword1">PROP</span> <span class="free">C</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_star_Pair<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fresh_star_zero"><span class="command">lemma</span></span> fresh_star_zero<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">as</span> <span class="main">♯*</span> <span class="main">(</span><span class="main">0</span><span class="main">::</span>perm<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fresh_star_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_zero_perm<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fresh_star_plus"><span class="command">lemma</span></span> fresh_star_plus<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p</span> <span class="free">q</span><span class="main">::</span><span class="quoted">perm</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">a</span> <span class="main">♯*</span> <span class="free">p</span><span class="main">;</span>  <span class="free">a</span> <span class="main">♯*</span> <span class="free">q</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">♯*</span> <span class="main">(</span><span class="free">p</span> <span class="main">+</span> <span class="free">q</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fresh_star_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_plus_perm<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fresh_star_permute_iff"><span class="command">lemma</span></span> fresh_star_permute_iff<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">a</span><span class="main">)</span> <span class="main">♯*</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">a</span> <span class="main">♯*</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fresh_star_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> mem_permute_iff permute_minus_cancel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> fresh_permute_iff<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fresh_star_eqvt"><span class="command">lemma</span></span> fresh_star_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">as</span> <span class="main">♯*</span> <span class="free">x</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">as</span><span class="main">)</span> <span class="main">♯*</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fresh_star_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Induction principle for permutations›</span></span>

<span class="keyword1" id="Nominal2_Base-smaller_supp"><span class="command">lemma</span></span> smaller_supp<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">∈</span> supp <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span><span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">a</span> <span class="main">⇌</span> <span class="free">a</span><span class="main">)</span> <span class="main">+</span> <span class="free">p</span><span class="main">)</span> <span class="main">⊂</span> supp <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span><span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">a</span> <span class="main">⇌</span> <span class="free">a</span><span class="main">)</span> <span class="main">+</span> <span class="free">p</span><span class="main">)</span> <span class="main">⊆</span> supp <span class="free">p</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> supp_perm <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> swap_atom<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">∉</span> supp <span class="main">(</span><span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">a</span> <span class="main">⇌</span> <span class="free">a</span><span class="main">)</span> <span class="main">+</span> <span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_perm<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span><span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">a</span> <span class="main">⇌</span> <span class="free">a</span><span class="main">)</span> <span class="main">+</span> <span class="free">p</span><span class="main">)</span> <span class="main">≠</span> supp <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> a <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">ultimately</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span><span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">a</span> <span class="main">⇌</span> <span class="free">a</span><span class="main">)</span> <span class="main">+</span> <span class="free">p</span><span class="main">)</span> <span class="main">⊂</span> supp <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1" id="Nominal2_Base-perm_struct_induct"><span class="command">lemma</span></span> perm_struct_induct<span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> zero swap<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> S<span class="main">:</span> <span class="quoted"><span class="quoted">"supp <span class="free">p</span> <span class="main">⊆</span> <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> zero<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">0</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> swap<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">p</span> <span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> <span class="main">⟦</span><span class="free">P</span> <span class="bound">p</span><span class="main">;</span> supp <span class="bound">p</span> <span class="main">⊆</span> <span class="free">S</span><span class="main">;</span> <span class="bound">a</span> <span class="main">∈</span> <span class="free">S</span><span class="main">;</span> <span class="bound">b</span> <span class="main">∈</span> <span class="free">S</span><span class="main">;</span> <span class="bound">a</span> <span class="main">≠</span> <span class="bound">b</span><span class="main">;</span> sort_of <span class="bound">a</span> <span class="main">=</span> sort_of <span class="bound">b</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span><span class="main">(</span><span class="bound">a</span> <span class="main">⇌</span> <span class="bound">b</span><span class="main">)</span> <span class="main">+</span> <span class="bound">p</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>supp <span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finite_supp<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> S
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="skolem">A</span><span class="main"><span class="main">≡</span></span><span class="quoted"><span class="quoted">"supp <span class="free">p</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> finite_psubset_induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>psubset <span class="skolem">p</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> ih<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">q</span><span class="main">.</span> supp <span class="bound">q</span> <span class="main">⊂</span> supp <span class="skolem">p</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">q</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> as<span class="main">:</span> <span class="quoted"><span class="quoted">"supp <span class="skolem">p</span> <span class="main">⊆</span> <span class="free">S</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"supp <span class="skolem">p</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_perm perm_eq_iff<span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="skolem">p</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> zero <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"supp <span class="skolem">p</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a</span></span> <span class="keyword2"><span class="keyword">where</span></span> a0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> supp <span class="skolem">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> a1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">∙</span> <span class="skolem">a</span> <span class="main">∈</span> <span class="free">S</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> <span class="free">S</span>"</span></span> <span class="quoted"><span class="quoted">"sort_of <span class="main">(</span><span class="skolem">p</span> <span class="main">∙</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">=</span> sort_of <span class="skolem">a</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">∙</span> <span class="skolem">a</span> <span class="main">≠</span> <span class="skolem">a</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> as <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> supp_atom supp_perm swap_atom<span class="main">)</span>
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?q</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">p</span> <span class="main">∙</span> <span class="skolem">a</span> <span class="main">⇌</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">+</span> <span class="skolem">p</span>"</span></span>
      <span class="keyword1"><span class="command">have</span></span> a2<span class="main">:</span> <span class="quoted"><span class="quoted">"supp <span class="var">?q</span> <span class="main">⊂</span> supp <span class="skolem">p</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> a0 smaller_supp <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="var">?q</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> ih <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">moreover</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"supp <span class="var">?q</span> <span class="main">⊆</span> <span class="free">S</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> as a2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">ultimately</span></span>  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span><span class="main">(</span><span class="skolem">p</span> <span class="main">∙</span> <span class="skolem">a</span> <span class="main">⇌</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">+</span> <span class="var">?q</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> as a1 swap <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">moreover</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">p</span> <span class="main">∙</span> <span class="skolem">a</span> <span class="main">⇌</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">+</span> <span class="var">?q</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> perm_eq_iff<span class="main">)</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="skolem">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="skolem">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Base-perm_simple_struct_induct"><span class="command">lemma</span></span> perm_simple_struct_induct<span class="main">[</span><span class="operator">case_names</span> zero swap<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> zero<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">0</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>     swap<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">p</span> <span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> <span class="main">⟦</span><span class="free">P</span> <span class="bound">p</span><span class="main">;</span> <span class="bound">a</span> <span class="main">≠</span> <span class="bound">b</span><span class="main">;</span> sort_of <span class="bound">a</span> <span class="main">=</span> sort_of <span class="bound">b</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span><span class="main">(</span><span class="bound">a</span> <span class="main">⇌</span> <span class="bound">b</span><span class="main">)</span> <span class="main">+</span> <span class="bound">p</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule_tac</span> S<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"supp <span class="free">p</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> perm_struct_induct<span class="main">)</span>
   <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> zero swap<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-perm_struct_induct2"><span class="command">lemma</span></span> perm_struct_induct2<span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> zero swap plus<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> S<span class="main">:</span> <span class="quoted"><span class="quoted">"supp <span class="free">p</span> <span class="main">⊆</span> <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> zero<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">0</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> swap<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> <span class="main">⟦</span>sort_of <span class="bound">a</span> <span class="main">=</span> sort_of <span class="bound">b</span><span class="main">;</span> <span class="bound">a</span> <span class="main">≠</span> <span class="bound">b</span><span class="main">;</span> <span class="bound">a</span> <span class="main">∈</span> <span class="free">S</span><span class="main">;</span> <span class="bound">b</span> <span class="main">∈</span> <span class="free">S</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span><span class="bound">a</span> <span class="main">⇌</span> <span class="bound">b</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> plus<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">p1</span> <span class="bound">p2</span><span class="main">.</span> <span class="main">⟦</span><span class="free">P</span> <span class="bound">p1</span><span class="main">;</span> <span class="free">P</span> <span class="bound">p2</span><span class="main">;</span> supp <span class="bound">p1</span> <span class="main">⊆</span> <span class="free">S</span><span class="main">;</span> supp <span class="bound">p2</span> <span class="main">⊆</span> <span class="free">S</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span><span class="bound">p1</span> <span class="main">+</span> <span class="bound">p2</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> S
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> perm_struct_induct<span class="main">)</span>
   <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> zero plus swap <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_swap<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-perm_simple_struct_induct2"><span class="command">lemma</span></span> perm_simple_struct_induct2<span class="main">[</span><span class="operator">case_names</span> zero swap plus<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> zero<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">0</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> swap<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> <span class="main">⟦</span>sort_of <span class="bound">a</span> <span class="main">=</span> sort_of <span class="bound">b</span><span class="main">;</span> <span class="bound">a</span> <span class="main">≠</span> <span class="bound">b</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span><span class="bound">a</span> <span class="main">⇌</span> <span class="bound">b</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> plus<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">p1</span> <span class="bound">p2</span><span class="main">.</span> <span class="main">⟦</span><span class="free">P</span> <span class="bound">p1</span><span class="main">;</span> <span class="free">P</span> <span class="bound">p2</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span><span class="bound">p1</span> <span class="main">+</span> <span class="bound">p2</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule_tac</span> S<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"supp <span class="free">p</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> perm_struct_induct2<span class="main">)</span>
   <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> zero swap plus<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-supp_perm_singleton"><span class="command">lemma</span></span> supp_perm_singleton<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p</span><span class="main">::</span><span class="quoted"><span class="quoted">"perm"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="free">p</span> <span class="main">⊆</span> <span class="main">{</span><span class="free">b</span><span class="main">}</span> <span class="main">⟷</span> <span class="free">p</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"supp <span class="free">p</span> <span class="main">⊆</span> <span class="main">{</span><span class="free">b</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> perm_struct_induct<span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"supp <span class="free">p</span> <span class="main">⊆</span> <span class="main">{</span><span class="free">b</span><span class="main">}</span> <span class="main">⟷</span> <span class="free">p</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> supp_zero_perm<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Base-supp_perm_pair"><span class="command">lemma</span></span> supp_perm_pair<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p</span><span class="main">::</span><span class="quoted"><span class="quoted">"perm"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="free">p</span> <span class="main">⊆</span> <span class="main">{</span><span class="free">a</span><span class="main">,</span> <span class="free">b</span><span class="main">}</span> <span class="main">⟷</span> <span class="free">p</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∨</span> <span class="free">p</span> <span class="main">=</span> <span class="main">(</span><span class="free">b</span> <span class="main">⇌</span> <span class="free">a</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"supp <span class="free">p</span> <span class="main">⊆</span> <span class="main">{</span><span class="free">a</span><span class="main">,</span> <span class="free">b</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∨</span> <span class="free">p</span> <span class="main">=</span> <span class="main">(</span><span class="free">b</span> <span class="main">⇌</span> <span class="free">a</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> perm_struct_induct<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> swap_cancel supp_zero_perm supp_swap<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> swap_commute<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"supp <span class="free">p</span> <span class="main">⊆</span> <span class="main">{</span><span class="free">a</span><span class="main">,</span> <span class="free">b</span><span class="main">}</span> <span class="main">⟷</span> <span class="free">p</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∨</span> <span class="free">p</span> <span class="main">=</span> <span class="main">(</span><span class="free">b</span> <span class="main">⇌</span> <span class="free">a</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> supp_zero_perm supp_swap <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Base-supp_perm_eq"><span class="command">lemma</span></span> supp_perm_eq<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>supp <span class="free">x</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"supp <span class="free">p</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">a</span><span class="main">.</span> <span class="bound">a</span> <span class="main">♯</span> <span class="free">x</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> supp_perm fresh_star_def fresh_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> perm_struct_induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> zero
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>swap <span class="skolem">p</span> <span class="skolem">a</span> <span class="skolem">b</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">♯</span> <span class="free">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">♯</span> <span class="free">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">a</span> <span class="main">⇌</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">+</span> <span class="skolem">p</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> swap_fresh_fresh<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹same lemma as above, but proved with a different induction principle›</span></span>
<span class="keyword1" id="Nominal2_Base-supp_perm_eq_test"><span class="command">lemma</span></span> supp_perm_eq_test<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>supp <span class="free">x</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"supp <span class="free">p</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">a</span><span class="main">.</span> <span class="bound">a</span> <span class="main">♯</span> <span class="free">x</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> supp_perm fresh_star_def fresh_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> perm_struct_induct2<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> zero
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>swap <span class="skolem">a</span> <span class="skolem">b</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">♯</span> <span class="free">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">♯</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span> <span class="main">⇌</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> swap_fresh_fresh<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>plus <span class="skolem">p1</span> <span class="skolem">p2</span><span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p1</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p2</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">p1</span> <span class="main">+</span> <span class="skolem">p2</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Base-perm_supp_eq"><span class="command">lemma</span></span> perm_supp_eq<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>supp <span class="free">p</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"supp <span class="free">p</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">a</span><span class="main">.</span> <span class="bound">a</span> <span class="main">♯</span> <span class="free">x</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> supp_perm fresh_star_def fresh_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> perm_struct_induct2<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> zero
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>swap <span class="skolem">a</span> <span class="skolem">b</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">♯</span> <span class="free">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">♯</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span> <span class="main">⇌</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> swap_fresh_fresh<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>plus <span class="skolem">p1</span> <span class="skolem">p2</span><span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p1</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p2</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">p1</span> <span class="main">+</span> <span class="skolem">p2</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Base-supp_perm_perm_eq"><span class="command">lemma</span></span> supp_perm_perm_eq<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">a</span> <span class="main">∈</span> supp <span class="free">x</span><span class="main">.</span> <span class="free">p</span> <span class="main">∙</span> <span class="bound">a</span> <span class="main">=</span> <span class="free">q</span> <span class="main">∙</span> <span class="bound">a</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">q</span> <span class="main">∙</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> a <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">a</span> <span class="main">∈</span> supp <span class="free">x</span><span class="main">.</span> <span class="main">(</span><span class="main">-</span><span class="free">q</span> <span class="main">+</span> <span class="free">p</span><span class="main">)</span> <span class="main">∙</span> <span class="bound">a</span> <span class="main">=</span> <span class="bound">a</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">a</span> <span class="main">∈</span> supp <span class="free">x</span><span class="main">.</span> <span class="bound">a</span> <span class="main">∉</span> supp <span class="main">(</span><span class="main">-</span><span class="free">q</span> <span class="main">+</span> <span class="free">p</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> supp_perm <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"supp <span class="free">x</span> <span class="main">♯*</span> <span class="main">(</span><span class="main">-</span><span class="free">q</span> <span class="main">+</span> <span class="free">p</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> fresh_star_def fresh_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">-</span><span class="free">q</span> <span class="main">+</span> <span class="free">p</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> supp_perm_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">q</span> <span class="main">∙</span> <span class="free">x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> permute_minus_cancel permute_plus<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹disagreement set›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">dset</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"perm <span class="main">⇒</span> perm <span class="main">⇒</span> atom set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">dset</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound">a</span><span class="main">::</span>atom<span class="main">.</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∙</span> <span class="bound">a</span> <span class="main">≠</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">∙</span> <span class="bound">a</span><span class="main">}</span>"</span></span>

<span class="keyword1" id="Nominal2_Base-ds_fresh"><span class="command">lemma</span></span> ds_fresh<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"dset <span class="free">p</span> <span class="free">q</span> <span class="main">♯*</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">q</span> <span class="main">∙</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">unfolding</span></span> dset_def fresh_star_def fresh_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> supp_perm_perm_eq<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-atom_set_perm_eq"><span class="command">lemma</span></span> atom_set_perm_eq<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">as</span> <span class="main">♯*</span> <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="free">as</span> <span class="main">=</span> <span class="free">as</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> a <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"supp <span class="free">p</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">a</span><span class="main">.</span> <span class="bound">a</span> <span class="main">∉</span> <span class="free">as</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> supp_perm fresh_star_def fresh_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="free">as</span> <span class="main">=</span> <span class="free">as</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> perm_struct_induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> zero
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">∙</span> <span class="free">as</span> <span class="main">=</span> <span class="free">as</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>swap <span class="skolem">p</span> <span class="skolem">a</span> <span class="skolem">b</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∉</span> <span class="free">as</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∉</span> <span class="free">as</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">∙</span> <span class="free">as</span> <span class="main">=</span> <span class="free">as</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">a</span> <span class="main">⇌</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">+</span> <span class="skolem">p</span><span class="main">)</span> <span class="main">∙</span> <span class="free">as</span> <span class="main">=</span> <span class="free">as</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> swap_set_not_in<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Avoiding of atom sets›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  For every set of atoms, there is another set of atoms
  avoiding a finitely supported c and there is a permutation
  which 'translates' between both sets.
›</span></span>

<span class="keyword1" id="Nominal2_Base-at_set_avoiding_aux"><span class="command">lemma</span></span> at_set_avoiding_aux<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">Xs</span><span class="main">::</span><span class="quoted"><span class="quoted">"atom set"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="free">As</span><span class="main">::</span><span class="quoted"><span class="quoted">"atom set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> b<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Xs</span> <span class="main">⊆</span> <span class="free">As</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>     c<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">As</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">p</span><span class="main">.</span> <span class="main">(</span><span class="bound">p</span> <span class="main">∙</span> <span class="free">Xs</span><span class="main">)</span> <span class="main">∩</span> <span class="free">As</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">∧</span> <span class="main">(</span>supp <span class="bound">p</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">Xs</span> <span class="main">∪</span> <span class="main">(</span><span class="bound">p</span> <span class="main">∙</span> <span class="free">Xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> b c <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">Xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> b
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> finite_subset_induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> empty
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">∙</span> <span class="main">{}</span> <span class="main">∩</span> <span class="free">As</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span><span class="main">0</span><span class="main">::</span>perm<span class="main">)</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">∪</span> <span class="main">0</span> <span class="main">∙</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_zero_perm<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>insert <span class="skolem">x</span> <span class="skolem">Xs</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p</span></span> <span class="keyword2"><span class="keyword">where</span></span>
      p1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">p</span> <span class="main">∙</span> <span class="skolem">Xs</span><span class="main">)</span> <span class="main">∩</span> <span class="free">As</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
      p2<span class="main">:</span> <span class="quoted"><span class="quoted">"supp <span class="skolem">p</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">Xs</span> <span class="main">∪</span> <span class="main">(</span><span class="skolem">p</span> <span class="main">∙</span> <span class="skolem">Xs</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> <span class="free">As</span>›</span></span> p1 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∉</span> <span class="skolem">p</span> <span class="main">∙</span> <span class="skolem">Xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fast</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∉</span> <span class="skolem">Xs</span>›</span></span> p2 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∉</span> supp <span class="skolem">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fast</span>
    <span class="keyword1"><span class="command">hence</span></span> px<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">∙</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> supp_perm <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="free">As</span> <span class="main">∪</span> <span class="skolem">p</span> <span class="main">∙</span> <span class="skolem">Xs</span> <span class="main">∪</span> supp <span class="skolem">p</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹finite <span class="free">As</span>›</span></span> <span class="quoted"><span class="quoted">‹finite <span class="skolem">Xs</span>›</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_set_eq_image finite_supp<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∉</span> <span class="main">(</span><span class="free">As</span> <span class="main">∪</span> <span class="skolem">p</span> <span class="main">∙</span> <span class="skolem">Xs</span> <span class="main">∪</span> supp <span class="skolem">p</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"sort_of <span class="skolem">y</span> <span class="main">=</span> sort_of <span class="skolem">x</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> obtain_atom<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> y<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∉</span> <span class="free">As</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∉</span> <span class="skolem">p</span> <span class="main">∙</span> <span class="skolem">Xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∉</span> supp <span class="skolem">p</span>"</span></span> <span class="quoted"><span class="quoted">"sort_of <span class="skolem">y</span> <span class="main">=</span> sort_of <span class="skolem">x</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command">hence</span></span> py<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">∙</span> <span class="skolem">y</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≠</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> <span class="free">As</span>›</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> supp_perm<span class="main">)</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?q</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span> <span class="main">⇌</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">+</span> <span class="skolem">p</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> q<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?q</span> <span class="main">∙</span> insert <span class="skolem">x</span> <span class="skolem">Xs</span> <span class="main">=</span> insert <span class="skolem">y</span> <span class="main">(</span><span class="skolem">p</span> <span class="main">∙</span> <span class="skolem">Xs</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> insert_eqvt
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">p</span> <span class="main">∙</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">x</span>›</span></span> <span class="quoted"><span class="quoted">‹sort_of <span class="skolem">y</span> <span class="main">=</span> sort_of <span class="skolem">x</span>›</span></span>
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∉</span> <span class="skolem">p</span> <span class="main">∙</span> <span class="skolem">Xs</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∉</span> <span class="skolem">p</span> <span class="main">∙</span> <span class="skolem">Xs</span>›</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> swap_atom swap_set_not_in<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?q</span> <span class="main">∙</span> insert <span class="skolem">x</span> <span class="skolem">Xs</span> <span class="main">∩</span> <span class="free">As</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∉</span> <span class="free">As</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">p</span> <span class="main">∙</span> <span class="skolem">Xs</span> <span class="main">∩</span> <span class="free">As</span> <span class="main">=</span> <span class="main">{}</span>›</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> q <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span><span class="skolem">x</span> <span class="main">⇌</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∩</span> supp <span class="skolem">p</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> px py <span class="quoted"><span class="quoted">‹sort_of <span class="skolem">y</span> <span class="main">=</span> sort_of <span class="skolem">x</span>›</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> supp_swap <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_perm<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"supp <span class="var">?q</span> <span class="main">=</span> <span class="main">(</span>supp <span class="main">(</span><span class="skolem">x</span> <span class="main">⇌</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∪</span> supp <span class="skolem">p</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_plus_perm_eq<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"supp <span class="var">?q</span> <span class="main">=</span> insert <span class="skolem">x</span> <span class="skolem">Xs</span> <span class="main">∪</span> <span class="var">?q</span> <span class="main">∙</span> insert <span class="skolem">x</span> <span class="skolem">Xs</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> p2 <span class="quoted"><span class="quoted">‹sort_of <span class="skolem">y</span> <span class="main">=</span> sort_of <span class="skolem">x</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">≠</span> <span class="skolem">y</span>›</span></span> <span class="keyword1"><span class="command">unfolding</span></span> q supp_swap
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Base-at_set_avoiding"><span class="command">lemma</span></span> at_set_avoiding<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">Xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>     b<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>supp <span class="free">c</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">p</span><span class="main">::</span><span class="quoted"><span class="quoted">"perm"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">Xs</span><span class="main">)</span><span class="main">♯*</span><span class="free">c</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>supp <span class="free">p</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">Xs</span> <span class="main">∪</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">Xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> a b at_set_avoiding_aux <span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> Xs<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">Xs</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> As<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">Xs</span> <span class="main">∪</span> supp <span class="free">c</span>"</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">unfolding</span></span> fresh_star_def fresh_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="Nominal2_Base-at_set_avoiding1"><span class="command">lemma</span></span> at_set_avoiding1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>     <span class="quoted"><span class="quoted">"finite <span class="main">(</span>supp <span class="free">c</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">p</span><span class="main">.</span> <span class="main">(</span><span class="bound">p</span> <span class="main">∙</span> <span class="free">xs</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">c</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule_tac</span> c<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">c</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> at_set_avoiding<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Nominal2_Base-at_set_avoiding2"><span class="command">lemma</span></span> at_set_avoiding2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>     <span class="quoted"><span class="quoted">"finite <span class="main">(</span>supp <span class="free">c</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>supp <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>     <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">♯*</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">p</span><span class="main">.</span> <span class="main">(</span><span class="bound">p</span> <span class="main">∙</span> <span class="free">xs</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">c</span> <span class="main">∧</span> supp <span class="free">x</span> <span class="main">♯*</span> <span class="bound">p</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule_tac</span> c<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">c</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> at_set_avoiding<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_Pair<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="improper">p</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_star_Pair<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> fresh_star_supp_conv<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fresh_star_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Nominal2_Base-at_set_avoiding3"><span class="command">lemma</span></span> at_set_avoiding3<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>     <span class="quoted"><span class="quoted">"finite <span class="main">(</span>supp <span class="free">c</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>supp <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>     <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">♯*</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">p</span><span class="main">.</span> <span class="main">(</span><span class="bound">p</span> <span class="main">∙</span> <span class="free">xs</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">c</span> <span class="main">∧</span> supp <span class="free">x</span> <span class="main">♯*</span> <span class="bound">p</span> <span class="main">∧</span> supp <span class="bound">p</span> <span class="main">=</span> <span class="free">xs</span> <span class="main">∪</span> <span class="main">(</span><span class="bound">p</span> <span class="main">∙</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule_tac</span> c<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">c</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> at_set_avoiding<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_Pair<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="improper">p</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_star_Pair<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> fresh_star_supp_conv<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fresh_star_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Nominal2_Base-at_set_avoiding2_atom"><span class="command">lemma</span></span> at_set_avoiding2_atom<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>supp <span class="free">c</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>supp <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>     b<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">p</span><span class="main">.</span> <span class="main">(</span><span class="bound">p</span> <span class="main">∙</span> <span class="free">a</span><span class="main">)</span> <span class="main">♯</span> <span class="free">c</span> <span class="main">∧</span> supp <span class="free">x</span> <span class="main">♯*</span> <span class="bound">p</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">a</span><span class="main">}</span> <span class="main">♯*</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> fresh_star_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> b<span class="main">)</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p</span></span> <span class="keyword2"><span class="keyword">where</span></span> p1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">p</span> <span class="main">∙</span> <span class="main">{</span><span class="free">a</span><span class="main">}</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">c</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> p2<span class="main">:</span> <span class="quoted"><span class="quoted">"supp <span class="free">x</span> <span class="main">♯*</span> <span class="skolem">p</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> at_set_avoiding2<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">a</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">c</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span>"</span></span><span class="main">]</span> assms a <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">have</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">p</span> <span class="main">∙</span> <span class="free">a</span><span class="main">)</span> <span class="main">♯</span> <span class="free">c</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> p1
    <span class="keyword1"><span class="command">unfolding</span></span> fresh_star_def Ball_def
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">erule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">∙</span> <span class="free">a</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> allE<span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_set_def<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">∙</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">c</span> <span class="main">∧</span> supp <span class="free">x</span> <span class="main">♯*</span> <span class="skolem">p</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> p2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">p</span><span class="main">.</span> <span class="main">(</span><span class="bound">p</span> <span class="main">∙</span> <span class="free">a</span><span class="main">)</span> <span class="main">♯</span> <span class="free">c</span> <span class="main">∧</span> supp <span class="free">x</span> <span class="main">♯*</span> <span class="bound">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Renaming permutations›</span></span>

<span class="keyword1" id="Nominal2_Base-set_renaming_perm"><span class="command">lemma</span></span> set_renaming_perm<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> b<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">bs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">q</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound">b</span> <span class="main">∈</span> <span class="free">bs</span><span class="main">.</span> <span class="bound">q</span> <span class="main">∙</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∧</span> supp <span class="bound">q</span> <span class="main">⊆</span> <span class="free">bs</span> <span class="main">∪</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">bs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> b
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> empty
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">b</span> <span class="main">∈</span> <span class="main">{}</span><span class="main">.</span> <span class="main">0</span> <span class="main">∙</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∧</span> supp <span class="main">(</span><span class="main">0</span><span class="main">::</span>perm<span class="main">)</span> <span class="main">⊆</span> <span class="main">{}</span> <span class="main">∪</span> <span class="free">p</span> <span class="main">∙</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_set_def supp_perm<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">q</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound">b</span> <span class="main">∈</span> <span class="main">{}</span><span class="main">.</span> <span class="bound">q</span> <span class="main">∙</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∧</span> supp <span class="bound">q</span> <span class="main">⊆</span> <span class="main">{}</span> <span class="main">∪</span> <span class="free">p</span> <span class="main">∙</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>insert <span class="skolem">a</span> <span class="skolem">bs</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">" <span class="main">∃</span><span class="bound">q</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound">b</span> <span class="main">∈</span> <span class="skolem">bs</span><span class="main">.</span> <span class="bound">q</span> <span class="main">∙</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∧</span> supp <span class="bound">q</span> <span class="main">⊆</span> <span class="skolem">bs</span> <span class="main">∪</span> <span class="free">p</span> <span class="main">∙</span> <span class="skolem">bs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">q</span></span> <span class="keyword2"><span class="keyword">where</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b</span> <span class="main">∈</span> <span class="skolem">bs</span><span class="main">.</span> <span class="skolem">q</span> <span class="main">∙</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="bound">b</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> **<span class="main">:</span> <span class="quoted"><span class="quoted">"supp <span class="skolem">q</span> <span class="main">⊆</span> <span class="skolem">bs</span> <span class="main">∪</span> <span class="free">p</span> <span class="main">∙</span> <span class="skolem">bs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> empty_subsetI insert<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> supp_swap<span class="main">)</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span> <span class="main">∙</span> <span class="skolem">a</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="skolem">a</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b</span> <span class="main">∈</span> <span class="main">(</span>insert <span class="skolem">a</span> <span class="skolem">bs</span><span class="main">)</span><span class="main">.</span> <span class="skolem">q</span> <span class="main">∙</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="bound">b</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> 1 * <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"supp <span class="skolem">q</span> <span class="main">⊆</span> insert <span class="skolem">a</span> <span class="skolem">bs</span> <span class="main">∪</span> <span class="free">p</span> <span class="main">∙</span> insert <span class="skolem">a</span> <span class="skolem">bs</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> ** <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> insert_eqvt<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">q</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound">b</span> <span class="main">∈</span> insert <span class="skolem">a</span> <span class="skolem">bs</span><span class="main">.</span> <span class="bound">q</span> <span class="main">∙</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∧</span> supp <span class="bound">q</span> <span class="main">⊆</span> insert <span class="skolem">a</span> <span class="skolem">bs</span> <span class="main">∪</span> <span class="free">p</span> <span class="main">∙</span> insert <span class="skolem">a</span> <span class="skolem">bs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span> <span class="main">∙</span> <span class="skolem">a</span> <span class="main">≠</span> <span class="free">p</span> <span class="main">∙</span> <span class="skolem">a</span>"</span></span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">q'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">q'</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">⇌</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="skolem">a</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span> <span class="skolem">q</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b</span> <span class="main">∈</span> insert <span class="skolem">a</span> <span class="skolem">bs</span><span class="main">.</span> <span class="skolem">q'</span> <span class="main">∙</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="bound">b</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> 2 * <span class="quoted"><span class="quoted">‹<span class="skolem">a</span> <span class="main">∉</span> <span class="skolem">bs</span>›</span></span> <span class="keyword1"><span class="command">unfolding</span></span> q'_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> swap_atom<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="skolem">q</span> <span class="main">∙</span> <span class="skolem">a</span><span class="main">,</span> <span class="free">p</span> <span class="main">∙</span> <span class="skolem">a</span><span class="main">}</span> <span class="main">⊆</span> insert <span class="skolem">a</span> <span class="skolem">bs</span> <span class="main">∪</span> <span class="free">p</span> <span class="main">∙</span> insert <span class="skolem">a</span> <span class="skolem">bs</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> **
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> supp_perm insert_eqvt<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span> <span class="main">∙</span> <span class="skolem">a</span> <span class="main">∈</span> <span class="skolem">bs</span> <span class="main">∪</span> <span class="free">p</span> <span class="main">∙</span> <span class="skolem">bs</span>"</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span> <span class="main">∙</span> <span class="skolem">a</span> <span class="main">∈</span> <span class="main">{</span><span class="bound">a</span><span class="main">.</span> <span class="skolem">q</span> <span class="main">∙</span> <span class="bound">a</span> <span class="main">≠</span> <span class="bound">a</span><span class="main">}</span>"</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">blast</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="skolem">a</span> <span class="main">⇌</span> <span class="free">p</span> <span class="main">∙</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">⊆</span> insert <span class="skolem">a</span> <span class="skolem">bs</span> <span class="main">∪</span> <span class="free">p</span> <span class="main">∙</span> insert <span class="skolem">a</span> <span class="skolem">bs</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> supp_swap <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">moreover</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"supp <span class="skolem">q</span> <span class="main">⊆</span> insert <span class="skolem">a</span> <span class="skolem">bs</span> <span class="main">∪</span> <span class="free">p</span> <span class="main">∙</span> insert <span class="skolem">a</span> <span class="skolem">bs</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> ** <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> insert_eqvt<span class="main">)</span>
      <span class="keyword1"><span class="command">ultimately</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"supp <span class="skolem">q'</span> <span class="main">⊆</span> insert <span class="skolem">a</span> <span class="skolem">bs</span> <span class="main">∪</span> <span class="free">p</span> <span class="main">∙</span> insert <span class="skolem">a</span> <span class="skolem">bs</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> q'_def <span class="keyword1"><span class="command">using</span></span> supp_plus_perm <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">q</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound">b</span> <span class="main">∈</span> insert <span class="skolem">a</span> <span class="skolem">bs</span><span class="main">.</span> <span class="bound">q</span> <span class="main">∙</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∧</span> supp <span class="bound">q</span> <span class="main">⊆</span> insert <span class="skolem">a</span> <span class="skolem">bs</span> <span class="main">∪</span> <span class="free">p</span> <span class="main">∙</span> insert <span class="skolem">a</span> <span class="skolem">bs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">q</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound">b</span> <span class="main">∈</span> insert <span class="skolem">a</span> <span class="skolem">bs</span><span class="main">.</span> <span class="bound">q</span> <span class="main">∙</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∧</span> supp <span class="bound">q</span> <span class="main">⊆</span> insert <span class="skolem">a</span> <span class="skolem">bs</span> <span class="main">∪</span> <span class="free">p</span> <span class="main">∙</span> insert <span class="skolem">a</span> <span class="skolem">bs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Base-set_renaming_perm2"><span class="command">lemma</span></span> set_renaming_perm2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">q</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound">b</span> <span class="main">∈</span> <span class="free">bs</span><span class="main">.</span> <span class="bound">q</span> <span class="main">∙</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∧</span> supp <span class="bound">q</span> <span class="main">⊆</span> <span class="free">bs</span> <span class="main">∪</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">bs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="free">bs</span> <span class="main">∩</span> supp <span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finite_supp<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">q</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b</span> <span class="main">∈</span> <span class="free">bs</span> <span class="main">∩</span> supp <span class="free">p</span><span class="main">.</span> <span class="skolem">q</span> <span class="main">∙</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="bound">b</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> **<span class="main">:</span> <span class="quoted"><span class="quoted">"supp <span class="skolem">q</span> <span class="main">⊆</span> <span class="main">(</span><span class="free">bs</span> <span class="main">∩</span> supp <span class="free">p</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">bs</span> <span class="main">∩</span> supp <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> set_renaming_perm <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">from</span></span> ** <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"supp <span class="skolem">q</span> <span class="main">⊆</span> <span class="free">bs</span> <span class="main">∪</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">bs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inter_eqvt<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b</span> <span class="main">∈</span> <span class="free">bs</span> <span class="main">-</span> supp <span class="free">p</span><span class="main">.</span> <span class="skolem">q</span> <span class="main">∙</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="bound">b</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="improper">b</span> <span class="main">∉</span> supp <span class="skolem">q</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_perm<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarify</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rotate_tac</span> 2<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule</span> subsetD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> **<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inter_eqvt supp_eqvt permute_self<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">b</span> <span class="main">∈</span> <span class="free">bs</span><span class="main">.</span> <span class="skolem">q</span> <span class="main">∙</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∧</span> supp <span class="skolem">q</span> <span class="main">⊆</span> <span class="free">bs</span> <span class="main">∪</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">bs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> * <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">q</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound">b</span> <span class="main">∈</span> <span class="free">bs</span><span class="main">.</span> <span class="bound">q</span> <span class="main">∙</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∧</span> supp <span class="bound">q</span> <span class="main">⊆</span> <span class="free">bs</span> <span class="main">∪</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">bs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Base-list_renaming_perm"><span class="command">lemma</span></span> list_renaming_perm<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">q</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound">b</span> <span class="main">∈</span> set <span class="free">bs</span><span class="main">.</span> <span class="bound">q</span> <span class="main">∙</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∧</span> supp <span class="bound">q</span> <span class="main">⊆</span> set <span class="free">bs</span> <span class="main">∪</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> set <span class="free">bs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">bs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">a</span> <span class="skolem">bs</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">" <span class="main">∃</span><span class="bound">q</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound">b</span> <span class="main">∈</span> set <span class="skolem">bs</span><span class="main">.</span> <span class="bound">q</span> <span class="main">∙</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∧</span> supp <span class="bound">q</span> <span class="main">⊆</span> set <span class="skolem">bs</span> <span class="main">∪</span> <span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>set <span class="skolem">bs</span><span class="main">)</span>"</span></span>  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">q</span></span> <span class="keyword2"><span class="keyword">where</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b</span> <span class="main">∈</span> set <span class="skolem">bs</span><span class="main">.</span> <span class="skolem">q</span> <span class="main">∙</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="bound">b</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> **<span class="main">:</span> <span class="quoted"><span class="quoted">"supp <span class="skolem">q</span> <span class="main">⊆</span> set <span class="skolem">bs</span> <span class="main">∪</span> <span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>set <span class="skolem">bs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span><span class="main">)</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> set <span class="skolem">bs</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span> <span class="main">∙</span> <span class="skolem">a</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="skolem">a</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> * 1 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">bs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">bs</span><span class="main">)</span><span class="main">.</span> <span class="skolem">q</span> <span class="main">∙</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="bound">b</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> * <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"supp <span class="skolem">q</span> <span class="main">⊆</span> set <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">bs</span><span class="main">)</span> <span class="main">∪</span> <span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>set <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">bs</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> ** <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> insert_eqvt<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">q</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound">b</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">bs</span><span class="main">)</span><span class="main">.</span> <span class="bound">q</span> <span class="main">∙</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∧</span> supp <span class="bound">q</span> <span class="main">⊆</span> set <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">bs</span><span class="main">)</span> <span class="main">∪</span> <span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>set <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">bs</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∉</span> set <span class="skolem">bs</span>"</span></span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">q'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">q'</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">⇌</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="skolem">a</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span> <span class="skolem">q</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">bs</span><span class="main">)</span><span class="main">.</span> <span class="skolem">q'</span> <span class="main">∙</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="bound">b</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> q'_def <span class="keyword1"><span class="command">using</span></span> 2 * <span class="quoted"><span class="quoted">‹<span class="skolem">a</span> <span class="main">∉</span> set <span class="skolem">bs</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> swap_atom<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="skolem">q</span> <span class="main">∙</span> <span class="skolem">a</span><span class="main">,</span> <span class="free">p</span> <span class="main">∙</span> <span class="skolem">a</span><span class="main">}</span> <span class="main">⊆</span> set <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">bs</span><span class="main">)</span> <span class="main">∪</span> <span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>set <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">bs</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> **
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> supp_perm insert_eqvt<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span> <span class="main">∙</span> <span class="skolem">a</span> <span class="main">∈</span> set <span class="skolem">bs</span> <span class="main">∪</span> <span class="free">p</span> <span class="main">∙</span> set <span class="skolem">bs</span>"</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span> <span class="main">∙</span> <span class="skolem">a</span> <span class="main">∈</span> <span class="main">{</span><span class="bound">a</span><span class="main">.</span> <span class="skolem">q</span> <span class="main">∙</span> <span class="bound">a</span> <span class="main">≠</span> <span class="bound">a</span><span class="main">}</span>"</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">blast</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="skolem">a</span> <span class="main">⇌</span> <span class="free">p</span> <span class="main">∙</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">⊆</span> set <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">bs</span><span class="main">)</span> <span class="main">∪</span> <span class="free">p</span> <span class="main">∙</span> set <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">bs</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> supp_swap <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">moreover</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"supp <span class="skolem">q</span> <span class="main">⊆</span> set <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">bs</span><span class="main">)</span> <span class="main">∪</span> <span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>set <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">bs</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> ** <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> insert_eqvt<span class="main">)</span>
      <span class="keyword1"><span class="command">ultimately</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"supp <span class="skolem">q'</span> <span class="main">⊆</span> set <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">bs</span><span class="main">)</span> <span class="main">∪</span> <span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>set <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">bs</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> q'_def <span class="keyword1"><span class="command">using</span></span> supp_plus_perm <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">q</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound">b</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">bs</span><span class="main">)</span><span class="main">.</span>  <span class="bound">q</span> <span class="main">∙</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∧</span> supp <span class="bound">q</span> <span class="main">⊆</span> set <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">bs</span><span class="main">)</span> <span class="main">∪</span> <span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>set <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">bs</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">q</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound">b</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">bs</span><span class="main">)</span><span class="main">.</span> <span class="bound">q</span> <span class="main">∙</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∧</span> supp <span class="bound">q</span> <span class="main">⊆</span> set <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">bs</span><span class="main">)</span> <span class="main">∪</span> <span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>set <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">bs</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">next</span></span>
 <span class="keyword3"><span class="command">case</span></span> Nil
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">b</span> <span class="main">∈</span> set <span class="main">[]</span><span class="main">.</span> <span class="main">0</span> <span class="main">∙</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∧</span> supp <span class="main">(</span><span class="main">0</span><span class="main">::</span>perm<span class="main">)</span> <span class="main">⊆</span> set <span class="main">[]</span> <span class="main">∪</span> <span class="free">p</span> <span class="main">∙</span> set <span class="main">[]</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_zero_perm<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">q</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound">b</span> <span class="main">∈</span> set <span class="main">[]</span><span class="main">.</span> <span class="bound">q</span> <span class="main">∙</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∧</span> supp <span class="bound">q</span> <span class="main">⊆</span> set <span class="main">[]</span> <span class="main">∪</span> <span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>set <span class="main">[]</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Concrete Atoms Types›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Class <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>at_base›</span></span></span></span> allows types containing multiple sorts of atoms.
  Class <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>at›</span></span></span></span> only allows types with a single sort.
›</span></span>

<span class="keyword1"><span class="command">class</span></span> at_base <span class="main">=</span> pt <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free"><span class="free"><span class="free">atom</span></span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> atom"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> atom_eq_iff <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">atom</span> <span class="free">a</span> <span class="main">=</span> <span class="free">atom</span> <span class="free">b</span> <span class="main">⟷</span> <span class="free">a</span> <span class="main">=</span> <span class="free">b</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> atom_eqvt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">atom</span> <span class="free">a</span><span class="main">)</span> <span class="main">=</span> <span class="free">atom</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">a</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">declare</span></span> atom_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span>

<span class="keyword1"><span class="command">class</span></span> at <span class="main">=</span> at_base <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> sort_of_atom_eq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sort_of <span class="main">(</span>atom <span class="free">a</span><span class="main">)</span> <span class="main">=</span> sort_of <span class="main">(</span>atom <span class="free">b</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Nominal2_Base-sort_ineq"><span class="command">lemma</span></span> sort_ineq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"sort_of <span class="main">(</span>atom <span class="free">a</span><span class="main">)</span> <span class="main">≠</span> sort_of <span class="main">(</span>atom <span class="free">b</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"atom <span class="free">a</span> <span class="main">≠</span> atom <span class="free">b</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>

<span class="keyword1" id="Nominal2_Base-supp_at_base"><span class="command">lemma</span></span> supp_at_base<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">a</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>at_base"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="free">a</span> <span class="main">=</span> <span class="main">{</span>atom <span class="free">a</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_atom <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> supp_def atom_eqvt<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fresh_at_base"><span class="command">lemma</span></span> fresh_at_base<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span>  <span class="quoted"><span class="quoted">"sort_of <span class="free">a</span> <span class="main">≠</span> sort_of <span class="main">(</span>atom <span class="free">b</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">b</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="free">b</span> <span class="main">⟷</span> <span class="free">a</span> <span class="main">≠</span> atom <span class="free">b</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fresh_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_at_base<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">metis</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="comment1">(* solves the freshness only if the inequality can be shown by the
   simproc below *)</span>
<span class="keyword1" id="Nominal2_Base-fresh_ineq_at_base"><span class="command">lemma</span></span> fresh_ineq_at_base <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">≠</span> atom <span class="free">b</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">b</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_at_base<span class="main">)</span>


<span class="keyword1" id="Nominal2_Base-fresh_atom_at_base"><span class="command">lemma</span></span> fresh_atom_at_base <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">b</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>at_base"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> atom <span class="free">b</span> <span class="main">⟷</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">b</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_def supp_at_base supp_atom<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fresh_star_atom_at_base"><span class="command">lemma</span></span> fresh_star_atom_at_base<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">b</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>at_base"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">as</span> <span class="main">♯*</span> atom <span class="free">b</span> <span class="main">⟷</span> <span class="free">as</span> <span class="main">♯*</span> <span class="free">b</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_star_def fresh_atom_at_base<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-if_fresh_at_base"><span class="command">lemma</span></span> if_fresh_at_base <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"atom <span class="free">a</span> <span class="main">♯</span> <span class="free">x</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">a</span> <span class="main">=</span> <span class="free">x</span> <span class="keyword1">then</span> <span class="free">t</span> <span class="keyword1">else</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> <span class="free">P</span> <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"atom <span class="free">a</span> <span class="main">♯</span> <span class="free">x</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span> <span class="main">=</span> <span class="free">a</span> <span class="keyword1">then</span> <span class="free">t</span> <span class="keyword1">else</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> <span class="free">P</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_at_base<span class="main">)</span>


<span class="keyword1"><span class="command">simproc_setup</span></span> fresh_ineq <span class="main">(</span><span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≠</span> <span class="main">(</span><span class="free">y</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>at_base<span class="main">)</span>"</span></span><span class="main">)</span> <span class="main">=</span> <span class="quoted">‹<span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctrm</span> <span class="main">=&gt;</span>
  <span class="keyword2"><span class="keyword">case</span></span> Thm.term_of <span class="entity">ctrm</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"HOL.Not"</span><span class="antiquote">}</span></span> $ <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> HOL.eq<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="entity">lhs</span> $ <span class="entity">rhs</span><span class="main">)</span> <span class="main">=&gt;</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">first_is_neg</span> <span class="entity">lhs</span> <span class="entity">rhs</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> NONE
        <span class="main">|</span> <span class="entity">first_is_neg</span> <span class="entity">lhs</span> <span class="entity">rhs</span> <span class="main">(</span><span class="entity">thm</span>::<span class="entity">thms</span><span class="main">)</span> <span class="main">=</span>
          <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> Thm.prop_of <span class="entity">thm</span> <span class="keyword2"><span class="keyword">of</span></span>
             <span class="main">_</span> $ <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"HOL.Not"</span><span class="antiquote">}</span></span> $ <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> HOL.eq<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="entity">l</span> $ <span class="entity">r</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span>
               <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">l</span> <span class="main">=</span> <span class="entity">lhs</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">r</span> <span class="main">=</span> <span class="entity">rhs</span> <span class="keyword2"><span class="keyword">then</span></span> SOME<span class="main">(</span><span class="entity">thm</span><span class="main">)</span>
                <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">r</span> <span class="main">=</span> <span class="entity">lhs</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">l</span> <span class="main">=</span> <span class="entity">rhs</span> <span class="keyword2"><span class="keyword">then</span></span> SOME<span class="main">(</span><span class="entity">thm</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> not_sym<span class="antiquote">}</span></span></span><span class="main">)</span>
                <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">first_is_neg</span> <span class="entity">lhs</span> <span class="entity">rhs</span> <span class="entity">thms</span><span class="main">)</span>
        <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">first_is_neg</span> <span class="entity">lhs</span> <span class="entity">rhs</span> <span class="entity">thms</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simp_thms</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> fresh_Pair fresh_at_base atom_eq_iff<span class="antiquote">}</span></span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prems</span> <span class="main">=</span> <span class="entity">Simplifier.prems_of</span> <span class="entity">ctxt</span>
         |&gt; filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">thm</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">case</span></span> Thm.prop_of <span class="entity">thm</span> <span class="keyword2"><span class="keyword">of</span></span>
            <span class="main">_</span> $ <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> fresh<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">ty</span><span class="main">)</span> $ <span class="main">(</span><span class="main">_</span> $ <span class="entity">a</span><span class="main">)</span> $ <span class="entity">b</span><span class="main">)</span> <span class="main">=&gt;</span>
            <span class="main">(</span><span class="keyword2"><span class="keyword">let</span></span>
               <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">atms</span> <span class="main">=</span> <span class="entity">a</span> :: <span class="entity">HOLogic.strip_tuple</span> <span class="entity">b</span>
             <span class="keyword2"><span class="keyword">in</span></span>
               member <span class="main">(</span><span class="main">(</span><span class="main">=</span><span class="main">)</span><span class="main">)</span> <span class="entity">atms</span> <span class="entity">lhs</span> <span class="keyword1"><span class="keyword">andalso</span></span> member <span class="main">(</span><span class="main">(</span><span class="main">=</span><span class="main">)</span><span class="main">)</span> <span class="entity">atms</span> <span class="entity">rhs</span>
             <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>
            <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false<span class="main">)</span>
         |&gt; map <span class="main">(</span><span class="entity">simplify</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span> addsimps <span class="entity">simp_thms</span><span class="main">)</span><span class="main">)</span>
         |&gt; map <span class="main">(</span><span class="entity">HOLogic.conj_elims</span> <span class="entity">ctxt</span><span class="main">)</span>
         |&gt; flat
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">first_is_neg</span> <span class="entity">lhs</span> <span class="entity">rhs</span> <span class="entity">prems</span> <span class="keyword2"><span class="keyword">of</span></span>
        SOME<span class="main">(</span><span class="entity">thm</span><span class="main">)</span> <span class="main">=&gt;</span> SOME<span class="main">(</span><span class="entity">thm</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Eq_TrueI<span class="antiquote">}</span></span></span><span class="main">)</span>
      <span class="main">|</span> NONE <span class="main">=&gt;</span> NONE
    <span class="keyword2"><span class="keyword">end</span></span>
  <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> NONE
›</span>


<span class="keyword1"><span class="command">instance</span></span> at_base <span class="main">&lt;</span> fs
<span class="keyword1"><span class="command">proof</span></span> <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_at_base<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-at_base_infinite"><span class="command">lemma</span></span> at_base_infinite <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"infinite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span><span class="main">::</span>at_base set<span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"infinite <span class="var">?U</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a</span></span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"True"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"finite <span class="var">?U</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>atom <span class="main">`</span> <span class="var">?U</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> finite_imageI<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">b</span></span> <span class="keyword2"><span class="keyword">where</span></span> b<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∉</span> atom <span class="main">`</span> <span class="var">?U</span>"</span></span> <span class="quoted"><span class="quoted">"sort_of <span class="skolem">b</span> <span class="main">=</span> sort_of <span class="main">(</span>atom <span class="skolem">a</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> obtain_atom<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> b<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">=</span> atom <span class="main">(</span><span class="main">(</span>atom <span class="skolem">a</span> <span class="main">⇌</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∙</span> <span class="skolem">a</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> atom_eqvt <span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> swap_atom<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> atom <span class="main">`</span> <span class="var">?U</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">with</span></span> b<span class="main">(</span>1<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"False"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Base-swap_at_base_simps"><span class="command">lemma</span></span> swap_at_base_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="free">y</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>at_base"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sort_of <span class="main">(</span>atom <span class="free">x</span><span class="main">)</span> <span class="main">=</span> sort_of <span class="main">(</span>atom <span class="free">y</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span>atom <span class="free">x</span> <span class="main">⇌</span> atom <span class="free">y</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"sort_of <span class="main">(</span>atom <span class="free">x</span><span class="main">)</span> <span class="main">=</span> sort_of <span class="main">(</span>atom <span class="free">y</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span>atom <span class="free">x</span> <span class="main">⇌</span> atom <span class="free">y</span><span class="main">)</span> <span class="main">∙</span> <span class="free">y</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"atom <span class="free">x</span> <span class="main">≠</span> <span class="free">a</span> <span class="main">⟹</span> atom <span class="free">x</span> <span class="main">≠</span> <span class="free">b</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> atom_eq_iff <span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
  <span class="keyword1"><span class="command">unfolding</span></span> atom_eqvt <span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Nominal2_Base-obtain_at_base"><span class="command">lemma</span></span> obtain_at_base<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> X<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">a</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>at_base"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"atom <span class="free">a</span> <span class="main">∉</span> <span class="free">X</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"inj <span class="main">(</span>atom <span class="main">::</span> <span class="tfree">'a</span> <span class="main">⇒</span> atom<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inj_on_def<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> X <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>atom <span class="main">-`</span> <span class="free">X</span> <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> finite_vimageI<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> at_base_infinite <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"atom <span class="main">-`</span> <span class="free">X</span> <span class="main">≠</span> <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a</span></span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"atom <span class="skolem">a</span> <span class="main">∉</span> <span class="free">X</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Base-obtain_fresh'"><span class="command">lemma</span></span> obtain_fresh'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> fin<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>supp <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">a</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>at_base"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"atom <span class="free">a</span> <span class="main">♯</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> obtain_at_base<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> X<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"supp <span class="free">x</span>"</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fresh_def fin<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-obtain_fresh"><span class="command">lemma</span></span> obtain_fresh<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'b</span><span class="main">::</span>fs"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">a</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>at_base"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"atom <span class="free">a</span> <span class="main">♯</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> obtain_fresh'<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> finite_supp<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-supp_finite_set_at_base"><span class="command">lemma</span></span> supp_finite_set_at_base<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="free">S</span> <span class="main">=</span> atom <span class="main">`</span> <span class="free">S</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_of_finite_sets<span class="main"><span class="main">[</span></span><span class="operator">OF</span> a<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_at_base<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="comment1">(* FIXME
lemma supp_cofinite_set_at_base:
  assumes a: "finite (UNIV - S)"
  shows "supp S = atom ` (UNIV - S)"
apply(rule finite_supp_unique)
*)</span>

<span class="keyword1" id="Nominal2_Base-fresh_finite_set_at_base"><span class="command">lemma</span></span> fresh_finite_set_at_base<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">a</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>at_base"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"atom <span class="free">a</span> <span class="main">♯</span> <span class="free">S</span> <span class="main">⟷</span> <span class="free">a</span> <span class="main">∉</span> <span class="free">S</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fresh_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_finite_set_at_base<span class="main"><span class="main">[</span></span><span class="operator">OF</span> a<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> inj_image_mem_iff<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inj_on_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Nominal2_Base-fresh_at_base_permute_iff"><span class="command">lemma</span></span> fresh_at_base_permute_iff <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">a</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>at_base"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"atom <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">a</span><span class="main">)</span> <span class="main">♯</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">⟷</span> atom <span class="free">a</span> <span class="main">♯</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> atom_eqvt<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> fresh_permute_iff<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-fresh_at_base_permI"><span class="command">lemma</span></span> fresh_at_base_permI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"atom <span class="free">a</span> <span class="main">♯</span> <span class="free">p</span> <span class="main">⟹</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">a</span> <span class="main">=</span> <span class="free">a</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_def supp_perm<span class="main">)</span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Infrastructure for concrete atom types›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">flip</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>at_base <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> perm"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">'(</span>_ <span class="keyword1">↔</span> _<span class="keyword1">')</span>"</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">(</span></span><span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main"><span class="free">↔</span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main"><span class="free">)</span></span> <span class="main">=</span> <span class="main">(</span>atom <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">⇌</span> atom <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Nominal2_Base-flip_fresh_fresh"><span class="command">lemma</span></span> flip_fresh_fresh<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"atom <span class="free">a</span> <span class="main">♯</span> <span class="free">x</span>"</span></span> <span class="quoted"><span class="quoted">"atom <span class="free">b</span> <span class="main">♯</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> flip_def swap_fresh_fresh<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-flip_self"><span class="command">lemma</span></span> flip_self <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">a</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> flip_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> swap_self<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-flip_commute"><span class="command">lemma</span></span> flip_commute<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">b</span> <span class="main">↔</span> <span class="free">a</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> flip_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> swap_commute<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-minus_flip"><span class="command">lemma</span></span> minus_flip <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">-</span> <span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> flip_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> minus_swap<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-add_flip_cancel"><span class="command">lemma</span></span> add_flip_cancel<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> flip_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> swap_cancel<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-permute_flip_cancel"><span class="command">lemma</span></span> permute_flip_cancel <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> permute_plus <span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> add_flip_cancel <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Nominal2_Base-permute_flip_cancel2"><span class="command">lemma</span></span> permute_flip_cancel2 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="main">(</span><span class="free">b</span> <span class="main">↔</span> <span class="free">a</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> flip_commute<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-flip_eqvt"><span class="command">lemma</span></span> flip_eqvt <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">a</span> <span class="main">↔</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">b</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> flip_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> swap_eqvt atom_eqvt<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-flip_at_base_simps"><span class="command">lemma</span></span> flip_at_base_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sort_of <span class="main">(</span>atom <span class="free">a</span><span class="main">)</span> <span class="main">=</span> sort_of <span class="main">(</span>atom <span class="free">b</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">a</span> <span class="main">=</span> <span class="free">b</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"sort_of <span class="main">(</span>atom <span class="free">a</span><span class="main">)</span> <span class="main">=</span> sort_of <span class="main">(</span>atom <span class="free">b</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">b</span> <span class="main">=</span> <span class="free">a</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">a</span> <span class="main">≠</span> <span class="free">c</span><span class="main">;</span> <span class="free">b</span> <span class="main">≠</span> <span class="free">c</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">c</span> <span class="main">=</span> <span class="free">c</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"sort_of <span class="main">(</span>atom <span class="free">a</span><span class="main">)</span> <span class="main">≠</span> sort_of <span class="main">(</span>atom <span class="free">b</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> flip_def
  <span class="keyword1"><span class="command">unfolding</span></span> atom_eq_iff <span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
  <span class="keyword1"><span class="command">unfolding</span></span> atom_eqvt <span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹the following two lemmas do not hold for <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>at_base›</span></span></span></span>,
  only for single sort atoms from at›</span></span>

<span class="keyword1" id="Nominal2_Base-flip_triple"><span class="command">lemma</span></span> flip_triple<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">a</span> <span class="free">b</span> <span class="free">c</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>at"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">≠</span> <span class="free">b</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">≠</span> <span class="free">b</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">c</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="free">b</span> <span class="main">↔</span> <span class="free">c</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">c</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> flip_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> swap_triple<span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-permute_flip_at"><span class="command">lemma</span></span> permute_flip_at<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">a</span> <span class="free">b</span> <span class="free">c</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>at"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">c</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">c</span> <span class="main">=</span> <span class="free">a</span> <span class="keyword1">then</span> <span class="free">b</span> <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free">c</span> <span class="main">=</span> <span class="free">b</span> <span class="keyword1">then</span> <span class="free">a</span> <span class="keyword1">else</span> <span class="free">c</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> flip_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> atom_eq_iff <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> iffD1<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> atom_eqvt <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> swap_atom<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Nominal2_Base-flip_at_simps"><span class="command">lemma</span></span> flip_at_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">a</span> <span class="free">b</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>at"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">a</span> <span class="main">=</span> <span class="free">b</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">b</span> <span class="main">=</span> <span class="free">a</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> permute_flip_at <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Syntax for coercing at-elements to the atom-type›</span></span>

<span class="keyword1"><span class="command">syntax</span></span>
  <span class="quoted">"_atom_constrain"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"logic <span class="main">⇒</span> type <span class="main">⇒</span> logic"</span></span> <span class="main">(</span><span class="quoted">"_<span class="keyword1">:::</span>_"</span> <span class="main">[</span>4<span class="main">,</span> 0<span class="main">]</span> 3<span class="main">)</span>

<span class="keyword1"><span class="command">translations</span></span>
  <span class="quoted">"_atom_constrain <span class="free">a</span> <span class="free">t</span>"</span> <span class="main">=&gt;</span> <span class="quoted">"<span class="keyword1">CONST</span> atom <span class="main">(</span>_constrain <span class="free">a</span> <span class="free">t</span><span class="main">)</span>"</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹A lemma for proving instances of class <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>at›</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹Sign.add_const_constraint <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "permute"<span class="antiquote">}</span></span><span class="main">,</span> NONE<span class="main">)</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹Sign.add_const_constraint <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "atom"<span class="antiquote">}</span></span><span class="main">,</span> NONE<span class="main">)</span>›</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  New atom types are defined as subtypes of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">atom</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>

<span class="keyword1" id="Nominal2_Base-exists_eq_simple_sort"><span class="command">lemma</span></span> exists_eq_simple_sort<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">a</span><span class="main">.</span> <span class="bound">a</span> <span class="main">∈</span> <span class="main">{</span><span class="bound">a</span><span class="main">.</span> sort_of <span class="bound">a</span> <span class="main">=</span> <span class="free">s</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"Atom <span class="free">s</span> <span class="main">0</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-exists_eq_sort"><span class="command">lemma</span></span> exists_eq_sort<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">a</span><span class="main">.</span> <span class="bound">a</span> <span class="main">∈</span> <span class="main">{</span><span class="bound">a</span><span class="main">.</span> sort_of <span class="bound">a</span> <span class="main">∈</span> range <span class="free">sort_fun</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"Atom <span class="main">(</span><span class="free">sort_fun</span> <span class="free">x</span><span class="main">)</span> <span class="free">y</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-at_base_class"><span class="command">lemma</span></span> at_base_class<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">sort_fun</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">⇒</span> atom_sort"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">Rep</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> atom"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">Abs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"atom <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> type<span class="main">:</span> <span class="quoted"><span class="quoted">"type_definition <span class="free">Rep</span> <span class="free">Abs</span> <span class="main">{</span><span class="bound">a</span><span class="main">.</span> sort_of <span class="bound">a</span> <span class="main">∈</span> range <span class="free">sort_fun</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> atom_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">a</span><span class="main">.</span> atom <span class="bound">a</span> <span class="main">=</span> <span class="free">Rep</span> <span class="bound">a</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> permute_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">p</span> <span class="bound">a</span><span class="main">.</span> <span class="bound">p</span> <span class="main">∙</span> <span class="bound">a</span> <span class="main">=</span> <span class="free">Abs</span> <span class="main">(</span><span class="bound">p</span> <span class="main">∙</span> <span class="free">Rep</span> <span class="bound">a</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">OFCLASS</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> at_base_class<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword1"><span class="command">interpret</span></span> type_definition <span class="quoted"><span class="free">Rep</span></span> <span class="quoted"><span class="free">Abs</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">a</span><span class="main">.</span> sort_of <span class="bound">a</span> <span class="main">∈</span> range <span class="free">sort_fun</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> type<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> sort_of_Rep<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">a</span><span class="main">.</span> sort_of <span class="main">(</span><span class="free">Rep</span> <span class="bound">a</span><span class="main">)</span> <span class="main">∈</span> range <span class="free">sort_fun</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Rep <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">p</span> <span class="skolem">p1</span> <span class="skolem">p2</span> <span class="main">::</span> <span class="quoted">perm</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">∙</span> <span class="skolem">a</span> <span class="main">=</span> <span class="skolem">a</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> permute_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Rep_inverse<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">p1</span> <span class="main">+</span> <span class="skolem">p2</span><span class="main">)</span> <span class="main">∙</span> <span class="skolem">a</span> <span class="main">=</span> <span class="skolem">p1</span> <span class="main">∙</span> <span class="skolem">p2</span> <span class="main">∙</span> <span class="skolem">a</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> permute_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_inverse sort_of_Rep<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"atom <span class="skolem">a</span> <span class="main">=</span> atom <span class="skolem">b</span> <span class="main">⟷</span> <span class="skolem">a</span> <span class="main">=</span> <span class="skolem">b</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> atom_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Rep_inject<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">∙</span> atom <span class="skolem">a</span> <span class="main">=</span> atom <span class="main">(</span><span class="skolem">p</span> <span class="main">∙</span> <span class="skolem">a</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> permute_def atom_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_inverse sort_of_Rep<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="comment1">(*
lemma at_class:
  fixes s :: atom_sort
  fixes Rep :: "'a ⇒ atom" and Abs :: "atom ⇒ 'a"
  assumes type: "type_definition Rep Abs {a. sort_of a ∈ range (λx::unit. s)}"
  assumes atom_def: "⋀a. atom a = Rep a"
  assumes permute_def: "⋀p a. p ∙ a = Abs (p ∙ Rep a)"
  shows "OFCLASS('a, at_class)"
proof
  interpret type_definition Rep Abs "{a. sort_of a ∈ range (λx::unit. s)}" by (rule type)
  have sort_of_Rep: "⋀a. sort_of (Rep a) = s" using Rep by (simp add: image_def)
  fix a b :: 'a and p p1 p2 :: perm
  show "0 ∙ a = a"
    unfolding permute_def by (simp add: Rep_inverse)
  show "(p1 + p2) ∙ a = p1 ∙ p2 ∙ a"
    unfolding permute_def by (simp add: Abs_inverse sort_of_Rep)
  show "sort_of (atom a) = sort_of (atom b)"
    unfolding atom_def by (simp add: sort_of_Rep)
  show "atom a = atom b ⟷ a = b"
    unfolding atom_def by (simp add: Rep_inject)
  show "p ∙ atom a = atom (p ∙ a)"
    unfolding permute_def atom_def by (simp add: Abs_inverse sort_of_Rep)
qed
*)</span>

<span class="keyword1" id="Nominal2_Base-at_class"><span class="command">lemma</span></span> at_class<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">s</span> <span class="main">::</span> <span class="quoted">atom_sort</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">Rep</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> atom"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">Abs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"atom <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> type<span class="main">:</span> <span class="quoted"><span class="quoted">"type_definition <span class="free">Rep</span> <span class="free">Abs</span> <span class="main">{</span><span class="bound">a</span><span class="main">.</span> sort_of <span class="bound">a</span> <span class="main">=</span> <span class="free">s</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> atom_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">a</span><span class="main">.</span> atom <span class="bound">a</span> <span class="main">=</span> <span class="free">Rep</span> <span class="bound">a</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> permute_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">p</span> <span class="bound">a</span><span class="main">.</span> <span class="bound">p</span> <span class="main">∙</span> <span class="bound">a</span> <span class="main">=</span> <span class="free">Abs</span> <span class="main">(</span><span class="bound">p</span> <span class="main">∙</span> <span class="free">Rep</span> <span class="bound">a</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">OFCLASS</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> at_class<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword1"><span class="command">interpret</span></span> type_definition <span class="quoted"><span class="free">Rep</span></span> <span class="quoted"><span class="free">Abs</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">a</span><span class="main">.</span> sort_of <span class="bound">a</span> <span class="main">=</span> <span class="free">s</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> type<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> sort_of_Rep<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">a</span><span class="main">.</span> sort_of <span class="main">(</span><span class="free">Rep</span> <span class="bound">a</span><span class="main">)</span> <span class="main">=</span> <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Rep <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> image_def<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">p</span> <span class="skolem">p1</span> <span class="skolem">p2</span> <span class="main">::</span> <span class="quoted">perm</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">∙</span> <span class="skolem">a</span> <span class="main">=</span> <span class="skolem">a</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> permute_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Rep_inverse<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">p1</span> <span class="main">+</span> <span class="skolem">p2</span><span class="main">)</span> <span class="main">∙</span> <span class="skolem">a</span> <span class="main">=</span> <span class="skolem">p1</span> <span class="main">∙</span> <span class="skolem">p2</span> <span class="main">∙</span> <span class="skolem">a</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> permute_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_inverse sort_of_Rep<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"sort_of <span class="main">(</span>atom <span class="skolem">a</span><span class="main">)</span> <span class="main">=</span> sort_of <span class="main">(</span>atom <span class="skolem">b</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> atom_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sort_of_Rep<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"atom <span class="skolem">a</span> <span class="main">=</span> atom <span class="skolem">b</span> <span class="main">⟷</span> <span class="skolem">a</span> <span class="main">=</span> <span class="skolem">b</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> atom_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Rep_inject<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">∙</span> atom <span class="skolem">a</span> <span class="main">=</span> atom <span class="main">(</span><span class="skolem">p</span> <span class="main">∙</span> <span class="skolem">a</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> permute_def atom_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_inverse sort_of_Rep<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Base-at_class_sort"><span class="command">lemma</span></span> at_class_sort<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">s</span> <span class="main">::</span> <span class="quoted">atom_sort</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">Rep</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> atom"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">Abs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"atom <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">a</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> type<span class="main">:</span> <span class="quoted"><span class="quoted">"type_definition <span class="free">Rep</span> <span class="free">Abs</span> <span class="main">{</span><span class="bound">a</span><span class="main">.</span> sort_of <span class="bound">a</span> <span class="main">=</span> <span class="free">s</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> atom_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">a</span><span class="main">.</span> atom <span class="bound">a</span> <span class="main">=</span> <span class="free">Rep</span> <span class="bound">a</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sort_of <span class="main">(</span>atom <span class="free">a</span><span class="main">)</span> <span class="main">=</span> <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> atom_def type
  <span class="keyword1"><span class="command">unfolding</span></span> type_definition_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>


<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹Sign.add_const_constraint
  <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "permute"<span class="antiquote">}</span></span><span class="main">,</span> SOME <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"perm <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">::</span>pt <span class="main">⇒</span> <span class="tfree">'a</span>"</span><span class="antiquote">}</span></span><span class="main">)</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹Sign.add_const_constraint
  <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "atom"<span class="antiquote">}</span></span><span class="main">,</span> SOME <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>at_base <span class="main">⇒</span> atom"</span><span class="antiquote">}</span></span><span class="main">)</span>›</span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Library functions for the nominal infrastructure›</span></span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹nominal_library.ML›</span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹The freshness lemma according to Andy Pitts›</span></span>

<span class="keyword1" id="Nominal2_Base-freshness_lemma"><span class="command">lemma</span></span> freshness_lemma<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">h</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>at <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>pt"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">a</span><span class="main">.</span> atom <span class="bound">a</span> <span class="main">♯</span> <span class="main">(</span><span class="free">h</span><span class="main">,</span> <span class="free">h</span> <span class="bound">a</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>  <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="main">∀</span><span class="bound">a</span><span class="main">.</span> atom <span class="bound">a</span> <span class="main">♯</span> <span class="free">h</span> <span class="main">⟶</span> <span class="free">h</span> <span class="bound">a</span> <span class="main">=</span> <span class="bound">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> a <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">b</span></span> <span class="keyword2"><span class="keyword">where</span></span> a1<span class="main">:</span> <span class="quoted"><span class="quoted">"atom <span class="skolem">b</span> <span class="main">♯</span> <span class="free">h</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> a2<span class="main">:</span> <span class="quoted"><span class="quoted">"atom <span class="skolem">b</span> <span class="main">♯</span> <span class="free">h</span> <span class="skolem">b</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fresh_Pair<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="main">∀</span><span class="bound">a</span><span class="main">.</span> atom <span class="bound">a</span> <span class="main">♯</span> <span class="free">h</span> <span class="main">⟶</span> <span class="free">h</span> <span class="bound">a</span> <span class="main">=</span> <span class="bound">x</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> exI allI impI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span>
    <span class="keyword3"><span class="command">assume</span></span> a3<span class="main">:</span> <span class="quoted"><span class="quoted">"atom <span class="skolem">a</span> <span class="main">♯</span> <span class="free">h</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="skolem">a</span> <span class="main">=</span> <span class="free">h</span> <span class="skolem">b</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">=</span> <span class="skolem">b</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">=</span> <span class="skolem">b</span>"</span></span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="skolem">a</span> <span class="main">=</span> <span class="free">h</span> <span class="skolem">b</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">≠</span> <span class="skolem">b</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"atom <span class="skolem">a</span> <span class="main">♯</span> <span class="skolem">b</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_at_base<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> a3 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"atom <span class="skolem">a</span> <span class="main">♯</span> <span class="free">h</span> <span class="skolem">b</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> fresh_fun_app<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> a2 <span class="keyword1"><span class="command">have</span></span> d1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>atom <span class="skolem">b</span> <span class="main">⇌</span> atom <span class="skolem">a</span><span class="main">)</span> <span class="main">∙</span> <span class="main">(</span><span class="free">h</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">h</span> <span class="skolem">b</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> swap_fresh_fresh<span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> a1 a3 <span class="keyword1"><span class="command">have</span></span> d2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>atom <span class="skolem">b</span> <span class="main">⇌</span> atom <span class="skolem">a</span><span class="main">)</span> <span class="main">∙</span> <span class="free">h</span> <span class="main">=</span> <span class="free">h</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> swap_fresh_fresh<span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> d1 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="skolem">b</span> <span class="main">=</span> <span class="main">(</span>atom <span class="skolem">b</span> <span class="main">⇌</span> atom <span class="skolem">a</span><span class="main">)</span> <span class="main">∙</span> <span class="main">(</span><span class="free">h</span> <span class="skolem">b</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span>atom <span class="skolem">b</span> <span class="main">⇌</span> atom <span class="skolem">a</span><span class="main">)</span> <span class="main">∙</span> <span class="free">h</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span>atom <span class="skolem">b</span> <span class="main">⇌</span> atom <span class="skolem">a</span><span class="main">)</span> <span class="main">∙</span> <span class="skolem">b</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> permute_fun_app_eq<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="free">h</span> <span class="skolem">a</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> d2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="skolem">a</span> <span class="main">=</span> <span class="free">h</span> <span class="skolem">b</span>"</span></span>  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Base-freshness_lemma_unique"><span class="command">lemma</span></span> freshness_lemma_unique<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">h</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>at <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>pt"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">a</span><span class="main">.</span> atom <span class="bound">a</span> <span class="main">♯</span> <span class="main">(</span><span class="free">h</span><span class="main">,</span> <span class="free">h</span> <span class="bound">a</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃!</span><span class="bound">x</span><span class="main">.</span> <span class="main">∀</span><span class="bound">a</span><span class="main">.</span> atom <span class="bound">a</span> <span class="main">♯</span> <span class="free">h</span> <span class="main">⟶</span> <span class="free">h</span> <span class="bound">a</span> <span class="main">=</span> <span class="bound">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ex_ex1I<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> a <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="main">∀</span><span class="bound">a</span><span class="main">.</span> atom <span class="bound">a</span> <span class="main">♯</span> <span class="free">h</span> <span class="main">⟶</span> <span class="free">h</span> <span class="bound">a</span> <span class="main">=</span> <span class="bound">x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> freshness_lemma<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span>
  <span class="keyword3"><span class="command">assume</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">a</span><span class="main">.</span> atom <span class="bound">a</span> <span class="main">♯</span> <span class="free">h</span> <span class="main">⟶</span> <span class="free">h</span> <span class="bound">a</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> y<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">a</span><span class="main">.</span> atom <span class="bound">a</span> <span class="main">♯</span> <span class="free">h</span> <span class="main">⟶</span> <span class="free">h</span> <span class="bound">a</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> a x y <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fresh_Pair<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹packaging the freshness lemma into a function›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">Fresh</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>at <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>pt<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Fresh</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">THE</span> <span class="bound">x</span><span class="main">.</span> <span class="main">∀</span><span class="bound">a</span><span class="main">.</span> atom <span class="bound">a</span> <span class="main">♯</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="bound">a</span> <span class="main">=</span> <span class="bound">x</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Nominal2_Base-Fresh_apply"><span class="command">lemma</span></span> Fresh_apply<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">h</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>at <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>pt"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">a</span><span class="main">.</span> atom <span class="bound">a</span> <span class="main">♯</span> <span class="main">(</span><span class="free">h</span><span class="main">,</span> <span class="free">h</span> <span class="bound">a</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> b<span class="main">:</span> <span class="quoted"><span class="quoted">"atom <span class="free">a</span> <span class="main">♯</span> <span class="free">h</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Fresh <span class="free">h</span> <span class="main">=</span> <span class="free">h</span> <span class="free">a</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Fresh_def
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> the_equality<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">a'</span><span class="main">.</span> atom <span class="bound">a'</span> <span class="main">♯</span> <span class="free">h</span> <span class="main">⟶</span> <span class="free">h</span> <span class="bound">a'</span> <span class="main">=</span> <span class="free">h</span> <span class="free">a</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> strip<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a'</span><span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span>
    <span class="keyword3"><span class="command">assume</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"atom <span class="skolem">a'</span> <span class="main">♯</span> <span class="free">h</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> a <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="main">∀</span><span class="bound">a</span><span class="main">.</span> atom <span class="bound">a</span> <span class="main">♯</span> <span class="free">h</span> <span class="main">⟶</span> <span class="free">h</span> <span class="bound">a</span> <span class="main">=</span> <span class="bound">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> freshness_lemma<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> b c <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="skolem">a'</span> <span class="main">=</span> <span class="free">h</span> <span class="free">a</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">fr</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'b</span></span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">a</span><span class="main">.</span> atom <span class="bound">a</span> <span class="main">♯</span> <span class="free">h</span> <span class="main">⟶</span> <span class="free">h</span> <span class="bound">a</span> <span class="main">=</span> <span class="skolem">fr</span>"</span></span>
  <span class="keyword1"><span class="command">with</span></span> b <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">fr</span> <span class="main">=</span> <span class="free">h</span> <span class="free">a</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Base-Fresh_apply'"><span class="command">lemma</span></span> Fresh_apply'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">h</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>at <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>pt"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"atom <span class="free">a</span> <span class="main">♯</span> <span class="free">h</span>"</span></span> <span class="quoted"><span class="quoted">"atom <span class="free">a</span> <span class="main">♯</span> <span class="free">h</span> <span class="free">a</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Fresh <span class="free">h</span> <span class="main">=</span> <span class="free">h</span> <span class="free">a</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> Fresh_apply<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fresh_Pair <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> a<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">simproc_setup</span></span> Fresh_simproc <span class="main">(</span><span class="quoted"><span class="quoted">"Fresh <span class="main">(</span><span class="free">h</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>at <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>pt<span class="main">)</span>"</span></span><span class="main">)</span> <span class="main">=</span> <span class="quoted">‹<span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctrm</span> <span class="main">=&gt;</span>
  <span class="keyword2"><span class="keyword">let</span></span>
     <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> $ <span class="entity">h</span> <span class="main">=</span> Thm.term_of <span class="entity">ctrm</span>

     <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cfresh</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> fresh<span class="antiquote">}</span></span>
     <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">catom</span>  <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> atom<span class="antiquote">}</span></span>

     <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">atoms</span> <span class="main">=</span> <span class="entity">Simplifier.prems_of</span> <span class="entity">ctxt</span>
      |&gt; map_filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">thm</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">case</span></span> Thm.prop_of <span class="entity">thm</span> <span class="keyword2"><span class="keyword">of</span></span>
           <span class="main">_</span> $ <span class="main">(</span>Const <span class="main">(</span><span class="entity">cfresh</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">(</span>Const <span class="main">(</span><span class="entity">catom</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="entity">atm</span><span class="main">)</span> $ <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> SOME <span class="main">(</span><span class="entity">atm</span><span class="main">)</span> <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> NONE<span class="main">)</span>
      |&gt; distinct <span class="main">(</span><span class="main">(</span><span class="main">=</span><span class="main">)</span><span class="main">)</span>

     <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_thm</span> <span class="entity">atm</span> <span class="main">=</span>
       <span class="keyword2"><span class="keyword">let</span></span>
         <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goal1</span> <span class="main">=</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">mk_fresh</span> <span class="main">(</span><span class="entity">mk_atom</span> <span class="entity">atm</span><span class="main">)</span> <span class="entity">h</span><span class="main">)</span>
         <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goal2</span> <span class="main">=</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">mk_fresh</span> <span class="main">(</span><span class="entity">mk_atom</span> <span class="entity">atm</span><span class="main">)</span> <span class="main">(</span><span class="entity">h</span> $ <span class="entity">atm</span><span class="main">)</span><span class="main">)</span>

         <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm1</span> <span class="main">=</span> Goal.prove <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">goal1</span> <span class="main">(</span>K <span class="main">(</span><span class="entity">asm_simp_tac</span> <span class="entity">ctxt</span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span>
         <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm2</span> <span class="main">=</span> Goal.prove <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">goal2</span> <span class="main">(</span>K <span class="main">(</span><span class="entity">asm_simp_tac</span> <span class="entity">ctxt</span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span>
       <span class="keyword2"><span class="keyword">in</span></span>
         SOME <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Fresh_apply'<span class="antiquote">}</span></span></span> OF <span class="main">[</span><span class="entity">thm1</span><span class="main">,</span> <span class="entity">thm2</span><span class="main">]</span> RS <span class="entity">eq_reflection</span><span class="main">)</span>
       <span class="keyword2"><span class="keyword">end</span></span> <span class="keyword3"><span class="keyword">handle</span></span> ERROR <span class="main">_</span> <span class="main">=&gt;</span> NONE
  <span class="keyword2"><span class="keyword">in</span></span>
    get_first <span class="entity">get_thm</span> <span class="entity">atoms</span>
  <span class="keyword2"><span class="keyword">end</span></span>
›</span>


<span class="keyword1" id="Nominal2_Base-Fresh_eqvt"><span class="command">lemma</span></span> Fresh_eqvt<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">h</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>at <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>pt"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">a</span><span class="main">.</span> atom <span class="bound">a</span> <span class="main">♯</span> <span class="main">(</span><span class="free">h</span><span class="main">,</span> <span class="free">h</span> <span class="bound">a</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>Fresh <span class="free">h</span><span class="main">)</span> <span class="main">=</span> Fresh <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">h</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> a <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a</span></span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>at"</span></span> <span class="keyword2"><span class="keyword">where</span></span> fr<span class="main">:</span> <span class="quoted"><span class="quoted">"atom <span class="skolem">a</span> <span class="main">♯</span> <span class="free">h</span>"</span></span> <span class="quoted"><span class="quoted">"atom <span class="skolem">a</span> <span class="main">♯</span> <span class="free">h</span> <span class="skolem">a</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> fresh_Pair<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> fr_p<span class="main">:</span> <span class="quoted"><span class="quoted">"atom <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">♯</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">h</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"atom <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">♯</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">h</span><span class="main">)</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="skolem">a</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> atom_eqvt fresh_permute_iff eqvt_apply<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>Fresh <span class="free">h</span><span class="main">)</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">h</span> <span class="skolem">a</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fr <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">h</span><span class="main">)</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="skolem">a</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> Fresh <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">h</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fr_p <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>Fresh <span class="free">h</span><span class="main">)</span> <span class="main">=</span> Fresh <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">h</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Base-Fresh_supports"><span class="command">lemma</span></span> Fresh_supports<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">h</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>at <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>pt"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">a</span><span class="main">.</span> atom <span class="bound">a</span> <span class="main">♯</span> <span class="main">(</span><span class="free">h</span><span class="main">,</span> <span class="free">h</span> <span class="bound">a</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>supp <span class="free">h</span><span class="main">)</span> <span class="keyword1">supports</span> <span class="main">(</span>Fresh <span class="free">h</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supports_def fresh_def <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Fresh_eqvt <span class="main"><span class="main">[</span></span><span class="operator">OF</span> a<span class="main"><span class="main">]</span></span> swap_fresh_fresh<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">notation</span></span> Fresh <span class="main">(</span><span class="keyword2"><span class="keyword">binder</span></span> <span class="quoted">"<span class="keyword1">FRESH</span> "</span> 10<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-FRESH_f_iff"><span class="command">lemma</span></span> FRESH_f_iff<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">P</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>at <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>pure"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">::</span>pure"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> P<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>supp <span class="free">P</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">FRESH</span> <span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="free">P</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span><span class="keyword1">FRESH</span> <span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a</span></span><span class="main">::</span><span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"atom <span class="skolem">a</span> <span class="main">♯</span> <span class="free">P</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> P <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> obtain_fresh'<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">FRESH</span> <span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="free">P</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span><span class="keyword1">FRESH</span> <span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pure_fresh<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Base-FRESH_binop_iff"><span class="command">lemma</span></span> FRESH_binop_iff<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">P</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>at <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>pure"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">Q</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>at <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">::</span>pure"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">binop</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'c</span> <span class="main">⇒</span> <span class="tfree">'d</span><span class="main">::</span>pure"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> P<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>supp <span class="free">P</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>     Q<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>supp <span class="free">Q</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">FRESH</span> <span class="bound">x</span><span class="main">.</span> <span class="free">binop</span> <span class="main">(</span><span class="free">P</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">Q</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">binop</span> <span class="main">(</span><span class="keyword1">FRESH</span> <span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="keyword1">FRESH</span> <span class="bound">x</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>supp <span class="main">(</span><span class="free">P</span><span class="main">,</span> <span class="free">Q</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_Pair<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a</span></span><span class="main">::</span><span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"atom <span class="skolem">a</span> <span class="main">♯</span> <span class="main">(</span><span class="free">P</span><span class="main">,</span> <span class="free">Q</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> obtain_fresh'<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pure_fresh<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Base-FRESH_conj_iff"><span class="command">lemma</span></span> FRESH_conj_iff<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">P</span> <span class="free">Q</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>at <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> P<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>supp <span class="free">P</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> Q<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>supp <span class="free">Q</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">FRESH</span> <span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="main">∧</span> <span class="free">Q</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="keyword1">FRESH</span> <span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="keyword1">FRESH</span> <span class="bound">x</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> P Q <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> FRESH_binop_iff<span class="main">)</span>

<span class="keyword1" id="Nominal2_Base-FRESH_disj_iff"><span class="command">lemma</span></span> FRESH_disj_iff<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">P</span> <span class="free">Q</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>at <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> P<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>supp <span class="free">P</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> Q<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>supp <span class="free">Q</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">FRESH</span> <span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="main">∨</span> <span class="free">Q</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="keyword1">FRESH</span> <span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span><span class="keyword1">FRESH</span> <span class="bound">x</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> P Q <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> FRESH_binop_iff<span class="main">)</span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Automation for creating concrete atom types›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹At the moment only single-sort concrete atoms are supported.›</span></span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹nominal_atoms.ML›</span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Automatic equivariance procedure for inductive definitions›</span></span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹nominal_eqvt.ML›</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/nominal_basics.ML">
<div class="head">
<h1>File ‹nominal_basics.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      nominal_basics.ML
    Author:     Christian Urban
    Author:     Tjark Weber

  Basic functions for nominal.
*)</span>

<span class="keyword1"><span class="keyword">infix</span></span> <span class="inner_numeral">1</span> ||&gt;&gt;&gt; |&gt;&gt;&gt;

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">NOMINAL_BASIC</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> trace<span class="main">:</span> bool Unsynchronized.ref
  <span class="keyword1"><span class="keyword">val</span></span> trace_msg<span class="main">:</span> <span class="main">(</span>unit <span class="main">-&gt;</span> string<span class="main">)</span> <span class="main">-&gt;</span> unit

  <span class="keyword1"><span class="keyword">val</span></span> |&gt;&gt;&gt; <span class="main">:</span> 'a * <span class="main">(</span>'a <span class="main">-&gt;</span> 'b * 'c<span class="main">)</span> <span class="main">-&gt;</span> 'b list * 'c
  <span class="keyword1"><span class="keyword">val</span></span> ||&gt;&gt;&gt; <span class="main">:</span> <span class="main">(</span>'a list * 'b<span class="main">)</span> * <span class="main">(</span>'b <span class="main">-&gt;</span> 'a * 'b<span class="main">)</span> <span class="main">-&gt;</span> 'a list * 'b

  <span class="keyword1"><span class="keyword">val</span></span> last2<span class="main">:</span> 'a list <span class="main">-&gt;</span> 'a * 'a
  <span class="keyword1"><span class="keyword">val</span></span> split_triples<span class="main">:</span> <span class="main">(</span>'a * 'b * 'c<span class="main">)</span> list <span class="main">-&gt;</span> <span class="main">(</span>'a list * 'b list * 'c list<span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> split_last2<span class="main">:</span> 'a list <span class="main">-&gt;</span> 'a list * 'a * 'a
  <span class="keyword1"><span class="keyword">val</span></span> order<span class="main">:</span> <span class="main">(</span>'a * 'a <span class="main">-&gt;</span> bool<span class="main">)</span> <span class="main">-&gt;</span> 'a list <span class="main">-&gt;</span> <span class="main">(</span>'a * 'b<span class="main">)</span> list <span class="main">-&gt;</span> 'b list
  <span class="keyword1"><span class="keyword">val</span></span> order_default<span class="main">:</span> <span class="main">(</span>'a * 'a <span class="main">-&gt;</span> bool<span class="main">)</span> <span class="main">-&gt;</span> 'b <span class="main">-&gt;</span> 'a list <span class="main">-&gt;</span> <span class="main">(</span>'a * 'b<span class="main">)</span> list <span class="main">-&gt;</span> 'b list
  <span class="keyword1"><span class="keyword">val</span></span> remove_dups<span class="main">:</span> <span class="main">(</span>'a * 'a <span class="main">-&gt;</span> bool<span class="main">)</span> <span class="main">-&gt;</span> 'a list <span class="main">-&gt;</span> 'a list
  <span class="keyword1"><span class="keyword">val</span></span> map4<span class="main">:</span> <span class="main">(</span>'a <span class="main">-&gt;</span> 'b <span class="main">-&gt;</span> 'c <span class="main">-&gt;</span> 'd <span class="main">-&gt;</span> 'e<span class="main">)</span> <span class="main">-&gt;</span> 'a list <span class="main">-&gt;</span> 'b list <span class="main">-&gt;</span> 'c list <span class="main">-&gt;</span> 'd list <span class="main">-&gt;</span> 'e list
  <span class="keyword1"><span class="keyword">val</span></span> split_filter<span class="main">:</span> <span class="main">(</span>'a <span class="main">-&gt;</span> bool<span class="main">)</span> <span class="main">-&gt;</span> 'a list <span class="main">-&gt;</span> 'a list * 'a list
  <span class="keyword1"><span class="keyword">val</span></span> fold_left<span class="main">:</span> <span class="main">(</span>'a * 'a <span class="main">-&gt;</span> 'a<span class="main">)</span> <span class="main">-&gt;</span> 'a list <span class="main">-&gt;</span> 'a <span class="main">-&gt;</span> 'a

  <span class="keyword1"><span class="keyword">val</span></span> is_true<span class="main">:</span> term <span class="main">-&gt;</span> bool

  <span class="keyword1"><span class="keyword">val</span></span> dest_listT<span class="main">:</span> typ <span class="main">-&gt;</span> typ
  <span class="keyword1"><span class="keyword">val</span></span> dest_fsetT<span class="main">:</span> typ <span class="main">-&gt;</span> typ

  <span class="keyword1"><span class="keyword">val</span></span> mk_id<span class="main">:</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> mk_all<span class="main">:</span> <span class="main">(</span>string * typ<span class="main">)</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> mk_All<span class="main">:</span> <span class="main">(</span>string * typ<span class="main">)</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> mk_exists<span class="main">:</span> <span class="main">(</span>string * typ<span class="main">)</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term

  <span class="keyword1"><span class="keyword">val</span></span> case_sum_const<span class="main">:</span> typ <span class="main">-&gt;</span> typ <span class="main">-&gt;</span> typ <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> mk_case_sum<span class="main">:</span> term <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term

  <span class="keyword1"><span class="keyword">val</span></span> mk_equiv<span class="main">:</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> safe_mk_equiv<span class="main">:</span> thm <span class="main">-&gt;</span> thm

  <span class="keyword1"><span class="keyword">val</span></span> mk_minus<span class="main">:</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> mk_plus<span class="main">:</span> term <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term

  <span class="keyword1"><span class="keyword">val</span></span> perm_ty<span class="main">:</span> typ <span class="main">-&gt;</span> typ
  <span class="keyword1"><span class="keyword">val</span></span> perm_const<span class="main">:</span> typ <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> mk_perm_ty<span class="main">:</span> typ <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> mk_perm<span class="main">:</span> term <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> dest_perm<span class="main">:</span> term <span class="main">-&gt;</span> term * term

  <span class="comment1">(* functions to deal with constants in local contexts *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> long_name<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string <span class="main">-&gt;</span> string
  <span class="keyword1"><span class="keyword">val</span></span> is_fixed<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> fixed_nonfixed_args<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term * term list
<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Nominal_Basic</span><span class="main">:</span> <span class="entity">NOMINAL_BASIC</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">trace</span> <span class="main">=</span> Unsynchronized.ref false
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">trace_msg</span> <span class="entity">msg</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> ! <span class="entity">trace</span> <span class="keyword2"><span class="keyword">then</span></span> tracing <span class="main">(</span><span class="entity">msg</span> <span class="main">(</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="main">)</span>


<span class="keyword1"><span class="keyword">infix</span></span> <span class="inner_numeral">1</span> ||&gt;&gt;&gt; |&gt;&gt;&gt;

<span class="keyword1"><span class="keyword">fun</span></span> <span class="main">(</span><span class="entity">x</span> <span class="entity">|&gt;&gt;&gt;</span> <span class="entity">f</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">x'</span><span class="main">,</span> <span class="entity">y'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">f</span> <span class="entity">x</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="main">[</span><span class="entity">x'</span><span class="main">]</span><span class="main">,</span> <span class="entity">y'</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="main">(</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span> <span class="entity">||&gt;&gt;&gt;</span> <span class="entity">f</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span>
  <span class="main">|</span> <span class="main">(</span><span class="main">(</span><span class="entity">xs</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span> <span class="entity">||&gt;&gt;&gt;</span> <span class="entity">f</span><span class="main">)</span> <span class="main">=</span>
       <span class="keyword2"><span class="keyword">let</span></span>
         <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">x'</span><span class="main">,</span> <span class="entity">y'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">f</span> <span class="entity">y</span>
       <span class="keyword2"><span class="keyword">in</span></span>
         <span class="main">(</span><span class="entity">xs</span> @ <span class="main">[</span><span class="entity">x'</span><span class="main">]</span><span class="main">,</span> <span class="entity">y'</span><span class="main">)</span>
       <span class="keyword2"><span class="keyword">end</span></span>


<span class="comment1">(* orders an AList according to keys - every key needs to be there *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">order</span> <span class="entity">eq</span> <span class="entity">keys</span> <span class="entity">list</span> <span class="main">=</span>
  map <span class="main">(</span>the o AList.lookup <span class="entity">eq</span> <span class="entity">list</span><span class="main">)</span> <span class="entity">keys</span>

<span class="comment1">(* orders an AList according to keys - returns default for non-existing keys *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">order_default</span> <span class="entity">eq</span> <span class="entity">default</span> <span class="entity">keys</span> <span class="entity">list</span> <span class="main">=</span>
  map <span class="main">(</span>the_default <span class="entity">default</span> o AList.lookup <span class="entity">eq</span> <span class="entity">list</span><span class="main">)</span> <span class="entity">keys</span>

<span class="comment1">(* remove duplicates *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">remove_dups</span> <span class="entity">eq</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="main">]</span>
  <span class="main">|</span> <span class="entity">remove_dups</span> <span class="entity">eq</span> <span class="main">(</span><span class="entity">x</span> :: <span class="entity">xs</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">if</span></span> member <span class="entity">eq</span> <span class="entity">xs</span> <span class="entity">x</span>
      <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">remove_dups</span> <span class="entity">eq</span> <span class="entity">xs</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">x</span> :: <span class="entity">remove_dups</span> <span class="entity">eq</span> <span class="entity">xs</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">split_triples</span> <span class="entity">xs</span> <span class="main">=</span>
  fold <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">b</span><span class="main">,</span> <span class="entity">c</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">axs</span><span class="main">,</span> <span class="entity">bxs</span><span class="main">,</span> <span class="entity">cxs</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">a</span> :: <span class="entity">axs</span><span class="main">,</span> <span class="entity">b</span> :: <span class="entity">bxs</span><span class="main">,</span> <span class="entity">c</span> :: <span class="entity">cxs</span><span class="main">)</span><span class="main">)</span> <span class="entity">xs</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">last2</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="keyword3"><span class="keyword">raise</span></span> Empty
  <span class="main">|</span> <span class="entity">last2</span> <span class="main">[</span><span class="main">_</span><span class="main">]</span> <span class="main">=</span> <span class="keyword3"><span class="keyword">raise</span></span> Empty
  <span class="main">|</span> <span class="entity">last2</span> <span class="main">[</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">]</span> <span class="main">=</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">last2</span> <span class="main">(</span><span class="main">_</span> :: <span class="entity">xs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">last2</span> <span class="entity">xs</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">split_last2</span> <span class="entity">xs</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">xs'</span><span class="main">,</span> <span class="entity">x</span><span class="main">)</span> <span class="main">=</span> split_last <span class="entity">xs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">xs''</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span> <span class="main">=</span> split_last <span class="entity">xs'</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="entity">xs''</span><span class="main">,</span> <span class="entity">y</span><span class="main">,</span> <span class="entity">x</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map4</span> <span class="main">_</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="main">]</span>
  <span class="main">|</span> <span class="entity">map4</span> <span class="entity">f</span> <span class="main">(</span><span class="entity">x</span> :: <span class="entity">xs</span><span class="main">)</span> <span class="main">(</span><span class="entity">y</span> :: <span class="entity">ys</span><span class="main">)</span> <span class="main">(</span><span class="entity">z</span> :: <span class="entity">zs</span><span class="main">)</span> <span class="main">(</span><span class="entity">u</span> :: <span class="entity">us</span><span class="main">)</span> <span class="main">=</span> <span class="entity">f</span> <span class="entity">x</span> <span class="entity">y</span> <span class="entity">z</span> <span class="entity">u</span> :: <span class="entity">map4</span> <span class="entity">f</span> <span class="entity">xs</span> <span class="entity">ys</span> <span class="entity">zs</span> <span class="entity">us</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">split_filter</span> <span class="entity">f</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">split_filter</span> <span class="entity">f</span> <span class="main">(</span><span class="entity">x</span> :: <span class="entity">xs</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">r</span><span class="main">,</span> <span class="entity">l</span><span class="main">)</span> <span class="main">=</span> <span class="entity">split_filter</span> <span class="entity">f</span> <span class="entity">xs</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">f</span> <span class="entity">x</span>
        <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="entity">x</span> :: <span class="entity">r</span><span class="main">,</span> <span class="entity">l</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="entity">r</span><span class="main">,</span> <span class="entity">x</span> :: <span class="entity">l</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* to be used with left-infix binop-operations *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">fold_left</span> <span class="entity">f</span> <span class="main">[</span><span class="main">]</span> <span class="entity">z</span> <span class="main">=</span> <span class="entity">z</span>
  <span class="main">|</span> <span class="entity">fold_left</span> <span class="entity">f</span> <span class="main">[</span><span class="entity">x</span><span class="main">]</span> <span class="entity">z</span> <span class="main">=</span> <span class="entity">x</span>
  <span class="main">|</span> <span class="entity">fold_left</span> <span class="entity">f</span> <span class="main">(</span><span class="entity">x</span> :: <span class="entity">y</span> :: <span class="entity">xs</span><span class="main">)</span> <span class="entity">z</span> <span class="main">=</span> <span class="entity">fold_left</span> <span class="entity">f</span> <span class="main">(</span><span class="entity">f</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span> :: <span class="entity">xs</span><span class="main">)</span> <span class="entity">z</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_true</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"Trueprop True"</span><span class="antiquote">}</span></span> <span class="main">=</span> true
  <span class="main">|</span> <span class="entity">is_true</span> <span class="main">_</span> <span class="main">=</span> false

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_listT</span> <span class="main">(</span>Type <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> list<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">[</span><span class="entity">T</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">T</span>
  <span class="main">|</span> <span class="entity">dest_listT</span> <span class="entity">T</span> <span class="main">=</span> <span class="keyword3"><span class="keyword">raise</span></span> TYPE <span class="main">(</span><span class="inner_quoted">"dest_listT: list type expected"</span><span class="main">,</span> <span class="main">[</span><span class="entity">T</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_fsetT</span> <span class="main">(</span>Type <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> fset<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">[</span><span class="entity">T</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">T</span>
  <span class="main">|</span> <span class="entity">dest_fsetT</span> <span class="entity">T</span> <span class="main">=</span> <span class="keyword3"><span class="keyword">raise</span></span> TYPE <span class="main">(</span><span class="inner_quoted">"dest_fsetT: fset type expected"</span><span class="main">,</span> <span class="main">[</span><span class="entity">T</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_id</span> <span class="entity">trm</span> <span class="main">=</span> <span class="entity">HOLogic.id_const</span> <span class="main">(</span>fastype_of <span class="entity">trm</span><span class="main">)</span> $ <span class="entity">trm</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_all</span> <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="entity">t</span> <span class="main">=</span>  Logic.all_const <span class="entity">T</span> $ Abs <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_All</span> <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="entity">t</span> <span class="main">=</span>  <span class="entity">HOLogic.all_const</span> <span class="entity">T</span> $ Abs <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_exists</span> <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="entity">t</span> <span class="main">=</span>  <span class="entity">HOLogic.exists_const</span> <span class="entity">T</span> $ Abs <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">case_sum_const</span> <span class="entity">ty1</span> <span class="entity">ty2</span> <span class="entity">ty3</span> <span class="main">=</span>
  Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> case_sum<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">[</span><span class="entity">ty1</span> --&gt; <span class="entity">ty3</span><span class="main">,</span> <span class="entity">ty2</span> --&gt; <span class="entity">ty3</span><span class="main">,</span> Type <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> sum<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">[</span><span class="entity">ty1</span><span class="main">,</span> <span class="entity">ty2</span><span class="main">]</span><span class="main">)</span><span class="main">]</span> ---&gt; <span class="entity">ty3</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_case_sum</span> <span class="entity">trm1</span> <span class="entity">trm2</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">[</span><span class="entity">ty1</span><span class="main">]</span><span class="main">,</span> <span class="entity">ty3</span><span class="main">)</span> <span class="main">=</span> strip_type <span class="main">(</span>fastype_of <span class="entity">trm1</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty2</span> <span class="main">=</span> domain_type <span class="main">(</span>fastype_of <span class="entity">trm2</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">case_sum_const</span> <span class="entity">ty1</span> <span class="entity">ty2</span> <span class="entity">ty3</span> $ <span class="entity">trm1</span> $ <span class="entity">trm2</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_equiv</span> <span class="entity">r</span> <span class="main">=</span> <span class="entity">r</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> eq_reflection<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">safe_mk_equiv</span> <span class="entity">r</span> <span class="main">=</span> <span class="entity">mk_equiv</span> <span class="entity">r</span> <span class="keyword3"><span class="keyword">handle</span></span> Thm.THM <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">r</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_minus</span> <span class="entity">p</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"uminus<span class="main">::</span>perm <span class="main">=&gt;</span> perm"</span><span class="antiquote">}</span></span> $ <span class="entity">p</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_plus</span> <span class="entity">p</span> <span class="entity">q</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"plus<span class="main">::</span>perm <span class="main">=&gt;</span> perm <span class="main">=&gt;</span> perm"</span><span class="antiquote">}</span></span> $ <span class="entity">p</span> $ <span class="entity">q</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">perm_ty</span> <span class="entity">ty</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"perm"</span><span class="antiquote">}</span></span> --&gt; <span class="entity">ty</span> --&gt; <span class="entity">ty</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">perm_const</span> <span class="entity">ty</span>  <span class="main">=</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "permute"<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">perm_ty</span> <span class="entity">ty</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_perm_ty</span> <span class="entity">ty</span> <span class="entity">p</span> <span class="entity">trm</span> <span class="main">=</span> <span class="entity">perm_const</span> <span class="entity">ty</span> $ <span class="entity">p</span> $ <span class="entity">trm</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_perm</span> <span class="entity">p</span> <span class="entity">trm</span> <span class="main">=</span> <span class="entity">mk_perm_ty</span> <span class="main">(</span>fastype_of <span class="entity">trm</span><span class="main">)</span> <span class="entity">p</span> <span class="entity">trm</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_perm</span> <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "permute"<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="entity">p</span> $ <span class="entity">t</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">p</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">dest_perm</span> <span class="entity">t</span> <span class="main">=</span> <span class="keyword3"><span class="keyword">raise</span></span> TERM <span class="main">(</span><span class="inner_quoted">"dest_perm"</span><span class="main">,</span> <span class="main">[</span><span class="entity">t</span><span class="main">]</span><span class="main">)</span>


<span class="comment1">(** functions to deal with constants in local contexts **)</span>

<span class="comment1">(* returns the fully qualified name of a constant *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">long_name</span> <span class="entity">ctxt</span> <span class="entity">name</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">case</span></span> head_of <span class="main">(</span>Syntax.read_term <span class="entity">ctxt</span> <span class="entity">name</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
    Const <span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">s</span>
  <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> error <span class="main">(</span><span class="inner_quoted">"Undeclared constant: "</span> ^ quote <span class="entity">name</span><span class="main">)</span>

<span class="comment1">(* returns true iff the argument term is a fixed Free *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_fixed_Free</span> <span class="entity">ctxt</span> <span class="main">(</span>Free <span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Variable.is_fixed <span class="entity">ctxt</span> <span class="entity">s</span>
  <span class="main">|</span> <span class="entity">is_fixed_Free</span> <span class="main">_</span> <span class="main">_</span> <span class="main">=</span> false

<span class="comment1">(* returns true iff c is a constant or fixed Free applied to
   fixed parameters *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_fixed</span> <span class="entity">ctxt</span> <span class="entity">c</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span> <span class="main">=</span> strip_comb <span class="entity">c</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span>is_Const <span class="entity">c</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">is_fixed_Free</span> <span class="entity">ctxt</span> <span class="entity">c</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">andalso</span></span> List.all <span class="main">(</span><span class="entity">is_fixed_Free</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">args</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* splits a list into the longest prefix containing only elements
   that satisfy p, and the rest of the list *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">chop_while</span> <span class="entity">p</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">chop_while_aux</span> <span class="entity">acc</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span>
      <span class="main">(</span>rev <span class="entity">acc</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">chop_while_aux</span> <span class="entity">acc</span> <span class="main">(</span><span class="entity">x</span>::<span class="entity">xs</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">p</span> <span class="entity">x</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">chop_while_aux</span> <span class="main">(</span><span class="entity">x</span>::<span class="entity">acc</span><span class="main">)</span> <span class="entity">xs</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span>rev <span class="entity">acc</span><span class="main">,</span> <span class="entity">x</span>::<span class="entity">xs</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">chop_while_aux</span> <span class="main">[</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* takes a combination "c $ fixed1 $ ... $ fixedN $ not-fixed $ ..."
   to the pair ("c $ fixed1 $ ... $ fixedN", ["not-fixed", ...]). *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">fixed_nonfixed_args</span> <span class="entity">ctxt</span> <span class="entity">c_args</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span>     <span class="main">=</span> strip_comb <span class="entity">c_args</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">frees</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span> <span class="main">=</span> <span class="entity">chop_while</span> <span class="main">(</span><span class="entity">is_fixed_Free</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">args</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c_frees</span>       <span class="main">=</span> list_comb <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">frees</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="entity">c_frees</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* structure *)</span>

<span class="keyword3"><span class="keyword">open</span></span> <span class="entity">Nominal_Basic</span><span class="main">;</span>
</pre>
</div><div id="files/nominal_thmdecls.ML">
<div class="head">
<h1>File ‹nominal_thmdecls.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      nominal_thmdecls.ML
    Author:     Christian Urban
    Author:     Tjark Weber

  Infrastructure for the lemma collections "eqvts", "eqvts_raw".

  Provides the attributes [eqvt] and [eqvt_raw], and the theorem
  lists "eqvts" and "eqvts_raw".

  The [eqvt] attribute expects a theorem of the form

    ?p ∙ (c ?x1 ?x2 ...) = c (?p ∙ ?x1) (?p ∙ ?x2) ...    (1)

  or, if c is a relation with arity &gt;= 1, of the form

    c ?x1 ?x2 ... ==&gt; c (?p ∙ ?x1) (?p ∙ ?x2) ...         (2)

  [eqvt] will store this theorem in the form (1) or, if c
  is a relation with arity &gt;= 1, in the form

    c (?p ∙ ?x1) (?p ∙ ?x2) ... = c ?x1 ?x2 ...           (3)

  in "eqvts". (The orientation of (3) was chosen because
  Isabelle's simplifier uses equations from left to right.)
  [eqvt] will also derive and store the theorem

    ?p ∙ c == c                                           (4)

  in "eqvts_raw".

  (1)-(4) are all logically equivalent. We consider (1) and (2)
  to be more end-user friendly, i.e., slightly more natural to
  understand and prove, while (3) and (4) make the rewriting
  system for equivariance more predictable and less prone to
  looping in Isabelle.

  The [eqvt_raw] attribute expects a theorem of the form (4),
  and merely stores it in "eqvts_raw".

  [eqvt_raw] is provided because certain equivariance theorems
  would lead to looping when used for simplification in the form
  (1): notably, equivariance of permute (infix ∙), i.e.,
  ?p ∙ (?q ∙ ?x) = (?p ∙ ?q) ∙ (?p ∙ ?x).

  To support binders such as All/Ex/Ball/Bex etc., which are
  typically applied to abstractions, argument terms ?xi (as well
  as permuted arguments ?p ∙ ?xi) in (1)-(3) need not be eta-
  contracted, i.e., they may be of the form "%z. ?xi z" or
  "%z. (?p ∙ ?x) z", respectively.

  For convenience, argument terms ?xi (as well as permuted
  arguments ?p ∙ ?xi) in (1)-(3) may actually be tuples, e.g.,
  "(?xi, ?xj)" or "(?p ∙ ?xi, ?p ∙ ?xj)", respectively.

  In (1)-(4), "c" is either a (global) constant or a locally
  fixed parameter, e.g., of a locale or type class.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">NOMINAL_THMDECLS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> eqvt_add<span class="main">:</span> attribute
  <span class="keyword1"><span class="keyword">val</span></span> eqvt_del<span class="main">:</span> attribute
  <span class="keyword1"><span class="keyword">val</span></span> eqvt_raw_add<span class="main">:</span> attribute
  <span class="keyword1"><span class="keyword">val</span></span> eqvt_raw_del<span class="main">:</span> attribute
  <span class="keyword1"><span class="keyword">val</span></span> get_eqvts_thms<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm list
  <span class="keyword1"><span class="keyword">val</span></span> get_eqvts_raw_thms<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm list
  <span class="keyword1"><span class="keyword">val</span></span> eqvt_transform<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> is_eqvt<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> bool
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Nominal_ThmDecls</span><span class="main">:</span> <span class="entity">NOMINAL_THMDECLS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">EqvtData</span> <span class="main">=</span> Generic_Data
<span class="main">(</span> <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span> thm Item_Net.T<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">empty</span> <span class="main">=</span> Thm.full_rules<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">extend</span> <span class="main">=</span> I<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">merge</span> <span class="main">=</span> Item_Net.merge<span class="main">)</span><span class="main">;</span>

<span class="comment1">(* EqvtRawData is implemented with a Termtab (rather than an
   Item_Net) so that we can efficiently decide whether a given
   constant has a corresponding equivariance theorem stored, cf.
   the function is_eqvt. *)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">EqvtRawData</span> <span class="main">=</span> Generic_Data
<span class="main">(</span> <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span> thm Termtab.table<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">empty</span> <span class="main">=</span> Termtab.empty<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">extend</span> <span class="main">=</span> I<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">merge</span> <span class="main">=</span> Termtab.merge <span class="main">(</span>K true<span class="main">)</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eqvts</span> <span class="main">=</span> Item_Net.content o EqvtData.get
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eqvts_raw</span> <span class="main">=</span> map snd o Termtab.dest o EqvtRawData.get

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  Theory.setup
   <span class="main">(</span>Global_Theory.add_thms_dynamic <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> "eqvts"<span class="antiquote">}</span></span></span><span class="main">,</span> <span class="entity">eqvts</span><span class="main">)</span> #&gt;
    Global_Theory.add_thms_dynamic <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> "eqvts_raw"<span class="antiquote">}</span></span></span><span class="main">,</span> <span class="entity">eqvts_raw</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">get_eqvts_thms</span> <span class="main">=</span> <span class="entity">eqvts</span> o Context.Proof
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">get_eqvts_raw_thms</span> <span class="main">=</span> <span class="entity">eqvts_raw</span> o Context.Proof


<span class="comment1">(** raw equivariance lemmas **)</span>

<span class="comment1">(* Returns true iff an equivariance lemma exists in "eqvts_raw"
   for a given term. *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">is_eqvt</span> <span class="main">=</span>
  Termtab.defined o EqvtRawData.get o Context.Proof

<span class="comment1">(* Returns c if thm is of the form (4), raises an error
   otherwise. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">key_of_raw_thm</span> <span class="entity">context</span> <span class="entity">thm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">error_msg</span> <span class="main">(</span><span class="main">)</span> <span class="main">=</span>
      error
        <span class="main">(</span><span class="inner_quoted">"Theorem must be of the form \"?p ∙ c ≡ c\", with c a constant or fixed parameter:\n"</span> ^
         Syntax.string_of_term <span class="main">(</span>Context.proof_of <span class="entity">context</span><span class="main">)</span> <span class="main">(</span>Thm.prop_of <span class="entity">thm</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="keyword2"><span class="keyword">case</span></span> Thm.prop_of <span class="entity">thm</span> <span class="keyword2"><span class="keyword">of</span></span>
      Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Pure.eq<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "permute"<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="entity">p</span> $ <span class="entity">c</span><span class="main">)</span> $ <span class="entity">c'</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">if</span></span> is_Var <span class="entity">p</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_fixed</span> <span class="main">(</span>Context.proof_of <span class="entity">context</span><span class="main">)</span> <span class="entity">c</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">c</span> aconv <span class="entity">c'</span> <span class="keyword2"><span class="keyword">then</span></span>
          <span class="entity">c</span>
        <span class="keyword2"><span class="keyword">else</span></span>
          <span class="entity">error_msg</span> <span class="main">(</span><span class="main">)</span>
    <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">error_msg</span> <span class="main">(</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_raw_thm</span> <span class="entity">thm</span> <span class="entity">context</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c</span> <span class="main">=</span> <span class="entity">key_of_raw_thm</span> <span class="entity">context</span> <span class="entity">thm</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="keyword2"><span class="keyword">if</span></span> Termtab.defined <span class="main">(</span>EqvtRawData.get <span class="entity">context</span><span class="main">)</span> <span class="entity">c</span> <span class="keyword2"><span class="keyword">then</span></span>
      warning <span class="main">(</span><span class="inner_quoted">"Replacing existing raw equivariance theorem for \""</span> ^
        Syntax.string_of_term <span class="main">(</span>Context.proof_of <span class="entity">context</span><span class="main">)</span> <span class="entity">c</span> ^ <span class="inner_quoted">"\"."</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="main">)</span><span class="main">;</span>
    EqvtRawData.map <span class="main">(</span>Termtab.update <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">thm</span><span class="main">)</span><span class="main">)</span> <span class="entity">context</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">del_raw_thm</span> <span class="entity">thm</span> <span class="entity">context</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c</span> <span class="main">=</span> <span class="entity">key_of_raw_thm</span> <span class="entity">context</span> <span class="entity">thm</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="keyword2"><span class="keyword">if</span></span> Termtab.defined <span class="main">(</span>EqvtRawData.get <span class="entity">context</span><span class="main">)</span> <span class="entity">c</span> <span class="keyword2"><span class="keyword">then</span></span>
      EqvtRawData.map <span class="main">(</span>Termtab.delete <span class="entity">c</span><span class="main">)</span> <span class="entity">context</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span>
      warning <span class="main">(</span><span class="inner_quoted">"Cannot delete non-existing raw equivariance theorem for \""</span> ^
        Syntax.string_of_term <span class="main">(</span>Context.proof_of <span class="entity">context</span><span class="main">)</span> <span class="entity">c</span> ^ <span class="inner_quoted">"\"."</span><span class="main">)</span><span class="main">;</span>
      <span class="entity">context</span>
    <span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="comment1">(** adding/deleting lemmas to/from "eqvts" **)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_thm</span> <span class="entity">thm</span> <span class="entity">context</span> <span class="main">=</span>
  <span class="main">(</span>
    <span class="keyword2"><span class="keyword">if</span></span> Item_Net.member <span class="main">(</span>EqvtData.get <span class="entity">context</span><span class="main">)</span> <span class="entity">thm</span> <span class="keyword2"><span class="keyword">then</span></span>
      warning <span class="main">(</span><span class="inner_quoted">"Theorem already declared as equivariant:\n"</span> ^
        Syntax.string_of_term <span class="main">(</span>Context.proof_of <span class="entity">context</span><span class="main">)</span> <span class="main">(</span>Thm.prop_of <span class="entity">thm</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="main">)</span><span class="main">;</span>
    EqvtData.map <span class="main">(</span>Item_Net.update <span class="entity">thm</span><span class="main">)</span> <span class="entity">context</span>
  <span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">del_thm</span> <span class="entity">thm</span> <span class="entity">context</span> <span class="main">=</span>
  <span class="main">(</span>
    <span class="keyword2"><span class="keyword">if</span></span> Item_Net.member <span class="main">(</span>EqvtData.get <span class="entity">context</span><span class="main">)</span> <span class="entity">thm</span> <span class="keyword2"><span class="keyword">then</span></span>
      EqvtData.map <span class="main">(</span>Item_Net.remove <span class="entity">thm</span><span class="main">)</span> <span class="entity">context</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span>
      warning <span class="main">(</span><span class="inner_quoted">"Cannot delete non-existing equivariance theorem:\n"</span> ^
        Syntax.string_of_term <span class="main">(</span>Context.proof_of <span class="entity">context</span><span class="main">)</span> <span class="main">(</span>Thm.prop_of <span class="entity">thm</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
      <span class="entity">context</span>
    <span class="main">)</span>
  <span class="main">)</span>


<span class="comment1">(** transformation of equivariance lemmas **)</span>

<span class="comment1">(* Transforms a theorem of the form (1) into the form (4). *)</span>
<span class="keyword2"><span class="keyword">local</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tac</span> <span class="entity">ctxt</span> <span class="entity">thm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ss_thms</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> "permute_minus_cancel" "permute_prod.simps" "split_paired_all"<span class="antiquote">}</span></span></span>
  <span class="keyword2"><span class="keyword">in</span></span>
    REPEAT o FIRST'
      <span class="main">[</span>CHANGED o <span class="entity">simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span> addsimps <span class="entity">ss_thms</span><span class="main">)</span><span class="main">,</span>
       resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">thm</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> trans<span class="antiquote">}</span></span></span><span class="main">]</span><span class="main">,</span>
       resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> trans<span class="main">[</span><span class="operator">OF</span> "permute_fun_def"<span class="main">]</span><span class="antiquote">}</span></span></span> THEN'
       resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> ext<span class="antiquote">}</span></span></span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">in</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">thm_4_of_1</span> <span class="entity">ctxt</span> <span class="entity">thm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">p</span><span class="main">,</span> <span class="entity">c</span><span class="main">)</span> <span class="main">=</span> <span class="entity">thm</span> |&gt; Thm.prop_of |&gt; <span class="entity">HOLogic.dest_Trueprop</span>
      |&gt; <span class="entity">HOLogic.dest_eq</span> |&gt; fst |&gt; <span class="entity">dest_perm</span> ||&gt; fst o <span class="main">(</span><span class="entity">fixed_nonfixed_args</span> <span class="entity">ctxt</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goal</span> <span class="main">=</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">mk_perm</span> <span class="entity">p</span> <span class="entity">c</span><span class="main">,</span> <span class="entity">c</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">[</span><span class="entity">goal'</span><span class="main">,</span> <span class="entity">p'</span><span class="main">]</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> Variable.import_terms false <span class="main">[</span><span class="entity">goal</span><span class="main">,</span> <span class="entity">p</span><span class="main">]</span> <span class="entity">ctxt</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Goal.prove <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">goal'</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span><span class="entity">context</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span> <span class="entity">tac</span> <span class="entity">context</span> <span class="entity">thm</span> <span class="inner_numeral">1</span><span class="main">)</span>
      |&gt; singleton <span class="main">(</span>Proof_Context.export <span class="entity">ctxt'</span> <span class="entity">ctxt</span><span class="main">)</span>
      |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">th</span> <span class="main">=&gt;</span> <span class="entity">th</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> "eq_reflection"<span class="antiquote">}</span></span></span><span class="main">)</span>
      |&gt; zero_var_indexes
  <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword3"><span class="keyword">handle</span></span> TERM <span class="main">_</span> <span class="main">=&gt;</span>
    <span class="keyword3"><span class="keyword">raise</span></span> THM <span class="main">(</span><span class="inner_quoted">"thm_4_of_1"</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">,</span> <span class="main">[</span><span class="entity">thm</span><span class="main">]</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* local *)</span>

<span class="comment1">(* Transforms a theorem of the form (2) into the form (1). *)</span>
<span class="keyword2"><span class="keyword">local</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tac</span> <span class="entity">ctxt</span> <span class="entity">thm</span> <span class="entity">thm'</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ss_thms</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> "permute_minus_cancel"<span class="main">(</span>2<span class="main">)</span><span class="antiquote">}</span></span></span>
  <span class="keyword2"><span class="keyword">in</span></span>
    EVERY' <span class="main">[</span>resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> iffI<span class="antiquote">}</span></span></span><span class="main">,</span>
      dresolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> permute_boolE<span class="antiquote">}</span></span></span><span class="main">,</span>
      resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">thm</span><span class="main">]</span><span class="main">,</span>
      assume_tac <span class="entity">ctxt</span><span class="main">,</span>
      resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> permute_boolI<span class="antiquote">}</span></span></span><span class="main">,</span>
      dresolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">thm'</span><span class="main">]</span><span class="main">,</span>
      <span class="entity">full_simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span> addsimps <span class="entity">ss_thms</span><span class="main">)</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">in</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">thm_1_of_2</span> <span class="entity">ctxt</span> <span class="entity">thm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">prem</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span> <span class="main">=</span> <span class="entity">thm</span> |&gt; Thm.prop_of |&gt; Logic.dest_implies |&gt; apply2 <span class="entity">HOLogic.dest_Trueprop</span>
    <span class="comment1">(* since argument terms "?p ∙ ?x1" may actually be eta-expanded
       or tuples, we need the following function to find ?p *)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">find_perm</span> <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "permute"<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">(</span><span class="entity">p</span> <span class="keyword1"><span class="keyword">as</span></span> Var <span class="main">_</span><span class="main">)</span> $ <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">p</span>
      <span class="main">|</span> <span class="entity">find_perm</span> <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "Pair"<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="entity">x</span> $ <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">find_perm</span> <span class="entity">x</span>
      <span class="main">|</span> <span class="entity">find_perm</span> <span class="main">(</span>Abs <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">body</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">find_perm</span> <span class="entity">body</span>
      <span class="main">|</span> <span class="entity">find_perm</span> <span class="main">_</span> <span class="main">=</span> <span class="keyword3"><span class="keyword">raise</span></span> THM <span class="main">(</span><span class="inner_quoted">"thm_3_of_2"</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">,</span> <span class="main">[</span><span class="entity">thm</span><span class="main">]</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">p</span> <span class="main">=</span> <span class="entity">concl</span> |&gt; dest_comb |&gt; snd |&gt; <span class="entity">find_perm</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goal</span> <span class="main">=</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">mk_perm</span> <span class="entity">p</span> <span class="entity">prem</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">[</span><span class="entity">goal'</span><span class="main">,</span> <span class="entity">p'</span><span class="main">]</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> Variable.import_terms false <span class="main">[</span><span class="entity">goal</span><span class="main">,</span> <span class="entity">p</span><span class="main">]</span> <span class="entity">ctxt</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm'</span> <span class="main">=</span> infer_instantiate <span class="entity">ctxt'</span> <span class="main">[</span><span class="main">(</span><span class="main">#</span><span class="inner_numeral">1</span> <span class="main">(</span>dest_Var <span class="entity">p</span><span class="main">)</span><span class="main">,</span> Thm.cterm_of <span class="entity">ctxt'</span> <span class="main">(</span><span class="entity">mk_minus</span> <span class="entity">p'</span><span class="main">)</span><span class="main">)</span><span class="main">]</span> <span class="entity">thm</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Goal.prove <span class="entity">ctxt'</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">goal'</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt''</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span> <span class="entity">tac</span> <span class="entity">ctxt''</span> <span class="entity">thm</span> <span class="entity">thm'</span> <span class="inner_numeral">1</span><span class="main">)</span>
      |&gt; singleton <span class="main">(</span>Proof_Context.export <span class="entity">ctxt'</span> <span class="entity">ctxt</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword3"><span class="keyword">handle</span></span> TERM <span class="main">_</span> <span class="main">=&gt;</span>
    <span class="keyword3"><span class="keyword">raise</span></span> THM <span class="main">(</span><span class="inner_quoted">"thm_1_of_2"</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">,</span> <span class="main">[</span><span class="entity">thm</span><span class="main">]</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* local *)</span>

<span class="comment1">(* Transforms a theorem of the form (1) into the form (3). *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">thm_3_of_1</span> <span class="main">_</span> <span class="entity">thm</span> <span class="main">=</span>
  <span class="main">(</span><span class="entity">thm</span> RS <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> "permute_bool_def"<span class="antiquote">}</span></span></span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> "sym"<span class="antiquote">}</span></span></span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> "trans"<span class="antiquote">}</span></span></span><span class="main">)</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> "sym"<span class="antiquote">}</span></span></span><span class="main">)</span>
    |&gt; zero_var_indexes

<span class="keyword2"><span class="keyword">local</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">msg</span> <span class="main">=</span> cat_lines
    <span class="main">[</span><span class="inner_quoted">"Equivariance theorem must be of the form"</span><span class="main">,</span>
     <span class="inner_quoted">"  ?p ∙ (c ?x1 ?x2 ...) = c (?p ∙ ?x1) (?p ∙ ?x2) ..."</span><span class="main">,</span>
     <span class="inner_quoted">"or, if c is a relation with arity &gt;= 1, of the form"</span><span class="main">,</span>
     <span class="inner_quoted">"  c ?x1 ?x2 ... ==&gt; c (?p ∙ ?x1) (?p ∙ ?x2) ..."</span><span class="main">]</span>
<span class="keyword2"><span class="keyword">in</span></span>

<span class="comment1">(* Transforms a theorem of the form (1) or (2) into the form (4). *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eqvt_transform</span> <span class="entity">ctxt</span> <span class="entity">thm</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> Thm.prop_of <span class="entity">thm</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> "Trueprop"<span class="antiquote">}</span></span> $ <span class="main">_</span> <span class="main">=&gt;</span>
    <span class="entity">thm_4_of_1</span> <span class="entity">ctxt</span> <span class="entity">thm</span>
  <span class="main">|</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> Pure.imp<span class="antiquote">}</span></span> $ <span class="main">_</span> $ <span class="main">_</span> <span class="main">=&gt;</span>
    <span class="entity">thm_4_of_1</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">thm_1_of_2</span> <span class="entity">ctxt</span> <span class="entity">thm</span><span class="main">)</span>
  <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span>
    error <span class="entity">msg</span><span class="main">)</span>
  <span class="keyword3"><span class="keyword">handle</span></span> THM <span class="main">_</span> <span class="main">=&gt;</span>
    error <span class="entity">msg</span>

<span class="comment1">(* Transforms a theorem of the form (1) into theorems of the
   form (1) (or, if c is a relation with arity &gt;= 1, of the form
   (3)) and (4); transforms a theorem of the form (2) into
   theorems of the form (3) and (4). *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eqvt_and_raw_transform</span> <span class="entity">ctxt</span> <span class="entity">thm</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> Thm.prop_of <span class="entity">thm</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> "Trueprop"<span class="antiquote">}</span></span> $ <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "HOL.eq"<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">_</span> $ <span class="entity">c_args</span><span class="main">)</span> <span class="main">=&gt;</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th'</span> <span class="main">=</span>
        <span class="keyword2"><span class="keyword">if</span></span> fastype_of <span class="entity">c_args</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"bool"</span><span class="antiquote">}</span></span>
            <span class="keyword1"><span class="keyword">andalso</span></span> <span class="main">(</span>not o null<span class="main">)</span> <span class="main">(</span>snd <span class="main">(</span><span class="entity">fixed_nonfixed_args</span> <span class="entity">ctxt</span> <span class="entity">c_args</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
          <span class="entity">thm_3_of_1</span> <span class="entity">ctxt</span> <span class="entity">thm</span>
        <span class="keyword2"><span class="keyword">else</span></span>
          <span class="entity">thm</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">(</span><span class="entity">th'</span><span class="main">,</span> <span class="entity">thm_4_of_1</span> <span class="entity">ctxt</span> <span class="entity">thm</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>
  <span class="main">|</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> Pure.imp<span class="antiquote">}</span></span> $ <span class="main">_</span> $ <span class="main">_</span> <span class="main">=&gt;</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th1</span> <span class="main">=</span> <span class="entity">thm_1_of_2</span> <span class="entity">ctxt</span> <span class="entity">thm</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">(</span><span class="entity">thm_3_of_1</span> <span class="entity">ctxt</span> <span class="entity">th1</span><span class="main">,</span> <span class="entity">thm_4_of_1</span> <span class="entity">ctxt</span> <span class="entity">th1</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>
  <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span>
    error <span class="entity">msg</span><span class="main">)</span>
  <span class="keyword3"><span class="keyword">handle</span></span> THM <span class="main">_</span> <span class="main">=&gt;</span>
    error <span class="entity">msg</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* local *)</span>


<span class="comment1">(** attributes **)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eqvt_raw_add</span> <span class="main">=</span> Thm.declaration_attribute <span class="entity">add_raw_thm</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eqvt_raw_del</span> <span class="main">=</span> Thm.declaration_attribute <span class="entity">del_raw_thm</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eqvt_add_or_del</span> <span class="entity">eqvt_fn</span> <span class="entity">raw_fn</span> <span class="main">=</span>
  Thm.declaration_attribute
    <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">thm</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">context</span> <span class="main">=&gt;</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">eqvt</span><span class="main">,</span> <span class="entity">raw</span><span class="main">)</span> <span class="main">=</span> <span class="entity">eqvt_and_raw_transform</span> <span class="main">(</span>Context.proof_of <span class="entity">context</span><span class="main">)</span> <span class="entity">thm</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="entity">context</span> |&gt; <span class="entity">eqvt_fn</span> <span class="entity">eqvt</span> |&gt; <span class="entity">raw_fn</span> <span class="entity">raw</span>
      <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eqvt_add</span> <span class="main">=</span> <span class="entity">eqvt_add_or_del</span> <span class="entity">add_thm</span> <span class="entity">add_raw_thm</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eqvt_del</span> <span class="main">=</span> <span class="entity">eqvt_add_or_del</span> <span class="entity">del_thm</span> <span class="entity">del_raw_thm</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  Theory.setup
   <span class="main">(</span><span class="entity">Attrib.setup</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> "eqvt"<span class="antiquote">}</span></span></span> <span class="main">(</span><span class="entity">Attrib.add_del</span> <span class="entity">eqvt_add</span> <span class="entity">eqvt_del</span><span class="main">)</span>
      <span class="inner_quoted">"Declaration of equivariance lemmas - they will automatically be brought into the form ?p ∙ c ≡ c"</span> #&gt;
    <span class="entity">Attrib.setup</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> "eqvt_raw"<span class="antiquote">}</span></span></span> <span class="main">(</span><span class="entity">Attrib.add_del</span> <span class="entity">eqvt_raw_add</span> <span class="entity">eqvt_raw_del</span><span class="main">)</span>
      <span class="inner_quoted">"Declaration of raw equivariance lemmas - no transformation is performed"</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
</pre>
</div><div id="files/nominal_permeq.ML">
<div class="head">
<h1>File ‹nominal_permeq.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      nominal_permeq.ML
    Author:     Christian Urban
    Author:     Brian Huffman
*)</span>

<span class="keyword1"><span class="keyword">infix</span></span> <span class="inner_numeral">4</span> addpres addposts addexcls

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">NOMINAL_PERMEQ</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">eqvt_config</span> <span class="main">=</span>
    <span class="entity">Eqvt_Config</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="main">{</span>strict_mode<span class="main">:</span> bool<span class="main">,</span> pre_thms<span class="main">:</span> thm list<span class="main">,</span> post_thms<span class="main">:</span> thm list<span class="main">,</span> excluded<span class="main">:</span> string list<span class="main">}</span>

  <span class="keyword1"><span class="keyword">val</span></span> eqvt_relaxed_config<span class="main">:</span> <span class="entity">eqvt_config</span>
  <span class="keyword1"><span class="keyword">val</span></span> eqvt_strict_config<span class="main">:</span> <span class="entity">eqvt_config</span>
  <span class="keyword1"><span class="keyword">val</span></span> addpres <span class="main">:</span> <span class="main">(</span><span class="entity">eqvt_config</span> * thm list<span class="main">)</span> <span class="main">-&gt;</span> <span class="entity">eqvt_config</span>
  <span class="keyword1"><span class="keyword">val</span></span> addposts <span class="main">:</span> <span class="main">(</span><span class="entity">eqvt_config</span> * thm list<span class="main">)</span> <span class="main">-&gt;</span> <span class="entity">eqvt_config</span>
  <span class="keyword1"><span class="keyword">val</span></span> addexcls <span class="main">:</span> <span class="main">(</span><span class="entity">eqvt_config</span> * string list<span class="main">)</span> <span class="main">-&gt;</span> <span class="entity">eqvt_config</span>
  <span class="keyword1"><span class="keyword">val</span></span> delpres <span class="main">:</span> <span class="entity">eqvt_config</span> <span class="main">-&gt;</span> <span class="entity">eqvt_config</span>
  <span class="keyword1"><span class="keyword">val</span></span> delposts <span class="main">:</span> <span class="entity">eqvt_config</span> <span class="main">-&gt;</span> <span class="entity">eqvt_config</span>

  <span class="keyword1"><span class="keyword">val</span></span> eqvt_conv<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">eqvt_config</span> <span class="main">-&gt;</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> eqvt_rule<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">eqvt_config</span> <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> eqvt_tac<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">eqvt_config</span> <span class="main">-&gt;</span> int <span class="main">-&gt;</span> tactic

  <span class="keyword1"><span class="keyword">val</span></span> perm_simp_meth<span class="main">:</span> thm list * string list <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Proof.method</span>
  <span class="keyword1"><span class="keyword">val</span></span> perm_strict_simp_meth<span class="main">:</span> thm list * string list <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Proof.method</span>
  <span class="keyword1"><span class="keyword">val</span></span> args_parser<span class="main">:</span> <span class="main">(</span>thm list * string list<span class="main">)</span> context_parser

  <span class="keyword1"><span class="keyword">val</span></span> trace_eqvt<span class="main">:</span> bool Config.T
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*

- eqvt_tac and eqvt_rule take a  list of theorems which
  are first tried to simplify permutations

- the string list contains constants that should not be
  analysed (for example there is no raw eqvt-lemma for
  the constant The); therefore it should not be analysed

- setting [[trace_eqvt = true]] switches on tracing
  information

*)</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Nominal_Permeq</span><span class="main">:</span> <span class="entity">NOMINAL_PERMEQ</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword3"><span class="keyword">open</span></span> Nominal_ThmDecls<span class="main">;</span>

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">eqvt_config</span> <span class="main">=</span> <span class="entity">Eqvt_Config</span> <span class="keyword2"><span class="keyword">of</span></span>
  <span class="main">{</span>strict_mode<span class="main">:</span> bool<span class="main">,</span> pre_thms<span class="main">:</span> thm list<span class="main">,</span> post_thms<span class="main">:</span> thm list<span class="main">,</span> excluded<span class="main">:</span> string list<span class="main">}</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="main">(</span><span class="entity">Eqvt_Config</span> <span class="main">{</span><span class="entity">strict_mode</span><span class="main">,</span> <span class="entity">pre_thms</span><span class="main">,</span> <span class="entity">post_thms</span><span class="main">,</span> <span class="entity">excluded</span><span class="main">}</span><span class="main">)</span> <span class="entity">addpres</span> <span class="entity">thms</span> <span class="main">=</span>
  <span class="entity">Eqvt_Config</span> <span class="main">{</span> strict_mode <span class="main">=</span> <span class="entity">strict_mode</span><span class="main">,</span>
                pre_thms <span class="main">=</span> <span class="entity">thms</span> @ <span class="entity">pre_thms</span><span class="main">,</span>
                post_thms <span class="main">=</span> <span class="entity">post_thms</span><span class="main">,</span>
                excluded <span class="main">=</span> <span class="entity">excluded</span> <span class="main">}</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="main">(</span><span class="entity">Eqvt_Config</span> <span class="main">{</span><span class="entity">strict_mode</span><span class="main">,</span> <span class="entity">pre_thms</span><span class="main">,</span> <span class="entity">post_thms</span><span class="main">,</span> <span class="entity">excluded</span><span class="main">}</span><span class="main">)</span> <span class="entity">addposts</span> <span class="entity">thms</span> <span class="main">=</span>
  <span class="entity">Eqvt_Config</span> <span class="main">{</span> strict_mode <span class="main">=</span> <span class="entity">strict_mode</span><span class="main">,</span>
                pre_thms <span class="main">=</span> <span class="entity">pre_thms</span><span class="main">,</span>
                post_thms <span class="main">=</span> <span class="entity">thms</span> @ <span class="entity">post_thms</span><span class="main">,</span>
                excluded <span class="main">=</span> <span class="entity">excluded</span> <span class="main">}</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="main">(</span><span class="entity">Eqvt_Config</span> <span class="main">{</span><span class="entity">strict_mode</span><span class="main">,</span> <span class="entity">pre_thms</span><span class="main">,</span> <span class="entity">post_thms</span><span class="main">,</span> <span class="entity">excluded</span><span class="main">}</span><span class="main">)</span> <span class="entity">addexcls</span> <span class="entity">excls</span> <span class="main">=</span>
  <span class="entity">Eqvt_Config</span> <span class="main">{</span> strict_mode <span class="main">=</span> <span class="entity">strict_mode</span><span class="main">,</span>
                pre_thms <span class="main">=</span> <span class="entity">pre_thms</span><span class="main">,</span>
                post_thms <span class="main">=</span> <span class="entity">post_thms</span><span class="main">,</span>
                excluded <span class="main">=</span> <span class="entity">excls</span> @ <span class="entity">excluded</span> <span class="main">}</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">delpres</span> <span class="main">(</span><span class="entity">Eqvt_Config</span> <span class="main">{</span><span class="entity">strict_mode</span><span class="main">,</span> <span class="entity">pre_thms</span><span class="main">,</span> <span class="entity">post_thms</span><span class="main">,</span> <span class="entity">excluded</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
  <span class="entity">Eqvt_Config</span> <span class="main">{</span> strict_mode <span class="main">=</span> <span class="entity">strict_mode</span><span class="main">,</span>
                pre_thms <span class="main">=</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span>
                post_thms <span class="main">=</span> <span class="entity">post_thms</span><span class="main">,</span>
                excluded <span class="main">=</span> <span class="entity">excluded</span> <span class="main">}</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">delposts</span> <span class="main">(</span><span class="entity">Eqvt_Config</span> <span class="main">{</span><span class="entity">strict_mode</span><span class="main">,</span> <span class="entity">pre_thms</span><span class="main">,</span> <span class="entity">post_thms</span><span class="main">,</span> <span class="entity">excluded</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
  <span class="entity">Eqvt_Config</span> <span class="main">{</span> strict_mode <span class="main">=</span> <span class="entity">strict_mode</span><span class="main">,</span>
                pre_thms <span class="main">=</span> <span class="entity">pre_thms</span><span class="main">,</span>
                post_thms <span class="main">=</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span>
                excluded <span class="main">=</span> <span class="entity">excluded</span> <span class="main">}</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eqvt_relaxed_config</span> <span class="main">=</span>
  <span class="entity">Eqvt_Config</span> <span class="main">{</span> strict_mode <span class="main">=</span> false<span class="main">,</span>
                pre_thms <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> eqvt_bound<span class="antiquote">}</span></span></span><span class="main">,</span>
                post_thms <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> permute_pure<span class="antiquote">}</span></span></span><span class="main">,</span>
                excluded <span class="main">=</span> <span class="main">[</span><span class="main">]</span> <span class="main">}</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eqvt_strict_config</span> <span class="main">=</span>
  <span class="entity">Eqvt_Config</span> <span class="main">{</span> strict_mode <span class="main">=</span> true<span class="main">,</span>
                pre_thms <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> eqvt_bound<span class="antiquote">}</span></span></span><span class="main">,</span>
                post_thms <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> permute_pure<span class="antiquote">}</span></span></span><span class="main">,</span>
                excluded <span class="main">=</span> <span class="main">[</span><span class="main">]</span> <span class="main">}</span>


<span class="comment1">(* tracing infrastructure *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">trace_eqvt</span> <span class="main">=</span> <span class="entity">Attrib.setup_config_bool</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> "trace_eqvt"<span class="antiquote">}</span></span></span> <span class="main">(</span>K false<span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">trace_enabled</span> <span class="entity">ctxt</span> <span class="main">=</span> Config.get <span class="entity">ctxt</span> <span class="entity">trace_eqvt</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">trace_msg</span> <span class="entity">ctxt</span> <span class="entity">result</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs_str</span> <span class="main">=</span> Syntax.string_of_term <span class="entity">ctxt</span> <span class="main">(</span>Thm.term_of <span class="main">(</span>Thm.lhs_of <span class="entity">result</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs_str</span> <span class="main">=</span> Syntax.string_of_term <span class="entity">ctxt</span> <span class="main">(</span>Thm.term_of <span class="main">(</span>Thm.rhs_of <span class="entity">result</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    warning <span class="main">(</span>Pretty.string_of <span class="main">(</span>Pretty.strs <span class="main">[</span><span class="inner_quoted">"Rewriting"</span><span class="main">,</span> <span class="entity">lhs_str</span><span class="main">,</span> <span class="inner_quoted">"to"</span><span class="main">,</span> <span class="entity">rhs_str</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">trace_conv</span> <span class="entity">ctxt</span> <span class="entity">conv</span> <span class="entity">ctrm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">result</span> <span class="main">=</span> <span class="entity">conv</span> <span class="entity">ctrm</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="keyword2"><span class="keyword">if</span></span> Thm.is_reflexive <span class="entity">result</span>
    <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">result</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="entity">trace_msg</span> <span class="entity">ctxt</span> <span class="entity">result</span><span class="main">;</span> <span class="entity">result</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* this conversion always fails, but prints
   out the analysed term  *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">trace_info_conv</span> <span class="entity">ctxt</span> <span class="entity">ctrm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">trm</span> <span class="main">=</span> Thm.term_of <span class="entity">ctrm</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="main">(</span>head_of <span class="entity">trm</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> "Trueprop"<span class="antiquote">}</span></span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">)</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> warning <span class="main">(</span><span class="inner_quoted">"Analysing term "</span> ^ Syntax.string_of_term <span class="entity">ctxt</span> <span class="entity">trm</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Conv.no_conv <span class="entity">ctrm</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* conversion for applications *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eqvt_apply_conv</span> <span class="entity">ctrm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">case</span></span> Thm.term_of <span class="entity">ctrm</span> <span class="keyword2"><span class="keyword">of</span></span>
    Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "permute"<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">_</span> $ <span class="main">(</span><span class="main">_</span> $ <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">perm</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="main">=</span> Thm.dest_comb <span class="entity">ctrm</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">p</span><span class="main">)</span> <span class="main">=</span> Thm.dest_comb <span class="entity">perm</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="entity">x</span><span class="main">)</span> <span class="main">=</span> Thm.dest_comb <span class="entity">t</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">a</span> <span class="main">=</span> Thm.ctyp_of_cterm <span class="entity">x</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">b</span> <span class="main">=</span> Thm.ctyp_of_cterm <span class="entity">t</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty_insts</span> <span class="main">=</span> map SOME <span class="main">[</span><span class="entity">b</span><span class="main">,</span> <span class="entity">a</span><span class="main">]</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">term_insts</span> <span class="main">=</span> map SOME <span class="main">[</span><span class="entity">p</span><span class="main">,</span> <span class="entity">f</span><span class="main">,</span> <span class="entity">x</span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        Thm.instantiate' <span class="entity">ty_insts</span> <span class="entity">term_insts</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> eqvt_apply<span class="antiquote">}</span></span></span>
      <span class="keyword2"><span class="keyword">end</span></span>
  <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> Conv.no_conv <span class="entity">ctrm</span>

<span class="comment1">(* conversion for lambdas *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eqvt_lambda_conv</span> <span class="entity">ctrm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">case</span></span> Thm.term_of <span class="entity">ctrm</span> <span class="keyword2"><span class="keyword">of</span></span>
    Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "permute"<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">_</span> $ <span class="main">(</span>Abs <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span>
      Conv.rewr_conv <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> eqvt_lambda<span class="antiquote">}</span></span></span> <span class="entity">ctrm</span>
  <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> Conv.no_conv <span class="entity">ctrm</span>


<span class="comment1">(* conversion that raises an error or prints a warning message,
   if a permutation on a constant or application cannot be analysed *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_excluded</span> <span class="entity">excluded</span> <span class="main">(</span>Const <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> member <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span><span class="main">)</span> <span class="entity">excluded</span> <span class="entity">a</span>
  <span class="main">|</span> <span class="entity">is_excluded</span> <span class="main">_</span> <span class="main">_</span> <span class="main">=</span> false

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">progress_info_conv</span> <span class="entity">ctxt</span> <span class="entity">strict_flag</span> <span class="entity">excluded</span> <span class="entity">ctrm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">msg</span> <span class="entity">trm</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_excluded</span> <span class="entity">excluded</span> <span class="entity">trm</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span>
        <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">strict_flag</span> <span class="keyword2"><span class="keyword">then</span></span> error <span class="keyword2"><span class="keyword">else</span></span> warning<span class="main">)</span>
          <span class="main">(</span><span class="inner_quoted">"Cannot solve equivariance for "</span> ^ <span class="main">(</span>Syntax.string_of_term <span class="entity">ctxt</span> <span class="entity">trm</span><span class="main">)</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">case</span></span> Thm.term_of <span class="entity">ctrm</span> <span class="keyword2"><span class="keyword">of</span></span>
        Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "permute"<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">_</span> $ <span class="main">(</span><span class="entity">trm</span> <span class="keyword1"><span class="keyword">as</span></span> Const <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">msg</span> <span class="entity">trm</span>
      <span class="main">|</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "permute"<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">_</span> $ <span class="main">(</span><span class="entity">trm</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">_</span> $ <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">msg</span> <span class="entity">trm</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Conv.all_conv <span class="entity">ctrm</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* main conversion *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">main_eqvt_conv</span> <span class="entity">ctxt</span> <span class="entity">config</span> <span class="entity">ctrm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Eqvt_Config</span> <span class="main">{</span><span class="entity">strict_mode</span><span class="main">,</span> <span class="entity">pre_thms</span><span class="main">,</span> <span class="entity">post_thms</span><span class="main">,</span> <span class="entity">excluded</span><span class="main">}</span> <span class="main">=</span> <span class="entity">config</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">first_conv_wrapper</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">trace_enabled</span> <span class="entity">ctxt</span>
      <span class="keyword2"><span class="keyword">then</span></span> Conv.first_conv o <span class="main">(</span>cons <span class="main">(</span><span class="entity">trace_info_conv</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span> o <span class="main">(</span>map <span class="main">(</span><span class="entity">trace_conv</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span> Conv.first_conv

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_pre_thms</span> <span class="main">=</span> map <span class="entity">safe_mk_equiv</span> <span class="main">(</span><span class="entity">pre_thms</span> @ <span class="entity">get_eqvts_raw_thms</span> <span class="entity">ctxt</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_post_thms</span> <span class="main">=</span> map <span class="entity">safe_mk_equiv</span> <span class="entity">post_thms</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">first_conv_wrapper</span>
      <span class="main">[</span> Conv.rewrs_conv <span class="entity">all_pre_thms</span><span class="main">,</span>
        <span class="entity">eqvt_apply_conv</span><span class="main">,</span>
        <span class="entity">eqvt_lambda_conv</span><span class="main">,</span>
        Conv.rewrs_conv <span class="entity">all_post_thms</span><span class="main">,</span>
        <span class="entity">progress_info_conv</span> <span class="entity">ctxt</span> <span class="entity">strict_mode</span> <span class="entity">excluded</span>
      <span class="main">]</span> <span class="entity">ctrm</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="comment1">(* the eqvt-conversion first eta-normalises goals in
   order to avoid problems with inductions in the
   equivariance command. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eqvt_conv</span> <span class="entity">ctxt</span> <span class="entity">config</span> <span class="main">=</span>
  Conv.top_conv <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> Thm.eta_conversion then_conv <span class="main">(</span><span class="entity">main_eqvt_conv</span> <span class="entity">ctxt</span> <span class="entity">config</span><span class="main">)</span><span class="main">)</span> <span class="entity">ctxt</span>

<span class="comment1">(* thms rewriter *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eqvt_rule</span> <span class="entity">ctxt</span> <span class="entity">config</span> <span class="main">=</span>
  Conv.fconv_rule <span class="main">(</span><span class="entity">eqvt_conv</span> <span class="entity">ctxt</span> <span class="entity">config</span><span class="main">)</span>

<span class="comment1">(* tactic *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eqvt_tac</span> <span class="entity">ctxt</span> <span class="entity">config</span> <span class="main">=</span>
  CONVERSION <span class="main">(</span><span class="entity">eqvt_conv</span> <span class="entity">ctxt</span> <span class="entity">config</span><span class="main">)</span>


<span class="comment1">(** methods **)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">unless_more_args</span> <span class="entity">scan</span> <span class="main">=</span> Scan.unless <span class="main">(</span>Scan.lift <span class="main">(</span><span class="main">(</span>Args.$$$ <span class="inner_quoted">"exclude"</span><span class="main">)</span> -- Args.colon<span class="main">)</span><span class="main">)</span> <span class="entity">scan</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">add_thms_parser</span> <span class="main">=</span> Scan.optional <span class="main">(</span>Scan.lift <span class="main">(</span>Args.add -- Args.colon<span class="main">)</span> |--
   Scan.repeat <span class="main">(</span><span class="entity">unless_more_args</span> <span class="entity">Attrib.multi_thm</span><span class="main">)</span> &gt;&gt; flat<span class="main">)</span> <span class="main">[</span><span class="main">]</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">exclude_consts_parser</span> <span class="main">=</span> Scan.optional <span class="main">(</span>Scan.lift <span class="main">(</span><span class="main">(</span>Args.$$$ <span class="inner_quoted">"exclude"</span><span class="main">)</span> -- Args.colon<span class="main">)</span> |--
  <span class="main">(</span>Scan.repeat <span class="main">(</span>Args.const <span class="main">{</span>proper <span class="main">=</span> true<span class="main">,</span> strict <span class="main">=</span> true<span class="main">}</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args_parser</span> <span class="main">=</span> <span class="entity">add_thms_parser</span> -- <span class="entity">exclude_consts_parser</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">perm_simp_meth</span> <span class="main">(</span><span class="entity">thms</span><span class="main">,</span> <span class="entity">consts</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="entity">SIMPLE_METHOD</span> <span class="main">(</span>HEADGOAL <span class="main">(</span><span class="entity">eqvt_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">eqvt_relaxed_config</span> <span class="entity">addpres</span> <span class="entity">thms</span> <span class="entity">addexcls</span> <span class="entity">consts</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">perm_strict_simp_meth</span> <span class="main">(</span><span class="entity">thms</span><span class="main">,</span> <span class="entity">consts</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="entity">SIMPLE_METHOD</span> <span class="main">(</span>HEADGOAL <span class="main">(</span><span class="entity">eqvt_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">eqvt_strict_config</span> <span class="entity">addpres</span> <span class="entity">thms</span> <span class="entity">addexcls</span> <span class="entity">consts</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span> <span class="comment1">(* structure *)</span>
</pre>
</div><div id="files/nominal_library.ML">
<div class="head">
<h1>File ‹nominal_library.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      nominal_library.ML
    Author:     Christian Urban

  Library functions for nominal.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">NOMINAL_LIBRARY</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> mk_sort_of<span class="main">:</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> atom_ty<span class="main">:</span> typ <span class="main">-&gt;</span> typ
  <span class="keyword1"><span class="keyword">val</span></span> atom_const<span class="main">:</span> typ <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> mk_atom_ty<span class="main">:</span> typ <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> mk_atom<span class="main">:</span> term <span class="main">-&gt;</span> term

  <span class="keyword1"><span class="keyword">val</span></span> mk_atom_set_ty<span class="main">:</span> typ <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> mk_atom_set<span class="main">:</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> mk_atom_fset_ty<span class="main">:</span> typ <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> mk_atom_fset<span class="main">:</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> mk_atom_list_ty<span class="main">:</span> typ <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> mk_atom_list<span class="main">:</span> term <span class="main">-&gt;</span> term

  <span class="keyword1"><span class="keyword">val</span></span> is_atom<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> typ <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> is_atom_set<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> typ <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> is_atom_fset<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> typ <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> is_atom_list<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> typ <span class="main">-&gt;</span> bool

  <span class="keyword1"><span class="keyword">val</span></span> to_set_ty<span class="main">:</span> typ <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> to_set<span class="main">:</span> term <span class="main">-&gt;</span> term

  <span class="keyword1"><span class="keyword">val</span></span> atomify_ty<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> typ <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> atomify<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> setify_ty<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> typ <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> setify<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> listify_ty<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> typ <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> listify<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term

  <span class="keyword1"><span class="keyword">val</span></span> fresh_ty<span class="main">:</span> typ <span class="main">-&gt;</span> typ
  <span class="keyword1"><span class="keyword">val</span></span> fresh_const<span class="main">:</span> typ <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> mk_fresh_ty<span class="main">:</span> typ <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> mk_fresh<span class="main">:</span> term <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term

  <span class="keyword1"><span class="keyword">val</span></span> fresh_star_ty<span class="main">:</span> typ <span class="main">-&gt;</span> typ
  <span class="keyword1"><span class="keyword">val</span></span> fresh_star_const<span class="main">:</span> typ <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> mk_fresh_star_ty<span class="main">:</span> typ <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> mk_fresh_star<span class="main">:</span> term <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term

  <span class="keyword1"><span class="keyword">val</span></span> supp_ty<span class="main">:</span> typ <span class="main">-&gt;</span> typ
  <span class="keyword1"><span class="keyword">val</span></span> supp_const<span class="main">:</span> typ <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> mk_supp_ty<span class="main">:</span> typ <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> mk_supp<span class="main">:</span> term <span class="main">-&gt;</span> term

  <span class="keyword1"><span class="keyword">val</span></span> supp_rel_ty<span class="main">:</span> typ <span class="main">-&gt;</span> typ
  <span class="keyword1"><span class="keyword">val</span></span> supp_rel_const<span class="main">:</span> typ <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> mk_supp_rel_ty<span class="main">:</span> typ <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> mk_supp_rel<span class="main">:</span> term <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term

  <span class="keyword1"><span class="keyword">val</span></span> supports_const<span class="main">:</span> typ <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> mk_supports_ty<span class="main">:</span> typ <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> mk_supports<span class="main">:</span> term <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term

  <span class="keyword1"><span class="keyword">val</span></span> finite_const<span class="main">:</span> typ <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> mk_finite_ty<span class="main">:</span> typ <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> mk_finite<span class="main">:</span> term <span class="main">-&gt;</span> term

  <span class="keyword1"><span class="keyword">val</span></span> mk_diff<span class="main">:</span> term * term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> mk_append<span class="main">:</span> term * term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> mk_union<span class="main">:</span> term * term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> fold_union<span class="main">:</span> term list <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> fold_append<span class="main">:</span> term list <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> mk_conj<span class="main">:</span> term * term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> fold_conj<span class="main">:</span> term list <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> fold_conj_balanced<span class="main">:</span> term list <span class="main">-&gt;</span> term

  <span class="comment1">(* functions for de-Bruijn open terms *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> mk_binop_env<span class="main">:</span> typ list <span class="main">-&gt;</span> string <span class="main">-&gt;</span> term * term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> mk_union_env<span class="main">:</span> typ list <span class="main">-&gt;</span> term * term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> fold_union_env<span class="main">:</span> typ list <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> term

  <span class="comment1">(* fresh arguments for a term *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> fresh_args<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term list

  <span class="comment1">(* some logic operations *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> strip_full_horn<span class="main">:</span> term <span class="main">-&gt;</span> <span class="main">(</span>string * typ<span class="main">)</span> list * term list * term
  <span class="keyword1"><span class="keyword">val</span></span> mk_full_horn<span class="main">:</span> <span class="main">(</span>string * typ<span class="main">)</span> list <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term

  <span class="comment1">(* datatype operations *)</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">cns_info</span> <span class="main">=</span> <span class="main">(</span>term * typ * typ list * bool list<span class="main">)</span> list

  <span class="keyword1"><span class="keyword">val</span></span> all_dtyp_constrs_types<span class="main">:</span> <span class="entity">Old_Datatype_Aux.descr</span> <span class="main">-&gt;</span> <span class="entity">cns_info</span> list

  <span class="comment1">(* tactics for function package *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> size_ss<span class="main">:</span> simpset
  <span class="keyword1"><span class="keyword">val</span></span> pat_completeness_simp<span class="main">:</span> thm list <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> tactic
  <span class="keyword1"><span class="keyword">val</span></span> prove_termination_ind<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> int <span class="main">-&gt;</span> tactic
  <span class="keyword1"><span class="keyword">val</span></span> prove_termination_fun<span class="main">:</span> thm list <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Function.info</span> * local_theory

  <span class="comment1">(* transformations of premises in inductions *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> transform_prem1<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string list <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> transform_prem2<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string list <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm

  <span class="comment1">(* transformation into the object logic *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> atomize<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> atomize_rule<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> int <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> atomize_concl<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm

  <span class="comment1">(* applies a tactic to a formula composed of conjunctions *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> conj_tac<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="main">(</span>int <span class="main">-&gt;</span> tactic<span class="main">)</span> <span class="main">-&gt;</span> int <span class="main">-&gt;</span> tactic
<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Nominal_Library</span><span class="main">:</span> <span class="entity">NOMINAL_LIBRARY</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_sort_of</span> <span class="entity">t</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"sort_of"</span><span class="antiquote">}</span></span> $ <span class="entity">t</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">atom_ty</span> <span class="entity">ty</span> <span class="main">=</span> <span class="entity">ty</span> --&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"atom"</span><span class="antiquote">}</span></span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">atom_const</span> <span class="entity">ty</span> <span class="main">=</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "atom"<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">atom_ty</span> <span class="entity">ty</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_atom_ty</span> <span class="entity">ty</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">atom_const</span> <span class="entity">ty</span> $ <span class="entity">t</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_atom</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">mk_atom_ty</span> <span class="main">(</span>fastype_of <span class="entity">t</span><span class="main">)</span> <span class="entity">t</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_atom_set_ty</span> <span class="entity">ty</span> <span class="entity">t</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">atom_ty</span> <span class="main">=</span> <span class="entity">HOLogic.dest_setT</span> <span class="entity">ty</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">img_ty</span> <span class="main">=</span> <span class="main">(</span><span class="entity">atom_ty</span> --&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">atom</span><span class="antiquote">}</span></span><span class="main">)</span> --&gt; <span class="entity">ty</span> --&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"atom set"</span><span class="antiquote">}</span></span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> image<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">img_ty</span><span class="main">)</span> $ <span class="entity">atom_const</span> <span class="entity">atom_ty</span> $ <span class="entity">t</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_atom_fset_ty</span> <span class="entity">ty</span> <span class="entity">t</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">atom_ty</span> <span class="main">=</span> <span class="entity">dest_fsetT</span> <span class="entity">ty</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fmap_ty</span> <span class="main">=</span> <span class="main">(</span><span class="entity">atom_ty</span> --&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">atom</span><span class="antiquote">}</span></span><span class="main">)</span> --&gt; <span class="entity">ty</span> --&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"atom fset"</span><span class="antiquote">}</span></span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> fimage<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">fmap_ty</span><span class="main">)</span> $ <span class="entity">atom_const</span> <span class="entity">atom_ty</span> $ <span class="entity">t</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_atom_list_ty</span> <span class="entity">ty</span> <span class="entity">t</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">atom_ty</span> <span class="main">=</span> <span class="entity">dest_listT</span> <span class="entity">ty</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">map_ty</span> <span class="main">=</span> <span class="main">(</span><span class="entity">atom_ty</span> --&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">atom</span><span class="antiquote">}</span></span><span class="main">)</span> --&gt; <span class="entity">ty</span> --&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"atom list"</span><span class="antiquote">}</span></span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> map<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">map_ty</span><span class="main">)</span> $ <span class="entity">atom_const</span> <span class="entity">atom_ty</span> $ <span class="entity">t</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_atom_set</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">mk_atom_set_ty</span> <span class="main">(</span>fastype_of <span class="entity">t</span><span class="main">)</span> <span class="entity">t</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_atom_fset</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">mk_atom_fset_ty</span> <span class="main">(</span>fastype_of <span class="entity">t</span><span class="main">)</span> <span class="entity">t</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_atom_list</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">mk_atom_list_ty</span> <span class="main">(</span>fastype_of <span class="entity">t</span><span class="main">)</span> <span class="entity">t</span>

<span class="comment1">(* coerces a list into a set *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">to_set_ty</span> <span class="entity">ty</span> <span class="entity">t</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ty</span> <span class="keyword2"><span class="keyword">of</span></span>
    <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"atom list"</span><span class="antiquote">}</span></span> <span class="main">=&gt;</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"set <span class="main">::</span> atom list <span class="main">=&gt;</span> atom set"</span><span class="antiquote">}</span></span> $ <span class="entity">t</span>
  <span class="main">|</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"atom fset"</span><span class="antiquote">}</span></span> <span class="main">=&gt;</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"fset <span class="main">::</span> atom fset <span class="main">=&gt;</span> atom set"</span><span class="antiquote">}</span></span> $ <span class="entity">t</span>
  <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">t</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">to_set</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">to_set_ty</span> <span class="main">(</span>fastype_of <span class="entity">t</span><span class="main">)</span> <span class="entity">t</span>


<span class="comment1">(* testing for concrete atom types *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_atom</span> <span class="entity">ctxt</span> <span class="entity">ty</span> <span class="main">=</span>
  Sign.of_sort <span class="main">(</span>Proof_Context.theory_of <span class="entity">ctxt</span><span class="main">)</span> <span class="main">(</span><span class="entity">ty</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">at_base</span><span class="antiquote">}</span></span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_atom_set</span> <span class="entity">ctxt</span> <span class="main">(</span>Type <span class="main">(</span><span class="inner_quoted">"fun"</span><span class="main">,</span> <span class="main">[</span><span class="entity">ty</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">bool</span><span class="antiquote">}</span></span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">is_atom</span> <span class="entity">ctxt</span> <span class="entity">ty</span>
  <span class="main">|</span> <span class="entity">is_atom_set</span> <span class="main">_</span> <span class="main">_</span> <span class="main">=</span> false<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_atom_fset</span> <span class="entity">ctxt</span> <span class="main">(</span>Type <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> "fset"<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">[</span><span class="entity">ty</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">is_atom</span> <span class="entity">ctxt</span> <span class="entity">ty</span>
  <span class="main">|</span> <span class="entity">is_atom_fset</span> <span class="main">_</span> <span class="main">_</span> <span class="main">=</span> false<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_atom_list</span> <span class="entity">ctxt</span> <span class="main">(</span>Type <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> "list"<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">[</span><span class="entity">ty</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">is_atom</span> <span class="entity">ctxt</span> <span class="entity">ty</span>
  <span class="main">|</span> <span class="entity">is_atom_list</span> <span class="main">_</span> <span class="main">_</span> <span class="main">=</span> false


<span class="comment1">(* functions that coerce singletons, sets, fsets and lists of concrete
   atoms into general atoms sets / lists *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">atomify_ty</span> <span class="entity">ctxt</span> <span class="entity">ty</span> <span class="entity">t</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_atom</span> <span class="entity">ctxt</span> <span class="entity">ty</span>
    <span class="keyword2"><span class="keyword">then</span></span>  <span class="entity">mk_atom_ty</span> <span class="entity">ty</span> <span class="entity">t</span>
  <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_atom_set</span> <span class="entity">ctxt</span> <span class="entity">ty</span>
    <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">mk_atom_set_ty</span> <span class="entity">ty</span> <span class="entity">t</span>
  <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_atom_fset</span> <span class="entity">ctxt</span> <span class="entity">ty</span>
    <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">mk_atom_fset_ty</span> <span class="entity">ty</span> <span class="entity">t</span>
  <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_atom_list</span> <span class="entity">ctxt</span> <span class="entity">ty</span>
    <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">mk_atom_list_ty</span> <span class="entity">ty</span> <span class="entity">t</span>
  <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword3"><span class="keyword">raise</span></span> TERM <span class="main">(</span><span class="inner_quoted">"atomify: term is not an atom, set or list of atoms"</span><span class="main">,</span> <span class="main">[</span><span class="entity">t</span><span class="main">]</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">setify_ty</span> <span class="entity">ctxt</span> <span class="entity">ty</span> <span class="entity">t</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_atom</span> <span class="entity">ctxt</span> <span class="entity">ty</span>
    <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">HOLogic.mk_set</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">atom</span><span class="antiquote">}</span></span> <span class="main">[</span><span class="entity">mk_atom_ty</span> <span class="entity">ty</span> <span class="entity">t</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_atom_set</span> <span class="entity">ctxt</span> <span class="entity">ty</span>
    <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">mk_atom_set_ty</span> <span class="entity">ty</span> <span class="entity">t</span>
  <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_atom_fset</span> <span class="entity">ctxt</span> <span class="entity">ty</span>
    <span class="keyword2"><span class="keyword">then</span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"fset <span class="main">::</span> atom fset <span class="main">=&gt;</span> atom set"</span><span class="antiquote">}</span></span> $ <span class="entity">mk_atom_fset_ty</span> <span class="entity">ty</span> <span class="entity">t</span>
  <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_atom_list</span> <span class="entity">ctxt</span> <span class="entity">ty</span>
    <span class="keyword2"><span class="keyword">then</span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"set <span class="main">::</span> atom list <span class="main">=&gt;</span> atom set"</span><span class="antiquote">}</span></span> $ <span class="entity">mk_atom_list_ty</span> <span class="entity">ty</span> <span class="entity">t</span>
  <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword3"><span class="keyword">raise</span></span> TERM <span class="main">(</span><span class="inner_quoted">"setify: term is not an atom, set or list of atoms"</span><span class="main">,</span> <span class="main">[</span><span class="entity">t</span><span class="main">]</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">listify_ty</span> <span class="entity">ctxt</span> <span class="entity">ty</span> <span class="entity">t</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_atom</span> <span class="entity">ctxt</span> <span class="entity">ty</span>
    <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">HOLogic.mk_list</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">atom</span><span class="antiquote">}</span></span> <span class="main">[</span><span class="entity">mk_atom_ty</span> <span class="entity">ty</span> <span class="entity">t</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_atom_list</span> <span class="entity">ctxt</span> <span class="entity">ty</span>
    <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">mk_atom_list_ty</span> <span class="entity">ty</span> <span class="entity">t</span>
  <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword3"><span class="keyword">raise</span></span> TERM <span class="main">(</span><span class="inner_quoted">"listify: term is not an atom or list of atoms"</span><span class="main">,</span> <span class="main">[</span><span class="entity">t</span><span class="main">]</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">atomify</span> <span class="entity">ctxt</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">atomify_ty</span> <span class="entity">ctxt</span> <span class="main">(</span>fastype_of <span class="entity">t</span><span class="main">)</span> <span class="entity">t</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">setify</span> <span class="entity">ctxt</span> <span class="entity">t</span>  <span class="main">=</span> <span class="entity">setify_ty</span> <span class="entity">ctxt</span> <span class="main">(</span>fastype_of <span class="entity">t</span><span class="main">)</span> <span class="entity">t</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">listify</span> <span class="entity">ctxt</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">listify_ty</span> <span class="entity">ctxt</span> <span class="main">(</span>fastype_of <span class="entity">t</span><span class="main">)</span> <span class="entity">t</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">fresh_ty</span> <span class="entity">ty</span> <span class="main">=</span> <span class="main">[</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">atom</span><span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">ty</span><span class="main">]</span> ---&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">bool</span><span class="antiquote">}</span></span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">fresh_const</span> <span class="entity">ty</span> <span class="main">=</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> fresh<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">fresh_ty</span> <span class="entity">ty</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_fresh_ty</span> <span class="entity">ty</span> <span class="entity">t1</span> <span class="entity">t2</span> <span class="main">=</span> <span class="entity">fresh_const</span> <span class="entity">ty</span> $ <span class="entity">t1</span> $ <span class="entity">t2</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_fresh</span> <span class="entity">t1</span> <span class="entity">t2</span> <span class="main">=</span> <span class="entity">mk_fresh_ty</span> <span class="main">(</span>fastype_of <span class="entity">t2</span><span class="main">)</span> <span class="entity">t1</span> <span class="entity">t2</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">fresh_star_ty</span> <span class="entity">ty</span> <span class="main">=</span> <span class="main">[</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"atom set"</span><span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">ty</span><span class="main">]</span> ---&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">bool</span><span class="antiquote">}</span></span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">fresh_star_const</span> <span class="entity">ty</span> <span class="main">=</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> fresh_star<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">fresh_star_ty</span> <span class="entity">ty</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_fresh_star_ty</span> <span class="entity">ty</span> <span class="entity">t1</span> <span class="entity">t2</span> <span class="main">=</span> <span class="entity">fresh_star_const</span> <span class="entity">ty</span> $ <span class="entity">t1</span> $ <span class="entity">t2</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_fresh_star</span> <span class="entity">t1</span> <span class="entity">t2</span> <span class="main">=</span> <span class="entity">mk_fresh_star_ty</span> <span class="main">(</span>fastype_of <span class="entity">t2</span><span class="main">)</span> <span class="entity">t1</span> <span class="entity">t2</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">supp_ty</span> <span class="entity">ty</span> <span class="main">=</span> <span class="entity">ty</span> --&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"atom set"</span><span class="antiquote">}</span></span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">supp_const</span> <span class="entity">ty</span> <span class="main">=</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> supp<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">supp_ty</span> <span class="entity">ty</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_supp_ty</span> <span class="entity">ty</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">supp_const</span> <span class="entity">ty</span> $ <span class="entity">t</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_supp</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">mk_supp_ty</span> <span class="main">(</span>fastype_of <span class="entity">t</span><span class="main">)</span> <span class="entity">t</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">supp_rel_ty</span> <span class="entity">ty</span> <span class="main">=</span> <span class="main">(</span><span class="main">[</span><span class="entity">ty</span><span class="main">,</span> <span class="entity">ty</span><span class="main">]</span> ---&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">bool</span><span class="antiquote">}</span></span><span class="main">)</span> --&gt; <span class="entity">ty</span> --&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"atom set"</span><span class="antiquote">}</span></span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">supp_rel_const</span> <span class="entity">ty</span> <span class="main">=</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> supp_rel<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">supp_rel_ty</span> <span class="entity">ty</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_supp_rel_ty</span> <span class="entity">ty</span> <span class="entity">r</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">supp_rel_const</span> <span class="entity">ty</span> $ <span class="entity">r</span> $ <span class="entity">t</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_supp_rel</span> <span class="entity">r</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">mk_supp_rel_ty</span> <span class="main">(</span>fastype_of <span class="entity">t</span><span class="main">)</span> <span class="entity">r</span> <span class="entity">t</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">supports_const</span> <span class="entity">ty</span> <span class="main">=</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> supports<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">[</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"atom set"</span><span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">ty</span><span class="main">]</span> ---&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">bool</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_supports_ty</span> <span class="entity">ty</span> <span class="entity">t1</span> <span class="entity">t2</span> <span class="main">=</span> <span class="entity">supports_const</span> <span class="entity">ty</span> $ <span class="entity">t1</span> $ <span class="entity">t2</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_supports</span> <span class="entity">t1</span> <span class="entity">t2</span> <span class="main">=</span> <span class="entity">mk_supports_ty</span> <span class="main">(</span>fastype_of <span class="entity">t2</span><span class="main">)</span> <span class="entity">t1</span> <span class="entity">t2</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">finite_const</span> <span class="entity">ty</span> <span class="main">=</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> finite<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">ty</span> --&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">bool</span><span class="antiquote">}</span></span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_finite_ty</span> <span class="entity">ty</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">finite_const</span> <span class="entity">ty</span> $ <span class="entity">t</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_finite</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">mk_finite_ty</span> <span class="main">(</span>fastype_of <span class="entity">t</span><span class="main">)</span> <span class="entity">t</span>


<span class="comment1">(* functions that construct differences, appends and unions
   but avoid producing empty atom sets or empty atom lists *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_diff</span> <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="main">{}</span><span class="main">::</span>atom set"</span><span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="main">{}</span><span class="main">::</span>atom set"</span><span class="antiquote">}</span></span>
  <span class="main">|</span> <span class="entity">mk_diff</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="main">{}</span><span class="main">::</span>atom set"</span><span class="antiquote">}</span></span><span class="main">)</span> <span class="main">=</span> <span class="entity">t1</span>
  <span class="main">|</span> <span class="entity">mk_diff</span> <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"set <span class="main">(</span><span class="main">[]</span><span class="main">::</span>atom list<span class="main">)</span>"</span><span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"set <span class="main">(</span><span class="main">[]</span><span class="main">::</span>atom list<span class="main">)</span>"</span><span class="antiquote">}</span></span>
  <span class="main">|</span> <span class="entity">mk_diff</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"set <span class="main">(</span><span class="main">[]</span><span class="main">::</span>atom list<span class="main">)</span>"</span><span class="antiquote">}</span></span><span class="main">)</span> <span class="main">=</span> <span class="entity">t1</span>
  <span class="main">|</span> <span class="entity">mk_diff</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">HOLogic.mk_binop</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> minus<span class="antiquote">}</span></span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_append</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="main">[]</span><span class="main">::</span>atom list"</span><span class="antiquote">}</span></span><span class="main">)</span> <span class="main">=</span> <span class="entity">t1</span>
  <span class="main">|</span> <span class="entity">mk_append</span> <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="main">[]</span><span class="main">::</span>atom list"</span><span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">t2</span>
  <span class="main">|</span> <span class="entity">mk_append</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">HOLogic.mk_binop</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "append"<span class="antiquote">}</span></span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_union</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="main">{}</span><span class="main">::</span>atom set"</span><span class="antiquote">}</span></span><span class="main">)</span> <span class="main">=</span> <span class="entity">t1</span>
  <span class="main">|</span> <span class="entity">mk_union</span> <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="main">{}</span><span class="main">::</span>atom set"</span><span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">t2</span>
  <span class="main">|</span> <span class="entity">mk_union</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"set <span class="main">(</span><span class="main">[]</span><span class="main">::</span>atom list<span class="main">)</span>"</span><span class="antiquote">}</span></span><span class="main">)</span> <span class="main">=</span> <span class="entity">t1</span>
  <span class="main">|</span> <span class="entity">mk_union</span> <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"set <span class="main">(</span><span class="main">[]</span><span class="main">::</span>atom list<span class="main">)</span>"</span><span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">t2</span>
  <span class="main">|</span> <span class="entity">mk_union</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">HOLogic.mk_binop</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "sup"<span class="antiquote">}</span></span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">fold_union</span> <span class="entity">trms</span> <span class="main">=</span> fold_rev <span class="main">(</span>curry <span class="entity">mk_union</span><span class="main">)</span> <span class="entity">trms</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="main">{}</span><span class="main">::</span>atom set"</span><span class="antiquote">}</span></span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">fold_append</span> <span class="entity">trms</span> <span class="main">=</span> fold_rev <span class="main">(</span>curry <span class="entity">mk_append</span><span class="main">)</span> <span class="entity">trms</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="main">[]</span><span class="main">::</span>atom list"</span><span class="antiquote">}</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_conj</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"True"</span><span class="antiquote">}</span></span><span class="main">)</span> <span class="main">=</span> <span class="entity">t1</span>
  <span class="main">|</span> <span class="entity">mk_conj</span> <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"True"</span><span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">t2</span>
  <span class="main">|</span> <span class="entity">mk_conj</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">HOLogic.mk_conj</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">fold_conj</span> <span class="entity">trms</span> <span class="main">=</span> fold_rev <span class="main">(</span>curry <span class="entity">mk_conj</span><span class="main">)</span> <span class="entity">trms</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"True"</span><span class="antiquote">}</span></span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">fold_conj_balanced</span> <span class="entity">ts</span> <span class="main">=</span> Balanced_Tree.make <span class="entity">HOLogic.mk_conj</span> <span class="entity">ts</span>


<span class="comment1">(* functions for de-Bruijn open terms *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_binop_env</span> <span class="entity">tys</span> <span class="entity">c</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">u</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty</span> <span class="main">=</span> fastype_of1 <span class="main">(</span><span class="entity">tys</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Const <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="main">[</span><span class="entity">ty</span><span class="main">,</span> <span class="entity">ty</span><span class="main">]</span> ---&gt; <span class="entity">ty</span><span class="main">)</span> $ <span class="entity">t</span> $ <span class="entity">u</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_union_env</span> <span class="entity">tys</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="main">{}</span><span class="main">::</span>atom set"</span><span class="antiquote">}</span></span><span class="main">)</span> <span class="main">=</span> <span class="entity">t1</span>
  <span class="main">|</span> <span class="entity">mk_union_env</span> <span class="entity">tys</span> <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="main">{}</span><span class="main">::</span>atom set"</span><span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">t2</span>
  <span class="main">|</span> <span class="entity">mk_union_env</span> <span class="entity">tys</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"set <span class="main">(</span><span class="main">[]</span><span class="main">::</span>atom list<span class="main">)</span>"</span><span class="antiquote">}</span></span><span class="main">)</span> <span class="main">=</span> <span class="entity">t1</span>
  <span class="main">|</span> <span class="entity">mk_union_env</span> <span class="entity">tys</span> <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"set <span class="main">(</span><span class="main">[]</span><span class="main">::</span>atom list<span class="main">)</span>"</span><span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">t2</span>
  <span class="main">|</span> <span class="entity">mk_union_env</span> <span class="entity">tys</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mk_binop_env</span> <span class="entity">tys</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "sup"<span class="antiquote">}</span></span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">fold_union_env</span> <span class="entity">tys</span> <span class="entity">trms</span> <span class="main">=</span> <span class="entity">fold_left</span> <span class="main">(</span><span class="entity">mk_union_env</span> <span class="entity">tys</span><span class="main">)</span> <span class="entity">trms</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="main">{}</span><span class="main">::</span>atom set"</span><span class="antiquote">}</span></span>


<span class="comment1">(* produces fresh arguments for a term *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">fresh_args</span> <span class="entity">ctxt</span> <span class="entity">f</span> <span class="main">=</span>
    <span class="entity">f</span> |&gt; fastype_of
      |&gt; binder_types
      |&gt; map <span class="main">(</span>pair <span class="inner_quoted">"z"</span><span class="main">)</span>
      |&gt; Variable.variant_frees <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">f</span><span class="main">]</span>
      |&gt; map Free


<span class="comment1">(** some logic operations **)</span>

<span class="comment1">(* decompses a formula into params, premises and a conclusion *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">strip_full_horn</span> <span class="entity">trm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">strip_outer_params</span> <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Pure.all<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ Abs <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">strip_outer_params</span> <span class="entity">t</span> |&gt;&gt; cons <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">strip_outer_params</span> <span class="entity">B</span> <span class="main">=</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">B</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">params</span><span class="main">,</span> <span class="entity">body</span><span class="main">)</span> <span class="main">=</span> <span class="entity">strip_outer_params</span> <span class="entity">trm</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">prems</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span> <span class="main">=</span> Logic.strip_horn <span class="entity">body</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="entity">params</span><span class="main">,</span> <span class="entity">prems</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* composes a formula out of params, premises and a conclusion *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_full_horn</span> <span class="entity">params</span> <span class="entity">prems</span> <span class="entity">concl</span> <span class="main">=</span>
  Logic.list_implies <span class="main">(</span><span class="entity">prems</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span>
  |&gt; fold_rev <span class="entity">mk_all</span> <span class="entity">params</span>

<span class="comment1">(** datatypes **)</span>

<span class="comment1">(* constructor infos *)</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">cns_info</span> <span class="main">=</span> <span class="main">(</span>term * typ * typ list * bool list<span class="main">)</span> list

<span class="comment1">(*  - term for constructor constant
    - type of the constructor
    - types of the arguments
    - flags indicating whether the argument is recursive
*)</span>

<span class="comment1">(* returns info about constructors in a datatype *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">all_dtyp_constrs_info</span> <span class="entity">descr</span> <span class="main">=</span>
  map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">(</span><span class="entity">ty</span><span class="main">,</span> <span class="entity">vs</span><span class="main">,</span> <span class="entity">constrs</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span> map <span class="main">(</span>pair <span class="main">(</span><span class="entity">ty</span><span class="main">,</span> <span class="entity">vs</span><span class="main">)</span><span class="main">)</span> <span class="entity">constrs</span><span class="main">)</span> <span class="entity">descr</span>

<span class="comment1">(* returns the constants of the constructors plus the
   corresponding type and types of arguments *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">all_dtyp_constrs_types</span> <span class="entity">descr</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">aux</span> <span class="main">(</span><span class="main">(</span><span class="entity">ty_name</span><span class="main">,</span> <span class="entity">vs</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">cname</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vs_tys</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">Old_Datatype_Aux.typ_of_dtyp</span> <span class="entity">descr</span><span class="main">)</span> <span class="entity">vs</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty</span> <span class="main">=</span> Type <span class="main">(</span><span class="entity">ty_name</span><span class="main">,</span> <span class="entity">vs_tys</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg_tys</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">Old_Datatype_Aux.typ_of_dtyp</span> <span class="entity">descr</span><span class="main">)</span> <span class="entity">args</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">is_rec</span> <span class="main">=</span> map <span class="entity">Old_Datatype_Aux.is_rec_type</span> <span class="entity">args</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span>Const <span class="main">(</span><span class="entity">cname</span><span class="main">,</span> <span class="entity">arg_tys</span> ---&gt; <span class="entity">ty</span><span class="main">)</span><span class="main">,</span> <span class="entity">ty</span><span class="main">,</span> <span class="entity">arg_tys</span><span class="main">,</span> <span class="entity">is_rec</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">in</span></span>
    map <span class="main">(</span>map <span class="entity">aux</span><span class="main">)</span> <span class="main">(</span><span class="entity">all_dtyp_constrs_info</span> <span class="entity">descr</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(** function package tactics **)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pat_completeness_simp</span> <span class="entity">simps</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simpset</span> <span class="main">=</span>
      put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span> addsimps <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> sum.inject sum.distinct<span class="antiquote">}</span></span></span> @ <span class="entity">simps</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">Pat_Completeness.pat_completeness_tac</span> <span class="entity">ctxt</span> <span class="inner_numeral">1</span>
      THEN ALLGOALS <span class="main">(</span><span class="entity">asm_full_simp_tac</span> <span class="entity">simpset</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* simpset for size goals *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">size_ss</span> <span class="main">=</span>
  simpset_of <span class="main">(</span>put_simpset <span class="entity">HOL_ss</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span>
   addsimprocs <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">simproc</span> natless_cancel_numerals<span class="antiquote">}</span></span></span><span class="main">]</span>
   addsimps <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> in_measure wf_measure sum.case add_Suc_right add.right_neutral
     zero_less_Suc prod.size<span class="main">(</span>1<span class="main">)</span> mult_Suc_right<span class="antiquote">}</span></span></span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">natT</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">nat</span><span class="antiquote">}</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">size_prod_const</span> <span class="entity">T1</span> <span class="entity">T2</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">T1_fun</span> <span class="main">=</span> <span class="entity">T1</span> --&gt; <span class="entity">natT</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">T2_fun</span> <span class="main">=</span> <span class="entity">T2</span> --&gt; <span class="entity">natT</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prodT</span> <span class="main">=</span> <span class="entity">HOLogic.mk_prodT</span> <span class="main">(</span><span class="entity">T1</span><span class="main">,</span> <span class="entity">T2</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> size_prod<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">[</span><span class="entity">T1_fun</span><span class="main">,</span> <span class="entity">T2_fun</span><span class="main">,</span> <span class="entity">prodT</span><span class="main">]</span> ---&gt; <span class="entity">natT</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">snd_const</span> <span class="entity">T1</span> <span class="entity">T2</span> <span class="main">=</span>
  Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Product_Type.snd<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">HOLogic.mk_prodT</span> <span class="main">(</span><span class="entity">T1</span><span class="main">,</span> <span class="entity">T2</span><span class="main">)</span> --&gt; <span class="entity">T2</span><span class="main">)</span>


<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_measure_trm</span> <span class="entity">f</span> <span class="entity">ctxt</span> <span class="entity">T</span> <span class="main">=</span>
  <span class="entity">HOLogic.dest_setT</span> <span class="entity">T</span>
  |&gt; fst o <span class="entity">HOLogic.dest_prodT</span>
  |&gt; <span class="entity">f</span>
  |&gt; curry <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> $<span class="main">)</span> <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "measure"<span class="antiquote">}</span></span><span class="main">,</span> dummyT<span class="main">)</span><span class="main">)</span>
  |&gt; Syntax.check_term <span class="entity">ctxt</span>

<span class="comment1">(* wf-goal arising in induction_schema *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_termination_ind</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_size_measure</span> <span class="entity">T</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">T</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">(</span>Type <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> Sum_Type.sum<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">[</span><span class="entity">T1</span><span class="main">,</span> <span class="entity">T2</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span>
           <span class="entity">Sum_Tree.mk_sumcase</span> <span class="entity">T1</span> <span class="entity">T2</span> <span class="entity">natT</span> <span class="main">(</span><span class="entity">mk_size_measure</span> <span class="entity">T1</span><span class="main">)</span> <span class="main">(</span><span class="entity">mk_size_measure</span> <span class="entity">T2</span><span class="main">)</span>
      <span class="main">|</span> <span class="main">(</span>Type <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> Product_Type.prod<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">[</span><span class="entity">T1</span><span class="main">,</span> <span class="entity">T2</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span>
           <span class="entity">HOLogic.mk_comp</span> <span class="main">(</span><span class="entity">mk_size_measure</span> <span class="entity">T2</span><span class="main">,</span> <span class="entity">snd_const</span> <span class="entity">T1</span> <span class="entity">T2</span><span class="main">)</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">HOLogic.size_const</span> <span class="entity">T</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">measure_trm</span> <span class="main">=</span> <span class="entity">mk_measure_trm</span> <span class="main">(</span><span class="entity">mk_size_measure</span><span class="main">)</span> <span class="entity">ctxt</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">Function_Relation.relation_tac</span> <span class="entity">ctxt</span> <span class="entity">measure_trm</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* wf-goal arising in function definitions *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_termination_fun</span> <span class="entity">size_simps</span> <span class="entity">ctxt</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_size_measure</span> <span class="entity">T</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">T</span> <span class="keyword2"><span class="keyword">of</span></span>
      <span class="main">(</span>Type <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> Sum_Type.sum<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">[</span><span class="entity">T1</span><span class="main">,</span> <span class="entity">T2</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span>
         <span class="entity">Sum_Tree.mk_sumcase</span> <span class="entity">T1</span> <span class="entity">T2</span> <span class="entity">natT</span> <span class="main">(</span><span class="entity">mk_size_measure</span> <span class="entity">T1</span><span class="main">)</span> <span class="main">(</span><span class="entity">mk_size_measure</span> <span class="entity">T2</span><span class="main">)</span>
    <span class="main">|</span> <span class="main">(</span>Type <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> Product_Type.prod<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">[</span><span class="entity">T1</span><span class="main">,</span> <span class="entity">T2</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span>
         <span class="entity">size_prod_const</span> <span class="entity">T1</span> <span class="entity">T2</span> $ <span class="main">(</span><span class="entity">mk_size_measure</span> <span class="entity">T1</span><span class="main">)</span> $ <span class="main">(</span><span class="entity">mk_size_measure</span> <span class="entity">T2</span><span class="main">)</span>
    <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">HOLogic.size_const</span> <span class="entity">T</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">measure_trm</span> <span class="main">=</span> <span class="entity">mk_measure_trm</span> <span class="main">(</span><span class="entity">mk_size_measure</span><span class="main">)</span> <span class="entity">ctxt</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tac</span> <span class="main">=</span>
    <span class="entity">Function_Relation.relation_tac</span> <span class="entity">ctxt</span> <span class="entity">measure_trm</span>
    THEN_ALL_NEW <span class="entity">simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">size_ss</span> <span class="entity">ctxt</span> addsimps <span class="entity">size_simps</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">Function.prove_termination</span> NONE <span class="main">(</span>HEADGOAL <span class="entity">tac</span><span class="main">)</span> <span class="entity">ctxt</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(** transformations of premises (in inductive proofs) **)</span>

<span class="comment1">(*
 given the theorem F[t]; proves the theorem F[f t]

  - F needs to be monotone
  - f returns either SOME for a term it fires on
    and NONE elsewhere
*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_term</span> <span class="entity">f</span> <span class="entity">t</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">f</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
     NONE <span class="main">=&gt;</span> <span class="entity">map_term'</span> <span class="entity">f</span> <span class="entity">t</span>
   <span class="main">|</span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="entity">x</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">map_term'</span> <span class="entity">f</span> <span class="main">(</span><span class="entity">t</span> $ <span class="entity">u</span><span class="main">)</span> <span class="main">=</span>
    <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="main">(</span><span class="entity">map_term</span> <span class="entity">f</span> <span class="entity">t</span><span class="main">,</span> <span class="entity">map_term</span> <span class="entity">f</span> <span class="entity">u</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">(</span>NONE<span class="main">,</span> NONE<span class="main">)</span> <span class="main">=&gt;</span> NONE
      <span class="main">|</span> <span class="main">(</span>SOME <span class="entity">t''</span><span class="main">,</span> NONE<span class="main">)</span> <span class="main">=&gt;</span> SOME <span class="main">(</span><span class="entity">t''</span> $ <span class="entity">u</span><span class="main">)</span>
      <span class="main">|</span> <span class="main">(</span>NONE<span class="main">,</span> SOME <span class="entity">u''</span><span class="main">)</span> <span class="main">=&gt;</span> SOME <span class="main">(</span><span class="entity">t</span> $ <span class="entity">u''</span><span class="main">)</span>
      <span class="main">|</span> <span class="main">(</span>SOME <span class="entity">t''</span><span class="main">,</span> SOME <span class="entity">u''</span><span class="main">)</span> <span class="main">=&gt;</span> SOME <span class="main">(</span><span class="entity">t''</span> $ <span class="entity">u''</span><span class="main">)</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">map_term'</span> <span class="entity">f</span> <span class="main">(</span>Abs <span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
      <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">map_term</span> <span class="entity">f</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
        NONE <span class="main">=&gt;</span> NONE
      <span class="main">|</span> SOME <span class="entity">t''</span> <span class="main">=&gt;</span> SOME <span class="main">(</span>Abs <span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">t''</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">map_term'</span> <span class="main">_</span> <span class="main">_</span>  <span class="main">=</span> NONE<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_thm_tac</span> <span class="entity">ctxt</span> <span class="entity">tac</span> <span class="entity">thm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">monos</span> <span class="main">=</span> <span class="entity">Inductive.get_monos</span> <span class="entity">ctxt</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simpset</span> <span class="main">=</span> put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span> addsimps <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> split_def<span class="antiquote">}</span></span></span>
  <span class="keyword2"><span class="keyword">in</span></span>
    EVERY <span class="main">[</span>cut_facts_tac <span class="main">[</span><span class="entity">thm</span><span class="main">]</span> <span class="inner_numeral">1</span><span class="main">,</span> eresolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">rev_mp</span><span class="main">]</span> <span class="inner_numeral">1</span><span class="main">,</span>
      REPEAT_DETERM <span class="main">(</span>FIRSTGOAL <span class="main">(</span><span class="entity">simp_tac</span> <span class="entity">simpset</span> THEN' resolve_tac <span class="entity">ctxt</span> <span class="entity">monos</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
      REPEAT_DETERM <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">impI</span><span class="main">]</span> <span class="inner_numeral">1</span> THEN <span class="main">(</span>assume_tac <span class="entity">ctxt</span> <span class="inner_numeral">1</span> ORELSE <span class="entity">tac</span><span class="main">)</span><span class="main">)</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_thm</span> <span class="entity">ctxt</span> <span class="entity">f</span> <span class="entity">tac</span> <span class="entity">thm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">opt_goal_trm</span> <span class="main">=</span> <span class="entity">map_term</span> <span class="entity">f</span> <span class="main">(</span>Thm.prop_of <span class="entity">thm</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">opt_goal_trm</span> <span class="keyword2"><span class="keyword">of</span></span>
      NONE <span class="main">=&gt;</span> <span class="entity">thm</span>
    <span class="main">|</span> SOME <span class="entity">goal</span> <span class="main">=&gt;</span>
        Goal.prove <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">goal</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">map_thm_tac</span> <span class="entity">ctxt</span> <span class="entity">tac</span> <span class="entity">thm</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(*
 inductive premises can be of the form

     R ... /\ P ...;

 split_conj_i picks out the part R or P part
*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">split_conj1</span> <span class="entity">names</span> <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "conj"<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="entity">f1</span> $ <span class="main">_</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> head_of <span class="entity">f1</span> <span class="keyword2"><span class="keyword">of</span></span>
     Const <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> member <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">names</span> <span class="entity">name</span> <span class="keyword2"><span class="keyword">then</span></span> SOME <span class="entity">f1</span> <span class="keyword2"><span class="keyword">else</span></span> NONE
   <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> NONE<span class="main">)</span>
<span class="main">|</span> <span class="entity">split_conj1</span> <span class="main">_</span> <span class="main">_</span> <span class="main">=</span> NONE<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">split_conj2</span> <span class="entity">names</span> <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "conj"<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="entity">f1</span> $ <span class="entity">f2</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> head_of <span class="entity">f1</span> <span class="keyword2"><span class="keyword">of</span></span>
     Const <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> member <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">names</span> <span class="entity">name</span> <span class="keyword2"><span class="keyword">then</span></span> SOME <span class="entity">f2</span> <span class="keyword2"><span class="keyword">else</span></span> NONE
   <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> NONE<span class="main">)</span>
<span class="main">|</span> <span class="entity">split_conj2</span> <span class="main">_</span> <span class="main">_</span> <span class="main">=</span> NONE<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">transform_prem1</span> <span class="entity">ctxt</span> <span class="entity">names</span> <span class="entity">thm</span> <span class="main">=</span>
  <span class="entity">map_thm</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">split_conj1</span> <span class="entity">names</span><span class="main">)</span> <span class="main">(</span>eresolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">conjunct1</span><span class="main">]</span> <span class="inner_numeral">1</span><span class="main">)</span> <span class="entity">thm</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">transform_prem2</span> <span class="entity">ctxt</span> <span class="entity">names</span> <span class="entity">thm</span> <span class="main">=</span>
  <span class="entity">map_thm</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">split_conj2</span> <span class="entity">names</span><span class="main">)</span> <span class="main">(</span>eresolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">conjunct2</span><span class="main">]</span> <span class="inner_numeral">1</span><span class="main">)</span> <span class="entity">thm</span>


<span class="comment1">(* transforms a theorem into one of the object logic *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">atomize</span> <span class="entity">ctxt</span> <span class="main">=</span> Conv.fconv_rule <span class="main">(</span>Object_Logic.atomize <span class="entity">ctxt</span><span class="main">)</span> o forall_intr_vars<span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">atomize_rule</span> <span class="entity">ctxt</span> <span class="entity">i</span> <span class="entity">thm</span> <span class="main">=</span>
  Conv.fconv_rule <span class="main">(</span>Conv.concl_conv <span class="entity">i</span> <span class="main">(</span>Object_Logic.atomize <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span> <span class="entity">thm</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">atomize_concl</span> <span class="entity">ctxt</span> <span class="entity">thm</span> <span class="main">=</span> <span class="entity">atomize_rule</span> <span class="entity">ctxt</span> <span class="main">(</span>length <span class="main">(</span>Thm.prems_of <span class="entity">thm</span><span class="main">)</span><span class="main">)</span> <span class="entity">thm</span>


<span class="comment1">(* applies a tactic to a formula composed of conjunctions *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">conj_tac</span> <span class="entity">ctxt</span> <span class="entity">tac</span> <span class="entity">i</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
     <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">select</span> <span class="main">(</span><span class="entity">trm</span><span class="main">,</span> <span class="entity">i</span><span class="main">)</span> <span class="main">=</span>
       <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">trm</span> <span class="keyword2"><span class="keyword">of</span></span>
         <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"Trueprop"</span><span class="antiquote">}</span></span> $ <span class="entity">t'</span> <span class="main">=&gt;</span> <span class="entity">select</span> <span class="main">(</span><span class="entity">t'</span><span class="main">,</span> <span class="entity">i</span><span class="main">)</span>
       <span class="main">|</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="main">(&amp;)</span>"</span><span class="antiquote">}</span></span> $ <span class="main">_</span> $ <span class="main">_</span> <span class="main">=&gt;</span>
          EVERY' <span class="main">[</span>resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> conjI<span class="antiquote">}</span></span></span><span class="main">,</span> RANGE <span class="main">[</span><span class="entity">conj_tac</span> <span class="entity">ctxt</span> <span class="entity">tac</span><span class="main">,</span> <span class="entity">conj_tac</span> <span class="entity">ctxt</span> <span class="entity">tac</span><span class="main">]</span><span class="main">]</span> <span class="entity">i</span>
       <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">tac</span> <span class="entity">i</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    SUBGOAL <span class="entity">select</span> <span class="entity">i</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* structure *)</span>

<span class="keyword3"><span class="keyword">open</span></span> <span class="entity">Nominal_Library</span><span class="main">;</span>
</pre>
</div><div id="files/nominal_atoms.ML">
<div class="head">
<h1>File ‹nominal_atoms.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      nominal_atoms/ML
    Authors:    Brian Huffman, Christian Urban

    Command for defining concrete atom types.

    At the moment, only single-sorted atom types
    are supported.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">ATOM_DECL</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> add_atom_decl<span class="main">:</span> <span class="main">(</span>binding * <span class="main">(</span>binding option<span class="main">)</span><span class="main">)</span> <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Atom_Decl</span> <span class="main">:</span> <span class="entity">ATOM_DECL</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simp_attr</span> <span class="main">=</span> <span class="entity">Attrib.internal</span> <span class="main">(</span>K <span class="entity">Simplifier.simp_add</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">atom_decl_set</span> <span class="main">(</span><span class="entity">str</span> <span class="main">:</span> string<span class="main">)</span> <span class="main">:</span> term <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">a</span> <span class="main">=</span> Free <span class="main">(</span><span class="inner_quoted">"a"</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">atom</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">s</span> <span class="main">=</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "Sort"<span class="antiquote">}</span></span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"string <span class="main">=&gt;</span> atom_sort list <span class="main">=&gt;</span> atom_sort"</span><span class="antiquote">}</span></span><span class="main">)</span>
              $ <span class="entity">HOLogic.mk_string</span> <span class="entity">str</span> $ <span class="entity">HOLogic.nil_const</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"atom_sort"</span><span class="antiquote">}</span></span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">HOLogic.mk_Collect</span> <span class="main">(</span><span class="inner_quoted">"a"</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">atom</span><span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">mk_sort_of</span> <span class="entity">a</span><span class="main">,</span> <span class="entity">s</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_atom_decl</span> <span class="main">(</span><span class="entity">name</span> <span class="main">:</span> binding<span class="main">,</span> <span class="entity">arg</span> <span class="main">:</span> binding option<span class="main">)</span> <span class="main">(</span><span class="entity">thy</span> <span class="main">:</span> theory<span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">str</span> <span class="main">=</span> Sign.full_name <span class="entity">thy</span> <span class="entity">name</span><span class="main">;</span>

    <span class="comment1">(* typedef *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">set</span> <span class="main">=</span> <span class="entity">atom_decl_set</span> <span class="entity">str</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tac</span> <span class="entity">ctxt</span> <span class="main">=</span> resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> exists_eq_simple_sort<span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">full_tname</span><span class="main">,</span> <span class="entity">info</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">(</span><span class="main">{</span><span class="entity">Rep_name</span><span class="main">,</span> <span class="entity">Abs_name</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">,</span> <span class="main">{</span><span class="entity">type_definition</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">thy</span>
      |&gt; <span class="entity">Named_Target.theory_map_result</span> <span class="main">(</span>apsnd o <span class="entity">Typedef.transform_info</span><span class="main">)</span>
        <span class="main">(</span><span class="entity">Typedef.add_typedef</span> <span class="main">{</span>overloaded <span class="main">=</span> false<span class="main">}</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> NoSyn<span class="main">)</span> <span class="entity">set</span> NONE <span class="entity">tac</span><span class="main">)</span><span class="main">;</span>

    <span class="comment1">(* definition of atom and permute *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">newT</span> <span class="main">=</span> <span class="main">#</span>abs_type <span class="main">(</span>fst <span class="entity">info</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">RepC</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">Rep_name</span><span class="main">,</span> <span class="entity">newT</span> --&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">atom</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">AbsC</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">Abs_name</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">atom</span><span class="antiquote">}</span></span> --&gt; <span class="entity">newT</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">a</span> <span class="main">=</span> Free <span class="main">(</span><span class="inner_quoted">"a"</span><span class="main">,</span> <span class="entity">newT</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">p</span> <span class="main">=</span> Free <span class="main">(</span><span class="inner_quoted">"p"</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">perm</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">atom_eqn</span> <span class="main">=</span>
      <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">mk_atom</span> <span class="entity">a</span><span class="main">,</span> <span class="entity">RepC</span> $ <span class="entity">a</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">permute_eqn</span> <span class="main">=</span>
      <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">HOLogic.mk_eq</span>
        <span class="main">(</span><span class="entity">mk_perm</span> <span class="entity">p</span> <span class="entity">a</span><span class="main">,</span> <span class="entity">AbsC</span> $ <span class="main">(</span><span class="entity">mk_perm</span> <span class="entity">p</span> <span class="main">(</span><span class="entity">RepC</span> $ <span class="entity">a</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">atom_def_name</span> <span class="main">=</span>
      Binding.prefix_name <span class="inner_quoted">"atom_"</span> <span class="main">(</span>Binding.suffix_name <span class="inner_quoted">"_def"</span> <span class="entity">name</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sort_thm_name</span> <span class="main">=</span>
      Binding.prefix_name <span class="inner_quoted">"atom_"</span> <span class="main">(</span>Binding.suffix_name <span class="inner_quoted">"_sort"</span> <span class="entity">name</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">permute_def_name</span> <span class="main">=</span>
      Binding.prefix_name <span class="inner_quoted">"permute_"</span> <span class="main">(</span>Binding.suffix_name <span class="inner_quoted">"_def"</span> <span class="entity">name</span><span class="main">)</span><span class="main">;</span>

    <span class="comment1">(* at class instance *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lthy</span> <span class="main">=</span>
      <span class="entity">Class.instantiation</span> <span class="main">(</span><span class="main">[</span><span class="entity">full_tname</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">at</span><span class="antiquote">}</span></span><span class="main">)</span> <span class="entity">thy</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">permute_ldef</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">Specification.definition</span> NONE <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="main">(</span><span class="entity">permute_def_name</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">permute_eqn</span><span class="main">)</span> <span class="entity">lthy</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">atom_ldef</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">Specification.definition</span> NONE <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="main">(</span><span class="entity">atom_def_name</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">atom_eqn</span><span class="main">)</span> <span class="entity">lthy</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt_thy</span> <span class="main">=</span> Proof_Context.init_global <span class="main">(</span>Proof_Context.theory_of <span class="entity">lthy</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">permute_def</span> <span class="main">=</span> singleton <span class="main">(</span>Proof_Context.export <span class="entity">lthy</span> <span class="entity">ctxt_thy</span><span class="main">)</span> <span class="entity">permute_ldef</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">atom_def</span> <span class="main">=</span> singleton <span class="main">(</span>Proof_Context.export <span class="entity">lthy</span> <span class="entity">ctxt_thy</span><span class="main">)</span> <span class="entity">atom_ldef</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">class_thm</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> at_class<span class="antiquote">}</span></span></span> OF <span class="main">[</span><span class="entity">type_definition</span><span class="main">,</span> <span class="entity">atom_def</span><span class="main">,</span> <span class="entity">permute_def</span><span class="main">]</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sort_thm</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> at_class_sort<span class="antiquote">}</span></span></span> OF <span class="main">[</span><span class="entity">type_definition</span><span class="main">,</span> <span class="entity">atom_def</span><span class="main">]</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> <span class="entity">lthy</span>
      |&gt; snd o <span class="main">(</span>Local_Theory.note <span class="main">(</span><span class="main">(</span><span class="entity">sort_thm_name</span><span class="main">,</span> <span class="main">[</span><span class="entity">simp_attr</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="entity">sort_thm</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
      |&gt; <span class="entity">Class.prove_instantiation_instance</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">class_thm</span><span class="main">]</span> <span class="inner_numeral">1</span><span class="main">)</span>
      |&gt; Local_Theory.exit_global<span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">thy</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** outer syntax **)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> <span class="keyword1">atom_decl</span><span class="antiquote">}</span></span></span>
    <span class="inner_quoted">"declaration of a concrete atom type"</span>
      <span class="main">(</span><span class="main">(</span>Parse.binding -- Scan.option <span class="main">(</span>Args.parens <span class="main">(</span>Parse.binding<span class="main">)</span><span class="main">)</span><span class="main">)</span> &gt;&gt;
        <span class="main">(</span><span class="entity">Toplevel.theory</span> o <span class="entity">add_atom_decl</span><span class="main">)</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
</pre>
</div><div id="files/nominal_eqvt.ML">
<div class="head">
<h1>File ‹nominal_eqvt.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      nominal_eqvt.ML
    Author:     Stefan Berghofer (original code)
    Author:     Christian Urban
    Author:     Tjark Weber

    Automatic proofs for equivariance of inductive predicates.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">NOMINAL_EQVT</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> raw_equivariance<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> thm list
  <span class="keyword1"><span class="keyword">val</span></span> equivariance_cmd<span class="main">:</span> string <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> local_theory
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Nominal_Eqvt</span> <span class="main">:</span> <span class="entity">NOMINAL_EQVT</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword3"><span class="keyword">open</span></span> Nominal_Permeq<span class="main">;</span>
<span class="keyword3"><span class="keyword">open</span></span> Nominal_ThmDecls<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">atomize_conv</span> <span class="entity">ctxt</span> <span class="main">=</span>
  Raw_Simplifier.rewrite_cterm <span class="main">(</span>true<span class="main">,</span> false<span class="main">,</span> false<span class="main">)</span> <span class="main">(</span>K <span class="main">(</span>K NONE<span class="main">)</span><span class="main">)</span>
    <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span> addsimps <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> induct_atomize<span class="antiquote">}</span></span></span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">atomize_intr</span> <span class="entity">ctxt</span> <span class="main">=</span> Conv.fconv_rule <span class="main">(</span>Conv.prems_conv <span class="inner_numeral">~1</span> <span class="main">(</span><span class="entity">atomize_conv</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">atomize_induct</span> <span class="entity">ctxt</span> <span class="main">=</span> Conv.fconv_rule <span class="main">(</span>Conv.prems_conv <span class="inner_numeral">~1</span>
  <span class="main">(</span>Conv.params_conv <span class="inner_numeral">~1</span> <span class="main">(</span>K <span class="main">(</span>Conv.prems_conv <span class="inner_numeral">~1</span> <span class="main">(</span><span class="entity">atomize_conv</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span>


<span class="comment1">(** equivariance tactics **)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eqvt_rel_single_case_tac</span> <span class="entity">ctxt</span> <span class="entity">pred_names</span> <span class="entity">pi</span> <span class="entity">intro</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cpi</span> <span class="main">=</span> Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">pi</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pi_intro_rule</span> <span class="main">=</span> Thm.instantiate' <span class="main">[</span><span class="main">]</span> <span class="main">[</span>NONE<span class="main">,</span> SOME <span class="entity">cpi</span><span class="main">]</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> permute_boolI<span class="antiquote">}</span></span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eqvt_sconfig</span> <span class="main">=</span> <span class="entity">eqvt_strict_config</span> <span class="entity">addexcls</span> <span class="entity">pred_names</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">eqvt_tac</span> <span class="entity">ctxt</span> <span class="entity">eqvt_sconfig</span> THEN'
    <span class="entity">SUBPROOF</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span><span class="entity">prems</span><span class="main">,</span> <span class="entity">context</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simps1</span> <span class="main">=</span>
          put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span> addsimps <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> permute_fun_def permute_self split_paired_all<span class="antiquote">}</span></span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simps2</span> <span class="main">=</span>
          put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span> addsimps <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> permute_bool_def permute_minus_cancel<span class="main">(</span>2<span class="main">)</span><span class="antiquote">}</span></span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prems'</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">transform_prem2</span> <span class="entity">ctxt</span> <span class="entity">pred_names</span><span class="main">)</span> <span class="entity">prems</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prems''</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">thm</span> <span class="main">=&gt;</span> <span class="entity">eqvt_rule</span> <span class="entity">ctxt</span> <span class="entity">eqvt_sconfig</span> <span class="main">(</span><span class="entity">thm</span> RS <span class="entity">pi_intro_rule</span><span class="main">)</span><span class="main">)</span> <span class="entity">prems'</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prems'''</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">simplify</span> <span class="entity">simps2</span> o <span class="entity">simplify</span> <span class="entity">simps1</span><span class="main">)</span> <span class="entity">prems''</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        HEADGOAL <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">intro</span><span class="main">]</span> THEN_ALL_NEW
          resolve_tac <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">prems'</span> @ <span class="entity">prems''</span> @ <span class="entity">prems'''</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span> <span class="entity">ctxt</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eqvt_rel_tac</span> <span class="entity">ctxt</span> <span class="entity">pred_names</span> <span class="entity">pi</span> <span class="entity">induct</span> <span class="entity">intros</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cases</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">eqvt_rel_single_case_tac</span> <span class="entity">ctxt</span> <span class="entity">pred_names</span> <span class="entity">pi</span><span class="main">)</span> <span class="entity">intros</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    EVERY' <span class="main">(</span><span class="main">(</span>DETERM o resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">induct</span><span class="main">]</span><span class="main">)</span> :: <span class="entity">cases</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="comment1">(** equivariance procedure **)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prepare_goal</span> <span class="entity">ctxt</span> <span class="entity">pi</span> <span class="entity">pred_with_args</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">xs</span><span class="main">)</span> <span class="main">=</span> strip_comb <span class="entity">pred_with_args</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_nonfixed_Free</span> <span class="main">(</span>Free <span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> not <span class="main">(</span>Variable.is_fixed <span class="entity">ctxt</span> <span class="entity">s</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">is_nonfixed_Free</span> <span class="main">_</span> <span class="main">=</span> false
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_perm_nonfixed_Free</span> <span class="entity">t</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_nonfixed_Free</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">mk_perm</span> <span class="entity">pi</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">t</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">HOLogic.mk_imp</span> <span class="main">(</span><span class="entity">pred_with_args</span><span class="main">,</span>
      list_comb <span class="main">(</span><span class="entity">c</span><span class="main">,</span> map <span class="entity">mk_perm_nonfixed_Free</span> <span class="entity">xs</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">name_of</span> <span class="main">(</span>Const <span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">s</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">raw_equivariance</span> <span class="entity">ctxt</span> <span class="entity">preds</span> <span class="entity">raw_induct</span> <span class="entity">intrs</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="comment1">(* FIXME: polymorphic predicates should either be rejected or
              specialized to arguments of sort pt *)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">is_already_eqvt</span> <span class="main">=</span> filter <span class="main">(</span><span class="entity">is_eqvt</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">preds</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">is_already_eqvt</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span> error <span class="main">(</span><span class="inner_quoted">"Already equivariant: "</span> ^ commas
        <span class="main">(</span>map <span class="main">(</span>Syntax.string_of_term <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">is_already_eqvt</span><span class="main">)</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pred_names</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">name_of</span> o head_of<span class="main">)</span> <span class="entity">preds</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_induct'</span> <span class="main">=</span> <span class="entity">atomize_induct</span> <span class="entity">ctxt</span> <span class="entity">raw_induct</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">intrs'</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">atomize_intr</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">intrs</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="main">[</span><span class="entity">raw_concl</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="entity">raw_pi</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">ctxt</span>
      |&gt; Variable.import_terms false <span class="main">[</span>Thm.concl_of <span class="entity">raw_induct'</span><span class="main">]</span>
      ||&gt;&gt; Variable.variant_fixes <span class="main">[</span><span class="inner_quoted">"p"</span><span class="main">]</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pi</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">raw_pi</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">perm</span><span class="antiquote">}</span></span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">preds_with_args</span> <span class="main">=</span> <span class="entity">raw_concl</span>
      |&gt; <span class="entity">HOLogic.dest_Trueprop</span>
      |&gt; <span class="entity">HOLogic.dest_conj</span>
      |&gt; map <span class="main">(</span>fst o <span class="entity">HOLogic.dest_imp</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goal</span> <span class="main">=</span> <span class="entity">preds_with_args</span>
      |&gt; map <span class="main">(</span><span class="entity">prepare_goal</span> <span class="entity">ctxt</span> <span class="entity">pi</span><span class="main">)</span>
      |&gt; foldr1 <span class="entity">HOLogic.mk_conj</span>
      |&gt; <span class="entity">HOLogic.mk_Trueprop</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Goal.prove <span class="entity">ctxt'</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">goal</span>
      <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span><span class="entity">context</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span> <span class="entity">eqvt_rel_tac</span> <span class="entity">context</span> <span class="entity">pred_names</span> <span class="entity">pi</span> <span class="entity">raw_induct'</span> <span class="entity">intrs'</span> <span class="inner_numeral">1</span><span class="main">)</span>
      |&gt; <span class="entity">Old_Datatype_Aux.split_conj_thm</span>
      |&gt; Proof_Context.export <span class="entity">ctxt'</span> <span class="entity">ctxt</span>
      |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">th</span> <span class="main">=&gt;</span> <span class="entity">th</span> RS <span class="entity">mp</span><span class="main">)</span>
      |&gt; map zero_var_indexes
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="comment1">(** stores thm under name.eqvt and adds [eqvt]-attribute **)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">note_named_thm</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">thm</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm_name</span> <span class="main">=</span> Binding.qualified_name
      <span class="main">(</span>Long_Name.qualify <span class="main">(</span>Long_Name.base_name <span class="entity">name</span><span class="main">)</span> <span class="inner_quoted">"eqvt"</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">attr</span> <span class="main">=</span> <span class="entity">Attrib.internal</span> <span class="main">(</span>K <span class="entity">eqvt_add</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">[</span><span class="entity">thm'</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> Local_Theory.note <span class="main">(</span><span class="main">(</span><span class="entity">thm_name</span><span class="main">,</span> <span class="main">[</span><span class="entity">attr</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="entity">thm</span><span class="main">]</span><span class="main">)</span> <span class="entity">ctxt</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="entity">thm'</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="comment1">(** equivariance command **)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">equivariance_cmd</span> <span class="entity">pred_name</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">{</span><span class="entity">names</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">,</span> <span class="main">{</span><span class="entity">preds</span><span class="main">,</span> <span class="entity">raw_induct</span><span class="main">,</span> <span class="entity">intrs</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">Inductive.the_inductive_global</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">long_name</span> <span class="entity">ctxt</span> <span class="entity">pred_name</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thms</span> <span class="main">=</span> <span class="entity">raw_equivariance</span> <span class="entity">ctxt</span> <span class="entity">preds</span> <span class="entity">raw_induct</span> <span class="entity">intrs</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    fold_map <span class="entity">note_named_thm</span> <span class="main">(</span><span class="entity">names</span> ~~ <span class="entity">thms</span><span class="main">)</span> <span class="entity">ctxt</span> |&gt; snd
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.local_theory</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> <span class="keyword1">equivariance</span><span class="antiquote">}</span></span></span>
    <span class="inner_quoted">"Proves equivariance for inductive predicate involving nominal datatypes."</span>
      <span class="main">(</span>Parse.const &gt;&gt; <span class="entity">equivariance_cmd</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* structure *)</span>
</pre>
</div><div id="Nominal2_Abs">
<div class="head">
<h1>Theory Nominal2_Abs</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> Nominal2_Abs
<span class="keyword2"><span class="keyword">imports</span></span> <a href="#Nominal2_Base">Nominal2_Base</a>
        <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/Quotient_List.html">HOL-Library.Quotient_List</a>"</span>
        <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/Quotient_Product.html">HOL-Library.Quotient_Product</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Abstractions›</span></span>

<span class="keyword1"><span class="command">fun</span></span>
  <span class="entity">alpha_set</span>
<span class="keyword2"><span class="keyword">where</span></span>
  alpha_set<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">alpha_set</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">bs</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">cs</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">⟷</span>
     <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">cs</span></span></span> <span class="main">∧</span>
     <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span><span class="main">)</span> <span class="main">♯*</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∧</span>
     <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∙</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">∧</span>
     <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∙</span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">cs</span></span></span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span>
  <span class="entity">alpha_res</span>
<span class="keyword2"><span class="keyword">where</span></span>
  alpha_res<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">alpha_res</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">bs</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">cs</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">⟷</span>
     <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">cs</span></span></span> <span class="main">∧</span>
     <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span><span class="main">)</span> <span class="main">♯*</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∧</span>
     <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∙</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span>
  <span class="entity">alpha_lst</span>
<span class="keyword2"><span class="keyword">where</span></span>
  alpha_lst<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">alpha_lst</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">bs</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">cs</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">⟷</span>
     <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">-</span> set <span class="free"><span class="bound"><span class="entity">bs</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">-</span> set <span class="free"><span class="bound"><span class="entity">cs</span></span></span> <span class="main">∧</span>
     <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">-</span> set <span class="free"><span class="bound"><span class="entity">bs</span></span></span><span class="main">)</span> <span class="main">♯*</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∧</span>
     <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∙</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">∧</span>
     <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∙</span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">cs</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> alphas <span class="main">=</span> alpha_set.simps alpha_res.simps alpha_lst.simps

<span class="keyword1"><span class="command">notation</span></span>
  alpha_set <span class="main">(</span><span class="quoted">"_ <span class="keyword1">≈set</span> _ _ _ _"</span> <span class="main">[</span>100<span class="main">,</span> 100<span class="main">,</span> 100<span class="main">,</span> 100<span class="main">,</span> 100<span class="main">]</span> 100<span class="main">)</span> <span class="keyword2"><span class="keyword">and</span></span>
  alpha_res <span class="main">(</span><span class="quoted">"_ <span class="keyword1">≈res</span> _ _ _ _"</span> <span class="main">[</span>100<span class="main">,</span> 100<span class="main">,</span> 100<span class="main">,</span> 100<span class="main">,</span> 100<span class="main">]</span> 100<span class="main">)</span> <span class="keyword2"><span class="keyword">and</span></span>
  alpha_lst <span class="main">(</span><span class="quoted">"_ <span class="keyword1">≈lst</span> _ _ _ _"</span> <span class="main">[</span>100<span class="main">,</span> 100<span class="main">,</span> 100<span class="main">,</span> 100<span class="main">,</span> 100<span class="main">]</span> 100<span class="main">)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Mono›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">mono</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">R1</span> <span class="main">≤</span> <span class="free">R2</span> <span class="main">⟹</span> alpha_set <span class="free">bs</span> <span class="free">R1</span> <span class="main">≤</span> alpha_set <span class="free">bs</span> <span class="free">R2</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="free">R1</span> <span class="main">≤</span> <span class="free">R2</span> <span class="main">⟹</span> alpha_res <span class="free">bs</span> <span class="free">R1</span> <span class="main">≤</span> alpha_res <span class="free">bs</span> <span class="free">R2</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="free">R1</span> <span class="main">≤</span> <span class="free">R2</span> <span class="main">⟹</span> alpha_lst <span class="free">cs</span> <span class="free">R1</span> <span class="main">≤</span> alpha_lst <span class="free">cs</span> <span class="free">R2</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">bs</span></span></span></span></span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">case_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">cs</span></span></span></span></span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> le_fun_def le_bool_def alphas<span class="main">)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Equivariance›</span></span>

<span class="keyword1" id="Nominal2_Abs-alpha_eqvt"><span class="command">lemma</span></span> alpha_eqvt<span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈set</span> <span class="free">R</span> <span class="free">f</span> <span class="free">q</span> <span class="main">(</span><span class="free">cs</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">bs</span><span class="main">,</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈set</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">R</span><span class="main">)</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">f</span><span class="main">)</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">q</span><span class="main">)</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">cs</span><span class="main">,</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈res</span> <span class="free">R</span> <span class="free">f</span> <span class="free">q</span> <span class="main">(</span><span class="free">cs</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">bs</span><span class="main">,</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈res</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">R</span><span class="main">)</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">f</span><span class="main">)</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">q</span><span class="main">)</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">cs</span><span class="main">,</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ds</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈lst</span> <span class="free">R</span> <span class="free">f</span> <span class="free">q</span> <span class="main">(</span><span class="free">es</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">ds</span><span class="main">,</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈lst</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">R</span><span class="main">)</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">f</span><span class="main">)</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">q</span><span class="main">)</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">es</span><span class="main">,</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> alphas
  <span class="keyword1"><span class="command">unfolding</span></span> permute_eqvt<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
  <span class="keyword1"><span class="command">unfolding</span></span> set_eqvt<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
  <span class="keyword1"><span class="command">unfolding</span></span> permute_fun_app_eq<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
  <span class="keyword1"><span class="command">unfolding</span></span> Diff_eqvt<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
  <span class="keyword1"><span class="command">unfolding</span></span> eq_eqvt<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
  <span class="keyword1"><span class="command">unfolding</span></span> fresh_star_eqvt<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> permute_bool_def<span class="main">)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Equivalence›</span></span>

<span class="keyword1" id="Nominal2_Abs-alpha_refl"><span class="command">lemma</span></span> alpha_refl<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="free">x</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈set</span> <span class="free">R</span> <span class="free">f</span> <span class="main">0</span> <span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈res</span> <span class="free">R</span> <span class="free">f</span> <span class="main">0</span> <span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">cs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈lst</span> <span class="free">R</span> <span class="free">f</span> <span class="main">0</span> <span class="main">(</span><span class="free">cs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> a
  <span class="keyword1"><span class="command">unfolding</span></span> alphas
  <span class="keyword1"><span class="command">unfolding</span></span> fresh_star_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_zero_perm<span class="main">)</span>

<span class="keyword1" id="Nominal2_Abs-alpha_sym"><span class="command">lemma</span></span> alpha_sym<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">R</span> <span class="main">(</span><span class="main">-</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">y</span><span class="main">)</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈set</span> <span class="free">R</span> <span class="free">f</span> <span class="free">p</span> <span class="main">(</span><span class="free">cs</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">cs</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="keyword1">≈set</span> <span class="free">R</span> <span class="free">f</span> <span class="main">(</span><span class="main">-</span> <span class="free">p</span><span class="main">)</span> <span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈res</span> <span class="free">R</span> <span class="free">f</span> <span class="free">p</span> <span class="main">(</span><span class="free">cs</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">cs</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="keyword1">≈res</span> <span class="free">R</span> <span class="free">f</span> <span class="main">(</span><span class="main">-</span> <span class="free">p</span><span class="main">)</span> <span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ds</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈lst</span> <span class="free">R</span> <span class="free">f</span> <span class="free">p</span> <span class="main">(</span><span class="free">es</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">es</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="keyword1">≈lst</span> <span class="free">R</span> <span class="free">f</span> <span class="main">(</span><span class="main">-</span> <span class="free">p</span><span class="main">)</span> <span class="main">(</span><span class="free">ds</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> alphas fresh_star_def
  <span class="keyword1"><span class="command">using</span></span> a
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fresh_minus_perm<span class="main">)</span>

<span class="keyword1" id="Nominal2_Abs-alpha_trans"><span class="command">lemma</span></span> alpha_trans<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">R</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="free">y</span><span class="main">;</span> <span class="free">R</span> <span class="main">(</span><span class="free">q</span> <span class="main">∙</span> <span class="free">y</span><span class="main">)</span> <span class="free">z</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">R</span> <span class="main">(</span><span class="main">(</span><span class="free">q</span> <span class="main">+</span> <span class="free">p</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="free">z</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈set</span> <span class="free">R</span> <span class="free">f</span> <span class="free">p</span> <span class="main">(</span><span class="free">cs</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span><span class="main">;</span> <span class="main">(</span><span class="free">cs</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="keyword1">≈set</span> <span class="free">R</span> <span class="free">f</span> <span class="free">q</span> <span class="main">(</span><span class="free">ds</span><span class="main">,</span> <span class="free">z</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈set</span> <span class="free">R</span> <span class="free">f</span> <span class="main">(</span><span class="free">q</span> <span class="main">+</span> <span class="free">p</span><span class="main">)</span> <span class="main">(</span><span class="free">ds</span><span class="main">,</span> <span class="free">z</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈res</span> <span class="free">R</span> <span class="free">f</span> <span class="free">p</span> <span class="main">(</span><span class="free">cs</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span><span class="main">;</span> <span class="main">(</span><span class="free">cs</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="keyword1">≈res</span> <span class="free">R</span> <span class="free">f</span> <span class="free">q</span> <span class="main">(</span><span class="free">ds</span><span class="main">,</span> <span class="free">z</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈res</span> <span class="free">R</span> <span class="free">f</span> <span class="main">(</span><span class="free">q</span> <span class="main">+</span> <span class="free">p</span><span class="main">)</span> <span class="main">(</span><span class="free">ds</span><span class="main">,</span> <span class="free">z</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">(</span><span class="free">es</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈lst</span> <span class="free">R</span> <span class="free">f</span> <span class="free">p</span> <span class="main">(</span><span class="free">gs</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span><span class="main">;</span> <span class="main">(</span><span class="free">gs</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="keyword1">≈lst</span> <span class="free">R</span> <span class="free">f</span> <span class="free">q</span> <span class="main">(</span><span class="free">hs</span><span class="main">,</span> <span class="free">z</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">es</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈lst</span> <span class="free">R</span> <span class="free">f</span> <span class="main">(</span><span class="free">q</span> <span class="main">+</span> <span class="free">p</span><span class="main">)</span> <span class="main">(</span><span class="free">hs</span><span class="main">,</span> <span class="free">z</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> a
  <span class="keyword1"><span class="command">unfolding</span></span> alphas fresh_star_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_plus_perm<span class="main">)</span>

<span class="keyword1" id="Nominal2_Abs-alpha_sym_eqvt"><span class="command">lemma</span></span> alpha_sym_eqvt<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">R</span> <span class="free">y</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>     b<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="free">R</span> <span class="main">=</span> <span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈set</span> <span class="free">R</span> <span class="free">f</span> <span class="free">p</span> <span class="main">(</span><span class="free">cs</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">cs</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="keyword1">≈set</span> <span class="free">R</span> <span class="free">f</span> <span class="main">(</span><span class="main">-</span> <span class="free">p</span><span class="main">)</span> <span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈res</span> <span class="free">R</span> <span class="free">f</span> <span class="free">p</span> <span class="main">(</span><span class="free">cs</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">cs</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="keyword1">≈res</span> <span class="free">R</span> <span class="free">f</span> <span class="main">(</span><span class="main">-</span> <span class="free">p</span><span class="main">)</span> <span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ds</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈lst</span> <span class="free">R</span> <span class="free">f</span> <span class="free">p</span> <span class="main">(</span><span class="free">es</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">es</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="keyword1">≈lst</span> <span class="free">R</span> <span class="free">f</span> <span class="main">(</span><span class="main">-</span> <span class="free">p</span><span class="main">)</span> <span class="main">(</span><span class="free">ds</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> alpha_sym<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> a<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> p<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free"><span class="free">p</span></span></span>"</span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> permute_boolE<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> b permute_self<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Nominal2_Abs-alpha_set_trans_eqvt"><span class="command">lemma</span></span> alpha_set_trans_eqvt<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> b<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">cs</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="keyword1">≈set</span> <span class="free">R</span> <span class="free">f</span> <span class="free">q</span> <span class="main">(</span><span class="free">ds</span><span class="main">,</span> <span class="free">z</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>     a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈set</span> <span class="free">R</span> <span class="free">f</span> <span class="free">p</span> <span class="main">(</span><span class="free">cs</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>     d<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="main">∙</span> <span class="free">R</span> <span class="main">=</span> <span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>     c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">R</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="free">y</span><span class="main">;</span> <span class="free">R</span> <span class="free">y</span> <span class="main">(</span><span class="main">-</span> <span class="free">q</span> <span class="main">∙</span> <span class="free">z</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">R</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span><span class="main">-</span> <span class="free">q</span> <span class="main">∙</span> <span class="free">z</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈set</span> <span class="free">R</span> <span class="free">f</span> <span class="main">(</span><span class="free">q</span> <span class="main">+</span> <span class="free">p</span><span class="main">)</span> <span class="main">(</span><span class="free">ds</span><span class="main">,</span> <span class="free">z</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> alpha_trans<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ a b<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule</span> c<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> p<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">q</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> permute_boolE<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> d permute_self<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rotate_tac</span> -1<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule_tac</span> p<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">q</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> permute_boolI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> d permute_self permute_eqvt<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Nominal2_Abs-alpha_res_trans_eqvt"><span class="command">lemma</span></span> alpha_res_trans_eqvt<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span>  b<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">cs</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="keyword1">≈res</span> <span class="free">R</span> <span class="free">f</span> <span class="free">q</span> <span class="main">(</span><span class="free">ds</span><span class="main">,</span> <span class="free">z</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>     a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈res</span> <span class="free">R</span> <span class="free">f</span> <span class="free">p</span> <span class="main">(</span><span class="free">cs</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>     d<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="main">∙</span> <span class="free">R</span> <span class="main">=</span> <span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>     c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">R</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="free">y</span><span class="main">;</span> <span class="free">R</span> <span class="free">y</span> <span class="main">(</span><span class="main">-</span> <span class="free">q</span> <span class="main">∙</span> <span class="free">z</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">R</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span><span class="main">-</span> <span class="free">q</span> <span class="main">∙</span> <span class="free">z</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈res</span> <span class="free">R</span> <span class="free">f</span> <span class="main">(</span><span class="free">q</span> <span class="main">+</span> <span class="free">p</span><span class="main">)</span> <span class="main">(</span><span class="free">ds</span><span class="main">,</span> <span class="free">z</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> alpha_trans<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ a b<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule</span> c<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> p<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">q</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> permute_boolE<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> d permute_self<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rotate_tac</span> -1<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule_tac</span> p<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">q</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> permute_boolI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> d permute_self permute_eqvt<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Nominal2_Abs-alpha_lst_trans_eqvt"><span class="command">lemma</span></span> alpha_lst_trans_eqvt<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> b<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">cs</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="keyword1">≈lst</span> <span class="free">R</span> <span class="free">f</span> <span class="free">q</span> <span class="main">(</span><span class="free">ds</span><span class="main">,</span> <span class="free">z</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>     a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈lst</span> <span class="free">R</span> <span class="free">f</span> <span class="free">p</span> <span class="main">(</span><span class="free">cs</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>     d<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="main">∙</span> <span class="free">R</span> <span class="main">=</span> <span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>     c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">R</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="free">y</span><span class="main">;</span> <span class="free">R</span> <span class="free">y</span> <span class="main">(</span><span class="main">-</span> <span class="free">q</span> <span class="main">∙</span> <span class="free">z</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">R</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span><span class="main">-</span> <span class="free">q</span> <span class="main">∙</span> <span class="free">z</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈lst</span> <span class="free">R</span> <span class="free">f</span> <span class="main">(</span><span class="free">q</span> <span class="main">+</span> <span class="free">p</span><span class="main">)</span> <span class="main">(</span><span class="free">ds</span><span class="main">,</span> <span class="free">z</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> alpha_trans<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ a b<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule</span> c<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> p<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">q</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> permute_boolE<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> d permute_self<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rotate_tac</span> -1<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule_tac</span> p<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">q</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> permute_boolI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> d permute_self permute_eqvt<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemmas</span></span> alpha_trans_eqvt <span class="main">=</span> alpha_set_trans_eqvt alpha_res_trans_eqvt alpha_lst_trans_eqvt


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹General Abstractions›</span></span>

<span class="keyword1"><span class="command">fun</span></span>
  <span class="entity">alpha_abs_set</span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">alpha_abs_set</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">bs</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">cs</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">p</span><span class="main">.</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">bs</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="keyword1">≈set</span> <span class="main">(</span><span class="main">(=)</span><span class="main">)</span> supp <span class="bound">p</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">cs</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span>
  <span class="entity">alpha_abs_lst</span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">alpha_abs_lst</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">bs</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">cs</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">p</span><span class="main">.</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">bs</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="keyword1">≈lst</span> <span class="main">(</span><span class="main">(=)</span><span class="main">)</span> supp <span class="bound">p</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">cs</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span>
  <span class="entity">alpha_abs_res</span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">alpha_abs_res</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">bs</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">cs</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">p</span><span class="main">.</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">bs</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="keyword1">≈res</span> <span class="main">(</span><span class="main">(=)</span><span class="main">)</span> supp <span class="bound">p</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">cs</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">notation</span></span>
  alpha_abs_set <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">≈abs'_set</span>"</span> 50<span class="main">)</span> <span class="keyword2"><span class="keyword">and</span></span>
  alpha_abs_lst <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">≈abs'_lst</span>"</span> 50<span class="main">)</span> <span class="keyword2"><span class="keyword">and</span></span>
  alpha_abs_res <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">≈abs'_res</span>"</span> 50<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> alphas_abs <span class="main">=</span> alpha_abs_set.simps alpha_abs_res.simps alpha_abs_lst.simps


<span class="keyword1" id="Nominal2_Abs-alphas_abs_refl"><span class="command">lemma</span></span> alphas_abs_refl<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈abs_set</span> <span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈abs_res</span> <span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">cs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈abs_lst</span> <span class="main">(</span><span class="free">cs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> alphas_abs
  <span class="keyword1"><span class="command">unfolding</span></span> alphas
  <span class="keyword1"><span class="command">unfolding</span></span> fresh_star_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">0</span></span></span>"</span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
     <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_zero_perm<span class="main">)</span>

<span class="keyword1" id="Nominal2_Abs-alphas_abs_sym"><span class="command">lemma</span></span> alphas_abs_sym<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈abs_set</span> <span class="main">(</span><span class="free">cs</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">cs</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="keyword1">≈abs_set</span> <span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈abs_res</span> <span class="main">(</span><span class="free">cs</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">cs</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="keyword1">≈abs_res</span> <span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ds</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈abs_lst</span> <span class="main">(</span><span class="free">es</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">es</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="keyword1">≈abs_lst</span> <span class="main">(</span><span class="free">ds</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> alphas_abs
  <span class="keyword1"><span class="command">unfolding</span></span> alphas
  <span class="keyword1"><span class="command">unfolding</span></span> fresh_star_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">erule_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> exE<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">-</span></span></span><span class="improper"><span class="improper"><span class="improper">p</span></span></span>"</span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
     <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fresh_minus_perm<span class="main">)</span>

<span class="keyword1" id="Nominal2_Abs-alphas_abs_trans"><span class="command">lemma</span></span> alphas_abs_trans<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈abs_set</span> <span class="main">(</span><span class="free">cs</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span><span class="main">;</span> <span class="main">(</span><span class="free">cs</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="keyword1">≈abs_set</span> <span class="main">(</span><span class="free">ds</span><span class="main">,</span> <span class="free">z</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈abs_set</span> <span class="main">(</span><span class="free">ds</span><span class="main">,</span> <span class="free">z</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈abs_res</span> <span class="main">(</span><span class="free">cs</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span><span class="main">;</span> <span class="main">(</span><span class="free">cs</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="keyword1">≈abs_res</span> <span class="main">(</span><span class="free">ds</span><span class="main">,</span> <span class="free">z</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈abs_res</span> <span class="main">(</span><span class="free">ds</span><span class="main">,</span> <span class="free">z</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">(</span><span class="free">es</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈abs_lst</span> <span class="main">(</span><span class="free">gs</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span><span class="main">;</span> <span class="main">(</span><span class="free">gs</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="keyword1">≈abs_lst</span> <span class="main">(</span><span class="free">hs</span><span class="main">,</span> <span class="free">z</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">es</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈abs_lst</span> <span class="main">(</span><span class="free">hs</span><span class="main">,</span> <span class="free">z</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> alphas_abs
  <span class="keyword1"><span class="command">unfolding</span></span> alphas
  <span class="keyword1"><span class="command">unfolding</span></span> fresh_star_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> exE<span class="main"><span class="keyword3">,</span></span> <span class="operator">erule_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> exE<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="improper"><span class="improper"><span class="improper">pa</span></span></span> <span class="main"><span class="main"><span class="main">+</span></span></span> <span class="improper"><span class="improper"><span class="improper">p</span></span></span>"</span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_plus_perm<span class="main">)</span>

<span class="keyword1" id="Nominal2_Abs-alphas_abs_eqvt"><span class="command">lemma</span></span> alphas_abs_eqvt<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈abs_set</span> <span class="main">(</span><span class="free">cs</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">bs</span><span class="main">,</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈abs_set</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">cs</span><span class="main">,</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈abs_res</span> <span class="main">(</span><span class="free">cs</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">bs</span><span class="main">,</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈abs_res</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">cs</span><span class="main">,</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ds</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈abs_lst</span> <span class="main">(</span><span class="free">es</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">ds</span><span class="main">,</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈abs_lst</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">es</span><span class="main">,</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> alphas_abs
  <span class="keyword1"><span class="command">unfolding</span></span> alphas
  <span class="keyword1"><span class="command">unfolding</span></span> set_eqvt<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
  <span class="keyword1"><span class="command">unfolding</span></span> supp_eqvt<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
  <span class="keyword1"><span class="command">unfolding</span></span> Diff_eqvt<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> exE<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free"><span class="free">p</span></span></span> <span class="main"><span class="main"><span class="main">∙</span></span></span> <span class="improper"><span class="improper"><span class="improper">pa</span></span></span>"</span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> fresh_star_permute_iff permute_eqvt<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Strengthening the equivalence›</span></span>

<span class="keyword1" id="Nominal2_Abs-disjoint_right_eq"><span class="command">lemma</span></span> disjoint_right_eq<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">∪</span> <span class="free">B1</span> <span class="main">=</span> <span class="free">A</span> <span class="main">∪</span> <span class="free">B2</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>     b<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">∩</span> <span class="free">B1</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">∩</span> <span class="free">B2</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">B1</span> <span class="main">=</span> <span class="free">B2</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> a b
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Int_Un_distrib2 Int_absorb2 Int_commute Un_upper2<span class="main">)</span>

<span class="keyword1" id="Nominal2_Abs-supp_property_res"><span class="command">lemma</span></span> supp_property_res<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">as</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈res</span> <span class="main">(=)</span> supp <span class="free">p</span> <span class="main">(</span><span class="free">as'</span><span class="main">,</span> <span class="free">x'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> <span class="free">as</span><span class="main">)</span> <span class="main">=</span> supp <span class="free">x'</span> <span class="main">∩</span> <span class="free">as'</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> a <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> <span class="free">as</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span>  <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> alphas<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> <span class="free">as</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> <span class="free">as</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> atom_set_perm_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>supp <span class="free">x'</span> <span class="main">-</span> <span class="free">as'</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>supp <span class="free">x'</span> <span class="main">∩</span> <span class="free">as'</span><span class="main">)</span> <span class="main">=</span> supp <span class="free">x'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> supp <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> a <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alphas<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>supp <span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_eqvt<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> <span class="free">as</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> <span class="free">as</span><span class="main">)</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> <span class="free">as</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> union_eqvt<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> <span class="free">as</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> * <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span>supp <span class="free">x'</span> <span class="main">-</span> <span class="free">as'</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> <span class="free">as</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> a <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alphas<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>supp <span class="free">x'</span> <span class="main">-</span> <span class="free">as'</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>supp <span class="free">x'</span> <span class="main">∩</span> <span class="free">as'</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>supp <span class="free">x'</span> <span class="main">-</span> <span class="free">as'</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> <span class="free">as</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>supp <span class="free">x'</span> <span class="main">-</span> <span class="free">as'</span><span class="main">)</span> <span class="main">∩</span> <span class="main">(</span>supp <span class="free">x'</span> <span class="main">∩</span> <span class="free">as'</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> <span class="free">as</span><span class="main">)</span> <span class="main">∩</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> <span class="free">as</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> <span class="free">as</span><span class="main">)</span> <span class="main">∩</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> <span class="free">as</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_bool_def<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> <span class="free">as</span><span class="main">)</span><span class="main">)</span> <span class="main">∩</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> <span class="free">as</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">perm_simp</span><span class="main">)</span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> <span class="free">as</span><span class="main">)</span> <span class="main">∩</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> <span class="free">as</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> * <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>supp <span class="free">x'</span> <span class="main">-</span> <span class="free">as'</span><span class="main">)</span> <span class="main">∩</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> <span class="free">as</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> a <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alphas<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> <span class="free">as</span><span class="main">)</span> <span class="main">=</span> supp <span class="free">x'</span> <span class="main">∩</span> <span class="free">as'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> disjoint_right_eq<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Abs-alpha_abs_res_stronger1_aux"><span class="command">lemma</span></span> alpha_abs_res_stronger1_aux<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> asm<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">as</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈res</span> <span class="main">(=)</span> supp <span class="free">p'</span> <span class="main">(</span><span class="free">as'</span><span class="main">,</span> <span class="free">x'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">p</span><span class="main">.</span> <span class="main">(</span><span class="free">as</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈res</span> <span class="main">(=)</span> supp <span class="bound">p</span> <span class="main">(</span><span class="free">as'</span><span class="main">,</span> <span class="free">x'</span><span class="main">)</span> <span class="main">∧</span> supp <span class="bound">p</span> <span class="main">⊆</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>supp <span class="free">x'</span> <span class="main">∩</span> <span class="free">as'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> asm <span class="keyword1"><span class="command">have</span></span> 0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> <span class="free">as</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">p'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span>  <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> alphas<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> #<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p'</span> <span class="main">∙</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> <span class="free">as</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> <span class="free">as</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> atom_set_perm_eq<span class="main">)</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p</span></span> <span class="keyword2"><span class="keyword">where</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b</span> <span class="main">∈</span> supp <span class="free">x</span><span class="main">.</span> <span class="skolem">p</span> <span class="main">∙</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">p'</span> <span class="main">∙</span> <span class="bound">b</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> **<span class="main">:</span> <span class="quoted"><span class="quoted">"supp <span class="skolem">p</span> <span class="main">⊆</span> supp <span class="free">x</span> <span class="main">∪</span> <span class="free">p'</span> <span class="main">∙</span> supp <span class="free">x</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> set_renaming_perm2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">from</span></span> * <span class="keyword1"><span class="command">have</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">p'</span> <span class="main">∙</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> supp_perm_perm_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> 0 <span class="keyword1"><span class="command">have</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> <span class="free">as</span><span class="main">)</span> <span class="main">♯*</span> <span class="skolem">p</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> *
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fresh_star_def fresh_perm<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> <span class="free">as</span><span class="main">)</span> <span class="main">∩</span> supp <span class="skolem">p</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fresh_star_def fresh_def<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> b<span class="main">:</span> <span class="quoted"><span class="quoted">"supp <span class="free">x</span> <span class="main">=</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> <span class="free">as</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"supp <span class="skolem">p</span> <span class="main">⊆</span> supp <span class="free">x</span> <span class="main">∪</span> <span class="free">p'</span> <span class="main">∙</span> supp <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> ** <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span><span class="free">p'</span> <span class="main">∙</span> <span class="main">(</span><span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> <span class="free">as</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> b <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span><span class="main">(</span><span class="free">p'</span> <span class="main">∙</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> <span class="free">as</span><span class="main">)</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span><span class="free">p'</span> <span class="main">∙</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> <span class="free">as</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> union_eqvt<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span><span class="free">p'</span> <span class="main">∙</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> <span class="free">as</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> # <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>supp <span class="free">x'</span> <span class="main">∩</span> <span class="free">as'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> asm
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_property_res<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"supp <span class="skolem">p</span> <span class="main">⊆</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>supp <span class="free">x'</span> <span class="main">∩</span> <span class="free">as'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">then</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"supp <span class="skolem">p</span> <span class="main">⊆</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>supp <span class="free">x'</span> <span class="main">∩</span> <span class="free">as'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> 2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">as</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈res</span> <span class="main">(=)</span> supp <span class="skolem">p</span> <span class="main">(</span><span class="free">as'</span><span class="main">,</span> <span class="free">x'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> asm 1 a <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alphas<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">p</span><span class="main">.</span> <span class="main">(</span><span class="free">as</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈res</span> <span class="main">(=)</span> supp <span class="bound">p</span> <span class="main">(</span><span class="free">as'</span><span class="main">,</span> <span class="free">x'</span><span class="main">)</span> <span class="main">∧</span> supp <span class="bound">p</span> <span class="main">⊆</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>supp <span class="free">x'</span> <span class="main">∩</span> <span class="free">as'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Abs-alpha_abs_res_minimal"><span class="command">lemma</span></span> alpha_abs_res_minimal<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> asm<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">as</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈res</span> <span class="main">(=)</span> supp <span class="free">p</span> <span class="main">(</span><span class="free">as'</span><span class="main">,</span> <span class="free">x'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">as</span> <span class="main">∩</span> supp <span class="free">x</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈res</span> <span class="main">(=)</span> supp <span class="free">p</span> <span class="main">(</span><span class="free">as'</span> <span class="main">∩</span> supp <span class="free">x'</span><span class="main">,</span> <span class="free">x'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> asm <span class="keyword1"><span class="command">unfolding</span></span> alpha_res <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Diff_Int<span class="main">)</span>

<span class="keyword1" id="Nominal2_Abs-alpha_abs_res_abs_set"><span class="command">lemma</span></span> alpha_abs_res_abs_set<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> asm<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">as</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈res</span> <span class="main">(=)</span> supp <span class="free">p</span> <span class="main">(</span><span class="free">as'</span><span class="main">,</span> <span class="free">x'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">as</span> <span class="main">∩</span> supp <span class="free">x</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈set</span> <span class="main">(=)</span> supp <span class="free">p</span> <span class="main">(</span><span class="free">as'</span> <span class="main">∩</span> supp <span class="free">x'</span><span class="main">,</span> <span class="free">x'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x'</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> alpha_abs_res_minimal<span class="main">[</span><span class="operator">OF</span> asm<span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> alpha_res <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarify</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"supp <span class="free">x</span> <span class="main">-</span> <span class="free">as</span> <span class="main">∩</span> supp <span class="free">x</span> <span class="main">=</span> supp <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="main">-</span> <span class="free">as'</span> <span class="main">∩</span> supp <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> alpha_abs_res_minimal<span class="main">[</span><span class="operator">OF</span> asm<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alpha_res<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> b<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> <span class="free">as</span> <span class="main">∩</span> supp <span class="free">x</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">p</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> alpha_abs_res_minimal<span class="main">[</span><span class="operator">OF</span> asm<span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> alpha_res <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarify</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">as</span> <span class="main">∩</span> supp <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">as'</span> <span class="main">∩</span> supp <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Int_commute asm c supp_property_res<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> a b c <span class="keyword1"><span class="command">unfolding</span></span> alpha_set <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Abs-alpha_abs_set_abs_res"><span class="command">lemma</span></span> alpha_abs_set_abs_res<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> asm<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">as</span> <span class="main">∩</span> supp <span class="free">x</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈set</span> <span class="main">(=)</span> supp <span class="free">p</span> <span class="main">(</span><span class="free">as'</span> <span class="main">∩</span> supp <span class="free">x'</span><span class="main">,</span> <span class="free">x'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">as</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈res</span> <span class="main">(=)</span> supp <span class="free">p</span> <span class="main">(</span><span class="free">as'</span><span class="main">,</span> <span class="free">x'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> asm <span class="keyword1"><span class="command">unfolding</span></span> alphas <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Diff_Int<span class="main">)</span>

<span class="keyword1" id="Nominal2_Abs-alpha_abs_res_stronger1"><span class="command">lemma</span></span> alpha_abs_res_stronger1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> asm<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">as</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈res</span> <span class="main">(=)</span> supp <span class="free">p'</span> <span class="main">(</span><span class="free">as'</span><span class="main">,</span> <span class="free">x'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">p</span><span class="main">.</span> <span class="main">(</span><span class="free">as</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈res</span> <span class="main">(=)</span> supp <span class="bound">p</span> <span class="main">(</span><span class="free">as'</span><span class="main">,</span> <span class="free">x'</span><span class="main">)</span> <span class="main">∧</span> supp <span class="bound">p</span> <span class="main">⊆</span> <span class="free">as</span> <span class="main">∪</span> <span class="free">as'</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> alpha_abs_res_stronger1_aux<span class="main">[</span><span class="operator">OF</span> asm<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Nominal2_Abs-alpha_abs_set_stronger1"><span class="command">lemma</span></span> alpha_abs_set_stronger1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> asm<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">as</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈set</span> <span class="main">(=)</span> supp <span class="free">p'</span> <span class="main">(</span><span class="free">as'</span><span class="main">,</span> <span class="free">x'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">p</span><span class="main">.</span> <span class="main">(</span><span class="free">as</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈set</span> <span class="main">(=)</span> supp <span class="bound">p</span> <span class="main">(</span><span class="free">as'</span><span class="main">,</span> <span class="free">x'</span><span class="main">)</span> <span class="main">∧</span> supp <span class="bound">p</span> <span class="main">⊆</span> <span class="free">as</span> <span class="main">∪</span> <span class="free">as'</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> asm <span class="keyword1"><span class="command">have</span></span> 0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> <span class="free">as</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">p'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span>  <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> alphas<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> #<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p'</span> <span class="main">∙</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> <span class="free">as</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> <span class="free">as</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> atom_set_perm_eq<span class="main">)</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p</span></span> <span class="keyword2"><span class="keyword">where</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b</span> <span class="main">∈</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∪</span> <span class="free">as</span><span class="main">)</span><span class="main">.</span> <span class="skolem">p</span> <span class="main">∙</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">p'</span> <span class="main">∙</span> <span class="bound">b</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> **<span class="main">:</span> <span class="quoted"><span class="quoted">"supp <span class="skolem">p</span> <span class="main">⊆</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∪</span> <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="free">p'</span> <span class="main">∙</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∪</span> <span class="free">as</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> set_renaming_perm2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">from</span></span> * <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b</span> <span class="main">∈</span> supp <span class="free">x</span><span class="main">.</span> <span class="skolem">p</span> <span class="main">∙</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">p'</span> <span class="main">∙</span> <span class="bound">b</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">p'</span> <span class="main">∙</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> supp_perm_perm_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> * <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b</span> <span class="main">∈</span> <span class="free">as</span><span class="main">.</span> <span class="skolem">p</span> <span class="main">∙</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">p'</span> <span class="main">∙</span> <span class="bound">b</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> zb<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">∙</span> <span class="free">as</span> <span class="main">=</span> <span class="free">p'</span> <span class="main">∙</span> <span class="free">as</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> permute_set_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="improper">xa</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">have</span></span> zc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p'</span> <span class="main">∙</span> <span class="free">as</span> <span class="main">=</span> <span class="free">as'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> asm <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alphas<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> 0 <span class="keyword1"><span class="command">have</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> <span class="free">as</span><span class="main">)</span> <span class="main">♯*</span> <span class="skolem">p</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> *
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fresh_star_def fresh_perm<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> <span class="free">as</span><span class="main">)</span> <span class="main">∩</span> supp <span class="skolem">p</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fresh_star_def fresh_def<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> b<span class="main">:</span> <span class="quoted"><span class="quoted">"supp <span class="free">x</span> <span class="main">=</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> <span class="free">as</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"supp <span class="skolem">p</span> <span class="main">⊆</span> supp <span class="free">x</span> <span class="main">∪</span> <span class="free">as</span> <span class="main">∪</span> <span class="free">p'</span> <span class="main">∙</span> supp <span class="free">x</span> <span class="main">∪</span> <span class="free">p'</span> <span class="main">∙</span> <span class="free">as</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> ** <span class="keyword1"><span class="command">using</span></span> union_eqvt <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="free">as</span> <span class="main">∪</span> <span class="main">(</span><span class="free">p'</span> <span class="main">∙</span> <span class="main">(</span><span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> <span class="free">as</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">∪</span> <span class="free">p'</span> <span class="main">∙</span> <span class="free">as</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> b <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="free">as</span> <span class="main">∪</span>
    <span class="main">(</span><span class="main">(</span><span class="free">p'</span> <span class="main">∙</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> <span class="free">as</span><span class="main">)</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span><span class="free">p'</span> <span class="main">∙</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> <span class="free">as</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">∪</span> <span class="free">p'</span> <span class="main">∙</span> <span class="free">as</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> union_eqvt<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="free">as</span> <span class="main">∪</span> <span class="main">(</span><span class="free">p'</span> <span class="main">∙</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> <span class="free">as</span><span class="main">)</span><span class="main">)</span> <span class="main">∪</span> <span class="free">p'</span> <span class="main">∙</span> <span class="free">as</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> # <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="free">as</span> <span class="main">∪</span> <span class="free">p'</span> <span class="main">∙</span> <span class="main">(</span><span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="free">as</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> union_eqvt
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="free">as</span> <span class="main">∪</span> <span class="free">p'</span> <span class="main">∙</span> <span class="free">as</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Int_commute Un_commute sup_inf_absorb<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="free">as</span> <span class="main">∪</span> <span class="free">p'</span> <span class="main">∙</span> <span class="free">as</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"supp <span class="skolem">p</span> <span class="main">⊆</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="free">as</span> <span class="main">∪</span> <span class="free">p'</span> <span class="main">∙</span> <span class="free">as</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"supp <span class="skolem">p</span> <span class="main">⊆</span> <span class="free">as</span> <span class="main">∪</span> <span class="free">p'</span> <span class="main">∙</span> <span class="free">as</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> 2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">as</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈set</span> <span class="main">(=)</span> supp <span class="skolem">p</span> <span class="main">(</span><span class="free">as'</span><span class="main">,</span> <span class="free">x'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> asm 1 a zb <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alphas<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">p</span><span class="main">.</span> <span class="main">(</span><span class="free">as</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈set</span> <span class="main">(=)</span> supp <span class="bound">p</span> <span class="main">(</span><span class="free">as'</span><span class="main">,</span> <span class="free">x'</span><span class="main">)</span> <span class="main">∧</span> supp <span class="bound">p</span> <span class="main">⊆</span> <span class="free">as</span> <span class="main">∪</span> <span class="free">as'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> zc <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Abs-alpha_abs_lst_stronger1"><span class="command">lemma</span></span> alpha_abs_lst_stronger1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> asm<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">as</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈lst</span> <span class="main">(=)</span> supp <span class="free">p'</span> <span class="main">(</span><span class="free">as'</span><span class="main">,</span> <span class="free">x'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">p</span><span class="main">.</span> <span class="main">(</span><span class="free">as</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈lst</span> <span class="main">(=)</span> supp <span class="bound">p</span> <span class="main">(</span><span class="free">as'</span><span class="main">,</span> <span class="free">x'</span><span class="main">)</span> <span class="main">∧</span> supp <span class="bound">p</span> <span class="main">⊆</span> set <span class="free">as</span> <span class="main">∪</span> set <span class="free">as'</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> asm <span class="keyword1"><span class="command">have</span></span> 0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> set <span class="free">as</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">p'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span>  <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> alphas<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> #<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p'</span> <span class="main">∙</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> set <span class="free">as</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> set <span class="free">as</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> atom_set_perm_eq<span class="main">)</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p</span></span> <span class="keyword2"><span class="keyword">where</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b</span> <span class="main">∈</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∪</span> set <span class="free">as</span><span class="main">)</span><span class="main">.</span> <span class="skolem">p</span> <span class="main">∙</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">p'</span> <span class="main">∙</span> <span class="bound">b</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> **<span class="main">:</span> <span class="quoted"><span class="quoted">"supp <span class="skolem">p</span> <span class="main">⊆</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∪</span> set <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="free">p'</span> <span class="main">∙</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∪</span> set <span class="free">as</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> set_renaming_perm2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">from</span></span> * <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b</span> <span class="main">∈</span> supp <span class="free">x</span><span class="main">.</span> <span class="skolem">p</span> <span class="main">∙</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">p'</span> <span class="main">∙</span> <span class="bound">b</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">p'</span> <span class="main">∙</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> supp_perm_perm_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> * <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b</span> <span class="main">∈</span> set <span class="free">as</span><span class="main">.</span> <span class="skolem">p</span> <span class="main">∙</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">p'</span> <span class="main">∙</span> <span class="bound">b</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> zb<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">∙</span> <span class="free">as</span> <span class="main">=</span> <span class="free">p'</span> <span class="main">∙</span> <span class="free">as</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">as</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> zc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p'</span> <span class="main">∙</span> set <span class="free">as</span> <span class="main">=</span> set <span class="free">as'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> asm <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alphas set_eqvt<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> 0 <span class="keyword1"><span class="command">have</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> set <span class="free">as</span><span class="main">)</span> <span class="main">♯*</span> <span class="skolem">p</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> *
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fresh_star_def fresh_perm<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> set <span class="free">as</span><span class="main">)</span> <span class="main">∩</span> supp <span class="skolem">p</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fresh_star_def fresh_def<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> b<span class="main">:</span> <span class="quoted"><span class="quoted">"supp <span class="free">x</span> <span class="main">=</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> set <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> set <span class="free">as</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"supp <span class="skolem">p</span> <span class="main">⊆</span> supp <span class="free">x</span> <span class="main">∪</span> set <span class="free">as</span> <span class="main">∪</span> <span class="free">p'</span> <span class="main">∙</span> supp <span class="free">x</span> <span class="main">∪</span> <span class="free">p'</span> <span class="main">∙</span> set <span class="free">as</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> ** <span class="keyword1"><span class="command">using</span></span> union_eqvt <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> set <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> set <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> set <span class="free">as</span> <span class="main">∪</span>
    <span class="main">(</span><span class="free">p'</span> <span class="main">∙</span> <span class="main">(</span><span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> set <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> set <span class="free">as</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">∪</span> <span class="free">p'</span> <span class="main">∙</span> set <span class="free">as</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> b <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> set <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> set <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> set <span class="free">as</span> <span class="main">∪</span>
    <span class="main">(</span><span class="main">(</span><span class="free">p'</span> <span class="main">∙</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> set <span class="free">as</span><span class="main">)</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span><span class="free">p'</span> <span class="main">∙</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> set <span class="free">as</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">∪</span> <span class="free">p'</span> <span class="main">∙</span> set <span class="free">as</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> union_eqvt<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> set <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> set <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> set <span class="free">as</span> <span class="main">∪</span>
    <span class="main">(</span><span class="free">p'</span> <span class="main">∙</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> set <span class="free">as</span><span class="main">)</span><span class="main">)</span> <span class="main">∪</span> <span class="free">p'</span> <span class="main">∙</span> set <span class="free">as</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> # <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> set <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> set <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> set <span class="free">as</span> <span class="main">∪</span> <span class="free">p'</span> <span class="main">∙</span> <span class="main">(</span><span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> set <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> set <span class="free">as</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> union_eqvt <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> set <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">∩</span> set <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> set <span class="free">as</span> <span class="main">∪</span> <span class="free">p'</span> <span class="main">∙</span> set <span class="free">as</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Int_commute Un_commute sup_inf_absorb<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> set <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> set <span class="free">as</span> <span class="main">∪</span> <span class="free">p'</span> <span class="main">∙</span> set <span class="free">as</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"supp <span class="skolem">p</span> <span class="main">⊆</span> <span class="main">(</span>supp <span class="free">x</span> <span class="main">-</span> set <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> set <span class="free">as</span> <span class="main">∪</span> <span class="free">p'</span> <span class="main">∙</span> set <span class="free">as</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"supp <span class="skolem">p</span> <span class="main">⊆</span> set <span class="free">as</span> <span class="main">∪</span> <span class="free">p'</span> <span class="main">∙</span> set <span class="free">as</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> 2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">as</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈lst</span> <span class="main">(=)</span> supp <span class="skolem">p</span> <span class="main">(</span><span class="free">as'</span><span class="main">,</span> <span class="free">x'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> asm 1 a zb <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alphas<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">p</span><span class="main">.</span> <span class="main">(</span><span class="free">as</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈lst</span> <span class="main">(=)</span> supp <span class="bound">p</span> <span class="main">(</span><span class="free">as'</span><span class="main">,</span> <span class="free">x'</span><span class="main">)</span> <span class="main">∧</span> supp <span class="bound">p</span> <span class="main">⊆</span> set <span class="free">as</span> <span class="main">∪</span> set <span class="free">as'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> zc <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Abs-alphas_abs_stronger"><span class="command">lemma</span></span> alphas_abs_stronger<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">as</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈abs_set</span> <span class="main">(</span><span class="free">as'</span><span class="main">,</span> <span class="free">x'</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">p</span><span class="main">.</span> <span class="main">(</span><span class="free">as</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈set</span> <span class="main">(=)</span> supp <span class="bound">p</span> <span class="main">(</span><span class="free">as'</span><span class="main">,</span> <span class="free">x'</span><span class="main">)</span> <span class="main">∧</span> supp <span class="bound">p</span> <span class="main">⊆</span> <span class="free">as</span> <span class="main">∪</span> <span class="free">as'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">as</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈abs_res</span> <span class="main">(</span><span class="free">as'</span><span class="main">,</span> <span class="free">x'</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">p</span><span class="main">.</span> <span class="main">(</span><span class="free">as</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈res</span> <span class="main">(=)</span> supp <span class="bound">p</span> <span class="main">(</span><span class="free">as'</span><span class="main">,</span> <span class="free">x'</span><span class="main">)</span> <span class="main">∧</span> supp <span class="bound">p</span> <span class="main">⊆</span> <span class="free">as</span> <span class="main">∪</span> <span class="free">as'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈abs_lst</span> <span class="main">(</span><span class="free">bs'</span><span class="main">,</span> <span class="free">x'</span><span class="main">)</span> <span class="main">⟷</span>
   <span class="main">(</span><span class="main">∃</span><span class="bound">p</span><span class="main">.</span> <span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈lst</span> <span class="main">(=)</span> supp <span class="bound">p</span> <span class="main">(</span><span class="free">bs'</span><span class="main">,</span> <span class="free">x'</span><span class="main">)</span> <span class="main">∧</span> supp <span class="bound">p</span> <span class="main">⊆</span> set <span class="free">bs</span> <span class="main">∪</span> set <span class="free">bs'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> iffI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> alphas_abs alpha_abs_set_stronger1<span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> alphas_abs<span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> iffI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> alphas_abs alpha_abs_res_stronger1<span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> alphas_abs<span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> iffI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> alphas_abs alpha_abs_lst_stronger1<span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> alphas_abs<span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Nominal2_Abs-alpha_res_alpha_set"><span class="command">lemma</span></span> alpha_res_alpha_set<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈res</span> <span class="main">(=)</span> supp <span class="free">p</span> <span class="main">(</span><span class="free">cs</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">bs</span> <span class="main">∩</span> supp <span class="free">x</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈set</span> <span class="main">(=)</span> supp <span class="free">p</span> <span class="main">(</span><span class="free">cs</span> <span class="main">∩</span> supp <span class="free">y</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> alpha_abs_set_abs_res alpha_abs_res_abs_set <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Quotient types›</span></span>

<span class="keyword1"><span class="command">quotient_type</span></span>
    <span class="tfree">'a</span> abs_set <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>atom set <span class="main">×</span> <span class="tfree">'a</span><span class="main">::</span>pt<span class="main">)</span>"</span></span> <span class="main">/</span> <span class="quoted"><span class="quoted">"alpha_abs_set"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> equivpI<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> reflp_def refl_on_def symp_def sym_def transp_def trans_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> alphas_abs_sym alphas_abs_refl alphas_abs_trans <span class="quasi_keyword">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">quotient_type</span></span>
    <span class="tfree">'b</span> abs_res <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>atom set <span class="main">×</span> <span class="tfree">'b</span><span class="main">::</span>pt<span class="main">)</span>"</span></span> <span class="main">/</span> <span class="quoted"><span class="quoted">"alpha_abs_res"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> equivpI<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> reflp_def refl_on_def symp_def sym_def transp_def trans_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> alphas_abs_sym alphas_abs_refl alphas_abs_trans <span class="quasi_keyword">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">quotient_type</span></span>
   <span class="tfree">'c</span> abs_lst <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>atom list <span class="main">×</span> <span class="tfree">'c</span><span class="main">::</span>pt<span class="main">)</span>"</span></span> <span class="main">/</span> <span class="quoted"><span class="quoted">"alpha_abs_lst"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> equivpI<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> reflp_def refl_on_def symp_def sym_def transp_def trans_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> alphas_abs_sym alphas_abs_refl alphas_abs_trans <span class="quasi_keyword">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">quotient_definition</span></span>
  Abs_set <span class="main">(</span><span class="quoted">"<span class="keyword1">[</span>_<span class="keyword1">]set.</span> _"</span> <span class="main">[</span>60<span class="main">,</span> 60<span class="main">]</span> 60<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Abs_set</span><span class="main">::</span>atom set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>pt<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> abs_set"</span></span>
<span class="keyword2"><span class="keyword">is</span></span>
  <span class="quoted"><span class="quoted">"Pair<span class="main">::</span>atom set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>pt<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span>atom set <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">quotient_definition</span></span>
  Abs_res <span class="main">(</span><span class="quoted">"<span class="keyword1">[</span>_<span class="keyword1">]res.</span> _"</span> <span class="main">[</span>60<span class="main">,</span> 60<span class="main">]</span> 60<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Abs_res</span><span class="main">::</span>atom set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>pt<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> abs_res"</span></span>
<span class="keyword2"><span class="keyword">is</span></span>
  <span class="quoted"><span class="quoted">"Pair<span class="main">::</span>atom set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>pt<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span>atom set <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">quotient_definition</span></span>
  Abs_lst <span class="main">(</span><span class="quoted">"<span class="keyword1">[</span>_<span class="keyword1">]lst.</span> _"</span> <span class="main">[</span>60<span class="main">,</span> 60<span class="main">]</span> 60<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Abs_lst</span><span class="main">::</span>atom list <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>pt<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> abs_lst"</span></span>
<span class="keyword2"><span class="keyword">is</span></span>
  <span class="quoted"><span class="quoted">"Pair<span class="main">::</span>atom list <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>pt<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span>atom list <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">quot_respect</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> alpha_abs_set<span class="main">)</span> Pair Pair"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> alpha_abs_res<span class="main">)</span> Pair Pair"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> alpha_abs_lst<span class="main">)</span> Pair Pair"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> rel_fun_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> alphas_abs_refl<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">quot_respect</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> alpha_abs_set <span class="main">===&gt;</span> alpha_abs_set<span class="main">)</span> permute permute"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> alpha_abs_res <span class="main">===&gt;</span> alpha_abs_res<span class="main">)</span> permute permute"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> alpha_abs_lst <span class="main">===&gt;</span> alpha_abs_lst<span class="main">)</span> permute permute"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> rel_fun_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> alphas_abs_eqvt <span class="quasi_keyword">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> Pair_eqvt<span class="main">)</span>

<span class="keyword1" id="Nominal2_Abs-Abs_eq_iff"><span class="command">lemma</span></span> Abs_eq_iff<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">bs</span><span class="keyword1">]set.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="free">bs'</span><span class="keyword1">]set.</span> <span class="free">y</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">p</span><span class="main">.</span> <span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈set</span> <span class="main">(=)</span> supp <span class="bound">p</span> <span class="main">(</span><span class="free">bs'</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">bs</span><span class="keyword1">]res.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="free">bs'</span><span class="keyword1">]res.</span> <span class="free">y</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">p</span><span class="main">.</span> <span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈res</span> <span class="main">(=)</span> supp <span class="bound">p</span> <span class="main">(</span><span class="free">bs'</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">cs</span><span class="keyword1">]lst.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="free">cs'</span><span class="keyword1">]lst.</span> <span class="free">y</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">p</span><span class="main">.</span> <span class="main">(</span><span class="free">cs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈lst</span> <span class="main">(=)</span> supp <span class="bound">p</span> <span class="main">(</span><span class="free">cs'</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">lifting</span> alphas_abs<span class="main">)</span>

<span class="keyword1" id="Nominal2_Abs-Abs_eq_iff2"><span class="command">lemma</span></span> Abs_eq_iff2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">bs</span><span class="keyword1">]set.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="free">bs'</span><span class="keyword1">]set.</span> <span class="free">y</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">p</span><span class="main">.</span> <span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈set</span> <span class="main">(</span><span class="main">(=)</span><span class="main">)</span> supp <span class="bound">p</span> <span class="main">(</span><span class="free">bs'</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∧</span> supp <span class="bound">p</span> <span class="main">⊆</span> <span class="free">bs</span> <span class="main">∪</span> <span class="free">bs'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">bs</span><span class="keyword1">]res.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="free">bs'</span><span class="keyword1">]res.</span> <span class="free">y</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">p</span><span class="main">.</span> <span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈res</span> <span class="main">(</span><span class="main">(=)</span><span class="main">)</span> supp <span class="bound">p</span> <span class="main">(</span><span class="free">bs'</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∧</span> supp <span class="bound">p</span> <span class="main">⊆</span> <span class="free">bs</span> <span class="main">∪</span> <span class="free">bs'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">cs</span><span class="keyword1">]lst.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="free">cs'</span><span class="keyword1">]lst.</span> <span class="free">y</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">p</span><span class="main">.</span> <span class="main">(</span><span class="free">cs</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">≈lst</span> <span class="main">(</span><span class="main">(=)</span><span class="main">)</span> supp <span class="bound">p</span> <span class="main">(</span><span class="free">cs'</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∧</span> supp <span class="bound">p</span> <span class="main">⊆</span> set <span class="free">cs</span> <span class="main">∪</span> set <span class="free">cs'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">lifting</span> alphas_abs_stronger<span class="main">)</span>


<span class="keyword1" id="Nominal2_Abs-Abs_eq_res_set"><span class="command">lemma</span></span> Abs_eq_res_set<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">bs</span><span class="keyword1">]res.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="free">cs</span><span class="keyword1">]res.</span> <span class="free">y</span> <span class="main">⟷</span> <span class="main">[</span><span class="free">bs</span> <span class="main">∩</span> supp <span class="free">x</span><span class="keyword1">]set.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="free">cs</span> <span class="main">∩</span> supp <span class="free">y</span><span class="keyword1">]set.</span> <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Abs_eq_iff alpha_res_alpha_set <span class="keyword1"><span class="command">by</span></span> <span class="operator">rule</span>

<span class="keyword1" id="Nominal2_Abs-Abs_eq_res_supp"><span class="command">lemma</span></span> Abs_eq_res_supp<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> asm<span class="main">:</span> <span class="quoted"><span class="quoted">"supp <span class="free">x</span> <span class="main">⊆</span> <span class="free">bs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">as</span><span class="keyword1">]res.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="free">as</span> <span class="main">∩</span> <span class="free">bs</span><span class="keyword1">]res.</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Abs_eq_iff alphas
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">0</span><span class="main">::</span>perm"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_star_zero<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> asm <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="Nominal2_Abs-Abs_exhausts"><span class="command">lemma</span></span> Abs_exhausts<span class="main">[</span><span class="operator">cases</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">type</span></span></span></span></span></span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">as</span> <span class="main">(</span><span class="bound">x</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>pt<span class="main">)</span><span class="main">.</span> <span class="free">y1</span> <span class="main">=</span> <span class="main">[</span><span class="bound">as</span><span class="keyword1">]set.</span> <span class="bound">x</span> <span class="main">⟹</span> <span class="free">P1</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">P1</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">as</span> <span class="main">(</span><span class="bound">x</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>pt<span class="main">)</span><span class="main">.</span> <span class="free">y2</span> <span class="main">=</span> <span class="main">[</span><span class="bound">as</span><span class="keyword1">]res.</span> <span class="bound">x</span> <span class="main">⟹</span> <span class="free">P2</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">P2</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">bs</span> <span class="main">(</span><span class="bound">x</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>pt<span class="main">)</span><span class="main">.</span> <span class="free">y3</span> <span class="main">=</span> <span class="main">[</span><span class="bound">bs</span><span class="keyword1">]lst.</span> <span class="bound">x</span> <span class="main">⟹</span> <span class="free">P3</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">P3</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">lifting</span> prod.exhaust<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span><span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"atom set"</span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> <span class="tfree">'b</span><span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree"><span class="tfree">'a</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span>
              prod.exhaust<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span><span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"atom set"</span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> <span class="tfree">'b</span><span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree"><span class="tfree">'a</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span>
              prod.exhaust<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span><span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"atom list"</span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> <span class="tfree">'b</span><span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree"><span class="tfree">'a</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">instantiation</span></span> abs_set <span class="main">::</span> <span class="main">(</span><span class="quoted">pt</span><span class="main">)</span> <span class="quoted">pt</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">quotient_definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">permute_abs_set</span><span class="main">::</span>perm <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>pt abs_set<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> abs_set"</span></span>
<span class="keyword2"><span class="keyword">is</span></span>
  <span class="quoted"><span class="quoted">"permute<span class="main">::</span> perm <span class="main">⇒</span> <span class="main">(</span>atom set <span class="main">×</span> <span class="tfree">'a</span><span class="main">::</span>pt<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span>atom set <span class="main">×</span> <span class="tfree">'a</span><span class="main">::</span>pt<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> alphas_abs_eqvt <span class="quasi_keyword">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> Pair_eqvt<span class="main">)</span>

<span class="keyword1" id="Nominal2_Abs-permute_Abs_set"><span class="command">lemma</span></span> permute_Abs_set<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>pt"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="main">[</span><span class="free">as</span><span class="keyword1">]set.</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">[</span><span class="free">p</span> <span class="main">∙</span> <span class="free">as</span><span class="keyword1">]set.</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">lifting</span> permute_prod.simps<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span><span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"atom set"</span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> <span class="tfree">'b</span><span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree"><span class="tfree">'a</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> <span class="quoted"><span class="improper"><span class="quoted"><span class="improper">x</span></span></span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> abs_res <span class="main">::</span> <span class="main">(</span><span class="quoted">pt</span><span class="main">)</span> <span class="quoted">pt</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">quotient_definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">permute_abs_res</span><span class="main">::</span>perm <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>pt abs_res<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> abs_res"</span></span>
<span class="keyword2"><span class="keyword">is</span></span>
  <span class="quoted"><span class="quoted">"permute<span class="main">::</span> perm <span class="main">⇒</span> <span class="main">(</span>atom set <span class="main">×</span> <span class="tfree">'a</span><span class="main">::</span>pt<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span>atom set <span class="main">×</span> <span class="tfree">'a</span><span class="main">::</span>pt<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> alphas_abs_eqvt <span class="quasi_keyword">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> Pair_eqvt<span class="main">)</span>

<span class="keyword1" id="Nominal2_Abs-permute_Abs_res"><span class="command">lemma</span></span> permute_Abs_res<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>pt"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="main">[</span><span class="free">as</span><span class="keyword1">]res.</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">[</span><span class="free">p</span> <span class="main">∙</span> <span class="free">as</span><span class="keyword1">]res.</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">lifting</span> permute_prod.simps<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span><span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"atom set"</span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> <span class="tfree">'b</span><span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree"><span class="tfree">'a</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> <span class="quoted"><span class="improper"><span class="quoted"><span class="improper">x</span></span></span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> abs_lst <span class="main">::</span> <span class="main">(</span><span class="quoted">pt</span><span class="main">)</span> <span class="quoted">pt</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">quotient_definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">permute_abs_lst</span><span class="main">::</span>perm <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>pt abs_lst<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> abs_lst"</span></span>
<span class="keyword2"><span class="keyword">is</span></span>
  <span class="quoted"><span class="quoted">"permute<span class="main">::</span> perm <span class="main">⇒</span> <span class="main">(</span>atom list <span class="main">×</span> <span class="tfree">'a</span><span class="main">::</span>pt<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span>atom list <span class="main">×</span> <span class="tfree">'a</span><span class="main">::</span>pt<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> alphas_abs_eqvt <span class="quasi_keyword">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> Pair_eqvt<span class="main">)</span>

<span class="keyword1" id="Nominal2_Abs-permute_Abs_lst"><span class="command">lemma</span></span> permute_Abs_lst<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>pt"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="main">[</span><span class="free">as</span><span class="keyword1">]lst.</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">[</span><span class="free">p</span> <span class="main">∙</span> <span class="free">as</span><span class="keyword1">]lst.</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">lifting</span> permute_prod.simps<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span><span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"atom list"</span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> <span class="tfree">'b</span><span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree"><span class="tfree">'a</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> <span class="quoted"><span class="improper"><span class="quoted"><span class="improper">x</span></span></span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> permute_Abs<span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span> <span class="main">=</span> permute_Abs_set permute_Abs_res permute_Abs_lst


<span class="keyword1" id="Nominal2_Abs-Abs_swap1"><span class="command">lemma</span></span> Abs_swap1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">∉</span> <span class="main">(</span>supp <span class="free">x</span><span class="main">)</span> <span class="main">-</span> <span class="free">bs</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>     a2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">∉</span> <span class="main">(</span>supp <span class="free">x</span><span class="main">)</span> <span class="main">-</span> <span class="free">bs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">bs</span><span class="keyword1">]set.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">bs</span><span class="keyword1">]set.</span> <span class="main">(</span><span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">bs</span><span class="keyword1">]res.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">bs</span><span class="keyword1">]res.</span> <span class="main">(</span><span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Abs_eq_iff
  <span class="keyword1"><span class="command">unfolding</span></span> alphas
  <span class="keyword1"><span class="command">unfolding</span></span> supp_eqvt<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> Diff_eqvt<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
  <span class="keyword1"><span class="command">unfolding</span></span> fresh_star_def fresh_def
  <span class="keyword1"><span class="command">unfolding</span></span> swap_set_not_in<span class="main">[</span><span class="operator">OF</span> a1 a2<span class="main">]</span>
  <span class="keyword1"><span class="command">using</span></span> a1 a2
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="free"><span class="free">a</span></span> <span class="main"><span class="main">⇌</span></span> <span class="free"><span class="free">b</span></span><span class="main"><span class="main">)</span></span>"</span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
     <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> supp_perm swap_atom<span class="main">)</span>

<span class="keyword1" id="Nominal2_Abs-Abs_swap2"><span class="command">lemma</span></span> Abs_swap2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">∉</span> <span class="main">(</span>supp <span class="free">x</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span>set <span class="free">bs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>     a2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">∉</span> <span class="main">(</span>supp <span class="free">x</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span>set <span class="free">bs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">bs</span><span class="keyword1">]lst.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">bs</span><span class="keyword1">]lst.</span> <span class="main">(</span><span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Abs_eq_iff
  <span class="keyword1"><span class="command">unfolding</span></span> alphas
  <span class="keyword1"><span class="command">unfolding</span></span> supp_eqvt<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> Diff_eqvt<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> set_eqvt<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
  <span class="keyword1"><span class="command">unfolding</span></span> fresh_star_def fresh_def
  <span class="keyword1"><span class="command">unfolding</span></span> swap_set_not_in<span class="main">[</span><span class="operator">OF</span> a1 a2<span class="main">]</span>
  <span class="keyword1"><span class="command">using</span></span> a1 a2
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">b</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
     <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> supp_perm swap_atom<span class="main">)</span>

<span class="keyword1" id="Nominal2_Abs-Abs_supports"><span class="command">lemma</span></span> Abs_supports<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>supp <span class="free">x</span><span class="main">)</span> <span class="main">-</span> <span class="free">as</span><span class="main">)</span> <span class="keyword1">supports</span> <span class="main">(</span><span class="main">[</span><span class="free">as</span><span class="keyword1">]set.</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>supp <span class="free">x</span><span class="main">)</span> <span class="main">-</span> <span class="free">as</span><span class="main">)</span> <span class="keyword1">supports</span> <span class="main">(</span><span class="main">[</span><span class="free">as</span><span class="keyword1">]res.</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>supp <span class="free">x</span><span class="main">)</span> <span class="main">-</span> set <span class="free">bs</span><span class="main">)</span> <span class="keyword1">supports</span> <span class="main">(</span><span class="main">[</span><span class="free">bs</span><span class="keyword1">]lst.</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> supports_def
  <span class="keyword1"><span class="command">unfolding</span></span> permute_Abs
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_swap1<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> Abs_swap2<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">function</span></span>
  <span class="entity">supp_set</span>  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>pt<span class="main">)</span> abs_set <span class="main">⇒</span> atom set"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="entity">supp_res</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>pt<span class="main">)</span> abs_res <span class="main">⇒</span> atom set"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="entity">supp_lst</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>pt<span class="main">)</span> abs_lst <span class="main">⇒</span> atom set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">supp_set</span> <span class="main">(</span><span class="main">[</span><span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="keyword1">]set.</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> supp <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">as</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">supp_res</span> <span class="main">(</span><span class="main">[</span><span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="keyword1">]res.</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> supp <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">as</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">supp_lst</span> <span class="main">(</span>Abs_lst <span class="free"><span class="bound"><span class="entity">cs</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>supp <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span>set <span class="free"><span class="bound"><span class="entity">cs</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_eq_iff alphas_abs alphas<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">a</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">b</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">a</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">ba</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">termination</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">lexicographic_order</span>

<span class="keyword1" id="Nominal2_Abs-supp_funs_eqvt"><span class="command">lemma</span></span> supp_funs_eqvt<span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">∙</span> supp_set <span class="free">x</span><span class="main">)</span> <span class="main">=</span> supp_set <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">∙</span> supp_res <span class="free">y</span><span class="main">)</span> <span class="main">=</span> supp_res <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">∙</span> supp_lst <span class="free">z</span><span class="main">)</span> <span class="main">=</span> supp_lst <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">z</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="free">y</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="free">z</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Nominal2_Abs-Abs_fresh_aux"><span class="command">lemma</span></span> Abs_fresh_aux<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="main">[</span><span class="free">bs</span><span class="keyword1">]set.</span> <span class="free">x</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">♯</span> supp_set <span class="main">(</span><span class="main">[</span><span class="free">bs</span><span class="keyword1">]set.</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="main">[</span><span class="free">bs</span><span class="keyword1">]res.</span> <span class="free">x</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">♯</span> supp_res <span class="main">(</span><span class="main">[</span><span class="free">bs</span><span class="keyword1">]res.</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="main">[</span><span class="free">cs</span><span class="keyword1">]lst.</span> <span class="free">x</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">♯</span> supp_lst <span class="main">(</span><span class="main">[</span><span class="free">cs</span><span class="keyword1">]lst.</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> fresh_fun_eqvt_app<span class="main">)</span>
     <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> eqvt_def <span class="dynamic"><span class="dynamic">eqvts_raw</span></span><span class="main">)</span>

<span class="keyword1" id="Nominal2_Abs-Abs_supp_subset1"><span class="command">lemma</span></span> Abs_supp_subset1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>supp <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>supp <span class="free">x</span><span class="main">)</span> <span class="main">-</span> <span class="free">as</span> <span class="main">⊆</span> supp <span class="main">(</span><span class="main">[</span><span class="free">as</span><span class="keyword1">]set.</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span>supp <span class="free">x</span><span class="main">)</span> <span class="main">-</span> <span class="free">as</span> <span class="main">⊆</span> supp <span class="main">(</span><span class="main">[</span><span class="free">as</span><span class="keyword1">]res.</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span>supp <span class="free">x</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span>set <span class="free">bs</span><span class="main">)</span> <span class="main">⊆</span> supp <span class="main">(</span><span class="main">[</span><span class="free">bs</span><span class="keyword1">]lst.</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> supp_conv_fresh
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Abs_fresh_aux<span class="main">)</span>
     <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_def supp_finite_atom_set a<span class="main">)</span>

<span class="keyword1" id="Nominal2_Abs-Abs_supp_subset2"><span class="command">lemma</span></span> Abs_supp_subset2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>supp <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span><span class="main">[</span><span class="free">as</span><span class="keyword1">]set.</span> <span class="free">x</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">(</span>supp <span class="free">x</span><span class="main">)</span> <span class="main">-</span> <span class="free">as</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"supp <span class="main">(</span><span class="main">[</span><span class="free">as</span><span class="keyword1">]res.</span> <span class="free">x</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">(</span>supp <span class="free">x</span><span class="main">)</span> <span class="main">-</span> <span class="free">as</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"supp <span class="main">(</span><span class="main">[</span><span class="free">bs</span><span class="keyword1">]lst.</span> <span class="free">x</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">(</span>supp <span class="free">x</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span>set <span class="free">bs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> supp_is_subset<span class="main">)</span>
     <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_supports a<span class="main">)</span>

<span class="keyword1" id="Nominal2_Abs-Abs_finite_supp"><span class="command">lemma</span></span> Abs_finite_supp<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>supp <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span><span class="main">[</span><span class="free">as</span><span class="keyword1">]set.</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>supp <span class="free">x</span><span class="main">)</span> <span class="main">-</span> <span class="free">as</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"supp <span class="main">(</span><span class="main">[</span><span class="free">as</span><span class="keyword1">]res.</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>supp <span class="free">x</span><span class="main">)</span> <span class="main">-</span> <span class="free">as</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"supp <span class="main">(</span><span class="main">[</span><span class="free">bs</span><span class="keyword1">]lst.</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>supp <span class="free">x</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span>set <span class="free">bs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> Abs_supp_subset1<span class="main">[</span><span class="operator">OF</span> a<span class="main">]</span> Abs_supp_subset2<span class="main">[</span><span class="operator">OF</span> a<span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Nominal2_Abs-supp_Abs"><span class="command">lemma</span></span> supp_Abs<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>fs"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span><span class="main">[</span><span class="free">as</span><span class="keyword1">]set.</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>supp <span class="free">x</span><span class="main">)</span> <span class="main">-</span> <span class="free">as</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"supp <span class="main">(</span><span class="main">[</span><span class="free">as</span><span class="keyword1">]res.</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>supp <span class="free">x</span><span class="main">)</span> <span class="main">-</span> <span class="free">as</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"supp <span class="main">(</span><span class="main">[</span><span class="free">bs</span><span class="keyword1">]lst.</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>supp <span class="free">x</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span>set <span class="free">bs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_finite_supp finite_supp<span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span> abs_set <span class="main">::</span> <span class="main">(</span><span class="quoted">fs</span><span class="main">)</span> <span class="quoted">fs</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_Abs finite_supp<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">instance</span></span> abs_res <span class="main">::</span> <span class="main">(</span><span class="quoted">fs</span><span class="main">)</span> <span class="quoted">fs</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_Abs finite_supp<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">instance</span></span> abs_lst <span class="main">::</span> <span class="main">(</span><span class="quoted">fs</span><span class="main">)</span> <span class="quoted">fs</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_Abs finite_supp<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Nominal2_Abs-Abs_fresh_iff"><span class="command">lemma</span></span> Abs_fresh_iff<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>fs"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="main">[</span><span class="free">bs</span><span class="keyword1">]set.</span> <span class="free">x</span> <span class="main">⟷</span> <span class="free">a</span> <span class="main">∈</span> <span class="free">bs</span> <span class="main">∨</span> <span class="main">(</span><span class="free">a</span> <span class="main">∉</span> <span class="free">bs</span> <span class="main">∧</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="main">[</span><span class="free">bs</span><span class="keyword1">]res.</span> <span class="free">x</span> <span class="main">⟷</span> <span class="free">a</span> <span class="main">∈</span> <span class="free">bs</span> <span class="main">∨</span> <span class="main">(</span><span class="free">a</span> <span class="main">∉</span> <span class="free">bs</span> <span class="main">∧</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="main">[</span><span class="free">cs</span><span class="keyword1">]lst.</span> <span class="free">x</span> <span class="main">⟷</span> <span class="free">a</span> <span class="main">∈</span> <span class="main">(</span>set <span class="free">cs</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span><span class="free">a</span> <span class="main">∉</span> <span class="main">(</span>set <span class="free">cs</span><span class="main">)</span> <span class="main">∧</span> <span class="free">a</span> <span class="main">♯</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fresh_def
  <span class="keyword1"><span class="command">unfolding</span></span> supp_Abs
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Nominal2_Abs-Abs_fresh_star_iff"><span class="command">lemma</span></span> Abs_fresh_star_iff<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>fs"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">as</span> <span class="main">♯*</span> <span class="main">(</span><span class="main">[</span><span class="free">bs</span><span class="keyword1">]set.</span> <span class="free">x</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">as</span> <span class="main">-</span> <span class="free">bs</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="free">as</span> <span class="main">♯*</span> <span class="main">(</span><span class="main">[</span><span class="free">bs</span><span class="keyword1">]res.</span> <span class="free">x</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">as</span> <span class="main">-</span> <span class="free">bs</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="free">as</span> <span class="main">♯*</span> <span class="main">(</span><span class="main">[</span><span class="free">cs</span><span class="keyword1">]lst.</span> <span class="free">x</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">as</span> <span class="main">-</span> set <span class="free">cs</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fresh_star_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Abs_fresh_iff<span class="main">)</span>

<span class="keyword1" id="Nominal2_Abs-Abs_fresh_star"><span class="command">lemma</span></span> Abs_fresh_star<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>fs"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">as</span> <span class="main">⊆</span> <span class="free">as'</span> <span class="main">⟹</span> <span class="free">as</span> <span class="main">♯*</span> <span class="main">(</span><span class="main">[</span><span class="free">as'</span><span class="keyword1">]set.</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="free">as</span> <span class="main">⊆</span> <span class="free">as'</span> <span class="main">⟹</span> <span class="free">as</span> <span class="main">♯*</span> <span class="main">(</span><span class="main">[</span><span class="free">as'</span><span class="keyword1">]res.</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="free">bs</span> <span class="main">⊆</span> set <span class="free">bs'</span> <span class="main">⟹</span> <span class="free">bs</span> <span class="main">♯*</span> <span class="main">(</span><span class="main">[</span><span class="free">bs'</span><span class="keyword1">]lst.</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fresh_star_def
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Abs_fresh_iff<span class="main">)</span>

<span class="keyword1" id="Nominal2_Abs-Abs_fresh_star2"><span class="command">lemma</span></span> Abs_fresh_star2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>fs"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">as</span> <span class="main">∩</span> <span class="free">bs</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">⟹</span> <span class="free">as</span> <span class="main">♯*</span> <span class="main">(</span><span class="main">[</span><span class="free">bs</span><span class="keyword1">]set.</span> <span class="free">x</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">as</span> <span class="main">♯*</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="free">as</span> <span class="main">∩</span> <span class="free">bs</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">⟹</span> <span class="free">as</span> <span class="main">♯*</span> <span class="main">(</span><span class="main">[</span><span class="free">bs</span><span class="keyword1">]res.</span> <span class="free">x</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">as</span> <span class="main">♯*</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="free">cs</span> <span class="main">∩</span> set <span class="free">ds</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">⟹</span> <span class="free">cs</span> <span class="main">♯*</span> <span class="main">(</span><span class="main">[</span><span class="free">ds</span><span class="keyword1">]lst.</span> <span class="free">x</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">cs</span> <span class="main">♯*</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fresh_star_def Abs_fresh_iff
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Abstractions of single atoms›</span></span>


<span class="keyword1" id="Nominal2_Abs-Abs1_eq"><span class="command">lemma</span></span> Abs1_eq<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="free">y</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>fs"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">{</span>atom <span class="free">a</span><span class="main">}</span><span class="keyword1">]set.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="main">{</span>atom <span class="free">a</span><span class="main">}</span><span class="keyword1">]set.</span> <span class="free">y</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">{</span>atom <span class="free">a</span><span class="main">}</span><span class="keyword1">]res.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="main">{</span>atom <span class="free">a</span><span class="main">}</span><span class="keyword1">]res.</span> <span class="free">y</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">[</span>atom <span class="free">a</span><span class="main">]</span><span class="keyword1">]lst.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="main">[</span>atom <span class="free">a</span><span class="main">]</span><span class="keyword1">]lst.</span> <span class="free">y</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Abs_eq_iff2 alphas
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> supp_perm_singleton fresh_star_def fresh_zero_perm<span class="main">)</span>

<span class="keyword1" id="Nominal2_Abs-Abs1_eq_iff_fresh"><span class="command">lemma</span></span> Abs1_eq_iff_fresh<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="free">y</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>fs"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">a</span> <span class="free">b</span> <span class="free">c</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'b</span><span class="main">::</span>at"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"atom <span class="free">c</span> <span class="main">♯</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="free">b</span><span class="main">,</span> <span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">{</span>atom <span class="free">a</span><span class="main">}</span><span class="keyword1">]set.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="main">{</span>atom <span class="free">b</span><span class="main">}</span><span class="keyword1">]set.</span> <span class="free">y</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">c</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">b</span> <span class="main">↔</span> <span class="free">c</span><span class="main">)</span> <span class="main">∙</span> <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">{</span>atom <span class="free">a</span><span class="main">}</span><span class="keyword1">]res.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="main">{</span>atom <span class="free">b</span><span class="main">}</span><span class="keyword1">]res.</span> <span class="free">y</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">c</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">b</span> <span class="main">↔</span> <span class="free">c</span><span class="main">)</span> <span class="main">∙</span> <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">[</span>atom <span class="free">a</span><span class="main">]</span><span class="keyword1">]lst.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="main">[</span>atom <span class="free">b</span><span class="main">]</span><span class="keyword1">]lst.</span> <span class="free">y</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">c</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">b</span> <span class="main">↔</span> <span class="free">c</span><span class="main">)</span> <span class="main">∙</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">{</span>atom <span class="free">a</span><span class="main">}</span><span class="keyword1">]set.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">c</span><span class="main">)</span> <span class="main">∙</span> <span class="main">(</span><span class="main">[</span><span class="main">{</span>atom <span class="free">a</span><span class="main">}</span><span class="keyword1">]set.</span> <span class="free">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule_tac</span> flip_fresh_fresh<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_fresh_iff assms<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">{</span>atom <span class="free">a</span><span class="main">}</span><span class="keyword1">]set.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="main">{</span>atom <span class="free">c</span><span class="main">}</span><span class="keyword1">]set.</span> <span class="main">(</span><span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">c</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">{</span>atom <span class="free">b</span><span class="main">}</span><span class="keyword1">]set.</span> <span class="free">y</span> <span class="main">=</span> <span class="main">(</span><span class="free">b</span> <span class="main">↔</span> <span class="free">c</span><span class="main">)</span> <span class="main">∙</span> <span class="main">(</span><span class="main">[</span><span class="main">{</span>atom <span class="free">b</span><span class="main">}</span><span class="keyword1">]set.</span> <span class="free">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule_tac</span> flip_fresh_fresh<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_fresh_iff assms<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">{</span>atom <span class="free">b</span><span class="main">}</span><span class="keyword1">]set.</span> <span class="free">y</span> <span class="main">=</span> <span class="main">[</span><span class="main">{</span>atom <span class="free">c</span><span class="main">}</span><span class="keyword1">]set.</span> <span class="main">(</span><span class="main">(</span><span class="free">b</span> <span class="main">↔</span> <span class="free">c</span><span class="main">)</span> <span class="main">∙</span> <span class="free">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">ultimately</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">{</span>atom <span class="free">a</span><span class="main">}</span><span class="keyword1">]set.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="main">{</span>atom <span class="free">b</span><span class="main">}</span><span class="keyword1">]set.</span> <span class="free">y</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">c</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">b</span> <span class="main">↔</span> <span class="free">c</span><span class="main">)</span> <span class="main">∙</span> <span class="free">y</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs1_eq<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">{</span>atom <span class="free">a</span><span class="main">}</span><span class="keyword1">]res.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">c</span><span class="main">)</span> <span class="main">∙</span> <span class="main">(</span><span class="main">[</span><span class="main">{</span>atom <span class="free">a</span><span class="main">}</span><span class="keyword1">]res.</span> <span class="free">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule_tac</span> flip_fresh_fresh<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_fresh_iff assms<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">{</span>atom <span class="free">a</span><span class="main">}</span><span class="keyword1">]res.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="main">{</span>atom <span class="free">c</span><span class="main">}</span><span class="keyword1">]res.</span> <span class="main">(</span><span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">c</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">{</span>atom <span class="free">b</span><span class="main">}</span><span class="keyword1">]res.</span> <span class="free">y</span> <span class="main">=</span> <span class="main">(</span><span class="free">b</span> <span class="main">↔</span> <span class="free">c</span><span class="main">)</span> <span class="main">∙</span> <span class="main">(</span><span class="main">[</span><span class="main">{</span>atom <span class="free">b</span><span class="main">}</span><span class="keyword1">]res.</span> <span class="free">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule_tac</span> flip_fresh_fresh<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_fresh_iff assms<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">{</span>atom <span class="free">b</span><span class="main">}</span><span class="keyword1">]res.</span> <span class="free">y</span> <span class="main">=</span> <span class="main">[</span><span class="main">{</span>atom <span class="free">c</span><span class="main">}</span><span class="keyword1">]res.</span> <span class="main">(</span><span class="main">(</span><span class="free">b</span> <span class="main">↔</span> <span class="free">c</span><span class="main">)</span> <span class="main">∙</span> <span class="free">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">ultimately</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">{</span>atom <span class="free">a</span><span class="main">}</span><span class="keyword1">]res.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="main">{</span>atom <span class="free">b</span><span class="main">}</span><span class="keyword1">]res.</span> <span class="free">y</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">c</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">b</span> <span class="main">↔</span> <span class="free">c</span><span class="main">)</span> <span class="main">∙</span> <span class="free">y</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs1_eq<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">[</span>atom <span class="free">a</span><span class="main">]</span><span class="keyword1">]lst.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">c</span><span class="main">)</span> <span class="main">∙</span> <span class="main">(</span><span class="main">[</span><span class="main">[</span>atom <span class="free">a</span><span class="main">]</span><span class="keyword1">]lst.</span> <span class="free">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule_tac</span> flip_fresh_fresh<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_fresh_iff assms<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">[</span>atom <span class="free">a</span><span class="main">]</span><span class="keyword1">]lst.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="main">[</span>atom <span class="free">c</span><span class="main">]</span><span class="keyword1">]lst.</span> <span class="main">(</span><span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">c</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">[</span>atom <span class="free">b</span><span class="main">]</span><span class="keyword1">]lst.</span> <span class="free">y</span> <span class="main">=</span> <span class="main">(</span><span class="free">b</span> <span class="main">↔</span> <span class="free">c</span><span class="main">)</span> <span class="main">∙</span> <span class="main">(</span><span class="main">[</span><span class="main">[</span>atom <span class="free">b</span><span class="main">]</span><span class="keyword1">]lst.</span> <span class="free">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule_tac</span> flip_fresh_fresh<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_fresh_iff assms<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">[</span>atom <span class="free">b</span><span class="main">]</span><span class="keyword1">]lst.</span> <span class="free">y</span> <span class="main">=</span> <span class="main">[</span><span class="main">[</span>atom <span class="free">c</span><span class="main">]</span><span class="keyword1">]lst.</span> <span class="main">(</span><span class="main">(</span><span class="free">b</span> <span class="main">↔</span> <span class="free">c</span><span class="main">)</span> <span class="main">∙</span> <span class="free">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">ultimately</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">[</span>atom <span class="free">a</span><span class="main">]</span><span class="keyword1">]lst.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="main">[</span>atom <span class="free">b</span><span class="main">]</span><span class="keyword1">]lst.</span> <span class="free">y</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">c</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">b</span> <span class="main">↔</span> <span class="free">c</span><span class="main">)</span> <span class="main">∙</span> <span class="free">y</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs1_eq<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Abs-Abs1_eq_iff_all"><span class="command">lemma</span></span> Abs1_eq_iff_all<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="free">y</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>fs"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">z</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'c</span><span class="main">::</span>fs"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">a</span> <span class="free">b</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'b</span><span class="main">::</span>at"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">{</span>atom <span class="free">a</span><span class="main">}</span><span class="keyword1">]set.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="main">{</span>atom <span class="free">b</span><span class="main">}</span><span class="keyword1">]set.</span> <span class="free">y</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">c</span><span class="main">.</span> atom <span class="bound">c</span> <span class="main">♯</span> <span class="free">z</span> <span class="main">⟶</span> atom <span class="bound">c</span> <span class="main">♯</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="free">b</span><span class="main">,</span> <span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">⟶</span> <span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">b</span> <span class="main">↔</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∙</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">{</span>atom <span class="free">a</span><span class="main">}</span><span class="keyword1">]res.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="main">{</span>atom <span class="free">b</span><span class="main">}</span><span class="keyword1">]res.</span> <span class="free">y</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">c</span><span class="main">.</span> atom <span class="bound">c</span> <span class="main">♯</span> <span class="free">z</span> <span class="main">⟶</span> atom <span class="bound">c</span> <span class="main">♯</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="free">b</span><span class="main">,</span> <span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">⟶</span> <span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">b</span> <span class="main">↔</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∙</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">[</span>atom <span class="free">a</span><span class="main">]</span><span class="keyword1">]lst.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="main">[</span>atom <span class="free">b</span><span class="main">]</span><span class="keyword1">]lst.</span> <span class="free">y</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">c</span><span class="main">.</span> atom <span class="bound">c</span> <span class="main">♯</span> <span class="free">z</span> <span class="main">⟶</span> atom <span class="bound">c</span> <span class="main">♯</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="free">b</span><span class="main">,</span> <span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">⟶</span> <span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">b</span> <span class="main">↔</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∙</span> <span class="free">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs1_eq_iff_fresh<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> <span class="tvar">?'a</span><span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="tfree">'b</span><span class="main">::</span>at"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="free">b</span><span class="main">,</span> <span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">,</span> <span class="free">z</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> obtain_fresh<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="improper">aa</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> Abs1_eq_iff_fresh<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fresh_Pair<span class="main">)</span><span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs1_eq_iff_fresh<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> <span class="tvar">?'a</span><span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="tfree">'b</span><span class="main">::</span>at"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="free">b</span><span class="main">,</span> <span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">,</span> <span class="free">z</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> obtain_fresh<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="improper">aa</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> Abs1_eq_iff_fresh<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fresh_Pair<span class="main">)</span><span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs1_eq_iff_fresh<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> <span class="tvar">?'a</span><span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="tfree">'b</span><span class="main">::</span>at"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="free">b</span><span class="main">,</span> <span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">,</span> <span class="free">z</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> obtain_fresh<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="improper">aa</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> Abs1_eq_iff_fresh<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fresh_Pair<span class="main">)</span><span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Nominal2_Abs-Abs1_eq_iff"><span class="command">lemma</span></span> Abs1_eq_iff<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="free">y</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>fs"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">a</span> <span class="free">b</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'b</span><span class="main">::</span>at"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">{</span>atom <span class="free">a</span><span class="main">}</span><span class="keyword1">]set.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="main">{</span>atom <span class="free">b</span><span class="main">}</span><span class="keyword1">]set.</span> <span class="free">y</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">a</span> <span class="main">=</span> <span class="free">b</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span><span class="free">a</span> <span class="main">≠</span> <span class="free">b</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">y</span> <span class="main">∧</span> atom <span class="free">a</span> <span class="main">♯</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">{</span>atom <span class="free">a</span><span class="main">}</span><span class="keyword1">]res.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="main">{</span>atom <span class="free">b</span><span class="main">}</span><span class="keyword1">]res.</span> <span class="free">y</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">a</span> <span class="main">=</span> <span class="free">b</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span><span class="free">a</span> <span class="main">≠</span> <span class="free">b</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">y</span> <span class="main">∧</span> atom <span class="free">a</span> <span class="main">♯</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">[</span>atom <span class="free">a</span><span class="main">]</span><span class="keyword1">]lst.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="main">[</span>atom <span class="free">b</span><span class="main">]</span><span class="keyword1">]lst.</span> <span class="free">y</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">a</span> <span class="main">=</span> <span class="free">b</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span><span class="free">a</span> <span class="main">≠</span> <span class="free">b</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">y</span> <span class="main">∧</span> atom <span class="free">a</span> <span class="main">♯</span> <span class="free">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">=</span> <span class="free">b</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">{</span>atom <span class="free">a</span><span class="main">}</span><span class="keyword1">]set.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="main">{</span>atom <span class="free">b</span><span class="main">}</span><span class="keyword1">]set.</span> <span class="free">y</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">a</span> <span class="main">=</span> <span class="free">b</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs1_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">≠</span> <span class="free">b</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> **<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">{</span>atom <span class="free">a</span><span class="main">}</span><span class="keyword1">]set.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="main">{</span>atom <span class="free">b</span><span class="main">}</span><span class="keyword1">]set.</span> <span class="free">y</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> #<span class="main">:</span> <span class="quoted"><span class="quoted">"atom <span class="free">a</span> <span class="main">♯</span> <span class="main">[</span><span class="main">{</span>atom <span class="free">b</span><span class="main">}</span><span class="keyword1">]set.</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> **<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> Abs_fresh_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">{</span>atom <span class="free">a</span><span class="main">}</span><span class="keyword1">]set.</span> <span class="main">(</span><span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="main">(</span><span class="main">[</span><span class="main">{</span>atom <span class="free">b</span><span class="main">}</span><span class="keyword1">]set.</span> <span class="free">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">[</span><span class="main">{</span>atom <span class="free">b</span><span class="main">}</span><span class="keyword1">]set.</span> <span class="free">y</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> flip_fresh_fresh<span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> #<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_fresh_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">[</span><span class="main">{</span>atom <span class="free">a</span><span class="main">}</span><span class="keyword1">]set.</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> ** <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">≠</span> <span class="free">b</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">y</span> <span class="main">∧</span> atom <span class="free">a</span> <span class="main">♯</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> # * <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs1_eq Abs_fresh_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">≠</span> <span class="free">b</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> **<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">y</span> <span class="main">∧</span> atom <span class="free">a</span> <span class="main">♯</span> <span class="free">y</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">{</span>atom <span class="free">a</span><span class="main">}</span><span class="keyword1">]set.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="main">{</span>atom <span class="free">a</span><span class="main">}</span><span class="keyword1">]set.</span> <span class="main">(</span><span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> ** <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="main">(</span><span class="main">[</span><span class="main">{</span>atom <span class="free">b</span><span class="main">}</span><span class="keyword1">]set.</span> <span class="free">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_set_def<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">[</span><span class="main">{</span>atom <span class="free">b</span><span class="main">}</span><span class="keyword1">]set.</span> <span class="free">y</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> flip_fresh_fresh<span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_fresh_iff **<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_fresh_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">{</span>atom <span class="free">a</span><span class="main">}</span><span class="keyword1">]set.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="main">{</span>atom <span class="free">b</span><span class="main">}</span><span class="keyword1">]set.</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">{</span>atom <span class="free">a</span><span class="main">}</span><span class="keyword1">]set.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="main">{</span>atom <span class="free">b</span><span class="main">}</span><span class="keyword1">]set.</span> <span class="free">y</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">a</span> <span class="main">=</span> <span class="free">b</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span><span class="free">a</span> <span class="main">≠</span> <span class="free">b</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">y</span> <span class="main">∧</span> atom <span class="free">a</span> <span class="main">♯</span> <span class="free">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">=</span> <span class="free">b</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Abs_res <span class="main">{</span>atom <span class="free">a</span><span class="main">}</span> <span class="free">x</span> <span class="main">=</span> Abs_res <span class="main">{</span>atom <span class="free">b</span><span class="main">}</span> <span class="free">y</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">a</span> <span class="main">=</span> <span class="free">b</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs1_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">≠</span> <span class="free">b</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> **<span class="main">:</span> <span class="quoted"><span class="quoted">"Abs_res <span class="main">{</span>atom <span class="free">a</span><span class="main">}</span> <span class="free">x</span> <span class="main">=</span> Abs_res <span class="main">{</span>atom <span class="free">b</span><span class="main">}</span> <span class="free">y</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> #<span class="main">:</span> <span class="quoted"><span class="quoted">"atom <span class="free">a</span> <span class="main">♯</span> Abs_res <span class="main">{</span>atom <span class="free">b</span><span class="main">}</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> **<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> Abs_fresh_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Abs_res <span class="main">{</span>atom <span class="free">a</span><span class="main">}</span> <span class="main">(</span><span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="main">(</span>Abs_res <span class="main">{</span>atom <span class="free">b</span><span class="main">}</span> <span class="free">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> Abs_res <span class="main">{</span>atom <span class="free">b</span><span class="main">}</span> <span class="free">y</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> flip_fresh_fresh<span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> #<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_fresh_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> Abs_res <span class="main">{</span>atom <span class="free">a</span><span class="main">}</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> ** <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">≠</span> <span class="free">b</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">y</span> <span class="main">∧</span> atom <span class="free">a</span> <span class="main">♯</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> # * <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs1_eq Abs_fresh_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">≠</span> <span class="free">b</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> **<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">y</span> <span class="main">∧</span> atom <span class="free">a</span> <span class="main">♯</span> <span class="free">y</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Abs_res <span class="main">{</span>atom <span class="free">a</span><span class="main">}</span> <span class="free">x</span> <span class="main">=</span> Abs_res <span class="main">{</span>atom <span class="free">a</span><span class="main">}</span> <span class="main">(</span><span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> ** <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> Abs_res <span class="main">{</span>atom <span class="free">b</span><span class="main">}</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_set_def<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> Abs_res <span class="main">{</span>atom <span class="free">b</span><span class="main">}</span> <span class="free">y</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> flip_fresh_fresh<span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_fresh_iff **<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_fresh_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Abs_res <span class="main">{</span>atom <span class="free">a</span><span class="main">}</span> <span class="free">x</span> <span class="main">=</span> Abs_res <span class="main">{</span>atom <span class="free">b</span><span class="main">}</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Abs_res <span class="main">{</span>atom <span class="free">a</span><span class="main">}</span> <span class="free">x</span> <span class="main">=</span> Abs_res <span class="main">{</span>atom <span class="free">b</span><span class="main">}</span> <span class="free">y</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">a</span> <span class="main">=</span> <span class="free">b</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span><span class="free">a</span> <span class="main">≠</span> <span class="free">b</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">y</span> <span class="main">∧</span> atom <span class="free">a</span> <span class="main">♯</span> <span class="free">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">=</span> <span class="free">b</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Abs_lst <span class="main">[</span>atom <span class="free">a</span><span class="main">]</span> <span class="free">x</span> <span class="main">=</span> Abs_lst <span class="main">[</span>atom <span class="free">b</span><span class="main">]</span> <span class="free">y</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">a</span> <span class="main">=</span> <span class="free">b</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs1_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">≠</span> <span class="free">b</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> **<span class="main">:</span> <span class="quoted"><span class="quoted">"Abs_lst <span class="main">[</span>atom <span class="free">a</span><span class="main">]</span> <span class="free">x</span> <span class="main">=</span> Abs_lst <span class="main">[</span>atom <span class="free">b</span><span class="main">]</span> <span class="free">y</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> #<span class="main">:</span> <span class="quoted"><span class="quoted">"atom <span class="free">a</span> <span class="main">♯</span> Abs_lst <span class="main">[</span>atom <span class="free">b</span><span class="main">]</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> **<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> Abs_fresh_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Abs_lst <span class="main">[</span>atom <span class="free">a</span><span class="main">]</span> <span class="main">(</span><span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="main">(</span>Abs_lst <span class="main">[</span>atom <span class="free">b</span><span class="main">]</span> <span class="free">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> Abs_lst <span class="main">[</span>atom <span class="free">b</span><span class="main">]</span> <span class="free">y</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> flip_fresh_fresh<span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> #<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_fresh_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> Abs_lst <span class="main">[</span>atom <span class="free">a</span><span class="main">]</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> ** <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">≠</span> <span class="free">b</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">y</span> <span class="main">∧</span> atom <span class="free">a</span> <span class="main">♯</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> # * <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs1_eq Abs_fresh_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">≠</span> <span class="free">b</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> **<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">y</span> <span class="main">∧</span> atom <span class="free">a</span> <span class="main">♯</span> <span class="free">y</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Abs_lst <span class="main">[</span>atom <span class="free">a</span><span class="main">]</span> <span class="free">x</span> <span class="main">=</span> Abs_lst <span class="main">[</span>atom <span class="free">a</span><span class="main">]</span> <span class="main">(</span><span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> ** <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> Abs_lst <span class="main">[</span>atom <span class="free">b</span><span class="main">]</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> Abs_lst <span class="main">[</span>atom <span class="free">b</span><span class="main">]</span> <span class="free">y</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> flip_fresh_fresh<span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_fresh_iff **<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_fresh_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Abs_lst <span class="main">[</span>atom <span class="free">a</span><span class="main">]</span> <span class="free">x</span> <span class="main">=</span> Abs_lst <span class="main">[</span>atom <span class="free">b</span><span class="main">]</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Abs_lst <span class="main">[</span>atom <span class="free">a</span><span class="main">]</span> <span class="free">x</span> <span class="main">=</span> Abs_lst <span class="main">[</span>atom <span class="free">b</span><span class="main">]</span> <span class="free">y</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">a</span> <span class="main">=</span> <span class="free">b</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span><span class="free">a</span> <span class="main">≠</span> <span class="free">b</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">y</span> <span class="main">∧</span> atom <span class="free">a</span> <span class="main">♯</span> <span class="free">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Abs-Abs1_eq_iff'"><span class="command">lemma</span></span> Abs1_eq_iff'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>fs"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">a</span> <span class="free">b</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'b</span><span class="main">::</span>at"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">{</span>atom <span class="free">a</span><span class="main">}</span><span class="keyword1">]set.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="main">{</span>atom <span class="free">b</span><span class="main">}</span><span class="keyword1">]set.</span> <span class="free">y</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">a</span> <span class="main">=</span> <span class="free">b</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span><span class="free">a</span> <span class="main">≠</span> <span class="free">b</span> <span class="main">∧</span> <span class="main">(</span><span class="free">b</span> <span class="main">↔</span> <span class="free">a</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span> <span class="main">∧</span> atom <span class="free">b</span> <span class="main">♯</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">{</span>atom <span class="free">a</span><span class="main">}</span><span class="keyword1">]res.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="main">{</span>atom <span class="free">b</span><span class="main">}</span><span class="keyword1">]res.</span> <span class="free">y</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">a</span> <span class="main">=</span> <span class="free">b</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span><span class="free">a</span> <span class="main">≠</span> <span class="free">b</span> <span class="main">∧</span> <span class="main">(</span><span class="free">b</span> <span class="main">↔</span> <span class="free">a</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span> <span class="main">∧</span> atom <span class="free">b</span> <span class="main">♯</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">[</span>atom <span class="free">a</span><span class="main">]</span><span class="keyword1">]lst.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="main">[</span>atom <span class="free">b</span><span class="main">]</span><span class="keyword1">]lst.</span> <span class="free">y</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">a</span> <span class="main">=</span> <span class="free">b</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span><span class="free">a</span> <span class="main">≠</span> <span class="free">b</span> <span class="main">∧</span> <span class="main">(</span><span class="free">b</span> <span class="main">↔</span> <span class="free">a</span><span class="main">)</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span> <span class="main">∧</span> atom <span class="free">b</span> <span class="main">♯</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Abs1_eq_iff fresh_permute_left<span class="main">)</span>


<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">alpha_single_simproc</span> <span class="entity">thm</span> <span class="main">_</span> <span class="entity">ctxt</span> <span class="entity">ctrm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> $ <span class="main">(</span><span class="main">_</span> $ <span class="entity">x</span><span class="main">)</span> $ <span class="main">(</span><span class="main">_</span> $ <span class="entity">y</span><span class="main">)</span> <span class="main">=</span> Thm.term_of <span class="entity">ctrm</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cvrs</span> <span class="main">=</span> union <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span>Term.add_frees <span class="entity">x</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="main">(</span>Term.add_frees <span class="entity">y</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
      |&gt; filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">ty</span><span class="main">)</span> <span class="main">=&gt;</span> Sign.of_sort <span class="entity">thy</span> <span class="main">(</span><span class="entity">ty</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">fs</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">)</span>
      |&gt; map Free
      |&gt; <span class="entity">HOLogic.mk_tuple</span>
      |&gt; Thm.cterm_of <span class="entity">ctxt</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cvrs_ty</span> <span class="main">=</span> Thm.ctyp_of_cterm <span class="entity">cvrs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm'</span> <span class="main">=</span> <span class="entity">thm</span>
      |&gt; Thm.instantiate' <span class="main">[</span>NONE<span class="main">,</span> NONE<span class="main">,</span> SOME <span class="entity">cvrs_ty</span><span class="main">]</span> <span class="main">[</span>NONE<span class="main">,</span> NONE<span class="main">,</span> NONE<span class="main">,</span> NONE<span class="main">,</span> SOME <span class="entity">cvrs</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    SOME <span class="entity">thm'</span>
  <span class="keyword2"><span class="keyword">end</span></span>
›</span>

<span class="keyword1"><span class="command">simproc_setup</span></span> alpha_set <span class="main">(</span><span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">{</span>atom <span class="free">a</span><span class="main">}</span><span class="keyword1">]set.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="main">{</span>atom <span class="free">b</span><span class="main">}</span><span class="keyword1">]set.</span> <span class="free">y</span>"</span></span><span class="main">)</span> <span class="main">=</span>
  <span class="quoted">‹<span class="entity">alpha_single_simproc</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Abs1_eq_iff_all<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">THEN</span> eq_reflection<span class="main">]</span><span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">simproc_setup</span></span> alpha_res <span class="main">(</span><span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">{</span>atom <span class="free">a</span><span class="main">}</span><span class="keyword1">]res.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="main">{</span>atom <span class="free">b</span><span class="main">}</span><span class="keyword1">]res.</span> <span class="free">y</span>"</span></span><span class="main">)</span> <span class="main">=</span>
  <span class="quoted">‹<span class="entity">alpha_single_simproc</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Abs1_eq_iff_all<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">THEN</span> eq_reflection<span class="main">]</span><span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">simproc_setup</span></span> alpha_lst <span class="main">(</span><span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">[</span>atom <span class="free">a</span><span class="main">]</span><span class="keyword1">]lst.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="main">[</span>atom <span class="free">b</span><span class="main">]</span><span class="keyword1">]lst.</span> <span class="free">y</span>"</span></span><span class="main">)</span> <span class="main">=</span>
  <span class="quoted">‹<span class="entity">alpha_single_simproc</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Abs1_eq_iff_all<span class="main">(</span>3<span class="main">)</span><span class="main">[</span><span class="operator">THEN</span> eq_reflection<span class="main">]</span><span class="antiquote">}</span></span></span>›</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Renaming of bodies of abstractions›</span></span>

<span class="keyword1" id="Nominal2_Abs-Abs_rename_set"><span class="command">lemma</span></span> Abs_rename_set<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>fs"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">bs</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">x</span>"</span></span>
  <span class="comment1">(*and     b: "finite bs"*)</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">q</span><span class="main">.</span> <span class="main">[</span><span class="free">bs</span><span class="keyword1">]set.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="free">p</span> <span class="main">∙</span> <span class="free">bs</span><span class="keyword1">]set.</span> <span class="main">(</span><span class="bound">q</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">q</span> <span class="main">∙</span> <span class="free">bs</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">bs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> set_renaming_perm2
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">q</span></span> <span class="keyword2"><span class="keyword">where</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b</span> <span class="main">∈</span> <span class="free">bs</span><span class="main">.</span> <span class="skolem">q</span> <span class="main">∙</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="bound">b</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> **<span class="main">:</span> <span class="quoted"><span class="quoted">"supp <span class="skolem">q</span> <span class="main">⊆</span> <span class="free">bs</span> <span class="main">∪</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">bs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">have</span></span> ***<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span> <span class="main">∙</span> <span class="free">bs</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">bs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> *
    <span class="keyword1"><span class="command">unfolding</span></span> permute_set_eq_image image_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">bs</span><span class="keyword1">]set.</span> <span class="free">x</span> <span class="main">=</span>  <span class="skolem">q</span> <span class="main">∙</span> <span class="main">(</span><span class="main">[</span><span class="free">bs</span><span class="keyword1">]set.</span> <span class="free">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> perm_supp_eq<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> a **
    <span class="keyword1"><span class="command">unfolding</span></span> Abs_fresh_star_iff
    <span class="keyword1"><span class="command">unfolding</span></span> fresh_star_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">[</span><span class="skolem">q</span> <span class="main">∙</span> <span class="free">bs</span><span class="keyword1">]set.</span> <span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">bs</span><span class="keyword1">]set.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="free">p</span> <span class="main">∙</span> <span class="free">bs</span><span class="keyword1">]set.</span> <span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ***<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">q</span><span class="main">.</span> <span class="main">[</span><span class="free">bs</span><span class="keyword1">]set.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="free">p</span> <span class="main">∙</span> <span class="free">bs</span><span class="keyword1">]set.</span> <span class="main">(</span><span class="bound">q</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">q</span> <span class="main">∙</span> <span class="free">bs</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">bs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> *** <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Abs-Abs_rename_res"><span class="command">lemma</span></span> Abs_rename_res<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>fs"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">bs</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">x</span>"</span></span>
  <span class="comment1">(*and     b: "finite bs"*)</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">q</span><span class="main">.</span> <span class="main">[</span><span class="free">bs</span><span class="keyword1">]res.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="free">p</span> <span class="main">∙</span> <span class="free">bs</span><span class="keyword1">]res.</span> <span class="main">(</span><span class="bound">q</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">q</span> <span class="main">∙</span> <span class="free">bs</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">bs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> set_renaming_perm2
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">q</span></span> <span class="keyword2"><span class="keyword">where</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b</span> <span class="main">∈</span> <span class="free">bs</span><span class="main">.</span> <span class="skolem">q</span> <span class="main">∙</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="bound">b</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> **<span class="main">:</span> <span class="quoted"><span class="quoted">"supp <span class="skolem">q</span> <span class="main">⊆</span> <span class="free">bs</span> <span class="main">∪</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">bs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">have</span></span> ***<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span> <span class="main">∙</span> <span class="free">bs</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">bs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> *
    <span class="keyword1"><span class="command">unfolding</span></span> permute_set_eq_image image_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">bs</span><span class="keyword1">]res.</span> <span class="free">x</span> <span class="main">=</span>  <span class="skolem">q</span> <span class="main">∙</span> <span class="main">(</span><span class="main">[</span><span class="free">bs</span><span class="keyword1">]res.</span> <span class="free">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> perm_supp_eq<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> a **
    <span class="keyword1"><span class="command">unfolding</span></span> Abs_fresh_star_iff
    <span class="keyword1"><span class="command">unfolding</span></span> fresh_star_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">[</span><span class="skolem">q</span> <span class="main">∙</span> <span class="free">bs</span><span class="keyword1">]res.</span> <span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">bs</span><span class="keyword1">]res.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="free">p</span> <span class="main">∙</span> <span class="free">bs</span><span class="keyword1">]res.</span> <span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ***<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">q</span><span class="main">.</span> <span class="main">[</span><span class="free">bs</span><span class="keyword1">]res.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="free">p</span> <span class="main">∙</span> <span class="free">bs</span><span class="keyword1">]res.</span> <span class="main">(</span><span class="bound">q</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">q</span> <span class="main">∙</span> <span class="free">bs</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">bs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> *** <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_Abs-Abs_rename_lst"><span class="command">lemma</span></span> Abs_rename_lst<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>fs"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>set <span class="free">bs</span><span class="main">)</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">q</span><span class="main">.</span> <span class="main">[</span><span class="free">bs</span><span class="keyword1">]lst.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="free">p</span> <span class="main">∙</span> <span class="free">bs</span><span class="keyword1">]lst.</span> <span class="main">(</span><span class="bound">q</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">q</span> <span class="main">∙</span> <span class="free">bs</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">bs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> list_renaming_perm
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">q</span></span> <span class="keyword2"><span class="keyword">where</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b</span> <span class="main">∈</span> set <span class="free">bs</span><span class="main">.</span> <span class="skolem">q</span> <span class="main">∙</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="bound">b</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> **<span class="main">:</span> <span class="quoted"><span class="quoted">"supp <span class="skolem">q</span> <span class="main">⊆</span> set <span class="free">bs</span> <span class="main">∪</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> set <span class="free">bs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">have</span></span> ***<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span> <span class="main">∙</span> <span class="free">bs</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">bs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> * <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">bs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> insert_eqvt<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">bs</span><span class="keyword1">]lst.</span> <span class="free">x</span> <span class="main">=</span>  <span class="skolem">q</span> <span class="main">∙</span> <span class="main">(</span><span class="main">[</span><span class="free">bs</span><span class="keyword1">]lst.</span> <span class="free">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> perm_supp_eq<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> a **
    <span class="keyword1"><span class="command">unfolding</span></span> Abs_fresh_star_iff
    <span class="keyword1"><span class="command">unfolding</span></span> fresh_star_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">[</span><span class="skolem">q</span> <span class="main">∙</span> <span class="free">bs</span><span class="keyword1">]lst.</span> <span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">bs</span><span class="keyword1">]lst.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="free">p</span> <span class="main">∙</span> <span class="free">bs</span><span class="keyword1">]lst.</span> <span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ***<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">q</span><span class="main">.</span> <span class="main">[</span><span class="free">bs</span><span class="keyword1">]lst.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="free">p</span> <span class="main">∙</span> <span class="free">bs</span><span class="keyword1">]lst.</span> <span class="main">(</span><span class="bound">q</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">q</span> <span class="main">∙</span> <span class="free">bs</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">bs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> *** <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹for deep recursive binders›</span></span>

<span class="keyword1" id="Nominal2_Abs-Abs_rename_set'"><span class="command">lemma</span></span> Abs_rename_set'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>fs"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">bs</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">x</span>"</span></span>
  <span class="comment1">(*and     b: "finite bs"*)</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">q</span><span class="main">.</span> <span class="main">[</span><span class="free">bs</span><span class="keyword1">]set.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="bound">q</span> <span class="main">∙</span> <span class="free">bs</span><span class="keyword1">]set.</span> <span class="main">(</span><span class="bound">q</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">q</span> <span class="main">∙</span> <span class="free">bs</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">bs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> Abs_rename_set<span class="main">[</span><span class="operator">OF</span> a<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>

<span class="keyword1" id="Nominal2_Abs-Abs_rename_res'"><span class="command">lemma</span></span> Abs_rename_res'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>fs"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">bs</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">x</span>"</span></span>
  <span class="comment1">(*and     b: "finite bs"*)</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">q</span><span class="main">.</span> <span class="main">[</span><span class="free">bs</span><span class="keyword1">]res.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="bound">q</span> <span class="main">∙</span> <span class="free">bs</span><span class="keyword1">]res.</span> <span class="main">(</span><span class="bound">q</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">q</span> <span class="main">∙</span> <span class="free">bs</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">bs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> Abs_rename_res<span class="main">[</span><span class="operator">OF</span> a<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>

<span class="keyword1" id="Nominal2_Abs-Abs_rename_lst'"><span class="command">lemma</span></span> Abs_rename_lst'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>fs"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="main">(</span>set <span class="free">bs</span><span class="main">)</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">q</span><span class="main">.</span> <span class="main">[</span><span class="free">bs</span><span class="keyword1">]lst.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="bound">q</span> <span class="main">∙</span> <span class="free">bs</span><span class="keyword1">]lst.</span> <span class="main">(</span><span class="bound">q</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">q</span> <span class="main">∙</span> <span class="free">bs</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">bs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> Abs_rename_lst<span class="main">[</span><span class="operator">OF</span> a<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Infrastructure for building tuples of relations and functions›</span></span>

<span class="keyword1"><span class="command">fun</span></span>
  <span class="entity">prod_fv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> atom set<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> atom set<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> atom set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">prod_fv</span> <span class="free"><span class="bound"><span class="entity">fv1</span></span></span> <span class="free"><span class="bound"><span class="entity">fv2</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">fv1</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">∪</span> <span class="free"><span class="bound"><span class="entity">fv2</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">prod_alpha</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool<span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
 <span class="quoted"><span class="quoted">"<span class="free">prod_alpha</span> <span class="main">=</span> rel_prod"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">quot_respect</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">R1</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">R2</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span> rel_prod <span class="free">R1</span> <span class="free">R2</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> prod_fv prod_fv"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> rel_fun_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">quot_preserve</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> q1<span class="main">:</span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R1</span> <span class="free">abs1</span> <span class="free">rep1</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>     q2<span class="main">:</span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R2</span> <span class="free">abs2</span> <span class="free">rep2</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">abs1</span> <span class="main">---&gt;</span> id<span class="main">)</span> <span class="main">---&gt;</span> <span class="main">(</span><span class="free">abs2</span> <span class="main">---&gt;</span> id<span class="main">)</span> <span class="main">---&gt;</span> map_prod <span class="free">rep1</span> <span class="free">rep2</span> <span class="main">---&gt;</span> id<span class="main">)</span> prod_fv <span class="main">=</span> prod_fv"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff Quotient3_abs_rep<span class="main"><span class="main">[</span></span><span class="operator">OF</span> q1<span class="main"><span class="main">]</span></span> Quotient3_abs_rep<span class="main"><span class="main">[</span></span><span class="operator">OF</span> q2<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">mono</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">&lt;=</span> <span class="free">B</span> <span class="main">⟹</span> <span class="free">C</span> <span class="main">&lt;=</span> <span class="free">D</span> <span class="main">==&gt;</span> prod_alpha <span class="free">A</span> <span class="free">C</span> <span class="main">&lt;=</span> prod_alpha <span class="free">B</span> <span class="free">D</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> prod_alpha_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> prod_alpha <span class="free">A</span> <span class="free">B</span> <span class="free">x</span> <span class="free">y</span> <span class="main">=</span> prod_alpha <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">A</span><span class="main">)</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">B</span><span class="main">)</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> prod_alpha_def
  <span class="keyword1"><span class="command">unfolding</span></span> rel_prod_conv
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">perm_simp</span><span class="main">)</span> <span class="main">(</span><span class="operator">rule</span> refl<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">eqvt</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> prod_fv <span class="free">A</span> <span class="free">B</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> prod_fv <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">A</span><span class="main">)</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">B</span><span class="main">)</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">,</span> <span class="free">p</span> <span class="main">∙</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> prod_fv.simps
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">perm_simp</span><span class="main">)</span> <span class="main">(</span><span class="operator">rule</span> refl<span class="main">)</span>

<span class="keyword1" id="Nominal2_Abs-prod_fv_supp"><span class="command">lemma</span></span> prod_fv_supp<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"prod_fv supp supp <span class="main">=</span> supp"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span>
   <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> supp_Pair<span class="main">)</span>

<span class="keyword1" id="Nominal2_Abs-prod_alpha_eq"><span class="command">lemma</span></span> prod_alpha_eq<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"prod_alpha <span class="main">(</span><span class="main">(=)</span><span class="main">)</span> <span class="main">(</span><span class="main">(=)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(=)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> prod_alpha_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ext<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Nominal2_FCB">
<div class="head">
<h1>Theory Nominal2_FCB</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> Nominal2_FCB
<span class="keyword2"><span class="keyword">imports</span></span> <a href="#Nominal2_Abs">Nominal2_Abs</a>
<span class="keyword2"><span class="keyword">begin</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  A tactic which solves all trivial cases in function
  definitions, and leaves the others unchanged.
›</span></span>

<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_trivials</span> <span class="main">:</span> <span class="main">(</span><span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Proof.method</span><span class="main">)</span> context_parser <span class="main">=</span>
Scan.succeed <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span>
 <span class="keyword2"><span class="keyword">let</span></span>
   <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tac</span> <span class="main">=</span> TRYALL <span class="main">(</span>SOLVED' <span class="main">(</span><span class="entity">full_simp_tac</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span>
 <span class="keyword2"><span class="keyword">in</span></span>
   <span class="entity">Method.SIMPLE_METHOD'</span> <span class="main">(</span>K <span class="entity">tac</span><span class="main">)</span>
 <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>
›</span>

<span class="keyword1"><span class="command">method_setup</span></span> all_trivials <span class="main">=</span> <span class="quoted">‹<span class="entity">all_trivials</span>›</span> <span class="quoted">‹solves trivial goals›</span>


<span class="keyword1" id="Nominal2_FCB-Abs_lst1_fcb"><span class="command">lemma</span></span> Abs_lst1_fcb<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="free">y</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> at"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">S</span> <span class="free">T</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">::</span> fs"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> e<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">[</span>atom <span class="free">x</span><span class="main">]</span><span class="keyword1">]lst.</span> <span class="free">T</span> <span class="main">=</span> <span class="main">[</span><span class="main">[</span>atom <span class="free">y</span><span class="main">]</span><span class="keyword1">]lst.</span> <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> f1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">x</span> <span class="main">≠</span> <span class="free">y</span><span class="main">;</span> atom <span class="free">y</span> <span class="main">♯</span> <span class="free">T</span><span class="main">;</span> atom <span class="free">x</span> <span class="main">♯</span> <span class="main">(</span><span class="free">y</span> <span class="main">↔</span> <span class="free">x</span><span class="main">)</span> <span class="main">∙</span> <span class="free">T</span><span class="main">⟧</span> <span class="main">⟹</span> atom <span class="free">x</span> <span class="main">♯</span> <span class="free">f</span> <span class="free">x</span> <span class="free">T</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> f2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">x</span> <span class="main">≠</span> <span class="free">y</span><span class="main">;</span> atom <span class="free">y</span> <span class="main">♯</span> <span class="free">T</span><span class="main">;</span> atom <span class="free">x</span> <span class="main">♯</span> <span class="main">(</span><span class="free">y</span> <span class="main">↔</span> <span class="free">x</span><span class="main">)</span> <span class="main">∙</span> <span class="free">T</span><span class="main">⟧</span> <span class="main">⟹</span> atom <span class="free">y</span> <span class="main">♯</span> <span class="free">f</span> <span class="free">x</span> <span class="free">T</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> p<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">S</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">↔</span> <span class="free">y</span><span class="main">)</span> <span class="main">∙</span> <span class="free">T</span><span class="main">;</span> <span class="free">x</span> <span class="main">≠</span> <span class="free">y</span><span class="main">;</span> atom <span class="free">y</span> <span class="main">♯</span> <span class="free">T</span><span class="main">;</span> atom <span class="free">x</span> <span class="main">♯</span> <span class="free">S</span><span class="main">⟧</span>
    <span class="main">⟹</span> <span class="main">(</span><span class="free">x</span> <span class="main">↔</span> <span class="free">y</span><span class="main">)</span> <span class="main">∙</span> <span class="main">(</span><span class="free">f</span> <span class="free">x</span> <span class="free">T</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="free">y</span> <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">x</span> <span class="free">T</span> <span class="main">=</span> <span class="free">f</span> <span class="free">y</span> <span class="free">S</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> e
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"atom <span class="free">x</span> <span class="main">♯</span> <span class="free">S</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs1_eq_iff'<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">elim</span> conjE disjE<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> trans<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> p<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">↔</span> <span class="free">y</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> supp_perm_eq<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> fresh_star_supp_conv<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> flip_def supp_swap fresh_star_def f1 f2<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> flip_commute p<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs1_eq_iff<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Nominal2_FCB-Abs_lst_fcb"><span class="command">lemma</span></span> Abs_lst_fcb<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> fs"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">S</span> <span class="free">T</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">::</span> fs"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> e<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Abs_lst <span class="main">(</span><span class="free">ba</span> <span class="free">xs</span><span class="main">)</span> <span class="free">T</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Abs_lst <span class="main">(</span><span class="free">ba</span> <span class="free">ys</span><span class="main">)</span> <span class="free">S</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> f1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> set <span class="main">(</span><span class="free">ba</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟹</span> <span class="bound">x</span> <span class="main">♯</span> <span class="free">f</span> <span class="free">xs</span> <span class="free">T</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> f2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="main">⟦</span>supp <span class="free">T</span> <span class="main">-</span> set <span class="main">(</span><span class="free">ba</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> supp <span class="free">S</span> <span class="main">-</span> set <span class="main">(</span><span class="free">ba</span> <span class="free">ys</span><span class="main">)</span><span class="main">;</span> <span class="bound">x</span> <span class="main">∈</span> set <span class="main">(</span><span class="free">ba</span> <span class="free">ys</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="bound">x</span> <span class="main">♯</span> <span class="free">f</span> <span class="free">xs</span> <span class="free">T</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> eqv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">p</span><span class="main">.</span> <span class="main">⟦</span><span class="bound">p</span> <span class="main">∙</span> <span class="free">T</span> <span class="main">=</span> <span class="free">S</span><span class="main">;</span> <span class="bound">p</span> <span class="main">∙</span> <span class="free">ba</span> <span class="free">xs</span> <span class="main">=</span> <span class="free">ba</span> <span class="free">ys</span><span class="main">;</span> supp <span class="bound">p</span> <span class="main">⊆</span> set <span class="main">(</span><span class="free">ba</span> <span class="free">xs</span><span class="main">)</span> <span class="main">∪</span> set <span class="main">(</span><span class="free">ba</span> <span class="free">ys</span><span class="main">)</span><span class="main">⟧</span>
      <span class="main">⟹</span> <span class="bound">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">f</span> <span class="free">xs</span> <span class="free">T</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="free">ys</span> <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">xs</span> <span class="free">T</span> <span class="main">=</span> <span class="free">f</span> <span class="free">ys</span> <span class="free">S</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> e <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> Abs_eq_iff2<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alphas<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">elim</span> exE conjE<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> trans<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> p<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="improper">p</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> supp_perm_eq<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> fresh_star_supp_conv<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule</span> fresh_star_perm_set_conv<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> finite_Diff<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> finite_supp<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>set <span class="main">(</span><span class="free">ba</span> <span class="free">xs</span><span class="main">)</span> <span class="main">∪</span> set <span class="main">(</span><span class="free">ba</span> <span class="free">ys</span><span class="main">)</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">f</span> <span class="free">xs</span> <span class="free">T</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">metis</span> Un_absorb2 fresh_star_Un<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> fresh_star_Un<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> conjI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_star_def f1<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_star_def f2<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eqv<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Nominal2_FCB-Abs_set_fcb"><span class="command">lemma</span></span> Abs_set_fcb<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> fs"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">S</span> <span class="free">T</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">::</span> fs"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> e<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Abs_set <span class="main">(</span><span class="free">ba</span> <span class="free">xs</span><span class="main">)</span> <span class="free">T</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Abs_set <span class="main">(</span><span class="free">ba</span> <span class="free">ys</span><span class="main">)</span> <span class="free">S</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> f1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">ba</span> <span class="free">xs</span> <span class="main">⟹</span> <span class="bound">x</span> <span class="main">♯</span> <span class="free">f</span> <span class="free">xs</span> <span class="free">T</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> f2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="main">⟦</span>supp <span class="free">T</span> <span class="main">-</span> <span class="free">ba</span> <span class="free">xs</span> <span class="main">=</span> supp <span class="free">S</span> <span class="main">-</span> <span class="free">ba</span> <span class="free">ys</span><span class="main">;</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">ba</span> <span class="free">ys</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="bound">x</span> <span class="main">♯</span> <span class="free">f</span> <span class="free">xs</span> <span class="free">T</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> eqv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">p</span><span class="main">.</span> <span class="main">⟦</span><span class="bound">p</span> <span class="main">∙</span> <span class="free">T</span> <span class="main">=</span> <span class="free">S</span><span class="main">;</span> <span class="bound">p</span> <span class="main">∙</span> <span class="free">ba</span> <span class="free">xs</span> <span class="main">=</span> <span class="free">ba</span> <span class="free">ys</span><span class="main">;</span> supp <span class="bound">p</span> <span class="main">⊆</span> <span class="free">ba</span> <span class="free">xs</span> <span class="main">∪</span> <span class="free">ba</span> <span class="free">ys</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="bound">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">f</span> <span class="free">xs</span> <span class="free">T</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="free">ys</span> <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">xs</span> <span class="free">T</span> <span class="main">=</span> <span class="free">f</span> <span class="free">ys</span> <span class="free">S</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> e <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> Abs_eq_iff2<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alphas<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">elim</span> exE conjE<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> trans<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> p<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="improper">p</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> supp_perm_eq<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> fresh_star_supp_conv<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule</span> fresh_star_perm_set_conv<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> finite_Diff<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> finite_supp<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ba</span> <span class="free">xs</span> <span class="main">∪</span> <span class="free">ba</span> <span class="free">ys</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">f</span> <span class="free">xs</span> <span class="free">T</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">metis</span> Un_absorb2 fresh_star_Un<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> fresh_star_Un<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> conjI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_star_def f1<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_star_def f2<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eqv<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Nominal2_FCB-Abs_res_fcb"><span class="command">lemma</span></span> Abs_res_fcb<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> at_base<span class="main">)</span> set"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">S</span> <span class="free">T</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">::</span> fs"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> e<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Abs_res <span class="main">(</span>atom <span class="main">`</span> <span class="free">xs</span><span class="main">)</span> <span class="free">T</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Abs_res <span class="main">(</span>atom <span class="main">`</span> <span class="free">ys</span><span class="main">)</span> <span class="free">S</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> f1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> atom <span class="main">`</span> <span class="free">xs</span> <span class="main">⟹</span> <span class="bound">x</span> <span class="main">∈</span> supp <span class="free">T</span> <span class="main">⟹</span> <span class="bound">x</span> <span class="main">♯</span> <span class="free">f</span> <span class="free">xs</span> <span class="free">T</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> f2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="main">⟦</span>supp <span class="free">T</span> <span class="main">-</span> atom <span class="main">`</span> <span class="free">xs</span> <span class="main">=</span> supp <span class="free">S</span> <span class="main">-</span> atom <span class="main">`</span> <span class="free">ys</span><span class="main">;</span> <span class="bound">x</span> <span class="main">∈</span> atom <span class="main">`</span> <span class="free">ys</span><span class="main">;</span> <span class="bound">x</span> <span class="main">∈</span> supp <span class="free">S</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="bound">x</span> <span class="main">♯</span> <span class="free">f</span> <span class="free">xs</span> <span class="free">T</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> eqv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">p</span><span class="main">.</span> <span class="main">⟦</span><span class="bound">p</span> <span class="main">∙</span> <span class="free">T</span> <span class="main">=</span> <span class="free">S</span><span class="main">;</span> supp <span class="bound">p</span> <span class="main">⊆</span> atom <span class="main">`</span> <span class="free">xs</span> <span class="main">∩</span> supp <span class="free">T</span> <span class="main">∪</span> atom <span class="main">`</span> <span class="free">ys</span> <span class="main">∩</span> supp <span class="free">S</span><span class="main">;</span>
      <span class="bound">p</span> <span class="main">∙</span> <span class="main">(</span>atom <span class="main">`</span> <span class="free">xs</span> <span class="main">∩</span> supp <span class="free">T</span><span class="main">)</span> <span class="main">=</span> atom <span class="main">`</span> <span class="free">ys</span> <span class="main">∩</span> supp <span class="free">S</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="bound">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">f</span> <span class="free">xs</span> <span class="free">T</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="free">ys</span> <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">xs</span> <span class="free">T</span> <span class="main">=</span> <span class="free">f</span> <span class="free">ys</span> <span class="free">S</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> e <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> Abs_eq_res_set<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> Abs_eq_iff2<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alphas<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">elim</span> exE conjE<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> trans<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> p<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="improper">p</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> supp_perm_eq<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> fresh_star_supp_conv<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule</span> fresh_star_perm_set_conv<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> finite_Diff<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> finite_supp<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>atom <span class="main">`</span> <span class="free">xs</span> <span class="main">∩</span> supp <span class="free">T</span> <span class="main">∪</span> atom <span class="main">`</span> <span class="free">ys</span> <span class="main">∩</span> supp <span class="free">S</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">f</span> <span class="free">xs</span> <span class="free">T</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">metis</span> Un_absorb2 fresh_star_Un<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> fresh_star_Un<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> conjI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_star_def f1<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"supp <span class="free">T</span> <span class="main">-</span> atom <span class="main">`</span> <span class="free">xs</span> <span class="main">=</span> supp <span class="free">S</span> <span class="main">-</span> atom <span class="main">`</span> <span class="free">ys</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_star_def f2<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">blast</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eqv<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>



<span class="keyword1" id="Nominal2_FCB-Abs_set_fcb2"><span class="command">lemma</span></span> Abs_set_fcb2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">as</span> <span class="free">bs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"atom set"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">x</span> <span class="free">y</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">::</span> fs"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">c</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'c</span><span class="main">::</span>fs"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">as</span><span class="keyword1">]set.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="free">bs</span><span class="keyword1">]set.</span> <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> fin<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">as</span>"</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">bs</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> fcb1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">as</span> <span class="main">♯*</span> <span class="free">f</span> <span class="free">as</span> <span class="free">x</span> <span class="free">c</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> fresh1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">as</span> <span class="main">♯*</span> <span class="free">c</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> fresh2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bs</span> <span class="main">♯*</span> <span class="free">c</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> perm1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">p</span><span class="main">.</span> supp <span class="bound">p</span> <span class="main">♯*</span> <span class="free">c</span> <span class="main">⟹</span> <span class="bound">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">f</span> <span class="free">as</span> <span class="free">x</span> <span class="free">c</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span><span class="bound">p</span> <span class="main">∙</span> <span class="free">as</span><span class="main">)</span> <span class="main">(</span><span class="bound">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="free">c</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> perm2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">p</span><span class="main">.</span> supp <span class="bound">p</span> <span class="main">♯*</span> <span class="free">c</span> <span class="main">⟹</span> <span class="bound">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">f</span> <span class="free">bs</span> <span class="free">y</span> <span class="free">c</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span><span class="bound">p</span> <span class="main">∙</span> <span class="free">bs</span><span class="main">)</span> <span class="main">(</span><span class="bound">p</span> <span class="main">∙</span> <span class="free">y</span><span class="main">)</span> <span class="free">c</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">as</span> <span class="free">x</span> <span class="free">c</span> <span class="main">=</span> <span class="free">f</span> <span class="free">bs</span> <span class="free">y</span> <span class="free">c</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span><span class="free">as</span><span class="main">,</span> <span class="free">x</span><span class="main">,</span> <span class="free">c</span><span class="main">)</span> <span class="keyword1">supports</span> <span class="main">(</span><span class="free">f</span> <span class="free">as</span> <span class="free">x</span> <span class="free">c</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span>  supports_def fresh_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_Pair perm1 fresh_star_def supp_swap swap_fresh_fresh<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> fin1<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>supp <span class="main">(</span><span class="free">f</span> <span class="free">as</span> <span class="free">x</span> <span class="free">c</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> fin <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> supports_finite <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finite_supp supp_of_finite_sets supp_Pair<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">y</span><span class="main">,</span> <span class="free">c</span><span class="main">)</span> <span class="keyword1">supports</span> <span class="main">(</span><span class="free">f</span> <span class="free">bs</span> <span class="free">y</span> <span class="free">c</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span>  supports_def fresh_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_Pair perm2 fresh_star_def supp_swap swap_fresh_fresh<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> fin2<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>supp <span class="main">(</span><span class="free">f</span> <span class="free">bs</span> <span class="free">y</span> <span class="free">c</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> fin <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> supports_finite <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finite_supp supp_of_finite_sets supp_Pair<span class="main">)</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">q</span></span><span class="main">::</span><span class="quoted"><span class="quoted">"perm"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    fr1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="free">as</span><span class="main">)</span> <span class="main">♯*</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">c</span><span class="main">,</span> <span class="free">f</span> <span class="free">as</span> <span class="free">x</span> <span class="free">c</span><span class="main">,</span> <span class="free">f</span> <span class="free">bs</span> <span class="free">y</span> <span class="free">c</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    fr2<span class="main">:</span> <span class="quoted"><span class="quoted">"supp <span class="skolem">q</span> <span class="main">♯*</span> <span class="main">(</span><span class="main">[</span><span class="free">as</span><span class="keyword1">]set.</span> <span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    inc<span class="main">:</span> <span class="quoted"><span class="quoted">"supp <span class="skolem">q</span> <span class="main">⊆</span> <span class="free">as</span> <span class="main">∪</span> <span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="free">as</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> at_set_avoiding3<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> xs<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">as</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> c<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">c</span><span class="main">,</span> <span class="free">f</span> <span class="free">as</span> <span class="free">x</span> <span class="free">c</span><span class="main">,</span> <span class="free">f</span> <span class="free">bs</span> <span class="free">y</span> <span class="free">c</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">as</span><span class="keyword1">]set.</span> <span class="free">x</span>"</span></span><span class="main">]</span>
      fin1 fin2 fin
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_Pair finite_supp Abs_fresh_star <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> fresh_star_supp_conv<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="skolem">q</span> <span class="main">∙</span> <span class="free">as</span><span class="keyword1">]set.</span> <span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">q</span> <span class="main">∙</span> <span class="main">(</span><span class="main">[</span><span class="free">as</span><span class="keyword1">]set.</span> <span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">[</span><span class="free">as</span><span class="keyword1">]set.</span> <span class="free">x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> fr2 perm_supp_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="skolem">q</span> <span class="main">∙</span> <span class="free">as</span><span class="keyword1">]set.</span> <span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">[</span><span class="free">bs</span><span class="keyword1">]set.</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">r</span></span><span class="main">::</span><span class="quoted">perm</span> <span class="keyword2"><span class="keyword">where</span></span>
    qq1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="skolem">r</span> <span class="main">∙</span> <span class="free">y</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    qq2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span> <span class="main">∙</span> <span class="free">as</span> <span class="main">=</span> <span class="skolem">r</span> <span class="main">∙</span> <span class="free">bs</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    qq3<span class="main">:</span> <span class="quoted"><span class="quoted">"supp <span class="skolem">r</span> <span class="main">⊆</span> <span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="free">bs</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule_tac</span> sym<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> Abs_eq_iff2 alphas<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule</span> exE<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule</span> conjE<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="improper">p</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> meta_spec<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_eqvt<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">blast</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">as</span> <span class="main">♯*</span> <span class="free">f</span> <span class="free">as</span> <span class="free">x</span> <span class="free">c</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> fcb1<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span> <span class="main">∙</span> <span class="main">(</span><span class="free">as</span> <span class="main">♯*</span> <span class="free">f</span> <span class="free">as</span> <span class="free">x</span> <span class="free">c</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_bool_def<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="free">as</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="free">as</span><span class="main">)</span> <span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="free">c</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> fresh_star_eqvt set_eqvt<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> perm1<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> inc fresh1 fr1
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_star_def fresh_Pair<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">r</span> <span class="main">∙</span> <span class="free">bs</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">r</span> <span class="main">∙</span> <span class="free">bs</span><span class="main">)</span> <span class="main">(</span><span class="skolem">r</span> <span class="main">∙</span> <span class="free">y</span><span class="main">)</span> <span class="free">c</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> qq1 qq2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span> <span class="main">∙</span> <span class="main">(</span><span class="free">bs</span> <span class="main">♯*</span> <span class="free">f</span> <span class="free">bs</span> <span class="free">y</span> <span class="free">c</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> fresh_star_eqvt set_eqvt<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> perm2<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> qq3 fresh2 fr1
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_eqvt fresh_star_def fresh_Pair<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> fcb2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bs</span> <span class="main">♯*</span> <span class="free">f</span> <span class="free">bs</span> <span class="free">y</span> <span class="free">c</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_bool_def<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">as</span> <span class="free">x</span> <span class="free">c</span> <span class="main">=</span> <span class="skolem">q</span> <span class="main">∙</span> <span class="main">(</span><span class="free">f</span> <span class="free">as</span> <span class="free">x</span> <span class="free">c</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> perm_supp_eq<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> inc fcb1 fr1 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_star_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="free">as</span><span class="main">)</span> <span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="free">c</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> perm1<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> inc fresh1 fr1 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_star_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">r</span> <span class="main">∙</span> <span class="free">bs</span><span class="main">)</span> <span class="main">(</span><span class="skolem">r</span> <span class="main">∙</span> <span class="free">y</span><span class="main">)</span> <span class="free">c</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> qq1 qq2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="skolem">r</span> <span class="main">∙</span> <span class="main">(</span><span class="free">f</span> <span class="free">bs</span> <span class="free">y</span> <span class="free">c</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> perm2<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> qq3 fresh2 fr1 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_star_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="free">f</span> <span class="free">bs</span> <span class="free">y</span> <span class="free">c</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> perm_supp_eq<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> qq3 fr1 fcb2 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_star_def<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1" id="Nominal2_FCB-Abs_res_fcb2"><span class="command">lemma</span></span> Abs_res_fcb2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">as</span> <span class="free">bs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"atom set"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">x</span> <span class="free">y</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">::</span> fs"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">c</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'c</span><span class="main">::</span>fs"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">as</span><span class="keyword1">]res.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="free">bs</span><span class="keyword1">]res.</span> <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> fin<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">as</span>"</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">bs</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> fcb1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">as</span> <span class="main">∩</span> supp <span class="free">x</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">f</span> <span class="main">(</span><span class="free">as</span> <span class="main">∩</span> supp <span class="free">x</span><span class="main">)</span> <span class="free">x</span> <span class="free">c</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> fresh1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">as</span> <span class="main">♯*</span> <span class="free">c</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> fresh2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bs</span> <span class="main">♯*</span> <span class="free">c</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> perm1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">p</span><span class="main">.</span> supp <span class="bound">p</span> <span class="main">♯*</span> <span class="free">c</span> <span class="main">⟹</span> <span class="bound">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">f</span> <span class="main">(</span><span class="free">as</span> <span class="main">∩</span> supp <span class="free">x</span><span class="main">)</span> <span class="free">x</span> <span class="free">c</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span><span class="bound">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">as</span> <span class="main">∩</span> supp <span class="free">x</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="bound">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="free">c</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> perm2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">p</span><span class="main">.</span> supp <span class="bound">p</span> <span class="main">♯*</span> <span class="free">c</span> <span class="main">⟹</span> <span class="bound">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">f</span> <span class="main">(</span><span class="free">bs</span> <span class="main">∩</span> supp <span class="free">y</span><span class="main">)</span> <span class="free">y</span> <span class="free">c</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span><span class="bound">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">bs</span> <span class="main">∩</span> supp <span class="free">y</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="bound">p</span> <span class="main">∙</span> <span class="free">y</span><span class="main">)</span> <span class="free">c</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span><span class="free">as</span> <span class="main">∩</span> supp <span class="free">x</span><span class="main">)</span> <span class="free">x</span> <span class="free">c</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span><span class="free">bs</span> <span class="main">∩</span> supp <span class="free">y</span><span class="main">)</span> <span class="free">y</span> <span class="free">c</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span><span class="free">as</span><span class="main">,</span> <span class="free">x</span><span class="main">,</span> <span class="free">c</span><span class="main">)</span> <span class="keyword1">supports</span> <span class="main">(</span><span class="free">f</span> <span class="main">(</span><span class="free">as</span> <span class="main">∩</span> supp <span class="free">x</span><span class="main">)</span> <span class="free">x</span> <span class="free">c</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span>  supports_def fresh_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_Pair perm1 fresh_star_def supp_swap swap_fresh_fresh inter_eqvt supp_eqvt<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> fin1<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>supp <span class="main">(</span><span class="free">f</span> <span class="main">(</span><span class="free">as</span> <span class="main">∩</span> supp <span class="free">x</span><span class="main">)</span> <span class="free">x</span> <span class="free">c</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> fin <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> supports_finite <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finite_supp supp_of_finite_sets supp_Pair<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">y</span><span class="main">,</span> <span class="free">c</span><span class="main">)</span> <span class="keyword1">supports</span> <span class="main">(</span><span class="free">f</span> <span class="main">(</span><span class="free">bs</span> <span class="main">∩</span> supp <span class="free">y</span><span class="main">)</span> <span class="free">y</span> <span class="free">c</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span>  supports_def fresh_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_Pair perm2 fresh_star_def supp_swap swap_fresh_fresh inter_eqvt supp_eqvt<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> fin2<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>supp <span class="main">(</span><span class="free">f</span> <span class="main">(</span><span class="free">bs</span> <span class="main">∩</span> supp <span class="free">y</span><span class="main">)</span> <span class="free">y</span> <span class="free">c</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> fin <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> supports_finite <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finite_supp supp_of_finite_sets supp_Pair<span class="main">)</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">q</span></span><span class="main">::</span><span class="quoted"><span class="quoted">"perm"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    fr1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="main">(</span><span class="free">as</span> <span class="main">∩</span> supp <span class="free">x</span><span class="main">)</span><span class="main">)</span> <span class="main">♯*</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">c</span><span class="main">,</span> <span class="free">f</span> <span class="main">(</span><span class="free">as</span> <span class="main">∩</span> supp <span class="free">x</span><span class="main">)</span> <span class="free">x</span> <span class="free">c</span><span class="main">,</span> <span class="free">f</span> <span class="main">(</span><span class="free">bs</span> <span class="main">∩</span> supp <span class="free">y</span><span class="main">)</span> <span class="free">y</span> <span class="free">c</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    fr2<span class="main">:</span> <span class="quoted"><span class="quoted">"supp <span class="skolem">q</span> <span class="main">♯*</span> <span class="main">(</span><span class="main">[</span><span class="free">as</span> <span class="main">∩</span> supp <span class="free">x</span><span class="keyword1">]set.</span> <span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    inc<span class="main">:</span> <span class="quoted"><span class="quoted">"supp <span class="skolem">q</span> <span class="main">⊆</span> <span class="main">(</span><span class="free">as</span> <span class="main">∩</span> supp <span class="free">x</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="main">(</span><span class="free">as</span> <span class="main">∩</span> supp <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> at_set_avoiding3<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> xs<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">as</span> <span class="main">∩</span> supp <span class="free">x</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> c<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">c</span><span class="main">,</span> <span class="free">f</span> <span class="main">(</span><span class="free">as</span> <span class="main">∩</span> supp <span class="free">x</span><span class="main">)</span> <span class="free">x</span> <span class="free">c</span><span class="main">,</span> <span class="free">f</span> <span class="main">(</span><span class="free">bs</span> <span class="main">∩</span> supp <span class="free">y</span><span class="main">)</span> <span class="free">y</span> <span class="free">c</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">as</span> <span class="main">∩</span> supp <span class="free">x</span><span class="keyword1">]set.</span> <span class="free">x</span>"</span></span><span class="main">]</span>
      fin1 fin2 fin
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_Pair finite_supp Abs_fresh_star <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> fresh_star_supp_conv<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="skolem">q</span> <span class="main">∙</span> <span class="main">(</span><span class="free">as</span> <span class="main">∩</span> supp <span class="free">x</span><span class="main">)</span><span class="keyword1">]set.</span> <span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">q</span> <span class="main">∙</span> <span class="main">(</span><span class="main">[</span><span class="free">as</span> <span class="main">∩</span> supp <span class="free">x</span><span class="keyword1">]set.</span> <span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">[</span><span class="free">as</span> <span class="main">∩</span> supp <span class="free">x</span><span class="keyword1">]set.</span> <span class="free">x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> fr2 perm_supp_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="skolem">q</span> <span class="main">∙</span> <span class="main">(</span><span class="free">as</span> <span class="main">∩</span> supp <span class="free">x</span><span class="main">)</span><span class="keyword1">]set.</span> <span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">[</span><span class="free">bs</span> <span class="main">∩</span> supp <span class="free">y</span><span class="keyword1">]set.</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> eq
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_eq_res_set<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">r</span></span><span class="main">::</span><span class="quoted">perm</span> <span class="keyword2"><span class="keyword">where</span></span>
    qq1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="skolem">r</span> <span class="main">∙</span> <span class="free">y</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    qq2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="free">as</span> <span class="main">∩</span> supp <span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">r</span> <span class="main">∙</span> <span class="main">(</span><span class="free">bs</span> <span class="main">∩</span> supp <span class="free">y</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    qq3<span class="main">:</span> <span class="quoted"><span class="quoted">"supp <span class="skolem">r</span> <span class="main">⊆</span> <span class="main">(</span><span class="free">bs</span> <span class="main">∩</span> supp <span class="free">y</span><span class="main">)</span> <span class="main">∪</span> <span class="skolem">q</span> <span class="main">∙</span> <span class="main">(</span><span class="free">as</span> <span class="main">∩</span> supp <span class="free">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule_tac</span> sym<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> Abs_eq_iff2 alphas<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule</span> exE<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule</span> conjE<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="improper">p</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> meta_spec<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_eqvt inter_eqvt supp_eqvt<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">as</span> <span class="main">∩</span> supp <span class="free">x</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">f</span> <span class="main">(</span><span class="free">as</span> <span class="main">∩</span> supp <span class="free">x</span><span class="main">)</span> <span class="free">x</span> <span class="free">c</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> fcb1<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span> <span class="main">∙</span> <span class="main">(</span><span class="main">(</span><span class="free">as</span> <span class="main">∩</span> supp <span class="free">x</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">f</span> <span class="main">(</span><span class="free">as</span> <span class="main">∩</span> supp <span class="free">x</span><span class="main">)</span> <span class="free">x</span> <span class="free">c</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_bool_def<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="main">(</span><span class="free">as</span> <span class="main">∩</span> supp <span class="free">x</span><span class="main">)</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="main">(</span><span class="free">as</span> <span class="main">∩</span> supp <span class="free">x</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="free">c</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> fresh_star_eqvt set_eqvt<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> perm1<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> inc fresh1 fr1
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_star_def fresh_Pair<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">r</span> <span class="main">∙</span> <span class="main">(</span><span class="free">bs</span> <span class="main">∩</span> supp <span class="free">y</span><span class="main">)</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">r</span> <span class="main">∙</span> <span class="main">(</span><span class="free">bs</span> <span class="main">∩</span> supp <span class="free">y</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="skolem">r</span> <span class="main">∙</span> <span class="free">y</span><span class="main">)</span> <span class="free">c</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> qq1 qq2
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">perm_simp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span> <span class="main">∙</span> <span class="main">(</span><span class="main">(</span><span class="free">bs</span> <span class="main">∩</span> supp <span class="free">y</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">f</span> <span class="main">(</span><span class="free">bs</span> <span class="main">∩</span> supp <span class="free">y</span><span class="main">)</span> <span class="free">y</span> <span class="free">c</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> fresh_star_eqvt set_eqvt<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> perm2<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> qq3 fresh2 fr1
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_eqvt fresh_star_def fresh_Pair<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> fcb2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">bs</span> <span class="main">∩</span> supp <span class="free">y</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">f</span> <span class="main">(</span><span class="free">bs</span> <span class="main">∩</span> supp <span class="free">y</span><span class="main">)</span> <span class="free">y</span> <span class="free">c</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_bool_def<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span><span class="free">as</span> <span class="main">∩</span> supp <span class="free">x</span><span class="main">)</span> <span class="free">x</span> <span class="free">c</span> <span class="main">=</span> <span class="skolem">q</span> <span class="main">∙</span> <span class="main">(</span><span class="free">f</span> <span class="main">(</span><span class="free">as</span> <span class="main">∩</span> supp <span class="free">x</span><span class="main">)</span> <span class="free">x</span> <span class="free">c</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> perm_supp_eq<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> inc fcb1 fr1
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_star_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="main">(</span><span class="free">as</span> <span class="main">∩</span> supp <span class="free">x</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="free">c</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> perm1<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> inc fresh1 fr1 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_star_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">r</span> <span class="main">∙</span> <span class="main">(</span><span class="free">bs</span> <span class="main">∩</span> supp <span class="free">y</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="skolem">r</span> <span class="main">∙</span> <span class="free">y</span><span class="main">)</span> <span class="free">c</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> qq1 qq2
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">perm_simp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="skolem">r</span> <span class="main">∙</span> <span class="main">(</span><span class="free">f</span> <span class="main">(</span><span class="free">bs</span> <span class="main">∩</span> supp <span class="free">y</span><span class="main">)</span> <span class="free">y</span> <span class="free">c</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> perm2<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> qq3 fresh2 fr1 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_star_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span><span class="free">bs</span> <span class="main">∩</span> supp <span class="free">y</span><span class="main">)</span> <span class="free">y</span> <span class="free">c</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> perm_supp_eq<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> qq3 fr1 fcb2 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_star_def<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_FCB-Abs_lst_fcb2"><span class="command">lemma</span></span> Abs_lst_fcb2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">as</span> <span class="free">bs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"atom list"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">x</span> <span class="free">y</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">::</span> fs"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">c</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'c</span><span class="main">::</span>fs"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">as</span><span class="keyword1">]lst.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="free">bs</span><span class="keyword1">]lst.</span> <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> fcb1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>set <span class="free">as</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">f</span> <span class="free">as</span> <span class="free">x</span> <span class="free">c</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> fresh1<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="free">as</span> <span class="main">♯*</span> <span class="free">c</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> fresh2<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="free">bs</span> <span class="main">♯*</span> <span class="free">c</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> perm1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">p</span><span class="main">.</span> supp <span class="bound">p</span> <span class="main">♯*</span> <span class="free">c</span> <span class="main">⟹</span> <span class="bound">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">f</span> <span class="free">as</span> <span class="free">x</span> <span class="free">c</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span><span class="bound">p</span> <span class="main">∙</span> <span class="free">as</span><span class="main">)</span> <span class="main">(</span><span class="bound">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="free">c</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> perm2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">p</span><span class="main">.</span> supp <span class="bound">p</span> <span class="main">♯*</span> <span class="free">c</span> <span class="main">⟹</span> <span class="bound">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">f</span> <span class="free">bs</span> <span class="free">y</span> <span class="free">c</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span><span class="bound">p</span> <span class="main">∙</span> <span class="free">bs</span><span class="main">)</span> <span class="main">(</span><span class="bound">p</span> <span class="main">∙</span> <span class="free">y</span><span class="main">)</span> <span class="free">c</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">as</span> <span class="free">x</span> <span class="free">c</span> <span class="main">=</span> <span class="free">f</span> <span class="free">bs</span> <span class="free">y</span> <span class="free">c</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span><span class="free">as</span><span class="main">,</span> <span class="free">x</span><span class="main">,</span> <span class="free">c</span><span class="main">)</span> <span class="keyword1">supports</span> <span class="main">(</span><span class="free">f</span> <span class="free">as</span> <span class="free">x</span> <span class="free">c</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span>  supports_def fresh_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_Pair perm1 fresh_star_def supp_swap swap_fresh_fresh<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> fin1<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>supp <span class="main">(</span><span class="free">f</span> <span class="free">as</span> <span class="free">x</span> <span class="free">c</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> supports_finite <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finite_supp<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"supp <span class="main">(</span><span class="free">bs</span><span class="main">,</span> <span class="free">y</span><span class="main">,</span> <span class="free">c</span><span class="main">)</span> <span class="keyword1">supports</span> <span class="main">(</span><span class="free">f</span> <span class="free">bs</span> <span class="free">y</span> <span class="free">c</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span>  supports_def fresh_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_Pair perm2 fresh_star_def supp_swap swap_fresh_fresh<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> fin2<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>supp <span class="main">(</span><span class="free">f</span> <span class="free">bs</span> <span class="free">y</span> <span class="free">c</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> supports_finite <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finite_supp<span class="main">)</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">q</span></span><span class="main">::</span><span class="quoted"><span class="quoted">"perm"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    fr1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="main">(</span>set <span class="free">as</span><span class="main">)</span><span class="main">)</span> <span class="main">♯*</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">c</span><span class="main">,</span> <span class="free">f</span> <span class="free">as</span> <span class="free">x</span> <span class="free">c</span><span class="main">,</span> <span class="free">f</span> <span class="free">bs</span> <span class="free">y</span> <span class="free">c</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    fr2<span class="main">:</span> <span class="quoted"><span class="quoted">"supp <span class="skolem">q</span> <span class="main">♯*</span> Abs_lst <span class="free">as</span> <span class="free">x</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    inc<span class="main">:</span> <span class="quoted"><span class="quoted">"supp <span class="skolem">q</span> <span class="main">⊆</span> <span class="main">(</span>set <span class="free">as</span><span class="main">)</span> <span class="main">∪</span> <span class="skolem">q</span> <span class="main">∙</span> <span class="main">(</span>set <span class="free">as</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> at_set_avoiding3<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> xs<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"set <span class="free">as</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> c<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">c</span><span class="main">,</span> <span class="free">f</span> <span class="free">as</span> <span class="free">x</span> <span class="free">c</span><span class="main">,</span> <span class="free">f</span> <span class="free">bs</span> <span class="free">y</span> <span class="free">c</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">as</span><span class="keyword1">]lst.</span> <span class="free">x</span>"</span></span><span class="main">]</span>
      fin1 fin2
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> supp_Pair finite_supp Abs_fresh_star <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> fresh_star_supp_conv<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Abs_lst <span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="free">as</span><span class="main">)</span> <span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">q</span> <span class="main">∙</span> Abs_lst <span class="free">as</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> Abs_lst <span class="free">as</span> <span class="free">x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> fr2 perm_supp_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Abs_lst <span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="free">as</span><span class="main">)</span> <span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> Abs_lst <span class="free">bs</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">r</span></span><span class="main">::</span><span class="quoted">perm</span> <span class="keyword2"><span class="keyword">where</span></span>
    qq1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span> <span class="main">∙</span> <span class="free">x</span> <span class="main">=</span> <span class="skolem">r</span> <span class="main">∙</span> <span class="free">y</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    qq2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span> <span class="main">∙</span> <span class="free">as</span> <span class="main">=</span> <span class="skolem">r</span> <span class="main">∙</span> <span class="free">bs</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    qq3<span class="main">:</span> <span class="quoted"><span class="quoted">"supp <span class="skolem">r</span> <span class="main">⊆</span> <span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="main">(</span>set <span class="free">as</span><span class="main">)</span><span class="main">)</span> <span class="main">∪</span> set <span class="free">bs</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule_tac</span> sym<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> Abs_eq_iff2 alphas<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule</span> exE<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule</span> conjE<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="improper">p</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> meta_spec<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_eqvt<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">blast</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>set <span class="free">as</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">f</span> <span class="free">as</span> <span class="free">x</span> <span class="free">c</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> fcb1<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span> <span class="main">∙</span> <span class="main">(</span><span class="main">(</span>set <span class="free">as</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">f</span> <span class="free">as</span> <span class="free">x</span> <span class="free">c</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_bool_def<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="free">as</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="free">as</span><span class="main">)</span> <span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="free">c</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> fresh_star_eqvt set_eqvt<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> perm1<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> inc fresh1 fr1
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_star_def fresh_Pair<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">r</span> <span class="main">∙</span> <span class="free">bs</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">r</span> <span class="main">∙</span> <span class="free">bs</span><span class="main">)</span> <span class="main">(</span><span class="skolem">r</span> <span class="main">∙</span> <span class="free">y</span><span class="main">)</span> <span class="free">c</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> qq1 qq2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span> <span class="main">∙</span> <span class="main">(</span><span class="main">(</span>set <span class="free">bs</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">f</span> <span class="free">bs</span> <span class="free">y</span> <span class="free">c</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> fresh_star_eqvt set_eqvt<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> perm2<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> qq3 fresh2 fr1
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_eqvt fresh_star_def fresh_Pair<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> fcb2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>set <span class="free">bs</span><span class="main">)</span> <span class="main">♯*</span> <span class="free">f</span> <span class="free">bs</span> <span class="free">y</span> <span class="free">c</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_bool_def<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">as</span> <span class="free">x</span> <span class="free">c</span> <span class="main">=</span> <span class="skolem">q</span> <span class="main">∙</span> <span class="main">(</span><span class="free">f</span> <span class="free">as</span> <span class="free">x</span> <span class="free">c</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> perm_supp_eq<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> inc fcb1 fr1 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_star_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="free">as</span><span class="main">)</span> <span class="main">(</span><span class="skolem">q</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="free">c</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> perm1<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> inc fresh1 fr1 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_star_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">r</span> <span class="main">∙</span> <span class="free">bs</span><span class="main">)</span> <span class="main">(</span><span class="skolem">r</span> <span class="main">∙</span> <span class="free">y</span><span class="main">)</span> <span class="free">c</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> qq1 qq2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="skolem">r</span> <span class="main">∙</span> <span class="main">(</span><span class="free">f</span> <span class="free">bs</span> <span class="free">y</span> <span class="free">c</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> perm2<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> qq3 fresh2 fr1 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_star_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="free">f</span> <span class="free">bs</span> <span class="free">y</span> <span class="free">c</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> perm_supp_eq<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> qq3 fr1 fcb2 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_star_def<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Nominal2_FCB-Abs_lst1_fcb2"><span class="command">lemma</span></span> Abs_lst1_fcb2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">a</span> <span class="free">b</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"atom"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">x</span> <span class="free">y</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">::</span> fs"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">c</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">::</span> fs"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> e<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">[</span><span class="free">a</span><span class="main">]</span><span class="keyword1">]lst.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="main">[</span><span class="free">b</span><span class="main">]</span><span class="keyword1">]lst.</span> <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> fcb1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="free">f</span> <span class="free">a</span> <span class="free">x</span> <span class="free">c</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> fresh<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">a</span><span class="main">,</span> <span class="free">b</span><span class="main">}</span> <span class="main">♯*</span> <span class="free">c</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> perm1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">p</span><span class="main">.</span> supp <span class="bound">p</span> <span class="main">♯*</span> <span class="free">c</span> <span class="main">⟹</span> <span class="bound">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">f</span> <span class="free">a</span> <span class="free">x</span> <span class="free">c</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span><span class="bound">p</span> <span class="main">∙</span> <span class="free">a</span><span class="main">)</span> <span class="main">(</span><span class="bound">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="free">c</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> perm2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">p</span><span class="main">.</span> supp <span class="bound">p</span> <span class="main">♯*</span> <span class="free">c</span> <span class="main">⟹</span> <span class="bound">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">f</span> <span class="free">b</span> <span class="free">y</span> <span class="free">c</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span><span class="bound">p</span> <span class="main">∙</span> <span class="free">b</span><span class="main">)</span> <span class="main">(</span><span class="bound">p</span> <span class="main">∙</span> <span class="free">y</span><span class="main">)</span> <span class="free">c</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">a</span> <span class="free">x</span> <span class="free">c</span> <span class="main">=</span> <span class="free">f</span> <span class="free">b</span> <span class="free">y</span> <span class="free">c</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> e
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule_tac</span> Abs_lst_fcb2<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> c<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">c</span></span>"</span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">λ</span></span><span class="main"><span class="main">(</span></span><span class="bound"><span class="bound">as</span></span><span class="main"><span class="main">::</span></span>atom list<span class="main"><span class="main">)</span></span> <span class="main"><span class="main">.</span></span> <span class="free"><span class="free">f</span></span> <span class="main"><span class="main">(</span></span>hd <span class="bound"><span class="bound">as</span></span><span class="main"><span class="main">)</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>
<span class="keyword1"><span class="command">using</span></span> fcb1 fresh perm1 perm2
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_star_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Nominal2_FCB-Abs_lst1_fcb2'"><span class="command">lemma</span></span> Abs_lst1_fcb2'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">a</span> <span class="free">b</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>at_base"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">x</span> <span class="free">y</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">::</span> fs"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">c</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">::</span> fs"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> e<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">[</span>atom <span class="free">a</span><span class="main">]</span><span class="keyword1">]lst.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="main">[</span>atom <span class="free">b</span><span class="main">]</span><span class="keyword1">]lst.</span> <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> fcb1<span class="main">:</span> <span class="quoted"><span class="quoted">"atom <span class="free">a</span> <span class="main">♯</span> <span class="free">f</span> <span class="free">a</span> <span class="free">x</span> <span class="free">c</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> fresh<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{</span>atom <span class="free">a</span><span class="main">,</span> atom <span class="free">b</span><span class="main">}</span> <span class="main">♯*</span> <span class="free">c</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> perm1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">p</span><span class="main">.</span> supp <span class="bound">p</span> <span class="main">♯*</span> <span class="free">c</span> <span class="main">⟹</span> <span class="bound">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">f</span> <span class="free">a</span> <span class="free">x</span> <span class="free">c</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span><span class="bound">p</span> <span class="main">∙</span> <span class="free">a</span><span class="main">)</span> <span class="main">(</span><span class="bound">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="free">c</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> perm2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">p</span><span class="main">.</span> supp <span class="bound">p</span> <span class="main">♯*</span> <span class="free">c</span> <span class="main">⟹</span> <span class="bound">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">f</span> <span class="free">b</span> <span class="free">y</span> <span class="free">c</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span><span class="bound">p</span> <span class="main">∙</span> <span class="free">b</span><span class="main">)</span> <span class="main">(</span><span class="bound">p</span> <span class="main">∙</span> <span class="free">y</span><span class="main">)</span> <span class="free">c</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">a</span> <span class="free">x</span> <span class="free">c</span> <span class="main">=</span> <span class="free">f</span> <span class="free">b</span> <span class="free">y</span> <span class="free">c</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> e
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule_tac</span> Abs_lst1_fcb2<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> c<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">c</span></span>"</span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">a</span></span> <span class="main"><span class="main">.</span></span> <span class="free"><span class="free">f</span></span> <span class="main"><span class="main">(</span></span><span class="main"><span class="main">(</span></span>inv atom<span class="main"><span class="main">)</span></span> <span class="bound"><span class="bound">a</span></span><span class="main"><span class="main">)</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">using</span></span>  fcb1 fresh perm1 perm2
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fresh_star_def inv_f_f inj_on_def atom_eqvt<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Nominal2">
<div class="head">
<h1>Theory Nominal2</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> Nominal2
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="#Nominal2_Base">Nominal2_Base</a> <a href="#Nominal2_Abs">Nominal2_Abs</a> <a href="#Nominal2_FCB">Nominal2_FCB</a>
<span class="keyword2"><span class="keyword">keywords</span></span>
  <span class="quoted">"nominal_datatype"</span> <span class="main">::</span> thy_defn <span class="keyword2"><span class="keyword">and</span></span>
  <span class="quoted">"nominal_function"</span> <span class="quoted">"nominal_inductive"</span> <span class="quoted">"nominal_termination"</span> <span class="main">::</span> thy_goal_defn <span class="keyword2"><span class="keyword">and</span></span>
  <span class="quoted">"avoids"</span> <span class="quoted">"binds"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹nominal_dt_data.ML›</span>
<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹<span class="keyword3"><span class="keyword">open</span></span> Nominal_Dt_Data›</span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹nominal_dt_rawfuns.ML›</span>
<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹<span class="keyword3"><span class="keyword">open</span></span> Nominal_Dt_RawFuns›</span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹nominal_dt_alpha.ML›</span>
<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹<span class="keyword3"><span class="keyword">open</span></span> Nominal_Dt_Alpha›</span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹nominal_dt_quot.ML›</span>
<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹<span class="keyword3"><span class="keyword">open</span></span> Nominal_Dt_Quot›</span>

<span class="comment1">(*****************************************)</span>
<span class="comment1">(* setup for induction principles method *)</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹nominal_induct.ML›</span>
<span class="keyword1"><span class="command">method_setup</span></span> nominal_induct <span class="main">=</span>
  <span class="quoted">‹<span class="entity">NominalInduct.nominal_induct_method</span>›</span>
  <span class="quoted">‹nominal induction›</span>

<span class="comment1">(****************************************************)</span>
<span class="comment1">(* inductive definition involving nominal datatypes *)</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹nominal_inductive.ML›</span>


<span class="comment1">(***************************************)</span>
<span class="comment1">(* forked code of the function package *)</span>
<span class="comment1">(* for defining nominal functions      *)</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹nominal_function_common.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹nominal_function_core.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹nominal_mutual.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹nominal_function.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹nominal_termination.ML›</span>

<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eqvt_attr</span> <span class="main">=</span> <span class="entity">Attrib.internal</span> <span class="main">(</span>K <span class="entity">Nominal_ThmDecls.eqvt_add</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simp_attr</span> <span class="main">=</span> <span class="entity">Attrib.internal</span> <span class="main">(</span>K <span class="entity">Simplifier.simp_add</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">induct_attr</span> <span class="main">=</span> <span class="entity">Attrib.internal</span> <span class="main">(</span>K <span class="entity">Induct.induct_simp_add</span><span class="main">)</span>
›</span>

<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Interface for <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>nominal_datatype›</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_cnstrs</span> <span class="entity">dts</span> <span class="main">=</span>
  map snd <span class="entity">dts</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_typed_cnstrs</span> <span class="entity">dts</span> <span class="main">=</span>
  flat <span class="main">(</span>map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">bn</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="entity">constrs</span><span class="main">)</span> <span class="main">=&gt;</span>
   <span class="main">(</span>map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">bn'</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span>Binding.name_of <span class="entity">bn</span><span class="main">,</span> Binding.name_of <span class="entity">bn'</span><span class="main">)</span><span class="main">)</span> <span class="entity">constrs</span><span class="main">)</span><span class="main">)</span> <span class="entity">dts</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_cnstr_strs</span> <span class="entity">dts</span> <span class="main">=</span>
  map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">bn</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> Binding.name_of <span class="entity">bn</span><span class="main">)</span> <span class="main">(</span>flat <span class="main">(</span><span class="entity">get_cnstrs</span> <span class="entity">dts</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_bn_fun_strs</span> <span class="entity">bn_funs</span> <span class="main">=</span>
  map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">bn_fun</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> Binding.name_of <span class="entity">bn_fun</span><span class="main">)</span> <span class="entity">bn_funs</span>
›</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Infrastructure for adding <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>_raw›</span></span></span></span> to types and terms›</span></span>

<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_raw</span> <span class="entity">s</span> <span class="main">=</span> <span class="entity">s</span> ^ <span class="inner_quoted">"_raw"</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_raws</span> <span class="entity">ss</span> <span class="main">=</span> map <span class="entity">add_raw</span> <span class="entity">ss</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">raw_bind</span> <span class="entity">bn</span> <span class="main">=</span> Binding.suffix_name <span class="inner_quoted">"_raw"</span> <span class="entity">bn</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">replace_str</span> <span class="entity">ss</span> <span class="entity">s</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">case</span></span> <span class="main">(</span>AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">ss</span> <span class="entity">s</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
     SOME <span class="entity">s'</span> <span class="main">=&gt;</span> <span class="entity">s'</span>
   <span class="main">|</span> NONE <span class="main">=&gt;</span> <span class="entity">s</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">replace_typ</span> <span class="entity">ty_ss</span> <span class="main">(</span>Type <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Type <span class="main">(</span><span class="entity">replace_str</span> <span class="entity">ty_ss</span> <span class="entity">a</span><span class="main">,</span> map <span class="main">(</span><span class="entity">replace_typ</span> <span class="entity">ty_ss</span><span class="main">)</span> <span class="entity">Ts</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">replace_typ</span> <span class="entity">ty_ss</span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">T</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">raw_dts</span> <span class="entity">ty_ss</span> <span class="entity">dts</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">raw_dts_aux1</span> <span class="main">(</span><span class="entity">bind</span><span class="main">,</span> <span class="entity">tys</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span>
    <span class="main">(</span><span class="entity">raw_bind</span> <span class="entity">bind</span><span class="main">,</span> map <span class="main">(</span><span class="entity">replace_typ</span> <span class="entity">ty_ss</span><span class="main">)</span> <span class="entity">tys</span><span class="main">,</span> NoSyn<span class="main">)</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">raw_dts_aux2</span> <span class="main">(</span><span class="main">(</span><span class="entity">bind</span><span class="main">,</span> <span class="entity">ty_args</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="entity">constrs</span><span class="main">)</span> <span class="main">=</span>
    <span class="main">(</span><span class="main">(</span><span class="entity">raw_bind</span> <span class="entity">bind</span><span class="main">,</span> <span class="entity">ty_args</span><span class="main">,</span> NoSyn<span class="main">)</span><span class="main">,</span> map <span class="entity">raw_dts_aux1</span> <span class="entity">constrs</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">in</span></span>
  map <span class="entity">raw_dts_aux2</span> <span class="entity">dts</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">replace_aterm</span> <span class="entity">trm_ss</span> <span class="main">(</span>Const <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">replace_str</span> <span class="entity">trm_ss</span> <span class="entity">a</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">replace_aterm</span> <span class="entity">trm_ss</span> <span class="main">(</span>Free <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">replace_str</span> <span class="entity">trm_ss</span> <span class="entity">a</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">replace_aterm</span> <span class="entity">trm_ss</span> <span class="entity">trm</span> <span class="main">=</span> <span class="entity">trm</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">replace_term</span> <span class="entity">trm_ss</span> <span class="entity">ty_ss</span> <span class="entity">trm</span> <span class="main">=</span>
  <span class="entity">trm</span> |&gt; Term.map_aterms <span class="main">(</span><span class="entity">replace_aterm</span> <span class="entity">trm_ss</span><span class="main">)</span> |&gt; map_types <span class="main">(</span><span class="entity">replace_typ</span> <span class="entity">ty_ss</span><span class="main">)</span>
›</span>

<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rawify_dts</span> <span class="entity">dts</span> <span class="entity">dts_env</span> <span class="main">=</span> <span class="entity">raw_dts</span> <span class="entity">dts_env</span> <span class="entity">dts</span>
›</span>

<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rawify_bn_funs</span> <span class="entity">dts_env</span> <span class="entity">cnstrs_env</span> <span class="entity">bn_fun_env</span> <span class="entity">bn_funs</span> <span class="entity">bn_eqs</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">bn_funs'</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">bn</span><span class="main">,</span> <span class="entity">ty</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span>
    <span class="main">(</span><span class="entity">raw_bind</span> <span class="entity">bn</span><span class="main">,</span> SOME <span class="main">(</span><span class="entity">replace_typ</span> <span class="entity">dts_env</span> <span class="entity">ty</span><span class="main">)</span><span class="main">,</span> NoSyn<span class="main">)</span><span class="main">)</span> <span class="entity">bn_funs</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">bn_eqs'</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">attr</span><span class="main">,</span> <span class="entity">trm</span><span class="main">)</span> <span class="main">=&gt;</span>
    <span class="main">(</span><span class="main">(</span><span class="entity">attr</span><span class="main">,</span> <span class="entity">replace_term</span> <span class="main">(</span><span class="entity">cnstrs_env</span> @ <span class="entity">bn_fun_env</span><span class="main">)</span> <span class="entity">dts_env</span> <span class="entity">trm</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="entity">bn_eqs</span>
<span class="keyword2"><span class="keyword">in</span></span>
  <span class="main">(</span><span class="entity">bn_funs'</span><span class="main">,</span> <span class="entity">bn_eqs'</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>
›</span>

<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rawify_bclauses</span> <span class="entity">dts_env</span> <span class="entity">cnstrs_env</span> <span class="entity">bn_fun_env</span> <span class="entity">bclauses</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rawify_bnds</span> <span class="entity">bnds</span> <span class="main">=</span>
    map <span class="main">(</span>apfst <span class="main">(</span>Option.map <span class="main">(</span><span class="entity">replace_term</span> <span class="main">(</span><span class="entity">cnstrs_env</span> @ <span class="entity">bn_fun_env</span><span class="main">)</span> <span class="entity">dts_env</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">bnds</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rawify_bclause</span> <span class="main">(</span><span class="entity">BC</span> <span class="main">(</span><span class="entity">mode</span><span class="main">,</span> <span class="entity">bnds</span><span class="main">,</span> <span class="entity">bdys</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">BC</span> <span class="main">(</span><span class="entity">mode</span><span class="main">,</span> <span class="entity">rawify_bnds</span> <span class="entity">bnds</span><span class="main">,</span> <span class="entity">bdys</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">in</span></span>
  <span class="main">(</span>map o map o map<span class="main">)</span> <span class="entity">rawify_bclause</span> <span class="entity">bclauses</span>
<span class="keyword2"><span class="keyword">end</span></span>
›</span>


<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹
<span class="comment1">(* definition of the raw datatype *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">define_raw_dts</span> <span class="entity">dts</span> <span class="entity">cnstr_names</span> <span class="entity">cnstr_tys</span> <span class="entity">bn_funs</span> <span class="entity">bn_eqs</span> <span class="entity">bclauses</span> <span class="entity">lthy</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Local_Theory.exit_global <span class="entity">lthy</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy_name</span> <span class="main">=</span> Context.theory_name <span class="entity">thy</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dt_names</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> Binding.name_of <span class="entity">s</span><span class="main">)</span> <span class="entity">dts</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dt_full_names</span> <span class="main">=</span> map <span class="main">(</span>Long_Name.qualify <span class="entity">thy_name</span><span class="main">)</span> <span class="entity">dt_names</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dt_full_names'</span> <span class="main">=</span> <span class="entity">add_raws</span> <span class="entity">dt_full_names</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dts_env</span> <span class="main">=</span> <span class="entity">dt_full_names</span> ~~ <span class="entity">dt_full_names'</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cnstr_full_names</span> <span class="main">=</span> map <span class="main">(</span>Long_Name.qualify <span class="entity">thy_name</span><span class="main">)</span> <span class="entity">cnstr_names</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cnstr_full_names'</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span> <span class="main">=&gt;</span> Long_Name.qualify <span class="entity">thy_name</span>
    <span class="main">(</span>Long_Name.qualify <span class="main">(</span><span class="entity">add_raw</span> <span class="entity">x</span><span class="main">)</span> <span class="main">(</span><span class="entity">add_raw</span> <span class="entity">y</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">cnstr_tys</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cnstrs_env</span> <span class="main">=</span> <span class="entity">cnstr_full_names</span> ~~ <span class="entity">cnstr_full_names'</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">bn_fun_strs</span> <span class="main">=</span> <span class="entity">get_bn_fun_strs</span> <span class="entity">bn_funs</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">bn_fun_strs'</span> <span class="main">=</span> <span class="entity">add_raws</span> <span class="entity">bn_fun_strs</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">bn_fun_env</span> <span class="main">=</span> <span class="entity">bn_fun_strs</span> ~~ <span class="entity">bn_fun_strs'</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">bn_fun_full_env</span> <span class="main">=</span> map <span class="main">(</span>apply2 <span class="main">(</span>Long_Name.qualify <span class="entity">thy_name</span><span class="main">)</span><span class="main">)</span>
    <span class="main">(</span><span class="entity">bn_fun_strs</span> ~~ <span class="entity">bn_fun_strs'</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_dts</span> <span class="main">=</span> <span class="entity">rawify_dts</span> <span class="entity">dts</span> <span class="entity">dts_env</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">raw_bn_funs</span><span class="main">,</span> <span class="entity">raw_bn_eqs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">rawify_bn_funs</span> <span class="entity">dts_env</span> <span class="entity">cnstrs_env</span> <span class="entity">bn_fun_env</span> <span class="entity">bn_funs</span> <span class="entity">bn_eqs</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_bclauses</span> <span class="main">=</span> <span class="entity">rawify_bclauses</span> <span class="entity">dts_env</span> <span class="entity">cnstrs_env</span> <span class="entity">bn_fun_full_env</span> <span class="entity">bclauses</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">raw_full_dt_names'</span><span class="main">,</span> <span class="entity">thy1</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">BNF_LFP_Compat.add_datatype</span> <span class="main">[</span><span class="entity">BNF_LFP_Compat.Kill_Type_Args</span><span class="main">]</span> <span class="entity">raw_dts</span> <span class="entity">thy</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lthy1</span> <span class="main">=</span> <span class="entity">Named_Target.theory_init</span> <span class="entity">thy1</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dtinfos</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">Old_Datatype_Data.the_info</span> <span class="main">(</span>Proof_Context.theory_of <span class="entity">lthy1</span><span class="main">)</span><span class="main">)</span> <span class="entity">raw_full_dt_names'</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_fp_sugars</span> <span class="main">=</span> map <span class="main">(</span>the o <span class="entity">BNF_FP_Def_Sugar.fp_sugar_of</span> <span class="entity">lthy1</span><span class="main">)</span> <span class="entity">raw_full_dt_names'</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">descr</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> hd <span class="entity">dtinfos</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_ty_args</span> <span class="main">=</span> hd <span class="main">(</span><span class="entity">Old_Datatype_Aux.get_rec_types</span> <span class="entity">descr</span><span class="main">)</span>
    |&gt; snd o dest_Type
    |&gt; map dest_TFree
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_schematic_ty_args</span> <span class="main">=</span> <span class="main">(</span>snd o dest_Type o <span class="main">#</span>T o hd<span class="main">)</span> <span class="entity">raw_fp_sugars</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">typ_subst</span> <span class="main">=</span> <span class="entity">raw_schematic_ty_args</span> ~~ map TFree <span class="entity">raw_ty_args</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">freezeT</span> <span class="main">=</span> Term.typ_subst_atomic <span class="entity">typ_subst</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">freeze</span> <span class="main">=</span> Term.subst_atomic_types <span class="entity">typ_subst</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_tys</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">freezeT</span> o <span class="main">#</span>T<span class="main">)</span> <span class="entity">raw_fp_sugars</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_cns_info</span> <span class="main">=</span> <span class="entity">all_dtyp_constrs_types</span> <span class="entity">descr</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_all_cns</span> <span class="main">=</span> map <span class="main">(</span>map <span class="entity">freeze</span> o <span class="main">#</span>ctrs o <span class="main">#</span>ctr_sugar o <span class="main">#</span>fp_ctr_sugar<span class="main">)</span> <span class="entity">raw_fp_sugars</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_inject_thms</span> <span class="main">=</span> flat <span class="main">(</span>map <span class="main">#</span>inject <span class="entity">dtinfos</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_distinct_thms</span> <span class="main">=</span> flat <span class="main">(</span>map <span class="main">#</span>distinct <span class="entity">dtinfos</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_induct_thm</span> <span class="main">=</span> <span class="main">(</span>hd o <span class="main">#</span>common_co_inducts o the o <span class="main">#</span>fp_co_induct_sugar o hd<span class="main">)</span> <span class="entity">raw_fp_sugars</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_induct_thms</span> <span class="main">=</span> map <span class="main">(</span>the_single o <span class="main">#</span>co_inducts o the o <span class="main">#</span>fp_co_induct_sugar<span class="main">)</span> <span class="entity">raw_fp_sugars</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_exhaust_thms</span> <span class="main">=</span> map <span class="main">#</span>exhaust <span class="entity">dtinfos</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_size_trms</span> <span class="main">=</span> map <span class="entity">HOLogic.size_const</span> <span class="entity">raw_tys</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_size_thms</span> <span class="main">=</span> these <span class="main">(</span>Option.map <span class="main">(</span><span class="main">#</span><span class="inner_numeral">2</span> o <span class="main">#</span><span class="inner_numeral">2</span><span class="main">)</span>
    <span class="main">(</span><span class="entity">BNF_LFP_Size.size_of</span> <span class="entity">lthy1</span> <span class="main">(</span>hd <span class="entity">raw_full_dt_names'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_result</span> <span class="main">=</span> <span class="entity">RawDtInfo</span>
    <span class="main">{</span>raw_dt_names <span class="main">=</span> <span class="entity">raw_full_dt_names'</span><span class="main">,</span>
     raw_fp_sugars <span class="main">=</span> <span class="entity">raw_fp_sugars</span><span class="main">,</span>
     raw_dts <span class="main">=</span> <span class="entity">raw_dts</span><span class="main">,</span>
     raw_tys <span class="main">=</span> <span class="entity">raw_tys</span><span class="main">,</span>
     raw_ty_args <span class="main">=</span> <span class="entity">raw_ty_args</span><span class="main">,</span>
     raw_cns_info <span class="main">=</span> <span class="entity">raw_cns_info</span><span class="main">,</span>
     raw_all_cns <span class="main">=</span> <span class="entity">raw_all_cns</span><span class="main">,</span>
     raw_inject_thms <span class="main">=</span> <span class="entity">raw_inject_thms</span><span class="main">,</span>
     raw_distinct_thms <span class="main">=</span> <span class="entity">raw_distinct_thms</span><span class="main">,</span>
     raw_induct_thm <span class="main">=</span> <span class="entity">raw_induct_thm</span><span class="main">,</span>
     raw_induct_thms <span class="main">=</span> <span class="entity">raw_induct_thms</span><span class="main">,</span>
     raw_exhaust_thms <span class="main">=</span> <span class="entity">raw_exhaust_thms</span><span class="main">,</span>
     raw_size_trms <span class="main">=</span> <span class="entity">raw_size_trms</span><span class="main">,</span>
     raw_size_thms <span class="main">=</span> <span class="entity">raw_size_thms</span><span class="main">}</span>
<span class="keyword2"><span class="keyword">in</span></span>
  <span class="main">(</span><span class="entity">raw_bclauses</span><span class="main">,</span> <span class="entity">raw_bn_funs</span><span class="main">,</span> <span class="entity">raw_bn_eqs</span><span class="main">,</span> <span class="entity">raw_result</span><span class="main">,</span> <span class="entity">lthy1</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>
›</span>


<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">nominal_datatype2</span> <span class="entity">opt_thms_name</span> <span class="entity">dts</span> <span class="entity">bn_funs</span> <span class="entity">bn_eqs</span> <span class="entity">bclauses</span> <span class="entity">lthy</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cnstr_names</span> <span class="main">=</span> <span class="entity">get_cnstr_strs</span> <span class="entity">dts</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cnstr_tys</span> <span class="main">=</span> <span class="entity">get_typed_cnstrs</span> <span class="entity">dts</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_msg</span> <span class="main">(</span>K <span class="inner_quoted">"Defining raw datatypes..."</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">raw_bclauses</span><span class="main">,</span> <span class="entity">raw_bn_funs</span><span class="main">,</span> <span class="entity">raw_bn_eqs</span><span class="main">,</span> <span class="entity">raw_dt_info</span><span class="main">,</span> <span class="entity">lthy0</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">define_raw_dts</span> <span class="entity">dts</span> <span class="entity">cnstr_names</span> <span class="entity">cnstr_tys</span> <span class="entity">bn_funs</span> <span class="entity">bn_eqs</span> <span class="entity">bclauses</span> <span class="entity">lthy</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">RawDtInfo</span>
    <span class="main">{</span><span class="entity">raw_dt_names</span><span class="main">,</span>
     <span class="entity">raw_tys</span><span class="main">,</span>
     <span class="entity">raw_ty_args</span><span class="main">,</span>
     <span class="entity">raw_fp_sugars</span><span class="main">,</span>
     <span class="entity">raw_all_cns</span><span class="main">,</span>
     <span class="entity">raw_inject_thms</span><span class="main">,</span>
     <span class="entity">raw_distinct_thms</span><span class="main">,</span>
     <span class="entity">raw_induct_thm</span><span class="main">,</span>
     <span class="entity">raw_induct_thms</span><span class="main">,</span>
     <span class="entity">raw_exhaust_thms</span><span class="main">,</span>
     <span class="entity">raw_size_trms</span><span class="main">,</span>
     <span class="entity">raw_size_thms</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">raw_dt_info</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_msg</span> <span class="main">(</span>K <span class="inner_quoted">"Defining raw permutations..."</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">raw_perm_funs</span><span class="main">,</span> <span class="entity">raw_perm_simps</span><span class="main">,</span> <span class="entity">raw_perm_laws</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy2a</span><span class="main">)</span> <span class="main">=</span> <span class="entity">define_raw_perms</span> <span class="entity">raw_dt_info</span> <span class="entity">lthy0</span>

  <span class="comment1">(* noting the raw permutations as eqvt theorems *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lthy3</span> <span class="main">=</span> snd <span class="main">(</span>Local_Theory.note <span class="main">(</span><span class="main">(</span>Binding.empty<span class="main">,</span> <span class="main">[</span><span class="entity">eqvt_attr</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">raw_perm_simps</span><span class="main">)</span> <span class="entity">lthy2a</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_msg</span> <span class="main">(</span>K <span class="inner_quoted">"Defining raw fv- and bn-functions..."</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">raw_bns</span><span class="main">,</span> <span class="entity">raw_bn_defs</span><span class="main">,</span> <span class="entity">raw_bn_info</span><span class="main">,</span> <span class="entity">raw_bn_inducts</span><span class="main">,</span> <span class="entity">lthy3a</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">define_raw_bns</span> <span class="entity">raw_dt_info</span> <span class="entity">raw_bn_funs</span> <span class="entity">raw_bn_eqs</span> <span class="entity">lthy3</span>

  <span class="comment1">(* defining the permute_bn functions *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">raw_perm_bns</span><span class="main">,</span> <span class="entity">raw_perm_bn_simps</span><span class="main">,</span> <span class="entity">lthy3b</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">define_raw_bn_perms</span> <span class="entity">raw_dt_info</span> <span class="entity">raw_bn_info</span> <span class="entity">lthy3a</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">raw_fvs</span><span class="main">,</span> <span class="entity">raw_fv_bns</span><span class="main">,</span> <span class="entity">raw_fv_defs</span><span class="main">,</span> <span class="entity">raw_fv_bns_induct</span><span class="main">,</span> <span class="entity">lthy3c</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">define_raw_fvs</span> <span class="entity">raw_dt_info</span> <span class="entity">raw_bn_info</span> <span class="entity">raw_bclauses</span> <span class="entity">lthy3b</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_msg</span> <span class="main">(</span>K <span class="inner_quoted">"Defining alpha relations..."</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">alpha_result</span><span class="main">,</span> <span class="entity">lthy4</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">define_raw_alpha</span> <span class="entity">raw_dt_info</span> <span class="entity">raw_bn_info</span> <span class="entity">raw_bclauses</span> <span class="entity">raw_fvs</span> <span class="entity">lthy3c</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_msg</span> <span class="main">(</span>K <span class="inner_quoted">"Proving distinct theorems..."</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alpha_distincts</span> <span class="main">=</span> <span class="entity">raw_prove_alpha_distincts</span> <span class="entity">lthy4</span> <span class="entity">alpha_result</span> <span class="entity">raw_dt_info</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_msg</span> <span class="main">(</span>K <span class="inner_quoted">"Proving eq-iff theorems..."</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alpha_eq_iff</span> <span class="main">=</span> <span class="entity">raw_prove_alpha_eq_iff</span> <span class="entity">lthy4</span> <span class="entity">alpha_result</span> <span class="entity">raw_dt_info</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_msg</span> <span class="main">(</span>K <span class="inner_quoted">"Proving equivariance of bns, fvs, size and alpha..."</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_bn_eqvt</span> <span class="main">=</span>
    <span class="entity">raw_prove_eqvt</span> <span class="entity">raw_bns</span> <span class="entity">raw_bn_inducts</span> <span class="main">(</span><span class="entity">raw_bn_defs</span> @ <span class="entity">raw_perm_simps</span><span class="main">)</span> <span class="entity">lthy4</span>

  <span class="comment1">(* noting the raw_bn_eqvt lemmas in a temporary theory *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lthy_tmp</span> <span class="main">=</span>
    <span class="entity">lthy4</span>
    |&gt; Local_Theory.begin_nested
    |&gt; snd
    |&gt; Local_Theory.note <span class="main">(</span><span class="main">(</span>Binding.empty<span class="main">,</span> <span class="main">[</span><span class="entity">eqvt_attr</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">raw_bn_eqvt</span><span class="main">)</span>
    |&gt; snd
    |&gt; Local_Theory.end_nested

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_fv_eqvt</span> <span class="main">=</span>
    <span class="entity">raw_prove_eqvt</span> <span class="main">(</span><span class="entity">raw_fvs</span> @ <span class="entity">raw_fv_bns</span><span class="main">)</span> <span class="entity">raw_fv_bns_induct</span> <span class="main">(</span><span class="entity">raw_fv_defs</span> @ <span class="entity">raw_perm_simps</span><span class="main">)</span>
      <span class="entity">lthy_tmp</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_size_eqvt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">RawDtInfo</span> <span class="main">{</span><span class="entity">raw_size_trms</span><span class="main">,</span> <span class="entity">raw_size_thms</span><span class="main">,</span> <span class="entity">raw_induct_thms</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">raw_dt_info</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">raw_prove_eqvt</span> <span class="entity">raw_size_trms</span> <span class="entity">raw_induct_thms</span> <span class="main">(</span><span class="entity">raw_size_thms</span> @ <span class="entity">raw_perm_simps</span><span class="main">)</span>
        <span class="entity">lthy_tmp</span>
        |&gt; map <span class="main">(</span>rewrite_rule <span class="entity">lthy_tmp</span>
            <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> permute_nat_def<span class="main">[</span><span class="operator">THEN</span> eq_reflection<span class="main">]</span><span class="antiquote">}</span></span></span><span class="main">)</span>
        |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">thm</span> <span class="main">=&gt;</span> <span class="entity">thm</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> sym<span class="antiquote">}</span></span></span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lthy5</span> <span class="main">=</span> snd <span class="main">(</span>Local_Theory.note <span class="main">(</span><span class="main">(</span>Binding.empty<span class="main">,</span> <span class="main">[</span><span class="entity">eqvt_attr</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">raw_fv_eqvt</span><span class="main">)</span> <span class="entity">lthy_tmp</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alpha_eqvt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">AlphaResult</span> <span class="main">{</span><span class="entity">alpha_trms</span><span class="main">,</span> <span class="entity">alpha_bn_trms</span><span class="main">,</span> <span class="entity">alpha_raw_induct</span><span class="main">,</span> <span class="entity">alpha_intros</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">alpha_result</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">Nominal_Eqvt.raw_equivariance</span> <span class="entity">lthy5</span> <span class="main">(</span><span class="entity">alpha_trms</span> @ <span class="entity">alpha_bn_trms</span><span class="main">)</span> <span class="entity">alpha_raw_induct</span> <span class="entity">alpha_intros</span>
    <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alpha_eqvt_norm</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">Nominal_ThmDecls.eqvt_transform</span> <span class="entity">lthy5</span><span class="main">)</span> <span class="entity">alpha_eqvt</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_msg</span> <span class="main">(</span>K <span class="inner_quoted">"Proving equivalence of alpha..."</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alpha_refl_thms</span> <span class="main">=</span> <span class="entity">raw_prove_refl</span> <span class="entity">lthy5</span> <span class="entity">alpha_result</span> <span class="entity">raw_induct_thm</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alpha_sym_thms</span> <span class="main">=</span> <span class="entity">raw_prove_sym</span> <span class="entity">lthy5</span> <span class="entity">alpha_result</span> <span class="entity">alpha_eqvt_norm</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alpha_trans_thms</span> <span class="main">=</span>
    <span class="entity">raw_prove_trans</span> <span class="entity">lthy5</span> <span class="entity">alpha_result</span> <span class="main">(</span><span class="entity">raw_distinct_thms</span> @ <span class="entity">raw_inject_thms</span><span class="main">)</span> <span class="entity">alpha_eqvt_norm</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">alpha_equivp_thms</span><span class="main">,</span> <span class="entity">alpha_bn_equivp_thms</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">raw_prove_equivp</span> <span class="entity">lthy5</span> <span class="entity">alpha_result</span> <span class="entity">alpha_refl_thms</span> <span class="entity">alpha_sym_thms</span> <span class="entity">alpha_trans_thms</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_msg</span> <span class="main">(</span>K <span class="inner_quoted">"Proving alpha implies bn..."</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alpha_bn_imp_thms</span> <span class="main">=</span> <span class="entity">raw_prove_bn_imp</span> <span class="entity">lthy5</span> <span class="entity">alpha_result</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_msg</span> <span class="main">(</span>K <span class="inner_quoted">"Proving respectfulness..."</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_funs_rsp_aux</span> <span class="main">=</span>
    <span class="entity">raw_fv_bn_rsp_aux</span> <span class="entity">lthy5</span> <span class="entity">alpha_result</span> <span class="entity">raw_fvs</span> <span class="entity">raw_bns</span> <span class="entity">raw_fv_bns</span> <span class="main">(</span><span class="entity">raw_bn_defs</span> @ <span class="entity">raw_fv_defs</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_funs_rsp</span> <span class="main">=</span> map <span class="main">(</span>Drule.eta_contraction_rule o <span class="entity">mk_funs_rsp</span> <span class="entity">lthy5</span><span class="main">)</span> <span class="entity">raw_funs_rsp_aux</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">match_const</span> <span class="entity">cnst</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="main">(</span>fst o dest_Const o snd o dest_comb o <span class="entity">HOLogic.dest_Trueprop</span> o Thm.prop_of<span class="main">)</span> <span class="entity">th</span> <span class="main">=</span>
    fst <span class="main">(</span>dest_Const <span class="entity">cnst</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">find_matching_rsp</span> <span class="entity">cnst</span> <span class="main">=</span>
    hd <span class="main">(</span>filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">th</span> <span class="main">=&gt;</span> <span class="entity">match_const</span> <span class="entity">cnst</span> <span class="entity">th</span><span class="main">)</span> <span class="entity">raw_funs_rsp</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_fv_rsp</span> <span class="main">=</span> map <span class="entity">find_matching_rsp</span> <span class="entity">raw_fvs</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_bn_rsp</span> <span class="main">=</span> map <span class="entity">find_matching_rsp</span> <span class="entity">raw_bns</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_fv_bn_rsp</span> <span class="main">=</span> map <span class="entity">find_matching_rsp</span> <span class="entity">raw_fv_bns</span><span class="main">;</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_size_rsp</span> <span class="main">=</span>
    <span class="entity">raw_size_rsp_aux</span> <span class="entity">lthy5</span> <span class="entity">alpha_result</span> <span class="main">(</span><span class="entity">raw_size_thms</span> @ <span class="entity">raw_size_eqvt</span><span class="main">)</span>
      |&gt; map <span class="main">(</span><span class="entity">mk_funs_rsp</span> <span class="entity">lthy5</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_constrs_rsp</span> <span class="main">=</span>
    <span class="entity">raw_constrs_rsp</span> <span class="entity">lthy5</span> <span class="entity">alpha_result</span> <span class="entity">raw_all_cns</span> <span class="main">(</span><span class="entity">alpha_bn_imp_thms</span> @ <span class="entity">raw_funs_rsp_aux</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alpha_permute_rsp</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">mk_alpha_permute_rsp</span> <span class="entity">lthy5</span><span class="main">)</span> <span class="entity">alpha_eqvt</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alpha_bn_rsp</span> <span class="main">=</span>
    <span class="entity">raw_alpha_bn_rsp</span> <span class="entity">alpha_result</span> <span class="entity">alpha_bn_equivp_thms</span> <span class="entity">alpha_bn_imp_thms</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_perm_bn_rsp</span> <span class="main">=</span> <span class="entity">raw_perm_bn_rsp</span> <span class="entity">lthy5</span> <span class="entity">alpha_result</span> <span class="entity">raw_perm_bns</span> <span class="entity">raw_perm_bn_simps</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_msg</span> <span class="main">(</span>K <span class="inner_quoted">"Defining the quotient types..."</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">qty_descr</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">bind</span><span class="main">,</span> <span class="entity">vs</span><span class="main">,</span> <span class="entity">mx</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span>map fst <span class="entity">vs</span><span class="main">,</span> <span class="entity">bind</span><span class="main">,</span> <span class="entity">mx</span><span class="main">)</span><span class="main">)</span> <span class="entity">dts</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">qty_infos</span><span class="main">,</span> <span class="entity">lthy7</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">AlphaResult</span> <span class="main">{</span><span class="entity">alpha_trms</span><span class="main">,</span> <span class="entity">alpha_tys</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">alpha_result</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">define_qtypes</span> <span class="entity">qty_descr</span> <span class="entity">alpha_tys</span> <span class="entity">alpha_trms</span> <span class="entity">alpha_equivp_thms</span> <span class="entity">lthy5</span>
    <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">qtys</span> <span class="main">=</span> map <span class="main">#</span>qtyp <span class="entity">qty_infos</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">qty_full_names</span> <span class="main">=</span> map <span class="main">(</span>fst o dest_Type<span class="main">)</span> <span class="entity">qtys</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">qty_names</span> <span class="main">=</span> map Long_Name.base_name <span class="entity">qty_full_names</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_msg</span> <span class="main">(</span>K <span class="inner_quoted">"Defining the quotient constants..."</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">qconstrs_descrs</span> <span class="main">=</span>
    <span class="main">(</span>map2 o map2<span class="main">)</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">b</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">mx</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span>Variable.check_name <span class="entity">b</span><span class="main">,</span> <span class="entity">t</span><span class="main">,</span> <span class="entity">mx</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span>
      <span class="main">(</span><span class="entity">get_cnstrs</span> <span class="entity">dts</span><span class="main">)</span> <span class="main">(</span>map <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> ~~<span class="main">)</span> <span class="main">(</span><span class="entity">raw_all_cns</span> ~~ <span class="entity">raw_constrs_rsp</span><span class="main">)</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">qbns_descr</span> <span class="main">=</span>
    map2 <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">b</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">mx</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span>Variable.check_name <span class="entity">b</span><span class="main">,</span> <span class="entity">t</span><span class="main">,</span> <span class="entity">mx</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span> <span class="entity">bn_funs</span> <span class="main">(</span><span class="entity">raw_bns</span> ~~ <span class="entity">raw_bn_rsp</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">qfvs_descr</span> <span class="main">=</span>
    map2 <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">n</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="inner_quoted">"fv_"</span> ^ <span class="entity">n</span><span class="main">,</span> <span class="entity">t</span><span class="main">,</span> NoSyn<span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span> <span class="entity">qty_names</span> <span class="main">(</span><span class="entity">raw_fvs</span> ~~ <span class="entity">raw_fv_rsp</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">qfv_bns_descr</span> <span class="main">=</span>
    map2 <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">b</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="inner_quoted">"fv_"</span> ^ Variable.check_name <span class="entity">b</span><span class="main">,</span> <span class="entity">t</span><span class="main">,</span> NoSyn<span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span>
      <span class="entity">bn_funs</span> <span class="main">(</span><span class="entity">raw_fv_bns</span> ~~ <span class="entity">raw_fv_bn_rsp</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">qalpha_bns_descr</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">AlphaResult</span> <span class="main">{</span><span class="entity">alpha_bn_trms</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">alpha_result</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      map2 <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">b</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="inner_quoted">"alpha_"</span> ^ Variable.check_name <span class="entity">b</span><span class="main">,</span> <span class="entity">t</span><span class="main">,</span> NoSyn<span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span>
        <span class="entity">bn_funs</span> <span class="main">(</span><span class="entity">alpha_bn_trms</span> ~~ <span class="entity">alpha_bn_rsp</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">qperm_descr</span> <span class="main">=</span>
    map2 <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">n</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="inner_quoted">"permute_"</span> ^ <span class="entity">n</span><span class="main">,</span> Type.legacy_freeze <span class="entity">t</span><span class="main">,</span> NoSyn<span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span>
      <span class="entity">qty_names</span> <span class="main">(</span><span class="entity">raw_perm_funs</span> ~~ <span class="main">(</span>take <span class="main">(</span>length <span class="entity">raw_perm_funs</span><span class="main">)</span> <span class="entity">alpha_permute_rsp</span><span class="main">)</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">qsize_descr</span> <span class="main">=</span>
    map2 <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">n</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="inner_quoted">"size_"</span> ^ <span class="entity">n</span><span class="main">,</span> <span class="entity">t</span><span class="main">,</span> NoSyn<span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span> <span class="entity">qty_names</span>
      <span class="main">(</span><span class="entity">raw_size_trms</span> ~~ <span class="main">(</span>take <span class="main">(</span>length <span class="entity">raw_size_trms</span><span class="main">)</span> <span class="entity">raw_size_rsp</span><span class="main">)</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">qperm_bn_descr</span> <span class="main">=</span>
    map2 <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">b</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="inner_quoted">"permute_"</span> ^ Variable.check_name <span class="entity">b</span><span class="main">,</span> <span class="entity">t</span><span class="main">,</span> NoSyn<span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span>
      <span class="entity">bn_funs</span> <span class="main">(</span><span class="entity">raw_perm_bns</span> ~~ <span class="entity">raw_perm_bn_rsp</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">qconstrs_infos</span><span class="main">,</span> <span class="entity">qbns_info</span><span class="main">)</span><span class="main">,</span> <span class="entity">qfvs_info</span><span class="main">)</span><span class="main">,</span> <span class="entity">qfv_bns_info</span><span class="main">)</span><span class="main">,</span> <span class="entity">qalpha_bns_info</span><span class="main">)</span><span class="main">,</span> <span class="entity">qperm_bns_info</span><span class="main">)</span><span class="main">,</span>
    <span class="entity">lthy8</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">lthy7</span>
      |&gt; fold_map <span class="main">(</span><span class="entity">define_qconsts</span> <span class="entity">qtys</span><span class="main">)</span> <span class="entity">qconstrs_descrs</span>
      ||&gt;&gt; <span class="entity">define_qconsts</span> <span class="entity">qtys</span> <span class="entity">qbns_descr</span>
      ||&gt;&gt; <span class="entity">define_qconsts</span> <span class="entity">qtys</span> <span class="entity">qfvs_descr</span>
      ||&gt;&gt; <span class="entity">define_qconsts</span> <span class="entity">qtys</span> <span class="entity">qfv_bns_descr</span>
      ||&gt;&gt; <span class="entity">define_qconsts</span> <span class="entity">qtys</span> <span class="entity">qalpha_bns_descr</span>
      ||&gt;&gt; <span class="entity">define_qconsts</span> <span class="entity">qtys</span> <span class="entity">qperm_bn_descr</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lthy9</span> <span class="main">=</span>
    <span class="entity">define_qperms</span> <span class="entity">qtys</span> <span class="entity">qty_full_names</span> <span class="entity">raw_ty_args</span> <span class="entity">qperm_descr</span> <span class="entity">raw_perm_laws</span> <span class="entity">lthy8</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lthy9a</span> <span class="main">=</span>
    <span class="entity">define_qsizes</span> <span class="entity">qtys</span> <span class="entity">qty_full_names</span> <span class="entity">raw_ty_args</span> <span class="entity">qsize_descr</span> <span class="entity">lthy9</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">qtrms</span> <span class="main">=</span> <span class="main">(</span>map o map<span class="main">)</span> <span class="main">#</span>qconst <span class="entity">qconstrs_infos</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">qbns</span> <span class="main">=</span> map <span class="main">#</span>qconst <span class="entity">qbns_info</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">qfvs</span> <span class="main">=</span> map <span class="main">#</span>qconst <span class="entity">qfvs_info</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">qfv_bns</span> <span class="main">=</span> map <span class="main">#</span>qconst <span class="entity">qfv_bns_info</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">qalpha_bns</span> <span class="main">=</span> map <span class="main">#</span>qconst <span class="entity">qalpha_bns_info</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">qperm_bns</span> <span class="main">=</span> map <span class="main">#</span>qconst <span class="entity">qperm_bns_info</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_msg</span> <span class="main">(</span>K <span class="inner_quoted">"Lifting of theorems..."</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_iff_simps</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> alphas permute_prod.simps prod_fv.simps prod_alpha_def rel_prod_sel
    prod.case<span class="antiquote">}</span></span></span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">[</span> <span class="entity">qdistincts</span><span class="main">,</span> <span class="entity">qeq_iffs</span><span class="main">,</span> <span class="entity">qfv_defs</span><span class="main">,</span> <span class="entity">qbn_defs</span><span class="main">,</span> <span class="entity">qperm_simps</span><span class="main">,</span> <span class="entity">qfv_qbn_eqvts</span><span class="main">,</span>
         <span class="entity">qbn_inducts</span><span class="main">,</span> <span class="entity">qsize_eqvt</span><span class="main">,</span> <span class="main">[</span><span class="entity">qinduct</span><span class="main">]</span><span class="main">,</span> <span class="entity">qexhausts</span><span class="main">,</span> <span class="entity">qsize_simps</span><span class="main">,</span> <span class="entity">qperm_bn_simps</span><span class="main">,</span>
         <span class="entity">qalpha_refl_thms</span><span class="main">,</span> <span class="entity">qalpha_sym_thms</span><span class="main">,</span> <span class="entity">qalpha_trans_thms</span> <span class="main">]</span><span class="main">,</span> <span class="entity">lthyB</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">lthy9a</span>
    <span class="entity">|&gt;&gt;&gt;</span> <span class="entity">lift_thms</span> <span class="entity">qtys</span> <span class="main">[</span><span class="main">]</span> <span class="entity">alpha_distincts</span>
    <span class="entity">||&gt;&gt;&gt;</span> <span class="entity">lift_thms</span> <span class="entity">qtys</span> <span class="entity">eq_iff_simps</span> <span class="entity">alpha_eq_iff</span>
    <span class="entity">||&gt;&gt;&gt;</span> <span class="entity">lift_thms</span> <span class="entity">qtys</span> <span class="main">[</span><span class="main">]</span> <span class="entity">raw_fv_defs</span>
    <span class="entity">||&gt;&gt;&gt;</span> <span class="entity">lift_thms</span> <span class="entity">qtys</span> <span class="main">[</span><span class="main">]</span> <span class="entity">raw_bn_defs</span>
    <span class="entity">||&gt;&gt;&gt;</span> <span class="entity">lift_thms</span> <span class="entity">qtys</span> <span class="main">[</span><span class="main">]</span> <span class="entity">raw_perm_simps</span>
    <span class="entity">||&gt;&gt;&gt;</span> <span class="entity">lift_thms</span> <span class="entity">qtys</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="entity">raw_fv_eqvt</span> @ <span class="entity">raw_bn_eqvt</span><span class="main">)</span>
    <span class="entity">||&gt;&gt;&gt;</span> <span class="entity">lift_thms</span> <span class="entity">qtys</span> <span class="main">[</span><span class="main">]</span> <span class="entity">raw_bn_inducts</span>
    <span class="entity">||&gt;&gt;&gt;</span> <span class="entity">lift_thms</span> <span class="entity">qtys</span> <span class="main">[</span><span class="main">]</span> <span class="entity">raw_size_eqvt</span>
    <span class="entity">||&gt;&gt;&gt;</span> <span class="entity">lift_thms</span> <span class="entity">qtys</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="entity">raw_induct_thm</span><span class="main">]</span>
    <span class="entity">||&gt;&gt;&gt;</span> <span class="entity">lift_thms</span> <span class="entity">qtys</span> <span class="main">[</span><span class="main">]</span> <span class="entity">raw_exhaust_thms</span>
    <span class="entity">||&gt;&gt;&gt;</span> <span class="entity">lift_thms</span> <span class="entity">qtys</span> <span class="main">[</span><span class="main">]</span> <span class="entity">raw_size_thms</span>
    <span class="entity">||&gt;&gt;&gt;</span> <span class="entity">lift_thms</span> <span class="entity">qtys</span> <span class="main">[</span><span class="main">]</span> <span class="entity">raw_perm_bn_simps</span>
    <span class="entity">||&gt;&gt;&gt;</span> <span class="entity">lift_thms</span> <span class="entity">qtys</span> <span class="main">[</span><span class="main">]</span> <span class="entity">alpha_refl_thms</span>
    <span class="entity">||&gt;&gt;&gt;</span> <span class="entity">lift_thms</span> <span class="entity">qtys</span> <span class="main">[</span><span class="main">]</span> <span class="entity">alpha_sym_thms</span>
    <span class="entity">||&gt;&gt;&gt;</span> <span class="entity">lift_thms</span> <span class="entity">qtys</span> <span class="main">[</span><span class="main">]</span> <span class="entity">alpha_trans_thms</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">qinducts</span> <span class="main">=</span> <span class="entity">Project_Rule.projections</span> <span class="entity">lthyB</span> <span class="entity">qinduct</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_msg</span> <span class="main">(</span>K <span class="inner_quoted">"Proving supp lemmas and fs-instances..."</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">qsupports_thms</span> <span class="main">=</span> <span class="entity">prove_supports</span> <span class="entity">lthyB</span> <span class="entity">qperm_simps</span> <span class="main">(</span>flat <span class="entity">qtrms</span><span class="main">)</span>

  <span class="comment1">(* finite supp lemmas *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">qfsupp_thms</span> <span class="main">=</span> <span class="entity">prove_fsupp</span> <span class="entity">lthyB</span> <span class="entity">qtys</span> <span class="entity">qinduct</span> <span class="entity">qsupports_thms</span>

  <span class="comment1">(* fs instances *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lthyC</span> <span class="main">=</span> <span class="entity">fs_instance</span> <span class="entity">qtys</span> <span class="entity">qty_full_names</span> <span class="entity">raw_ty_args</span> <span class="entity">qfsupp_thms</span> <span class="entity">lthyB</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_msg</span> <span class="main">(</span>K <span class="inner_quoted">"Proving equality between fv and supp..."</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">qfv_supp_thms</span> <span class="main">=</span>
    <span class="entity">prove_fv_supp</span> <span class="entity">qtys</span> <span class="main">(</span>flat <span class="entity">qtrms</span><span class="main">)</span> <span class="entity">qfvs</span> <span class="entity">qfv_bns</span> <span class="entity">qalpha_bns</span> <span class="entity">qfv_defs</span> <span class="entity">qeq_iffs</span>
      <span class="entity">qperm_simps</span> <span class="entity">qfv_qbn_eqvts</span> <span class="entity">qinduct</span> <span class="main">(</span>flat <span class="entity">raw_bclauses</span><span class="main">)</span> <span class="entity">lthyC</span>
    |&gt; map Drule.eta_contraction_rule

  <span class="comment1">(* postprocessing of eq and fv theorems *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">qeq_iffs'</span> <span class="main">=</span> <span class="entity">qeq_iffs</span>
    |&gt; map <span class="main">(</span><span class="entity">simplify</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">lthyC</span> addsimps <span class="entity">qfv_supp_thms</span><span class="main">)</span><span class="main">)</span>
    |&gt; map <span class="main">(</span><span class="entity">simplify</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">lthyC</span>
        addsimps <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> prod_fv_supp prod_alpha_eq Abs_eq_iff<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span><span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">)</span>

  <span class="comment1">(* filters the theorems that are of the form "qfv = supp" *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">qfv_names</span> <span class="main">=</span> map <span class="main">(</span>fst o dest_Const<span class="main">)</span> <span class="entity">qfvs</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_qfv_thm</span> <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">Trueprop</span><span class="antiquote">}</span></span> $ <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> HOL.eq<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ Const <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
    member <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">qfv_names</span> <span class="entity">lhs</span>
  <span class="main">|</span> <span class="entity">is_qfv_thm</span> <span class="main">_</span> <span class="main">=</span> false

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">qsupp_constrs</span> <span class="main">=</span> <span class="entity">qfv_defs</span>
    |&gt; map <span class="main">(</span><span class="entity">simplify</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">lthyC</span>
        addsimps <span class="main">(</span>filter <span class="main">(</span><span class="entity">is_qfv_thm</span> o Thm.prop_of<span class="main">)</span> <span class="entity">qfv_supp_thms</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">transform_thm</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">lemma</span> <span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">∉</span> <span class="free">x</span> <span class="main">⟷</span> <span class="free">a</span> <span class="main">∉</span> <span class="free">y</span>"</span> <span class="keyword1"><span class="keyword">by</span></span> <span class="operator">simp</span><span class="antiquote">}</span></span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">transform_thms</span> <span class="main">=</span>
    <span class="main">[</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">lemma</span> <span class="quoted">"<span class="free">a</span> <span class="main">∉</span> <span class="main">(</span><span class="free">S</span> <span class="main">∪</span> <span class="free">T</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">a</span> <span class="main">∉</span> <span class="free">S</span> <span class="main">∧</span> <span class="free">a</span> <span class="main">∉</span> <span class="free">T</span>"</span> <span class="keyword1"><span class="keyword">by</span></span> <span class="operator">simp</span><span class="antiquote">}</span></span></span><span class="main">,</span>
      <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">lemma</span> <span class="quoted">"<span class="free">a</span> <span class="main">∉</span> <span class="main">(</span><span class="free">S</span> <span class="main">-</span> <span class="free">T</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">a</span> <span class="main">∉</span> <span class="free">S</span> <span class="main">∨</span> <span class="free">a</span> <span class="main">∈</span> <span class="free">T</span>"</span> <span class="keyword1"><span class="keyword">by</span></span> <span class="operator">simp</span><span class="antiquote">}</span></span></span><span class="main">,</span>
      <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">lemma</span> <span class="quoted">"<span class="main">(</span><span class="free">lhs</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span> <span class="main">∉</span> <span class="main">{}</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">lhs</span>"</span> <span class="keyword1"><span class="keyword">by</span></span> <span class="operator">simp</span><span class="antiquote">}</span></span></span><span class="main">,</span>
      <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> fresh_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span><span class="antiquote">}</span></span></span><span class="main">]</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">qfresh_constrs</span> <span class="main">=</span> <span class="entity">qsupp_constrs</span>
    |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">thm</span> <span class="main">=&gt;</span> <span class="entity">thm</span> RS <span class="entity">transform_thm</span><span class="main">)</span>
    |&gt; map <span class="main">(</span><span class="entity">simplify</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">lthyC</span> addsimps <span class="entity">transform_thms</span><span class="main">)</span><span class="main">)</span>

  <span class="comment1">(* proving that the qbn result is finite *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">qbn_finite_thms</span> <span class="main">=</span> <span class="entity">prove_bns_finite</span> <span class="entity">qtys</span> <span class="entity">qbns</span> <span class="entity">qinduct</span> <span class="entity">qbn_defs</span> <span class="entity">lthyC</span>

  <span class="comment1">(* proving that perm_bns preserve alpha *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">qperm_bn_alpha_thms</span> <span class="main">=</span>
    <span class="entity">prove_perm_bn_alpha_thms</span> <span class="entity">qtys</span> <span class="entity">qperm_bns</span> <span class="entity">qalpha_bns</span> <span class="entity">qinduct</span> <span class="entity">qperm_bn_simps</span> <span class="entity">qeq_iffs'</span>
      <span class="entity">qalpha_refl_thms</span> <span class="entity">lthyC</span>

  <span class="comment1">(* proving the relationship of bn and permute_bn *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">qpermute_bn_thms</span> <span class="main">=</span>
    <span class="entity">prove_permute_bn_thms</span> <span class="entity">qtys</span> <span class="entity">qbns</span> <span class="entity">qperm_bns</span> <span class="entity">qinduct</span> <span class="entity">qperm_bn_simps</span> <span class="entity">qbn_defs</span> <span class="entity">qfv_qbn_eqvts</span> <span class="entity">lthyC</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_msg</span> <span class="main">(</span>K <span class="inner_quoted">"Proving strong exhaust lemmas..."</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">qstrong_exhaust_thms</span> <span class="main">=</span> <span class="entity">prove_strong_exhausts</span> <span class="entity">lthyC</span> <span class="entity">qexhausts</span> <span class="entity">bclauses</span> <span class="entity">qbn_finite_thms</span> <span class="entity">qeq_iffs'</span>
    <span class="entity">qfv_qbn_eqvts</span> <span class="entity">qpermute_bn_thms</span> <span class="entity">qperm_bn_alpha_thms</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_msg</span> <span class="main">(</span>K <span class="inner_quoted">"Proving strong induct lemmas..."</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">qstrong_induct_thms</span> <span class="main">=</span>  <span class="entity">prove_strong_induct</span> <span class="entity">lthyC</span> <span class="entity">qinduct</span> <span class="entity">qstrong_exhaust_thms</span> <span class="entity">qsize_simps</span> <span class="entity">bclauses</span>

  <span class="comment1">(* noting the theorems *)</span>

  <span class="comment1">(* generating the prefix for the theorem names *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thms_name</span> <span class="main">=</span>
    the_default <span class="main">(</span>Binding.name <span class="main">(</span>space_implode <span class="inner_quoted">"_"</span> <span class="entity">qty_names</span><span class="main">)</span><span class="main">)</span> <span class="entity">opt_thms_name</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">thms_suffix</span> <span class="entity">s</span> <span class="main">=</span> Binding.qualify_name true <span class="entity">thms_name</span> <span class="entity">s</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">case_names_attr</span> <span class="main">=</span> <span class="entity">Attrib.internal</span> <span class="main">(</span>K <span class="main">(</span>Rule_Cases.case_names <span class="entity">cnstr_names</span><span class="main">)</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">infos</span> <span class="main">=</span> <span class="entity">mk_infos</span> <span class="entity">qty_full_names</span> <span class="entity">qeq_iffs'</span> <span class="entity">qdistincts</span> <span class="entity">qstrong_exhaust_thms</span> <span class="entity">qstrong_induct_thms</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">lthy9'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">lthyC</span>
     |&gt; Local_Theory.declaration <span class="main">{</span>syntax <span class="main">=</span> false<span class="main">,</span> pervasive <span class="main">=</span> false<span class="main">}</span> <span class="main">(</span>K <span class="main">(</span>fold <span class="entity">register_info</span> <span class="entity">infos</span><span class="main">)</span><span class="main">)</span>
     |&gt; Local_Theory.note <span class="main">(</span><span class="main">(</span><span class="entity">thms_suffix</span> <span class="inner_quoted">"distinct"</span><span class="main">,</span> <span class="main">[</span><span class="entity">induct_attr</span><span class="main">,</span> <span class="entity">simp_attr</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">qdistincts</span><span class="main">)</span>
     ||&gt;&gt; Local_Theory.note <span class="main">(</span><span class="main">(</span><span class="entity">thms_suffix</span> <span class="inner_quoted">"eq_iff"</span><span class="main">,</span> <span class="main">[</span><span class="entity">induct_attr</span><span class="main">,</span> <span class="entity">simp_attr</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">qeq_iffs'</span><span class="main">)</span>
     ||&gt;&gt; Local_Theory.note <span class="main">(</span><span class="main">(</span><span class="entity">thms_suffix</span> <span class="inner_quoted">"fv_defs"</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">qfv_defs</span><span class="main">)</span>
     ||&gt;&gt; Local_Theory.note <span class="main">(</span><span class="main">(</span><span class="entity">thms_suffix</span> <span class="inner_quoted">"bn_defs"</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">qbn_defs</span><span class="main">)</span>
     ||&gt;&gt; Local_Theory.note <span class="main">(</span><span class="main">(</span><span class="entity">thms_suffix</span> <span class="inner_quoted">"bn_inducts"</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">qbn_inducts</span><span class="main">)</span>
     ||&gt;&gt; Local_Theory.note <span class="main">(</span><span class="main">(</span><span class="entity">thms_suffix</span> <span class="inner_quoted">"perm_simps"</span><span class="main">,</span> <span class="main">[</span><span class="entity">eqvt_attr</span><span class="main">,</span> <span class="entity">simp_attr</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">qperm_simps</span><span class="main">)</span>
     ||&gt;&gt; Local_Theory.note <span class="main">(</span><span class="main">(</span><span class="entity">thms_suffix</span> <span class="inner_quoted">"fv_bn_eqvt"</span><span class="main">,</span> <span class="main">[</span><span class="entity">eqvt_attr</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">qfv_qbn_eqvts</span><span class="main">)</span>
     ||&gt;&gt; Local_Theory.note <span class="main">(</span><span class="main">(</span><span class="entity">thms_suffix</span> <span class="inner_quoted">"size"</span><span class="main">,</span> <span class="main">[</span><span class="entity">simp_attr</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">qsize_simps</span><span class="main">)</span>
     ||&gt;&gt; Local_Theory.note <span class="main">(</span><span class="main">(</span><span class="entity">thms_suffix</span> <span class="inner_quoted">"size_eqvt"</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">qsize_eqvt</span><span class="main">)</span>
     ||&gt;&gt; Local_Theory.note <span class="main">(</span><span class="main">(</span><span class="entity">thms_suffix</span> <span class="inner_quoted">"induct"</span><span class="main">,</span> <span class="main">[</span><span class="entity">case_names_attr</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="entity">qinduct</span><span class="main">]</span><span class="main">)</span>
     ||&gt;&gt; Local_Theory.note <span class="main">(</span><span class="main">(</span><span class="entity">thms_suffix</span> <span class="inner_quoted">"inducts"</span><span class="main">,</span> <span class="main">[</span><span class="entity">case_names_attr</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">qinducts</span><span class="main">)</span>
     ||&gt;&gt; Local_Theory.note <span class="main">(</span><span class="main">(</span><span class="entity">thms_suffix</span> <span class="inner_quoted">"exhaust"</span><span class="main">,</span> <span class="main">[</span><span class="entity">case_names_attr</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">qexhausts</span><span class="main">)</span>
     ||&gt;&gt; Local_Theory.note <span class="main">(</span><span class="main">(</span><span class="entity">thms_suffix</span> <span class="inner_quoted">"strong_exhaust"</span><span class="main">,</span> <span class="main">[</span><span class="entity">case_names_attr</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">qstrong_exhaust_thms</span><span class="main">)</span>
     ||&gt;&gt; Local_Theory.note <span class="main">(</span><span class="main">(</span><span class="entity">thms_suffix</span> <span class="inner_quoted">"strong_induct"</span><span class="main">,</span> <span class="main">[</span><span class="entity">case_names_attr</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">qstrong_induct_thms</span><span class="main">)</span>
     ||&gt;&gt; Local_Theory.note <span class="main">(</span><span class="main">(</span><span class="entity">thms_suffix</span> <span class="inner_quoted">"supports"</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">qsupports_thms</span><span class="main">)</span>
     ||&gt;&gt; Local_Theory.note <span class="main">(</span><span class="main">(</span><span class="entity">thms_suffix</span> <span class="inner_quoted">"fsupp"</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">qfsupp_thms</span><span class="main">)</span>
     ||&gt;&gt; Local_Theory.note <span class="main">(</span><span class="main">(</span><span class="entity">thms_suffix</span> <span class="inner_quoted">"supp"</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">qsupp_constrs</span><span class="main">)</span>
     ||&gt;&gt; Local_Theory.note <span class="main">(</span><span class="main">(</span><span class="entity">thms_suffix</span> <span class="inner_quoted">"fresh"</span><span class="main">,</span> <span class="main">[</span><span class="entity">simp_attr</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">qfresh_constrs</span><span class="main">)</span>
     ||&gt;&gt; Local_Theory.note <span class="main">(</span><span class="main">(</span><span class="entity">thms_suffix</span> <span class="inner_quoted">"perm_bn_simps"</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">qperm_bn_simps</span><span class="main">)</span>
     ||&gt;&gt; Local_Theory.note <span class="main">(</span><span class="main">(</span><span class="entity">thms_suffix</span> <span class="inner_quoted">"bn_finite"</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">qbn_finite_thms</span><span class="main">)</span>
     ||&gt;&gt; Local_Theory.note <span class="main">(</span><span class="main">(</span><span class="entity">thms_suffix</span> <span class="inner_quoted">"perm_bn_alpha"</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">qperm_bn_alpha_thms</span><span class="main">)</span>
     ||&gt;&gt; Local_Theory.note <span class="main">(</span><span class="main">(</span><span class="entity">thms_suffix</span> <span class="inner_quoted">"permute_bn"</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">qpermute_bn_thms</span><span class="main">)</span>
     ||&gt;&gt; Local_Theory.note <span class="main">(</span><span class="main">(</span><span class="entity">thms_suffix</span> <span class="inner_quoted">"alpha_refl"</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">qalpha_refl_thms</span><span class="main">)</span>
     ||&gt;&gt; Local_Theory.note <span class="main">(</span><span class="main">(</span><span class="entity">thms_suffix</span> <span class="inner_quoted">"alpha_sym"</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">qalpha_sym_thms</span><span class="main">)</span>
     ||&gt;&gt; Local_Theory.note <span class="main">(</span><span class="main">(</span><span class="entity">thms_suffix</span> <span class="inner_quoted">"alpha_trans"</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">qalpha_trans_thms</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">in</span></span>
  <span class="entity">lthy9'</span>
<span class="keyword2"><span class="keyword">end</span></span>
›</span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Preparing and parsing of the specification›</span></span>

<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹
<span class="comment1">(* adds the default sort @{sort fs} to nominal specifications *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">augment_sort</span> <span class="entity">thy</span> <span class="entity">S</span> <span class="main">=</span> Sign.inter_sort <span class="entity">thy</span> <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">fs</span><span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">S</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">augment_sort_typ</span> <span class="entity">thy</span> <span class="main">=</span>
  map_type_tfree <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="entity">S</span><span class="main">)</span> <span class="main">=&gt;</span> TFree <span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="entity">augment_sort</span> <span class="entity">thy</span> <span class="entity">S</span><span class="main">)</span><span class="main">)</span>
›</span>

<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹
<span class="comment1">(* generates the parsed datatypes and declares the constructors *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prepare_dts</span> <span class="entity">dt_strs</span> <span class="entity">thy</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prep_spec</span> <span class="main">(</span><span class="main">(</span><span class="entity">tname</span><span class="main">,</span> <span class="entity">tvs</span><span class="main">,</span> <span class="entity">mx</span><span class="main">)</span><span class="main">,</span> <span class="entity">constrs</span><span class="main">)</span> <span class="main">=</span>
    <span class="main">(</span><span class="main">(</span><span class="entity">tname</span><span class="main">,</span> <span class="entity">tvs</span><span class="main">,</span> <span class="entity">mx</span><span class="main">)</span><span class="main">,</span> <span class="entity">constrs</span> |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">atys</span><span class="main">,</span> <span class="entity">mx'</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> map snd <span class="entity">atys</span><span class="main">,</span> <span class="entity">mx'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">dts</span><span class="main">,</span> <span class="entity">spec_ctxt</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">Old_Datatype.read_specs</span> <span class="main">(</span>map <span class="entity">prep_spec</span> <span class="entity">dt_strs</span><span class="main">)</span> <span class="entity">thy</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">augment</span> <span class="main">(</span><span class="main">(</span><span class="entity">tname</span><span class="main">,</span> <span class="entity">tvs</span><span class="main">,</span> <span class="entity">mx</span><span class="main">)</span><span class="main">,</span> <span class="entity">constrs</span><span class="main">)</span> <span class="main">=</span>
    <span class="main">(</span><span class="main">(</span><span class="entity">tname</span><span class="main">,</span> map <span class="main">(</span>apsnd <span class="main">(</span><span class="entity">augment_sort</span> <span class="entity">thy</span><span class="main">)</span><span class="main">)</span> <span class="entity">tvs</span><span class="main">,</span> <span class="entity">mx</span><span class="main">)</span><span class="main">,</span>
      <span class="entity">constrs</span> |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">tys</span><span class="main">,</span> <span class="entity">mx'</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> map <span class="main">(</span><span class="entity">augment_sort_typ</span> <span class="entity">thy</span><span class="main">)</span> <span class="entity">tys</span><span class="main">,</span> <span class="entity">mx'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dts'</span> <span class="main">=</span> map <span class="entity">augment</span> <span class="entity">dts</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_constr_trms</span> <span class="main">(</span><span class="main">(</span><span class="entity">tname</span><span class="main">,</span> <span class="entity">tvs</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="entity">constrs</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty</span> <span class="main">=</span> Type <span class="main">(</span>Sign.full_name <span class="entity">thy</span> <span class="entity">tname</span><span class="main">,</span> map TFree <span class="entity">tvs</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">tys</span><span class="main">,</span> <span class="entity">mx</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="main">(</span><span class="entity">tys</span> ---&gt; <span class="entity">ty</span><span class="main">)</span><span class="main">,</span> <span class="entity">mx</span><span class="main">)</span><span class="main">)</span> <span class="entity">constrs</span>
    <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">constr_trms</span> <span class="main">=</span> flat <span class="main">(</span>map <span class="entity">mk_constr_trms</span> <span class="entity">dts'</span><span class="main">)</span>

  <span class="comment1">(* FIXME: local version *)</span>
  <span class="comment1">(* val (_, spec_ctxt') = Proof_Context.add_fixes constr_trms spec_ctxt *)</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy'</span> <span class="main">=</span> Sign.add_consts <span class="entity">constr_trms</span> <span class="main">(</span>Proof_Context.theory_of <span class="entity">spec_ctxt</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">in</span></span>
  <span class="main">(</span><span class="entity">dts'</span><span class="main">,</span> <span class="entity">thy'</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>
›</span>

<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹
<span class="comment1">(* parsing the binding function specifications and *)</span>
<span class="comment1">(* declaring the function constants                *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prepare_bn_funs</span> <span class="entity">bn_fun_strs</span> <span class="entity">bn_eq_strs</span> <span class="entity">thy</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lthy</span> <span class="main">=</span> <span class="entity">Named_Target.theory_init</span> <span class="entity">thy</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">bn_funs</span><span class="main">,</span> <span class="entity">bn_eqs</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">Specification.read_multi_specs</span> <span class="entity">bn_fun_strs</span> <span class="entity">bn_eq_strs</span> <span class="entity">lthy</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prep_bn_fun</span> <span class="main">(</span><span class="main">(</span><span class="entity">bn</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> <span class="entity">mx</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">bn</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">mx</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">bn_funs'</span> <span class="main">=</span> map <span class="entity">prep_bn_fun</span> <span class="entity">bn_funs</span>

<span class="keyword2"><span class="keyword">in</span></span>
  <span class="main">(</span>Local_Theory.exit_global <span class="entity">lthy'</span><span class="main">)</span>
  |&gt; Sign.add_consts <span class="entity">bn_funs'</span>
  |&gt; pair <span class="main">(</span><span class="entity">bn_funs'</span><span class="main">,</span> <span class="entity">bn_eqs</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>
›</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹associates every SOME with the index in the list; drops NONEs›</span></span>
<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">indexify</span> <span class="entity">xs</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mapp</span> <span class="main">_</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="main">]</span>
    <span class="main">|</span> <span class="entity">mapp</span> <span class="entity">i</span> <span class="main">(</span>NONE :: <span class="entity">xs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mapp</span> <span class="main">(</span><span class="entity">i</span> + <span class="inner_numeral">1</span><span class="main">)</span> <span class="entity">xs</span>
    <span class="main">|</span> <span class="entity">mapp</span> <span class="entity">i</span> <span class="main">(</span>SOME <span class="entity">x</span> :: <span class="entity">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">i</span><span class="main">)</span> :: <span class="entity">mapp</span> <span class="main">(</span><span class="entity">i</span> + <span class="inner_numeral">1</span><span class="main">)</span> <span class="entity">xs</span>
<span class="keyword2"><span class="keyword">in</span></span>
  <span class="entity">mapp</span> <span class="inner_numeral">0</span> <span class="entity">xs</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">index_lookup</span> <span class="entity">xs</span> <span class="entity">x</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">case</span></span> AList.lookup <span class="main">(</span><span class="main">(</span><span class="main">=</span><span class="main">)</span><span class="main">)</span> <span class="entity">xs</span> <span class="entity">x</span> <span class="keyword2"><span class="keyword">of</span></span>
    SOME <span class="entity">x</span> <span class="main">=&gt;</span> <span class="entity">x</span>
  <span class="main">|</span> NONE <span class="main">=&gt;</span> error <span class="main">(</span><span class="inner_quoted">"Cannot find "</span> ^ <span class="entity">x</span> ^ <span class="inner_quoted">" as argument annotation."</span><span class="main">)</span><span class="main">;</span>
›</span>

<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prepare_bclauses</span> <span class="entity">dt_strs</span> <span class="entity">thy</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">annos_bclauses</span> <span class="main">=</span>
    <span class="entity">get_cnstrs</span> <span class="entity">dt_strs</span>
    |&gt; <span class="main">(</span>map o map<span class="main">)</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">antys</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">bns</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span>map fst <span class="entity">antys</span><span class="main">,</span> <span class="entity">bns</span><span class="main">)</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prep_binder</span> <span class="entity">env</span> <span class="entity">bn_str</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="main">(</span>Syntax.read_term_global <span class="entity">thy</span> <span class="entity">bn_str</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
      Free <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span>NONE<span class="main">,</span> <span class="entity">index_lookup</span> <span class="entity">env</span> <span class="entity">x</span><span class="main">)</span>
    <span class="main">|</span> Const <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> $ Free <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span>SOME <span class="main">(</span>Const <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="entity">index_lookup</span> <span class="entity">env</span> <span class="entity">x</span><span class="main">)</span>
    <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> error <span class="main">(</span><span class="inner_quoted">"The term "</span> ^ <span class="entity">bn_str</span> ^ <span class="inner_quoted">" is not allowed as binding function."</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prep_body</span> <span class="entity">env</span> <span class="entity">bn_str</span> <span class="main">=</span> <span class="entity">index_lookup</span> <span class="entity">env</span> <span class="entity">bn_str</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prep_bclause</span> <span class="entity">env</span> <span class="main">(</span><span class="entity">mode</span><span class="main">,</span> <span class="entity">binders</span><span class="main">,</span> <span class="entity">bodies</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">binders'</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">prep_binder</span> <span class="entity">env</span><span class="main">)</span> <span class="entity">binders</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">bodies'</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">prep_body</span> <span class="entity">env</span><span class="main">)</span> <span class="entity">bodies</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">BC</span> <span class="main">(</span><span class="entity">mode</span><span class="main">,</span> <span class="entity">binders'</span><span class="main">,</span> <span class="entity">bodies'</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prep_bclauses</span> <span class="main">(</span><span class="entity">annos</span><span class="main">,</span> <span class="entity">bclause_strs</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">env</span> <span class="main">=</span> <span class="entity">indexify</span> <span class="entity">annos</span> <span class="comment1">(* for every label, associate the index *)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    map <span class="main">(</span><span class="entity">prep_bclause</span> <span class="entity">env</span><span class="main">)</span> <span class="entity">bclause_strs</span>
  <span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword2"><span class="keyword">in</span></span>
  <span class="main">(</span><span class="main">(</span>map o map<span class="main">)</span> <span class="entity">prep_bclauses</span> <span class="entity">annos_bclauses</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>
›</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  adds an empty binding clause for every argument
  that is not already part of a binding clause
›</span></span>

<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">included</span> <span class="entity">i</span> <span class="entity">bcs</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">incl</span> <span class="main">(</span><span class="entity">BC</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">bns</span><span class="main">,</span> <span class="entity">bds</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
    member <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span>map snd <span class="entity">bns</span><span class="main">)</span> <span class="entity">i</span> <span class="keyword1"><span class="keyword">orelse</span></span> member <span class="main">(</span><span class="main">=</span><span class="main">)</span> <span class="entity">bds</span> <span class="entity">i</span>
<span class="keyword2"><span class="keyword">in</span></span>
  exists <span class="entity">incl</span> <span class="entity">bcs</span>
<span class="keyword2"><span class="keyword">end</span></span>
›</span>

<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">complete</span> <span class="entity">dt_strs</span> <span class="entity">bclauses</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span>
    <span class="entity">get_cnstrs</span> <span class="entity">dt_strs</span>
    |&gt; <span class="main">(</span>map o map<span class="main">)</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">antys</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> length <span class="entity">antys</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">complt</span> <span class="entity">n</span> <span class="entity">bcs</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add</span> <span class="entity">bcs</span> <span class="entity">i</span> <span class="main">=</span> <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">included</span> <span class="entity">i</span> <span class="entity">bcs</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="entity">BC</span> <span class="main">(</span><span class="entity">Lst</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="entity">i</span><span class="main">]</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">bcs</span> @ <span class="main">(</span>flat <span class="main">(</span>map_range <span class="main">(</span><span class="entity">add</span> <span class="entity">bcs</span><span class="main">)</span> <span class="entity">n</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword2"><span class="keyword">in</span></span>
  <span class="main">(</span>map2 o map2<span class="main">)</span> <span class="entity">complt</span> <span class="entity">args</span> <span class="entity">bclauses</span>
<span class="keyword2"><span class="keyword">end</span></span>
›</span>

<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">nominal_datatype2_cmd</span> <span class="main">(</span><span class="entity">opt_thms_name</span><span class="main">,</span> <span class="entity">dt_strs</span><span class="main">,</span> <span class="entity">bn_fun_strs</span><span class="main">,</span> <span class="entity">bn_eq_strs</span><span class="main">)</span> <span class="entity">lthy</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="comment1">(* this theory is used just for parsing *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">lthy</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">dts</span><span class="main">,</span> <span class="main">(</span><span class="entity">bn_funs</span><span class="main">,</span> <span class="entity">bn_eqs</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="entity">bclauses</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">thy</span>
    |&gt; <span class="entity">prepare_dts</span> <span class="entity">dt_strs</span>
    ||&gt;&gt; <span class="entity">prepare_bn_funs</span> <span class="entity">bn_fun_strs</span> <span class="entity">bn_eq_strs</span>
    ||&gt;&gt; <span class="entity">prepare_bclauses</span> <span class="entity">dt_strs</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">bclauses'</span> <span class="main">=</span> <span class="entity">complete</span> <span class="entity">dt_strs</span> <span class="entity">bclauses</span>
<span class="keyword2"><span class="keyword">in</span></span>
  <span class="entity">nominal_datatype2</span> <span class="entity">opt_thms_name</span> <span class="entity">dts</span> <span class="entity">bn_funs</span> <span class="entity">bn_eqs</span> <span class="entity">bclauses'</span> <span class="entity">lthy</span>
<span class="keyword2"><span class="keyword">end</span></span>
›</span>

<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹
<span class="comment1">(* nominal datatype parser *)</span>
<span class="keyword2"><span class="keyword">local</span></span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">triple1</span> <span class="main">(</span><span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span><span class="main">,</span> <span class="entity">z</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">,</span> <span class="entity">z</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">triple2</span> <span class="main">(</span><span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span><span class="main">,</span> <span class="entity">z</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">y</span><span class="main">,</span> <span class="entity">x</span><span class="main">,</span> <span class="entity">z</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tuple2</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span><span class="main">,</span> <span class="entity">z</span><span class="main">)</span><span class="main">,</span> <span class="entity">u</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">,</span> <span class="entity">u</span><span class="main">,</span> <span class="entity">z</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tuple3</span> <span class="main">(</span><span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">z</span><span class="main">,</span> <span class="entity">u</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">,</span> <span class="entity">z</span><span class="main">,</span> <span class="entity">u</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">in</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">opt_name</span> <span class="main">=</span> Scan.option <span class="main">(</span>Parse.binding --| Args.colon<span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">anno_typ</span> <span class="main">=</span> Scan.option <span class="main">(</span>Parse.name --| <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">::</span>"<span class="antiquote">}</span></span></span><span class="main">)</span> -- Parse.typ

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">bind_mode</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">binds</span>"<span class="antiquote">}</span></span></span> |--
  Scan.optional <span class="main">(</span>Args.parens
    <span class="main">(</span>Args.$$$ <span class="inner_quoted">"list"</span> &gt;&gt; K <span class="entity">Lst</span> || <span class="main">(</span>Args.$$$ <span class="inner_quoted">"set"</span> -- Args.$$$ <span class="inner_quoted">"+"</span><span class="main">)</span> &gt;&gt; K <span class="entity">Res</span> || Args.$$$ <span class="inner_quoted">"set"</span> &gt;&gt; K <span class="entity">Set</span><span class="main">)</span><span class="main">)</span> <span class="entity">Lst</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">bind_clauses</span> <span class="main">=</span>
  Parse.enum <span class="inner_quoted">","</span> <span class="main">(</span><span class="entity">bind_mode</span> -- Scan.repeat1 Parse.term -- <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">in</span>"<span class="antiquote">}</span></span></span> |-- Scan.repeat1 Parse.name<span class="main">)</span> &gt;&gt; <span class="entity">triple1</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cnstr_parser</span> <span class="main">=</span>
  Parse.binding -- Scan.repeat <span class="entity">anno_typ</span> -- <span class="entity">bind_clauses</span> -- Parse.opt_mixfix &gt;&gt; <span class="entity">tuple2</span>

<span class="comment1">(* datatype parser *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dt_parser</span> <span class="main">=</span>
  <span class="main">(</span>Parse.type_args_constrained -- Parse.binding -- Parse.opt_mixfix &gt;&gt; <span class="entity">triple2</span><span class="main">)</span> --
    <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">=</span>"<span class="antiquote">}</span></span></span> |-- Parse.enum1 <span class="inner_quoted">"|"</span> <span class="entity">cnstr_parser</span><span class="main">)</span>

<span class="comment1">(* binding function parser *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">bnfun_parser</span> <span class="main">=</span>
  Scan.optional <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">binder</span>"<span class="antiquote">}</span></span></span> |-- <span class="entity">Parse_Spec.specification</span><span class="main">)</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>

<span class="comment1">(* main parser *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">main_parser</span> <span class="main">=</span>
  <span class="entity">opt_name</span> -- Parse.and_list1 <span class="entity">dt_parser</span> -- <span class="entity">bnfun_parser</span> &gt;&gt; <span class="entity">tuple3</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Command Keyword *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">Outer_Syntax.local_theory</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> <span class="keyword1">nominal_datatype</span><span class="antiquote">}</span></span></span>
  <span class="inner_quoted">"declaration of nominal datatypes"</span>
    <span class="main">(</span><span class="entity">main_parser</span> &gt;&gt; <span class="entity">nominal_datatype2_cmd</span><span class="main">)</span>
›</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/nominal_dt_data.ML">
<div class="head">
<h1>File ‹nominal_dt_data.ML›</h1>
</div>
<pre class="source"><span class="comment1">(* Author: Christian Urban

   data about nominal datatypes
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">NOMINAL_DT_DATA</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="comment1">(* info of raw binding functions *)</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">bn_info</span> <span class="main">=</span> term * int * <span class="main">(</span>int * term option<span class="main">)</span> list list

  <span class="comment1">(* binding modes and binding clauses *)</span>
  <span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">bmode</span> <span class="main">=</span> <span class="entity">Lst</span> <span class="main">|</span> <span class="entity">Res</span> <span class="main">|</span> <span class="entity">Set</span>
  <span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">bclause</span> <span class="main">=</span> <span class="entity">BC</span> <span class="keyword2"><span class="keyword">of</span></span> bmode * <span class="main">(</span>term option * int<span class="main">)</span> list * int list

  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">info</span> <span class="main">=</span>
    <span class="main">{</span>inject <span class="main">:</span> thm list<span class="main">,</span>
     distinct <span class="main">:</span> thm list<span class="main">,</span>
     strong_inducts <span class="main">:</span> thm list<span class="main">,</span>
     strong_exhaust <span class="main">:</span> thm list<span class="main">}</span>

  <span class="keyword1"><span class="keyword">val</span></span> get_all_info<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="main">(</span>string * <span class="entity">info</span><span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> get_info<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string <span class="main">-&gt;</span> <span class="entity">info</span> option
  <span class="keyword1"><span class="keyword">val</span></span> the_info<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string <span class="main">-&gt;</span> <span class="entity">info</span>
  <span class="keyword1"><span class="keyword">val</span></span> register_info<span class="main">:</span> <span class="main">(</span>string * <span class="entity">info</span><span class="main">)</span> <span class="main">-&gt;</span> Context.generic <span class="main">-&gt;</span> Context.generic
  <span class="keyword1"><span class="keyword">val</span></span> mk_infos<span class="main">:</span> string list <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> <span class="main">(</span>string * <span class="entity">info</span><span class="main">)</span> list

  <span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">user_data</span> <span class="main">=</span> <span class="entity">UserData</span> <span class="keyword2"><span class="keyword">of</span></span>
    <span class="main">{</span>dts      <span class="main">:</span> Old_Datatype.spec list<span class="main">,</span>
     cn_names <span class="main">:</span> string list<span class="main">,</span>
     cn_tys   <span class="main">:</span> <span class="main">(</span>string * string<span class="main">)</span> list<span class="main">,</span>
     bn_funs  <span class="main">:</span> <span class="main">(</span>binding * typ * mixfix<span class="main">)</span> list<span class="main">,</span>
     bn_eqs   <span class="main">:</span> <span class="main">(</span>Attrib.binding * term<span class="main">)</span> list<span class="main">,</span>
     bclauses <span class="main">:</span> bclause list list list<span class="main">}</span>

  <span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">raw_dt_info</span> <span class="main">=</span> <span class="entity">RawDtInfo</span> <span class="keyword2"><span class="keyword">of</span></span>
    <span class="main">{</span>raw_dt_names         <span class="main">:</span> string list<span class="main">,</span>
     raw_fp_sugars        <span class="main">:</span> BNF_FP_Def_Sugar.fp_sugar list<span class="main">,</span>
     raw_dts              <span class="main">:</span> Old_Datatype.spec list<span class="main">,</span>
     raw_tys              <span class="main">:</span> typ list<span class="main">,</span>
     raw_ty_args          <span class="main">:</span> <span class="main">(</span>string * sort<span class="main">)</span> list<span class="main">,</span>
     raw_cns_info         <span class="main">:</span> cns_info list<span class="main">,</span>
     raw_all_cns          <span class="main">:</span> term list list<span class="main">,</span>
     raw_inject_thms      <span class="main">:</span> thm list<span class="main">,</span>
     raw_distinct_thms    <span class="main">:</span> thm list<span class="main">,</span>
     raw_induct_thm       <span class="main">:</span> thm<span class="main">,</span>
     raw_induct_thms      <span class="main">:</span> thm list<span class="main">,</span>
     raw_exhaust_thms     <span class="main">:</span> thm list<span class="main">,</span>
     raw_size_trms        <span class="main">:</span> term list<span class="main">,</span>
     raw_size_thms        <span class="main">:</span> thm list<span class="main">}</span>

  <span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">alpha_result</span> <span class="main">=</span> <span class="entity">AlphaResult</span> <span class="keyword2"><span class="keyword">of</span></span>
    <span class="main">{</span>alpha_names      <span class="main">:</span> string list<span class="main">,</span>
     alpha_trms       <span class="main">:</span> term list<span class="main">,</span>
     alpha_tys        <span class="main">:</span> typ list<span class="main">,</span>
     alpha_bn_names   <span class="main">:</span> string list<span class="main">,</span>
     alpha_bn_trms    <span class="main">:</span> term list<span class="main">,</span>
     alpha_bn_tys     <span class="main">:</span> typ list<span class="main">,</span>
     alpha_intros     <span class="main">:</span> thm list<span class="main">,</span>
     alpha_cases      <span class="main">:</span> thm list<span class="main">,</span>
     alpha_raw_induct <span class="main">:</span> thm<span class="main">}</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Nominal_Dt_Data</span><span class="main">:</span> <span class="entity">NOMINAL_DT_DATA</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>


<span class="comment1">(* term              - is constant of the bn-function
   int               - is datatype number over which the bn-function is defined
   int * term option - is number of the corresponding argument with possibly
                       recursive call with bn-function term
*)</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">bn_info</span> <span class="main">=</span> term * int * <span class="main">(</span>int * term option<span class="main">)</span> list list

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">bmode</span> <span class="main">=</span> <span class="entity">Lst</span> <span class="main">|</span> <span class="entity">Res</span> <span class="main">|</span> <span class="entity">Set</span>
<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">bclause</span> <span class="main">=</span> <span class="entity">BC</span> <span class="keyword2"><span class="keyword">of</span></span> bmode * <span class="main">(</span>term option * int<span class="main">)</span> list * int list


<span class="comment1">(* information generated by nominal_datatype *)</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">info</span> <span class="main">=</span>
   <span class="main">{</span>inject <span class="main">:</span> thm list<span class="main">,</span>
    distinct <span class="main">:</span> thm list<span class="main">,</span>
    strong_inducts <span class="main">:</span> thm list<span class="main">,</span>
    strong_exhaust <span class="main">:</span> thm list<span class="main">}</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">NominalData</span> <span class="main">=</span> Generic_Data
 <span class="main">(</span><span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">info</span> Symtab.table
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">empty</span> <span class="main">=</span> Symtab.empty
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">extend</span> <span class="main">=</span> I
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">merge</span> <span class="main">=</span> Symtab.merge <span class="main">(</span>K true<span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">get_all_info</span> <span class="main">=</span> Symtab.dest o NominalData.get o Context.Proof
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">get_info</span> <span class="main">=</span> Symtab.lookup o NominalData.get o Context.Proof
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">register_info</span> <span class="main">=</span> NominalData.map o Symtab.update

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">the_info</span> <span class="entity">thy</span> <span class="entity">name</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">get_info</span> <span class="entity">thy</span> <span class="entity">name</span> <span class="keyword2"><span class="keyword">of</span></span>
    SOME <span class="entity">info</span> <span class="main">=&gt;</span> <span class="entity">info</span>
  <span class="main">|</span> NONE <span class="main">=&gt;</span> error <span class="main">(</span><span class="inner_quoted">"Unknown nominal datatype "</span> ^ quote <span class="entity">name</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_infos</span> <span class="entity">ty_names</span> <span class="entity">inject</span> <span class="entity">distinct</span> <span class="entity">strong_inducts</span> <span class="entity">strong_exhaust</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">aux</span> <span class="entity">ty_name</span> <span class="main">=</span>
    <span class="main">(</span><span class="entity">ty_name</span><span class="main">,</span> <span class="main">{</span>inject <span class="main">=</span> <span class="entity">inject</span><span class="main">,</span>
               distinct <span class="main">=</span> <span class="entity">distinct</span><span class="main">,</span>
               strong_inducts <span class="main">=</span> <span class="entity">strong_inducts</span><span class="main">,</span>
               strong_exhaust <span class="main">=</span> <span class="entity">strong_exhaust</span>
              <span class="main">}</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">in</span></span>
  map <span class="entity">aux</span> <span class="entity">ty_names</span>
<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">user_data</span> <span class="main">=</span> <span class="entity">UserData</span> <span class="keyword2"><span class="keyword">of</span></span>
  <span class="main">{</span>dts      <span class="main">:</span> Old_Datatype.spec list<span class="main">,</span>
   cn_names <span class="main">:</span> string list<span class="main">,</span>
   cn_tys   <span class="main">:</span> <span class="main">(</span>string * string<span class="main">)</span> list<span class="main">,</span>
   bn_funs  <span class="main">:</span> <span class="main">(</span>binding * typ * mixfix<span class="main">)</span> list<span class="main">,</span>
   bn_eqs   <span class="main">:</span> <span class="main">(</span>Attrib.binding * term<span class="main">)</span> list<span class="main">,</span>
   bclauses <span class="main">:</span> bclause list list list<span class="main">}</span>

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">raw_dt_info</span> <span class="main">=</span> <span class="entity">RawDtInfo</span> <span class="keyword2"><span class="keyword">of</span></span>
  <span class="main">{</span>raw_dt_names         <span class="main">:</span> string list<span class="main">,</span>
   raw_fp_sugars        <span class="main">:</span> BNF_FP_Def_Sugar.fp_sugar list<span class="main">,</span>
   raw_dts              <span class="main">:</span> Old_Datatype.spec list<span class="main">,</span>
   raw_tys              <span class="main">:</span> typ list<span class="main">,</span>
   raw_ty_args          <span class="main">:</span> <span class="main">(</span>string * sort<span class="main">)</span> list<span class="main">,</span>
   raw_cns_info         <span class="main">:</span> cns_info list<span class="main">,</span>
   raw_all_cns          <span class="main">:</span> term list list<span class="main">,</span>
   raw_inject_thms      <span class="main">:</span> thm list<span class="main">,</span>
   raw_distinct_thms    <span class="main">:</span> thm list<span class="main">,</span>
   raw_induct_thm       <span class="main">:</span> thm<span class="main">,</span>
   raw_induct_thms      <span class="main">:</span> thm list<span class="main">,</span>
   raw_exhaust_thms     <span class="main">:</span> thm list<span class="main">,</span>
   raw_size_trms        <span class="main">:</span> term list<span class="main">,</span>
   raw_size_thms        <span class="main">:</span> thm list<span class="main">}</span>

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">alpha_result</span> <span class="main">=</span> <span class="entity">AlphaResult</span> <span class="keyword2"><span class="keyword">of</span></span>
  <span class="main">{</span>alpha_names      <span class="main">:</span> string list<span class="main">,</span>
   alpha_trms       <span class="main">:</span> term list<span class="main">,</span>
   alpha_tys        <span class="main">:</span> typ list<span class="main">,</span>
   alpha_bn_names   <span class="main">:</span> string list<span class="main">,</span>
   alpha_bn_trms    <span class="main">:</span> term list<span class="main">,</span>
   alpha_bn_tys     <span class="main">:</span> typ list<span class="main">,</span>
   alpha_intros     <span class="main">:</span> thm list<span class="main">,</span>
   alpha_cases      <span class="main">:</span> thm list<span class="main">,</span>
   alpha_raw_induct <span class="main">:</span> thm<span class="main">}</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/nominal_dt_rawfuns.ML">
<div class="head">
<h1>File ‹nominal_dt_rawfuns.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      nominal_dt_rawfuns.ML
    Author:     Cezary Kaliszyk
    Author:     Christian Urban

  Definitions of the raw fv, fv_bn and permute functions.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">NOMINAL_DT_RAWFUNS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> get_all_binders<span class="main">:</span> <span class="entity">bclause</span> list <span class="main">-&gt;</span> <span class="main">(</span>term option * int<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> is_recursive_binder<span class="main">:</span> <span class="entity">bclause</span> <span class="main">-&gt;</span> bool

  <span class="keyword1"><span class="keyword">val</span></span> define_raw_bns<span class="main">:</span> <span class="entity">raw_dt_info</span> <span class="main">-&gt;</span> <span class="main">(</span>binding * typ option * mixfix<span class="main">)</span> list <span class="main">-&gt;</span>
    <span class="entity">Specification.multi_specs</span> <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span>
    <span class="main">(</span>term list * thm list * <span class="entity">bn_info</span> list * thm list * local_theory<span class="main">)</span>

  <span class="keyword1"><span class="keyword">val</span></span> define_raw_fvs<span class="main">:</span> <span class="entity">raw_dt_info</span> <span class="main">-&gt;</span> <span class="entity">bn_info</span> list <span class="main">-&gt;</span> <span class="entity">bclause</span> list list list <span class="main">-&gt;</span>
    <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term list * term list * thm list * thm list * local_theory

  <span class="keyword1"><span class="keyword">val</span></span> define_raw_bn_perms<span class="main">:</span> <span class="entity">raw_dt_info</span> <span class="main">-&gt;</span> <span class="entity">bn_info</span> list <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span>
    <span class="main">(</span>term list * thm list * local_theory<span class="main">)</span>

  <span class="keyword1"><span class="keyword">val</span></span> define_raw_perms<span class="main">:</span> <span class="entity">raw_dt_info</span> <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> <span class="main">(</span>term list * thm list * thm list<span class="main">)</span> * local_theory

  <span class="keyword1"><span class="keyword">val</span></span> raw_prove_eqvt<span class="main">:</span> term list <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm list

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Nominal_Dt_RawFuns</span><span class="main">:</span> <span class="entity">NOMINAL_DT_RAWFUNS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword3"><span class="keyword">open</span></span> Nominal_Permeq

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_all_binders</span> <span class="entity">bclauses</span> <span class="main">=</span>
  <span class="entity">bclauses</span>
  |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">BC</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">binders</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">binders</span><span class="main">)</span>
  |&gt; flat
  |&gt; <span class="entity">remove_dups</span> <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_recursive_binder</span> <span class="main">(</span><span class="entity">BC</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">binders</span><span class="main">,</span> <span class="entity">bodies</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">case</span></span> <span class="main">(</span>inter <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span>map snd <span class="entity">binders</span><span class="main">)</span> <span class="entity">bodies</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
    nil <span class="main">=&gt;</span> false
  <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> true


<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">lookup</span> <span class="entity">xs</span> <span class="entity">x</span> <span class="main">=</span> the <span class="main">(</span>AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span><span class="main">)</span> <span class="entity">xs</span> <span class="entity">x</span><span class="main">)</span>


<span class="comment1">(** functions that define the raw binding functions **)</span>

<span class="comment1">(* strip_bn_fun takes a rhs of a bn function: this can only contain unions or
   appends of elements; in case of recursive calls it returns also the applied
   bn function *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">strip_bn_fun</span> <span class="entity">ctxt</span> <span class="entity">args</span> <span class="entity">t</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">aux</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
      Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> sup<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="entity">l</span> $ <span class="entity">r</span> <span class="main">=&gt;</span> <span class="entity">aux</span> <span class="entity">l</span> @ <span class="entity">aux</span> <span class="entity">r</span>
    <span class="main">|</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> append<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="entity">l</span> $ <span class="entity">r</span> <span class="main">=&gt;</span> <span class="entity">aux</span> <span class="entity">l</span> @ <span class="entity">aux</span> <span class="entity">r</span>
    <span class="main">|</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> insert<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> atom<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">(</span><span class="entity">x</span> <span class="keyword1"><span class="keyword">as</span></span> Var <span class="main">_</span><span class="main">)</span><span class="main">)</span> $ <span class="entity">y</span> <span class="main">=&gt;</span>
        <span class="main">(</span>find_index <span class="main">(</span>equal <span class="entity">x</span><span class="main">)</span> <span class="entity">args</span><span class="main">,</span> NONE<span class="main">)</span> :: <span class="entity">aux</span> <span class="entity">y</span>
    <span class="main">|</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Cons<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> atom<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">(</span><span class="entity">x</span> <span class="keyword1"><span class="keyword">as</span></span> Var <span class="main">_</span><span class="main">)</span><span class="main">)</span> $ <span class="entity">y</span> <span class="main">=&gt;</span>
        <span class="main">(</span>find_index <span class="main">(</span>equal <span class="entity">x</span><span class="main">)</span> <span class="entity">args</span><span class="main">,</span> NONE<span class="main">)</span> :: <span class="entity">aux</span> <span class="entity">y</span>
    <span class="main">|</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> bot<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span>
    <span class="main">|</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Nil<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span>
    <span class="main">|</span> <span class="main">(</span><span class="entity">f</span> <span class="keyword1"><span class="keyword">as</span></span> Const <span class="main">_</span><span class="main">)</span> $ <span class="main">(</span><span class="entity">x</span> <span class="keyword1"><span class="keyword">as</span></span> Var <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="main">(</span>find_index <span class="main">(</span>equal <span class="entity">x</span><span class="main">)</span> <span class="entity">args</span><span class="main">,</span> SOME <span class="entity">f</span><span class="main">)</span><span class="main">]</span>
    <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> error <span class="main">(</span><span class="inner_quoted">"Unsupported binding function: "</span> ^ <span class="main">(</span>Syntax.string_of_term <span class="entity">ctxt</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">in</span></span>
  <span class="entity">aux</span> <span class="entity">t</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(** definition of the raw binding functions **)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prep_bn_info</span> <span class="entity">ctxt</span> <span class="entity">dt_names</span> <span class="entity">dts</span> <span class="entity">bn_funs</span> <span class="entity">eqs</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_eq</span> <span class="entity">eq</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">eq</span>
      |&gt; <span class="entity">HOLogic.dest_Trueprop</span>
      |&gt; <span class="entity">HOLogic.dest_eq</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">bn_fun</span><span class="main">,</span> <span class="main">[</span><span class="entity">cnstr</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> strip_comb <span class="entity">lhs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">ty</span><span class="main">)</span> <span class="main">=</span> dest_Const <span class="entity">bn_fun</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ty_name</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> dest_Type <span class="main">(</span>domain_type <span class="entity">ty</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dt_index</span> <span class="main">=</span> find_index <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="entity">x</span> <span class="main">=</span> <span class="entity">ty_name</span><span class="main">)</span> <span class="entity">dt_names</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">cnstr_head</span><span class="main">,</span> <span class="entity">cnstr_args</span><span class="main">)</span> <span class="main">=</span> strip_comb <span class="entity">cnstr</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cnstr_name</span> <span class="main">=</span> Long_Name.base_name <span class="main">(</span>fst <span class="main">(</span>dest_Const <span class="entity">cnstr_head</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs_elements</span> <span class="main">=</span> <span class="entity">strip_bn_fun</span> <span class="entity">ctxt</span> <span class="entity">cnstr_args</span> <span class="entity">rhs</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="main">(</span><span class="entity">bn_fun</span><span class="main">,</span> <span class="entity">dt_index</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">cnstr_name</span><span class="main">,</span> <span class="entity">rhs_elements</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

  <span class="comment1">(* order according to constructor names *)</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">cntrs_order</span> <span class="main">(</span><span class="main">(</span><span class="entity">bn</span><span class="main">,</span> <span class="entity">dt_index</span><span class="main">)</span><span class="main">,</span> <span class="entity">data</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dt</span> <span class="main">=</span> nth <span class="entity">dts</span> <span class="entity">dt_index</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cts</span> <span class="main">=</span> snd <span class="entity">dt</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ct_names</span> <span class="main">=</span> map <span class="main">(</span>Binding.name_of o <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">x</span><span class="main">)</span><span class="main">)</span> <span class="entity">cts</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="entity">bn</span><span class="main">,</span> <span class="main">(</span><span class="entity">bn</span><span class="main">,</span> <span class="entity">dt_index</span><span class="main">,</span> <span class="entity">order</span> <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span><span class="main">)</span> <span class="entity">ct_names</span> <span class="entity">data</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword2"><span class="keyword">in</span></span>
  <span class="entity">eqs</span>
  |&gt; map <span class="entity">process_eq</span>
  |&gt; AList.group <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span><span class="main">)</span>      <span class="comment1">(* eqs grouped according to bn_functions *)</span>
  |&gt; map <span class="entity">cntrs_order</span>        <span class="comment1">(* inner data ordered according to constructors *)</span>
  |&gt; <span class="entity">order</span> <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span><span class="main">)</span> <span class="entity">bn_funs</span>    <span class="comment1">(* ordered according to bn_functions *)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">define_raw_bns</span> <span class="entity">raw_dt_info</span> <span class="entity">raw_bn_funs</span> <span class="entity">raw_bn_eqs</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">raw_bn_funs</span>
  <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">else</span></span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">RawDtInfo</span>
        <span class="main">{</span><span class="entity">raw_dt_names</span><span class="main">,</span> <span class="entity">raw_dts</span><span class="main">,</span> <span class="entity">raw_inject_thms</span><span class="main">,</span> <span class="entity">raw_distinct_thms</span><span class="main">,</span> <span class="entity">raw_size_thms</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">raw_dt_info</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lthy1</span> <span class="main">=</span>
        <span class="entity">lthy</span>
        |&gt; Local_Theory.begin_nested
        |&gt; snd
        |&gt; <span class="entity">Function.add_function</span> <span class="entity">raw_bn_funs</span> <span class="entity">raw_bn_eqs</span>
            <span class="entity">Function_Common.default_config</span> <span class="main">(</span><span class="entity">pat_completeness_simp</span> <span class="main">(</span><span class="entity">raw_inject_thms</span> @ <span class="entity">raw_distinct_thms</span><span class="main">)</span><span class="main">)</span>
        |&gt; snd
        |&gt; Local_Theory.end_nested<span class="main">;</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">{</span><span class="entity">fs</span><span class="main">,</span> <span class="entity">simps</span><span class="main">,</span> <span class="entity">inducts</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">,</span> <span class="entity">lthy2</span><span class="main">)</span> <span class="main">=</span>
        <span class="entity">prove_termination_fun</span> <span class="entity">raw_size_thms</span>    <span class="entity">lthy1</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_bn_induct</span> <span class="main">=</span> the <span class="entity">inducts</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_bn_eqs</span> <span class="main">=</span> the <span class="entity">simps</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_bn_info</span> <span class="main">=</span>
        <span class="entity">prep_bn_info</span> <span class="entity">lthy</span> <span class="entity">raw_dt_names</span> <span class="entity">raw_dts</span> <span class="entity">fs</span> <span class="main">(</span>map Thm.prop_of <span class="entity">raw_bn_eqs</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">(</span><span class="entity">fs</span><span class="main">,</span> <span class="entity">raw_bn_eqs</span><span class="main">,</span> <span class="entity">raw_bn_info</span><span class="main">,</span> <span class="entity">raw_bn_induct</span><span class="main">,</span> <span class="entity">lthy2</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>



<span class="comment1">(** functions that construct the equations for fv and fv_bn **)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_fv_rhs</span> <span class="entity">lthy</span> <span class="entity">fv_map</span> <span class="entity">fv_bn_map</span> <span class="entity">args</span> <span class="main">(</span><span class="entity">BC</span> <span class="main">(</span><span class="entity">bmode</span><span class="main">,</span> <span class="entity">binders</span><span class="main">,</span> <span class="entity">bodies</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_fv_body</span> <span class="entity">i</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg</span> <span class="main">=</span> nth <span class="entity">args</span> <span class="entity">i</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty</span> <span class="main">=</span> fastype_of <span class="entity">arg</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="keyword2"><span class="keyword">case</span></span> AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span><span class="main">)</span> <span class="entity">fv_map</span> <span class="entity">ty</span> <span class="keyword2"><span class="keyword">of</span></span>
          NONE <span class="main">=&gt;</span> <span class="entity">mk_supp</span> <span class="entity">arg</span>
        <span class="main">|</span> SOME <span class="entity">fv</span> <span class="main">=&gt;</span> <span class="entity">fv</span> $ <span class="entity">arg</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">bind_set</span> <span class="main">(</span>NONE<span class="main">,</span> <span class="entity">i</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">setify</span> <span class="entity">lthy</span> <span class="main">(</span>nth <span class="entity">args</span> <span class="entity">i</span><span class="main">)</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="main">{}</span><span class="main">::</span>atom set"</span><span class="antiquote">}</span></span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">bind_set</span> <span class="main">(</span>SOME <span class="entity">bn</span><span class="main">,</span> <span class="entity">i</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">bn</span> $ <span class="main">(</span>nth <span class="entity">args</span> <span class="entity">i</span><span class="main">)</span><span class="main">,</span>
          <span class="keyword2"><span class="keyword">if</span></span>  member <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span><span class="main">)</span> <span class="entity">bodies</span> <span class="entity">i</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="main">{}</span><span class="main">::</span>atom set"</span><span class="antiquote">}</span></span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">lookup</span> <span class="entity">fv_bn_map</span> <span class="entity">bn</span> $ <span class="main">(</span>nth <span class="entity">args</span> <span class="entity">i</span><span class="main">)</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">bind_lst</span> <span class="main">(</span>NONE<span class="main">,</span> <span class="entity">i</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">listify</span> <span class="entity">lthy</span> <span class="main">(</span>nth <span class="entity">args</span> <span class="entity">i</span><span class="main">)</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="main">[]</span><span class="main">::</span>atom list"</span><span class="antiquote">}</span></span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">bind_lst</span> <span class="main">(</span>SOME <span class="entity">bn</span><span class="main">,</span> <span class="entity">i</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">bn</span> $ <span class="main">(</span>nth <span class="entity">args</span> <span class="entity">i</span><span class="main">)</span><span class="main">,</span>
          <span class="keyword2"><span class="keyword">if</span></span>  member <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span><span class="main">)</span> <span class="entity">bodies</span> <span class="entity">i</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="main">[]</span><span class="main">::</span>atom list"</span><span class="antiquote">}</span></span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">lookup</span> <span class="entity">fv_bn_map</span> <span class="entity">bn</span> $ <span class="main">(</span>nth <span class="entity">args</span> <span class="entity">i</span><span class="main">)</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">combine_fn</span><span class="main">,</span> <span class="entity">bind_fn</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">bmode</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">Lst</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">fold_append</span><span class="main">,</span> <span class="entity">bind_lst</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">Set</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">fold_union</span><span class="main">,</span> <span class="entity">bind_set</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">Res</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">fold_union</span><span class="main">,</span> <span class="entity">bind_set</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t1</span> <span class="main">=</span> map <span class="entity">mk_fv_body</span> <span class="entity">bodies</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">t2</span><span class="main">,</span> <span class="entity">t3</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">binders</span>
      |&gt; map <span class="entity">bind_fn</span>
      |&gt; split_list
      |&gt; apply2 <span class="entity">combine_fn</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">mk_union</span> <span class="main">(</span><span class="entity">mk_diff</span> <span class="main">(</span><span class="entity">fold_union</span> <span class="entity">t1</span><span class="main">,</span> <span class="entity">to_set</span> <span class="entity">t2</span><span class="main">)</span><span class="main">,</span> <span class="entity">to_set</span> <span class="entity">t3</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* in case of fv_bn we have to treat the case special, where an
   "empty" binding clause is given *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_fv_bn_rhs</span> <span class="entity">lthy</span> <span class="entity">fv_map</span> <span class="entity">fv_bn_map</span> <span class="entity">bn_args</span> <span class="entity">args</span> <span class="entity">bclause</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_fv_bn_body</span> <span class="entity">i</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg</span> <span class="main">=</span> nth <span class="entity">args</span> <span class="entity">i</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty</span> <span class="main">=</span> fastype_of <span class="entity">arg</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span><span class="main">)</span> <span class="entity">bn_args</span> <span class="entity">i</span> <span class="keyword2"><span class="keyword">of</span></span>
        NONE <span class="main">=&gt;</span> <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="main">(</span>AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span><span class="main">)</span> <span class="entity">fv_map</span> <span class="entity">ty</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
                   NONE <span class="main">=&gt;</span> <span class="entity">mk_supp</span> <span class="entity">arg</span>
                 <span class="main">|</span> SOME <span class="entity">fv</span> <span class="main">=&gt;</span> <span class="entity">fv</span> $ <span class="entity">arg</span><span class="main">)</span>
      <span class="main">|</span> SOME <span class="main">(</span>NONE<span class="main">)</span> <span class="main">=&gt;</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="main">{}</span><span class="main">::</span>atom set"</span><span class="antiquote">}</span></span>
      <span class="main">|</span> SOME <span class="main">(</span>SOME <span class="entity">bn</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">lookup</span> <span class="entity">fv_bn_map</span> <span class="entity">bn</span> $ <span class="entity">arg</span>
    <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">bclause</span> <span class="keyword2"><span class="keyword">of</span></span>
      <span class="entity">BC</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">bodies</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">fold_union</span> <span class="main">(</span>map <span class="entity">mk_fv_bn_body</span> <span class="entity">bodies</span><span class="main">)</span>
    <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">mk_fv_rhs</span> <span class="entity">lthy</span> <span class="entity">fv_map</span> <span class="entity">fv_bn_map</span> <span class="entity">args</span> <span class="entity">bclause</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_fv_eq</span> <span class="entity">lthy</span> <span class="entity">fv_map</span> <span class="entity">fv_bn_map</span> <span class="main">(</span><span class="entity">constr</span><span class="main">,</span> <span class="entity">ty</span><span class="main">,</span> <span class="entity">arg_tys</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="entity">bclauses</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg_names</span> <span class="main">=</span> <span class="entity">Old_Datatype_Prop.make_tnames</span> <span class="entity">arg_tys</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> map Free <span class="main">(</span><span class="entity">arg_names</span> ~~ <span class="entity">arg_tys</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fv</span> <span class="main">=</span> <span class="entity">lookup</span> <span class="entity">fv_map</span> <span class="entity">ty</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs</span> <span class="main">=</span> <span class="entity">fv</span> $ list_comb <span class="main">(</span><span class="entity">constr</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs_trms</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">mk_fv_rhs</span> <span class="entity">lthy</span> <span class="entity">fv_map</span> <span class="entity">fv_bn_map</span> <span class="entity">args</span><span class="main">)</span> <span class="entity">bclauses</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> <span class="entity">fold_union</span> <span class="entity">rhs_trms</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_fv_bn_eq</span> <span class="entity">lthy</span> <span class="entity">bn_trm</span> <span class="entity">fv_map</span> <span class="entity">fv_bn_map</span> <span class="main">(</span><span class="entity">bn_args</span><span class="main">,</span> <span class="main">(</span><span class="entity">constr</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">arg_tys</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="entity">bclauses</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg_names</span> <span class="main">=</span> <span class="entity">Old_Datatype_Prop.make_tnames</span> <span class="entity">arg_tys</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> map Free <span class="main">(</span><span class="entity">arg_names</span> ~~ <span class="entity">arg_tys</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fv_bn</span> <span class="main">=</span> <span class="entity">lookup</span> <span class="entity">fv_bn_map</span> <span class="entity">bn_trm</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs</span> <span class="main">=</span> <span class="entity">fv_bn</span> $ list_comb <span class="main">(</span><span class="entity">constr</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs_trms</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">mk_fv_bn_rhs</span> <span class="entity">lthy</span> <span class="entity">fv_map</span> <span class="entity">fv_bn_map</span> <span class="entity">bn_args</span> <span class="entity">args</span><span class="main">)</span> <span class="entity">bclauses</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> <span class="entity">fold_union</span> <span class="entity">rhs_trms</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_fv_bn_eqs</span> <span class="entity">lthy</span> <span class="entity">fv_map</span> <span class="entity">fv_bn_map</span> <span class="entity">constrs_info</span> <span class="entity">bclausesss</span> <span class="main">(</span><span class="entity">bn_trm</span><span class="main">,</span> <span class="entity">bn_n</span><span class="main">,</span> <span class="entity">bn_argss</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nth_constrs_info</span> <span class="main">=</span> nth <span class="entity">constrs_info</span> <span class="entity">bn_n</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nth_bclausess</span> <span class="main">=</span> nth <span class="entity">bclausesss</span> <span class="entity">bn_n</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    map2 <span class="main">(</span><span class="entity">mk_fv_bn_eq</span> <span class="entity">lthy</span> <span class="entity">bn_trm</span> <span class="entity">fv_map</span> <span class="entity">fv_bn_map</span><span class="main">)</span> <span class="main">(</span><span class="entity">bn_argss</span> ~~ <span class="entity">nth_constrs_info</span><span class="main">)</span> <span class="entity">nth_bclausess</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">define_raw_fvs</span> <span class="entity">raw_dt_info</span> <span class="entity">bn_info</span> <span class="entity">bclausesss</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">RawDtInfo</span>
      <span class="main">{</span><span class="entity">raw_dt_names</span><span class="main">,</span> <span class="entity">raw_tys</span><span class="main">,</span> <span class="entity">raw_cns_info</span><span class="main">,</span> <span class="entity">raw_inject_thms</span><span class="main">,</span> <span class="entity">raw_distinct_thms</span><span class="main">,</span> <span class="entity">raw_size_thms</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span>
        <span class="entity">raw_dt_info</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fv_names</span> <span class="main">=</span> map <span class="main">(</span>prefix <span class="inner_quoted">"fv_"</span> o Long_Name.base_name<span class="main">)</span> <span class="entity">raw_dt_names</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fv_tys</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ty</span> <span class="main">=&gt;</span> <span class="entity">ty</span> --&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"atom set"</span><span class="antiquote">}</span></span><span class="main">)</span> <span class="entity">raw_tys</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fv_frees</span> <span class="main">=</span> map Free <span class="main">(</span><span class="entity">fv_names</span> ~~ <span class="entity">fv_tys</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fv_map</span> <span class="main">=</span> <span class="entity">raw_tys</span> ~~ <span class="entity">fv_frees</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">bns</span><span class="main">,</span> <span class="entity">bn_tys</span><span class="main">)</span> <span class="main">=</span> split_list <span class="main">(</span>map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">bn</span><span class="main">,</span> <span class="entity">i</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">bn</span><span class="main">,</span> <span class="entity">i</span><span class="main">)</span><span class="main">)</span> <span class="entity">bn_info</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">bn_names</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">bn</span> <span class="main">=&gt;</span> Long_Name.base_name <span class="main">(</span>fst <span class="main">(</span>dest_Const <span class="entity">bn</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">bns</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fv_bn_names</span> <span class="main">=</span> map <span class="main">(</span>prefix <span class="inner_quoted">"fv_"</span><span class="main">)</span> <span class="entity">bn_names</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fv_bn_arg_tys</span> <span class="main">=</span> map <span class="main">(</span>nth <span class="entity">raw_tys</span><span class="main">)</span> <span class="entity">bn_tys</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fv_bn_tys</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ty</span> <span class="main">=&gt;</span> <span class="entity">ty</span> --&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"atom set"</span><span class="antiquote">}</span></span><span class="main">)</span> <span class="entity">fv_bn_arg_tys</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fv_bn_frees</span> <span class="main">=</span> map Free <span class="main">(</span><span class="entity">fv_bn_names</span> ~~ <span class="entity">fv_bn_tys</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fv_bn_map</span> <span class="main">=</span> <span class="entity">bns</span> ~~ <span class="entity">fv_bn_frees</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fv_eqs</span> <span class="main">=</span> map2 <span class="main">(</span>map2 <span class="main">(</span><span class="entity">mk_fv_eq</span> <span class="entity">lthy</span> <span class="entity">fv_map</span> <span class="entity">fv_bn_map</span><span class="main">)</span><span class="main">)</span> <span class="entity">raw_cns_info</span> <span class="entity">bclausesss</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fv_bn_eqs</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">mk_fv_bn_eqs</span> <span class="entity">lthy</span> <span class="entity">fv_map</span> <span class="entity">fv_bn_map</span> <span class="entity">raw_cns_info</span> <span class="entity">bclausesss</span><span class="main">)</span> <span class="entity">bn_info</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_fun_names</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">s</span> <span class="main">=&gt;</span> <span class="main">(</span>Binding.name <span class="entity">s</span><span class="main">,</span> NONE<span class="main">,</span> NoSyn<span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">fv_names</span> @ <span class="entity">fv_bn_names</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_fun_eqs</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">(</span>Binding.empty_atts<span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>flat <span class="entity">fv_eqs</span> @ flat <span class="entity">fv_bn_eqs</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lthy'</span> <span class="main">=</span>
      <span class="entity">lthy</span>
      |&gt; Local_Theory.begin_nested
      |&gt; snd
      |&gt; <span class="entity">Function.add_function</span> <span class="entity">all_fun_names</span> <span class="entity">all_fun_eqs</span>
          <span class="entity">Function_Common.default_config</span> <span class="main">(</span><span class="entity">pat_completeness_simp</span> <span class="main">(</span><span class="entity">raw_inject_thms</span> @ <span class="entity">raw_distinct_thms</span><span class="main">)</span><span class="main">)</span>
      |&gt; snd
      |&gt; Local_Theory.end_nested<span class="main">;</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">{</span><span class="entity">fs</span><span class="main">,</span> <span class="entity">simps</span><span class="main">,</span> <span class="entity">inducts</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">,</span> <span class="entity">lthy''</span><span class="main">)</span> <span class="main">=</span> <span class="entity">prove_termination_fun</span> <span class="entity">raw_size_thms</span> <span class="entity">lthy'</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">morphism</span> <span class="main">=</span>
      Proof_Context.export_morphism <span class="entity">lthy''</span>
        <span class="main">(</span>Proof_Context.transfer <span class="main">(</span>Proof_Context.theory_of <span class="entity">lthy''</span><span class="main">)</span> <span class="entity">lthy</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simps_exp</span> <span class="main">=</span> map <span class="main">(</span>Morphism.thm <span class="entity">morphism</span><span class="main">)</span> <span class="main">(</span>the <span class="entity">simps</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inducts_exp</span> <span class="main">=</span> map <span class="main">(</span>Morphism.thm <span class="entity">morphism</span><span class="main">)</span> <span class="main">(</span>the <span class="entity">inducts</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">fvs'</span><span class="main">,</span> <span class="entity">fv_bns'</span><span class="main">)</span> <span class="main">=</span> chop <span class="main">(</span>length <span class="entity">fv_frees</span><span class="main">)</span> <span class="entity">fs</span>

    <span class="comment1">(* grafting the types so that they coincide with the input into the function package *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fvs''</span> <span class="main">=</span> map2 <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ty</span> <span class="main">=&gt;</span> Const <span class="main">(</span>fst <span class="main">(</span>dest_Const <span class="entity">t</span><span class="main">)</span><span class="main">,</span> <span class="entity">ty</span><span class="main">)</span> <span class="main">)</span> <span class="entity">fvs'</span> <span class="entity">fv_tys</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fv_bns''</span> <span class="main">=</span> map2 <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ty</span> <span class="main">=&gt;</span> Const <span class="main">(</span>fst <span class="main">(</span>dest_Const <span class="entity">t</span><span class="main">)</span><span class="main">,</span> <span class="entity">ty</span><span class="main">)</span> <span class="main">)</span> <span class="entity">fv_bns'</span> <span class="entity">fv_bn_tys</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="entity">fvs''</span><span class="main">,</span> <span class="entity">fv_bns''</span><span class="main">,</span> <span class="entity">simps_exp</span><span class="main">,</span> <span class="entity">inducts_exp</span><span class="main">,</span> <span class="entity">lthy''</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="comment1">(** definition of raw permute_bn functions **)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_perm_bn_eq_rhs</span> <span class="entity">p</span> <span class="entity">perm_bn_map</span> <span class="entity">bn_args</span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span> <span class="entity">arg</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">case</span></span> AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span><span class="main">)</span> <span class="entity">bn_args</span> <span class="entity">i</span> <span class="keyword2"><span class="keyword">of</span></span>
    NONE <span class="main">=&gt;</span> <span class="entity">arg</span>
  <span class="main">|</span> SOME <span class="main">(</span>NONE<span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">mk_perm</span> <span class="entity">p</span> <span class="entity">arg</span>
  <span class="main">|</span> SOME <span class="main">(</span>SOME <span class="entity">bn</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">lookup</span> <span class="entity">perm_bn_map</span> <span class="entity">bn</span><span class="main">)</span> $ <span class="entity">p</span> $ <span class="entity">arg</span>


<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_perm_bn_eq</span> <span class="entity">lthy</span> <span class="entity">bn_trm</span> <span class="entity">perm_bn_map</span> <span class="entity">bn_args</span> <span class="main">(</span><span class="entity">constr</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">arg_tys</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">p</span> <span class="main">=</span> Free <span class="main">(</span><span class="inner_quoted">"p"</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">perm</span><span class="antiquote">}</span></span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg_names</span> <span class="main">=</span> <span class="entity">Old_Datatype_Prop.make_tnames</span> <span class="entity">arg_tys</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> map Free <span class="main">(</span><span class="entity">arg_names</span> ~~ <span class="entity">arg_tys</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">perm_bn</span> <span class="main">=</span> <span class="entity">lookup</span> <span class="entity">perm_bn_map</span> <span class="entity">bn_trm</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs</span> <span class="main">=</span> <span class="entity">perm_bn</span> $ <span class="entity">p</span> $ list_comb <span class="main">(</span><span class="entity">constr</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> list_comb <span class="main">(</span><span class="entity">constr</span><span class="main">,</span> map_index <span class="main">(</span><span class="entity">mk_perm_bn_eq_rhs</span> <span class="entity">p</span> <span class="entity">perm_bn_map</span> <span class="entity">bn_args</span><span class="main">)</span> <span class="entity">args</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_perm_bn_eqs</span> <span class="entity">lthy</span> <span class="entity">perm_bn_map</span> <span class="entity">cns_info</span> <span class="main">(</span><span class="entity">bn_trm</span><span class="main">,</span> <span class="entity">bn_n</span><span class="main">,</span> <span class="entity">bn_argss</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nth_cns_info</span> <span class="main">=</span> nth <span class="entity">cns_info</span> <span class="entity">bn_n</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    map2 <span class="main">(</span><span class="entity">mk_perm_bn_eq</span> <span class="entity">lthy</span> <span class="entity">bn_trm</span> <span class="entity">perm_bn_map</span><span class="main">)</span> <span class="entity">bn_argss</span> <span class="entity">nth_cns_info</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">define_raw_bn_perms</span> <span class="entity">raw_dt_info</span> <span class="entity">bn_info</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">bn_info</span>
  <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">else</span></span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">RawDtInfo</span>
        <span class="main">{</span><span class="entity">raw_tys</span><span class="main">,</span> <span class="entity">raw_cns_info</span><span class="main">,</span> <span class="entity">raw_inject_thms</span><span class="main">,</span> <span class="entity">raw_distinct_thms</span><span class="main">,</span> <span class="entity">raw_size_thms</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">raw_dt_info</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">bns</span><span class="main">,</span> <span class="entity">bn_tys</span><span class="main">)</span> <span class="main">=</span> split_list <span class="main">(</span>map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">bn</span><span class="main">,</span> <span class="entity">i</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">bn</span><span class="main">,</span> <span class="entity">i</span><span class="main">)</span><span class="main">)</span> <span class="entity">bn_info</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">bn_names</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">bn</span> <span class="main">=&gt;</span> Long_Name.base_name <span class="main">(</span>fst <span class="main">(</span>dest_Const <span class="entity">bn</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">bns</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">perm_bn_names</span> <span class="main">=</span> map <span class="main">(</span>prefix <span class="inner_quoted">"permute_"</span><span class="main">)</span> <span class="entity">bn_names</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">perm_bn_arg_tys</span> <span class="main">=</span> map <span class="main">(</span>nth <span class="entity">raw_tys</span><span class="main">)</span> <span class="entity">bn_tys</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">perm_bn_tys</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ty</span> <span class="main">=&gt;</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"perm"</span><span class="antiquote">}</span></span> --&gt; <span class="entity">ty</span> --&gt; <span class="entity">ty</span><span class="main">)</span> <span class="entity">perm_bn_arg_tys</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">perm_bn_frees</span> <span class="main">=</span> map Free <span class="main">(</span><span class="entity">perm_bn_names</span> ~~ <span class="entity">perm_bn_tys</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">perm_bn_map</span> <span class="main">=</span> <span class="entity">bns</span> ~~ <span class="entity">perm_bn_frees</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">perm_bn_eqs</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">mk_perm_bn_eqs</span> <span class="entity">lthy</span> <span class="entity">perm_bn_map</span> <span class="entity">raw_cns_info</span><span class="main">)</span> <span class="entity">bn_info</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_fun_names</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">s</span> <span class="main">=&gt;</span> <span class="main">(</span>Binding.name <span class="entity">s</span><span class="main">,</span> NONE<span class="main">,</span> NoSyn<span class="main">)</span><span class="main">)</span> <span class="entity">perm_bn_names</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_fun_eqs</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">(</span>Binding.empty_atts<span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>flat <span class="entity">perm_bn_eqs</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prod_simps</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> prod.inject HOL.simp_thms<span class="antiquote">}</span></span></span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lthy'</span> <span class="main">=</span>
        <span class="entity">lthy</span>
        |&gt; Local_Theory.begin_nested
        |&gt; snd
        |&gt; <span class="entity">Function.add_function</span> <span class="entity">all_fun_names</span> <span class="entity">all_fun_eqs</span>
            <span class="entity">Function_Common.default_config</span> <span class="main">(</span><span class="entity">pat_completeness_simp</span> <span class="main">(</span><span class="entity">prod_simps</span> @ <span class="entity">raw_inject_thms</span> @ <span class="entity">raw_distinct_thms</span><span class="main">)</span><span class="main">)</span>
        |&gt; snd
        |&gt; Local_Theory.end_nested<span class="main">;</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">{</span><span class="entity">fs</span><span class="main">,</span> <span class="entity">simps</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">,</span> <span class="entity">lthy''</span><span class="main">)</span> <span class="main">=</span> <span class="entity">prove_termination_fun</span> <span class="entity">raw_size_thms</span> <span class="entity">lthy'</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">morphism</span> <span class="main">=</span>
        Proof_Context.export_morphism <span class="entity">lthy''</span>
          <span class="main">(</span>Proof_Context.transfer <span class="main">(</span>Proof_Context.theory_of <span class="entity">lthy''</span><span class="main">)</span> <span class="entity">lthy</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simps_exp</span> <span class="main">=</span> map <span class="main">(</span>Morphism.thm <span class="entity">morphism</span><span class="main">)</span> <span class="main">(</span>the <span class="entity">simps</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">(</span><span class="entity">fs</span><span class="main">,</span> <span class="entity">simps_exp</span><span class="main">,</span> <span class="entity">lthy''</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(*** raw permutation functions ***)</span>

<span class="comment1">(** proves the two pt-type class properties **)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_permute_zero</span> <span class="entity">induct</span> <span class="entity">bnfs</span> <span class="entity">perm_defs</span> <span class="entity">perm_fns</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">perm_types</span> <span class="main">=</span> map <span class="main">(</span>body_type o fastype_of<span class="main">)</span> <span class="entity">perm_fns</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">perm_indnames</span> <span class="main">=</span> <span class="entity">Old_Datatype_Prop.make_tnames</span> <span class="entity">perm_types</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">single_goal</span> <span class="main">(</span><span class="main">(</span><span class="entity">perm_fn</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> <span class="entity">x</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">perm_fn</span> $ <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="main">0</span><span class="main">::</span>perm"</span><span class="antiquote">}</span></span> $ Free <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> Free <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goals</span> <span class="main">=</span>
      <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span>foldr1 <span class="entity">HOLogic.mk_conj</span>
        <span class="main">(</span>map <span class="entity">single_goal</span> <span class="main">(</span><span class="entity">perm_fns</span> ~~ <span class="entity">perm_types</span> ~~ <span class="entity">perm_indnames</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">map_ids</span> <span class="main">=</span> map <span class="entity">BNF_Def.map_ident_of_bnf</span> <span class="entity">bnfs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rules</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> permute_zero<span class="antiquote">}</span></span></span> :: <span class="entity">perm_defs</span> @ <span class="entity">map_ids</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">congs</span> <span class="main">=</span> map <span class="entity">BNF_Def.map_cong0_of_bnf</span> <span class="entity">bnfs</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Goal.prove <span class="entity">ctxt</span> <span class="entity">perm_indnames</span> <span class="main">[</span><span class="main">]</span> <span class="entity">goals</span>
      <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt'</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
        <span class="main">(</span><span class="entity">Old_Datatype_Aux.ind_tac</span> <span class="entity">ctxt'</span> <span class="entity">induct</span> <span class="entity">perm_indnames</span> THEN_ALL_NEW
          <span class="entity">asm_simp_tac</span>
            <span class="main">(</span>fold <span class="entity">Simplifier.add_cong</span> <span class="entity">congs</span>
              <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt'</span> addsimps <span class="entity">rules</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="inner_numeral">1</span><span class="main">)</span>
    |&gt; <span class="entity">Old_Datatype_Aux.split_conj_thm</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_permute_plus</span> <span class="entity">induct</span> <span class="entity">bnfs</span> <span class="entity">perm_defs</span> <span class="entity">perm_fns</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">p</span> <span class="main">=</span> Free <span class="main">(</span><span class="inner_quoted">"p"</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">perm</span><span class="antiquote">}</span></span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">q</span> <span class="main">=</span> Free <span class="main">(</span><span class="inner_quoted">"q"</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">perm</span><span class="antiquote">}</span></span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">perm_types</span> <span class="main">=</span> map <span class="main">(</span>body_type o fastype_of<span class="main">)</span> <span class="entity">perm_fns</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">perm_indnames</span> <span class="main">=</span> <span class="entity">Old_Datatype_Prop.make_tnames</span> <span class="entity">perm_types</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">single_goal</span> <span class="main">(</span><span class="main">(</span><span class="entity">perm_fn</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> <span class="entity">x</span><span class="main">)</span> <span class="main">=</span> <span class="entity">HOLogic.mk_eq</span>
      <span class="main">(</span><span class="entity">perm_fn</span> $ <span class="main">(</span><span class="entity">mk_plus</span> <span class="entity">p</span> <span class="entity">q</span><span class="main">)</span> $ Free <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> <span class="entity">perm_fn</span> $ <span class="entity">p</span> $ <span class="main">(</span><span class="entity">perm_fn</span> $ <span class="entity">q</span> $ Free <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goals</span> <span class="main">=</span>
      <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span>foldr1 <span class="entity">HOLogic.mk_conj</span>
        <span class="main">(</span>map <span class="entity">single_goal</span> <span class="main">(</span><span class="entity">perm_fns</span> ~~ <span class="entity">perm_types</span> ~~ <span class="entity">perm_indnames</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">map_comps</span> <span class="main">=</span> map <span class="entity">BNF_Def.map_comp_of_bnf</span> <span class="entity">bnfs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rules</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> permute_plus o_def<span class="antiquote">}</span></span></span> @ <span class="entity">perm_defs</span> @ <span class="entity">map_comps</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">congs</span> <span class="main">=</span> map <span class="entity">BNF_Def.map_cong0_of_bnf</span> <span class="entity">bnfs</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Goal.prove <span class="entity">ctxt</span> <span class="main">(</span><span class="inner_quoted">"p"</span> :: <span class="inner_quoted">"q"</span> :: <span class="entity">perm_indnames</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span> <span class="entity">goals</span>
      <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt'</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
        <span class="main">(</span><span class="entity">Old_Datatype_Aux.ind_tac</span> <span class="entity">ctxt'</span> <span class="entity">induct</span> <span class="entity">perm_indnames</span> THEN_ALL_NEW
          <span class="entity">asm_simp_tac</span>
            <span class="main">(</span>fold <span class="entity">Simplifier.add_cong</span> <span class="entity">congs</span>
              <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt'</span> addsimps <span class="entity">rules</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="inner_numeral">1</span><span class="main">)</span>
    |&gt; <span class="entity">Old_Datatype_Aux.split_conj_thm</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="comment1">(* Return the map operator for the given type, along with its list of
argument types, if a map operator exists; otherwise return NONE *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_map_of_type</span> <span class="entity">lthy</span> <span class="main">(</span>Type <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">tys</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_map</span> <span class="entity">bnf</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">live</span> <span class="main">=</span> <span class="entity">BNF_Def.live_of_bnf</span> <span class="entity">bnf</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">BNF_Def.mk_map</span> <span class="entity">live</span> <span class="entity">tys</span> <span class="entity">tys</span> <span class="main">(</span><span class="entity">BNF_Def.map_of_bnf</span> <span class="entity">bnf</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">map_arg_tys</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">BNF_Util.strip_typeN</span> <span class="entity">live</span> <span class="main">(</span>fastype_of <span class="entity">t</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="entity">t</span><span class="main">,</span> map domain_type <span class="entity">map_arg_tys</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Option.map <span class="entity">mk_map</span> <span class="main">(</span><span class="entity">BNF_Def.bnf_of</span> <span class="entity">lthy</span> <span class="entity">c</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>
  <span class="main">|</span> <span class="entity">mk_map_of_type</span> <span class="main">_</span> <span class="main">_</span> <span class="main">=</span> NONE


<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_perm_eq</span> <span class="entity">lthy</span> <span class="entity">ty_perm_assoc</span> <span class="entity">cnstr</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="comment1">(* permute function with boolean flag indicating recursion *)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_perm</span> <span class="entity">p</span> <span class="entity">ty</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="main">(</span>AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span><span class="main">)</span> <span class="entity">ty_perm_assoc</span> <span class="entity">ty</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
        SOME <span class="entity">perm</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">perm</span> $ <span class="entity">p</span><span class="main">,</span> true<span class="main">)</span>
      <span class="main">|</span> NONE <span class="main">=&gt;</span>
        <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">mk_map_of_type</span> <span class="entity">lthy</span> <span class="entity">ty</span> <span class="keyword2"><span class="keyword">of</span></span>
          SOME <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">tys</span><span class="main">)</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ts</span><span class="main">,</span> <span class="entity">recs</span><span class="main">)</span> <span class="main">=</span> split_list <span class="main">(</span>map <span class="main">(</span><span class="entity">mk_perm</span> <span class="entity">p</span><span class="main">)</span> <span class="entity">tys</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> exists I <span class="entity">recs</span>
            <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span>list_comb <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">ts</span><span class="main">)</span><span class="main">,</span> true<span class="main">)</span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="entity">perm_const</span> <span class="entity">ty</span> $ <span class="entity">p</span><span class="main">,</span> false<span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>
        <span class="main">|</span> NONE <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">perm_const</span> <span class="entity">ty</span> $ <span class="entity">p</span><span class="main">,</span> false<span class="main">)</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">lookup_perm</span> <span class="entity">p</span> <span class="main">(</span><span class="entity">ty</span><span class="main">,</span> <span class="entity">arg</span><span class="main">)</span> <span class="main">=</span> fst <span class="main">(</span><span class="entity">mk_perm</span> <span class="entity">p</span> <span class="entity">ty</span><span class="main">)</span> $ <span class="entity">arg</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">p</span> <span class="main">=</span> Free <span class="main">(</span><span class="inner_quoted">"p"</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">perm</span><span class="antiquote">}</span></span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">arg_tys</span><span class="main">,</span> <span class="entity">ty</span><span class="main">)</span> <span class="main">=</span> strip_type <span class="main">(</span>fastype_of <span class="entity">cnstr</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg_names</span> <span class="main">=</span> Name.variant_list <span class="main">[</span><span class="inner_quoted">"p"</span><span class="main">]</span> <span class="main">(</span><span class="entity">Old_Datatype_Prop.make_tnames</span> <span class="entity">arg_tys</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> map Free <span class="main">(</span><span class="entity">arg_names</span> ~~ <span class="entity">arg_tys</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs</span> <span class="main">=</span> <span class="entity">lookup_perm</span> <span class="entity">p</span> <span class="main">(</span><span class="entity">ty</span><span class="main">,</span> list_comb <span class="main">(</span><span class="entity">cnstr</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> list_comb <span class="main">(</span><span class="entity">cnstr</span><span class="main">,</span> map <span class="main">(</span><span class="entity">lookup_perm</span> <span class="entity">p</span><span class="main">)</span> <span class="main">(</span><span class="entity">arg_tys</span> ~~ <span class="entity">args</span><span class="main">)</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq</span> <span class="main">=</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="main">(</span>Binding.empty_atts<span class="main">,</span> <span class="entity">eq</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">define_raw_perms</span> <span class="entity">raw_dt_info</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">RawDtInfo</span>
      <span class="main">{</span><span class="entity">raw_dt_names</span><span class="main">,</span> <span class="entity">raw_fp_sugars</span><span class="main">,</span> <span class="entity">raw_tys</span><span class="main">,</span> <span class="entity">raw_ty_args</span><span class="main">,</span> <span class="entity">raw_all_cns</span><span class="main">,</span> <span class="entity">raw_induct_thm</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">raw_dt_info</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">bnfs</span> <span class="main">=</span> <span class="main">(</span><span class="main">#</span>fp_nesting_bnfs o hd<span class="main">)</span> <span class="entity">raw_fp_sugars</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">perm_fn_names</span> <span class="main">=</span> <span class="entity">raw_dt_names</span>
      |&gt; map Long_Name.base_name
      |&gt; map <span class="main">(</span>prefix <span class="inner_quoted">"permute_"</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">perm_fn_types</span> <span class="main">=</span> map <span class="entity">perm_ty</span> <span class="entity">raw_tys</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">perm_fn_frees</span> <span class="main">=</span> map Free <span class="main">(</span><span class="entity">perm_fn_names</span> ~~ <span class="entity">perm_fn_types</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">perm_fn_binds</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">s</span> <span class="main">=&gt;</span> <span class="main">(</span>Binding.name <span class="entity">s</span><span class="main">,</span> NONE<span class="main">,</span> NoSyn<span class="main">)</span><span class="main">)</span> <span class="entity">perm_fn_names</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">perm_eqs</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">mk_perm_eq</span> <span class="entity">lthy</span> <span class="main">(</span><span class="entity">raw_tys</span> ~~ <span class="entity">perm_fn_frees</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>flat <span class="entity">raw_all_cns</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">simps</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">Class.intro_classes_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> THEN ALLGOALS <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="entity">simps</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">morphism</span> <span class="entity">phi</span> <span class="main">(</span><span class="entity">fvs</span><span class="main">,</span> <span class="entity">dfs</span><span class="main">,</span> <span class="entity">simps</span><span class="main">)</span> <span class="main">=</span>
      <span class="main">(</span>map <span class="main">(</span>Morphism.term <span class="entity">phi</span><span class="main">)</span> <span class="entity">fvs</span><span class="main">,</span>
       map <span class="main">(</span>Morphism.thm <span class="entity">phi</span><span class="main">)</span> <span class="entity">dfs</span><span class="main">,</span>
       map <span class="main">(</span>Morphism.thm <span class="entity">phi</span><span class="main">)</span> <span class="entity">simps</span><span class="main">)</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">perm_funs</span><span class="main">,</span> <span class="entity">perm_eq_thms</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">lthy</span>
      |&gt; Local_Theory.exit_global
      |&gt; <span class="entity">Class.instantiation</span> <span class="main">(</span><span class="entity">raw_dt_names</span><span class="main">,</span> <span class="entity">raw_ty_args</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">pt</span><span class="antiquote">}</span></span><span class="main">)</span>
      |&gt; <span class="entity">BNF_LFP_Compat.primrec</span> <span class="entity">perm_fn_binds</span> <span class="entity">perm_eqs</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">perm_zero_thms</span> <span class="main">=</span> <span class="entity">prove_permute_zero</span> <span class="entity">raw_induct_thm</span> <span class="entity">bnfs</span> <span class="entity">perm_eq_thms</span> <span class="entity">perm_funs</span> <span class="entity">lthy'</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">perm_plus_thms</span> <span class="main">=</span> <span class="entity">prove_permute_plus</span> <span class="entity">raw_induct_thm</span> <span class="entity">bnfs</span> <span class="entity">perm_eq_thms</span> <span class="entity">perm_funs</span> <span class="entity">lthy'</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">lthy'</span>
    |&gt; <span class="entity">Class.prove_instantiation_exit_result</span> <span class="entity">morphism</span> <span class="entity">tac</span>
         <span class="main">(</span><span class="entity">perm_funs</span><span class="main">,</span> <span class="entity">perm_eq_thms</span><span class="main">,</span> <span class="entity">perm_zero_thms</span> @ <span class="entity">perm_plus_thms</span><span class="main">)</span>
    ||&gt; <span class="entity">Named_Target.theory_init</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="comment1">(** equivarance proofs **)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eqvt_apply_sym</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> eqvt_apply<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span><span class="antiquote">}</span></span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">subproof_tac</span> <span class="entity">const_names</span> <span class="entity">simps</span> <span class="main">=</span>
  <span class="entity">SUBPROOF</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span><span class="entity">prems</span><span class="main">,</span> context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
    HEADGOAL
      <span class="main">(</span><span class="entity">simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span> addsimps <span class="entity">simps</span><span class="main">)</span>
       THEN' <span class="entity">eqvt_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">eqvt_relaxed_config</span> <span class="entity">addexcls</span> <span class="entity">const_names</span><span class="main">)</span>
       THEN' <span class="entity">simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span> addsimps <span class="main">(</span><span class="entity">prems</span> @ <span class="main">[</span><span class="entity">eqvt_apply_sym</span><span class="main">]</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_eqvt_tac</span> <span class="entity">insts</span> <span class="entity">ind_thms</span> <span class="entity">const_names</span> <span class="entity">simps</span> <span class="entity">ctxt</span> <span class="main">=</span>
  HEADGOAL
    <span class="main">(</span>Object_Logic.full_atomize_tac <span class="entity">ctxt</span>
     THEN' <span class="main">(</span>DETERM o <span class="main">(</span><span class="entity">Induct_Tacs.induct_tac</span> <span class="entity">ctxt</span> <span class="entity">insts</span> <span class="main">(</span>SOME <span class="entity">ind_thms</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
     THEN_ALL_NEW  <span class="entity">subproof_tac</span> <span class="entity">const_names</span> <span class="entity">simps</span> <span class="entity">ctxt</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_eqvt_goal</span> <span class="entity">pi</span> <span class="entity">const</span> <span class="entity">arg</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs</span> <span class="main">=</span> <span class="entity">mk_perm</span> <span class="entity">pi</span> <span class="main">(</span><span class="entity">const</span> $ <span class="entity">arg</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> <span class="entity">const</span> $ <span class="main">(</span><span class="entity">mk_perm</span> <span class="entity">pi</span> <span class="entity">arg</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">raw_prove_eqvt</span> <span class="entity">consts</span> <span class="entity">ind_thms</span> <span class="entity">simps</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">consts</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">else</span></span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">[</span><span class="entity">p</span><span class="main">]</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> Variable.variant_fixes <span class="main">[</span><span class="inner_quoted">"p"</span><span class="main">]</span> <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">p</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">p</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">perm</span><span class="antiquote">}</span></span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg_tys</span> <span class="main">=</span>
        <span class="entity">consts</span>
        |&gt; map fastype_of
        |&gt; map domain_type
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">arg_names</span><span class="main">,</span> <span class="entity">ctxt''</span><span class="main">)</span> <span class="main">=</span>
        Variable.variant_fixes <span class="main">(</span><span class="entity">Old_Datatype_Prop.make_tnames</span> <span class="entity">arg_tys</span><span class="main">)</span> <span class="entity">ctxt'</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> map Free <span class="main">(</span><span class="entity">arg_names</span> ~~ <span class="entity">arg_tys</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goals</span> <span class="main">=</span> map2 <span class="main">(</span><span class="entity">mk_eqvt_goal</span> <span class="entity">p</span><span class="main">)</span> <span class="entity">consts</span> <span class="entity">args</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">insts</span> <span class="main">=</span> map <span class="main">(</span>single o SOME<span class="main">)</span> <span class="entity">arg_names</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">const_names</span> <span class="main">=</span> map <span class="main">(</span>fst o dest_Const<span class="main">)</span> <span class="entity">consts</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      Goal.prove_common <span class="entity">ctxt''</span> NONE <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">goals</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span><span class="entity">context</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
        <span class="entity">prove_eqvt_tac</span> <span class="entity">insts</span> <span class="entity">ind_thms</span> <span class="entity">const_names</span> <span class="entity">simps</span> <span class="entity">context</span><span class="main">)</span>
      |&gt; Proof_Context.export <span class="entity">ctxt''</span> <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* structure *)</span>
</pre>
</div><div id="files/nominal_dt_alpha.ML">
<div class="head">
<h1>File ‹nominal_dt_alpha.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      nominal_dt_alpha.ML
    Author:     Cezary Kaliszyk
    Author:     Christian Urban

  Definitions and proofs for the alpha-relations.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">NOMINAL_DT_ALPHA</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> comb_binders<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">bmode</span> <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> <span class="main">(</span>term option * int<span class="main">)</span> list <span class="main">-&gt;</span> term

  <span class="keyword1"><span class="keyword">val</span></span> define_raw_alpha<span class="main">:</span> <span class="entity">raw_dt_info</span> <span class="main">-&gt;</span> <span class="entity">bn_info</span> list <span class="main">-&gt;</span> <span class="entity">bclause</span> list list list <span class="main">-&gt;</span> term list <span class="main">-&gt;</span>
    <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">alpha_result</span> * local_theory

  <span class="keyword1"><span class="keyword">val</span></span> induct_prove<span class="main">:</span> typ list <span class="main">-&gt;</span> <span class="main">(</span>typ * <span class="main">(</span>term <span class="main">-&gt;</span> term<span class="main">)</span><span class="main">)</span> list <span class="main">-&gt;</span> thm <span class="main">-&gt;</span>
    <span class="main">(</span><span class="entity">Proof.context</span> <span class="main">-&gt;</span> int <span class="main">-&gt;</span> tactic<span class="main">)</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm list

  <span class="keyword1"><span class="keyword">val</span></span> alpha_prove<span class="main">:</span> term list <span class="main">-&gt;</span> <span class="main">(</span>term * <span class="main">(</span><span class="main">(</span>term * term<span class="main">)</span> <span class="main">-&gt;</span> term<span class="main">)</span><span class="main">)</span> list <span class="main">-&gt;</span> thm <span class="main">-&gt;</span>
    <span class="main">(</span><span class="entity">Proof.context</span> <span class="main">-&gt;</span> int <span class="main">-&gt;</span> tactic<span class="main">)</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm list

  <span class="keyword1"><span class="keyword">val</span></span> raw_prove_alpha_distincts<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">alpha_result</span> <span class="main">-&gt;</span> <span class="entity">raw_dt_info</span> <span class="main">-&gt;</span> thm list
  <span class="keyword1"><span class="keyword">val</span></span> raw_prove_alpha_eq_iff<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">alpha_result</span> <span class="main">-&gt;</span> <span class="entity">raw_dt_info</span> <span class="main">-&gt;</span> thm list
  <span class="keyword1"><span class="keyword">val</span></span> raw_prove_refl<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">alpha_result</span> <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm list
  <span class="keyword1"><span class="keyword">val</span></span> raw_prove_sym<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">alpha_result</span> <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> thm list
  <span class="keyword1"><span class="keyword">val</span></span> raw_prove_trans<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">alpha_result</span> <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> thm list
  <span class="keyword1"><span class="keyword">val</span></span> raw_prove_equivp<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">alpha_result</span> <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span>
    thm list * thm list
  <span class="keyword1"><span class="keyword">val</span></span> raw_prove_bn_imp<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">alpha_result</span> <span class="main">-&gt;</span> thm list
  <span class="keyword1"><span class="keyword">val</span></span> raw_fv_bn_rsp_aux<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">alpha_result</span> <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> term list <span class="main">-&gt;</span>
    thm list <span class="main">-&gt;</span> thm list
  <span class="keyword1"><span class="keyword">val</span></span> raw_size_rsp_aux<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">alpha_result</span> <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> thm list
  <span class="keyword1"><span class="keyword">val</span></span> raw_constrs_rsp<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">alpha_result</span> <span class="main">-&gt;</span> term list list <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> thm list list
  <span class="keyword1"><span class="keyword">val</span></span> raw_alpha_bn_rsp<span class="main">:</span> <span class="entity">alpha_result</span> <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> thm list
  <span class="keyword1"><span class="keyword">val</span></span> raw_perm_bn_rsp<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">alpha_result</span> <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> thm list

  <span class="keyword1"><span class="keyword">val</span></span> mk_funs_rsp<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> mk_alpha_permute_rsp<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Nominal_Dt_Alpha</span><span class="main">:</span> <span class="entity">NOMINAL_DT_ALPHA</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword3"><span class="keyword">open</span></span> Nominal_Permeq
<span class="keyword3"><span class="keyword">open</span></span> Nominal_Dt_Data

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">lookup</span> <span class="entity">xs</span> <span class="entity">x</span> <span class="main">=</span> the <span class="main">(</span>AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span><span class="main">)</span> <span class="entity">xs</span> <span class="entity">x</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">group</span> <span class="entity">xs</span> <span class="main">=</span> AList.group <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span><span class="main">)</span> <span class="entity">xs</span>


<span class="comment1">(** definition of the inductive rules for alpha and alpha_bn **)</span>

<span class="comment1">(* construct the compound terms for prod_fv and prod_alpha *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_prod_fv</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty1</span> <span class="main">=</span> fastype_of <span class="entity">t1</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty2</span> <span class="main">=</span> fastype_of <span class="entity">t2</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">resT</span> <span class="main">=</span> <span class="entity">HOLogic.mk_prodT</span> <span class="main">(</span>domain_type <span class="entity">ty1</span><span class="main">,</span> domain_type <span class="entity">ty2</span><span class="main">)</span> --&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"atom set"</span><span class="antiquote">}</span></span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "prod_fv"<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">[</span><span class="entity">ty1</span><span class="main">,</span> <span class="entity">ty2</span><span class="main">]</span> ---&gt; <span class="entity">resT</span><span class="main">)</span> $ <span class="entity">t1</span> $ <span class="entity">t2</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_prod_alpha</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty1</span> <span class="main">=</span> fastype_of <span class="entity">t1</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty2</span> <span class="main">=</span> fastype_of <span class="entity">t2</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prodT</span> <span class="main">=</span> <span class="entity">HOLogic.mk_prodT</span> <span class="main">(</span>domain_type <span class="entity">ty1</span><span class="main">,</span> domain_type <span class="entity">ty2</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">resT</span> <span class="main">=</span> <span class="main">[</span><span class="entity">prodT</span><span class="main">,</span> <span class="entity">prodT</span><span class="main">]</span> ---&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"bool"</span><span class="antiquote">}</span></span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "prod_alpha"<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">[</span><span class="entity">ty1</span><span class="main">,</span> <span class="entity">ty2</span><span class="main">]</span> ---&gt; <span class="entity">resT</span><span class="main">)</span> $ <span class="entity">t1</span> $ <span class="entity">t2</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* generates the compound binder terms *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">comb_binders</span> <span class="entity">lthy</span> <span class="entity">bmode</span> <span class="entity">args</span> <span class="entity">binders</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">bind_set</span> <span class="entity">lthy</span> <span class="entity">args</span> <span class="main">(</span>NONE<span class="main">,</span> <span class="entity">i</span><span class="main">)</span> <span class="main">=</span> <span class="entity">setify</span> <span class="entity">lthy</span> <span class="main">(</span>nth <span class="entity">args</span> <span class="entity">i</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">bind_set</span> <span class="main">_</span> <span class="entity">args</span> <span class="main">(</span>SOME <span class="entity">bn</span><span class="main">,</span> <span class="entity">i</span><span class="main">)</span> <span class="main">=</span> <span class="entity">bn</span> $ <span class="main">(</span>nth <span class="entity">args</span> <span class="entity">i</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">bind_lst</span> <span class="entity">lthy</span> <span class="entity">args</span> <span class="main">(</span>NONE<span class="main">,</span> <span class="entity">i</span><span class="main">)</span> <span class="main">=</span> <span class="entity">listify</span> <span class="entity">lthy</span> <span class="main">(</span>nth <span class="entity">args</span> <span class="entity">i</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">bind_lst</span> <span class="main">_</span> <span class="entity">args</span> <span class="main">(</span>SOME <span class="entity">bn</span><span class="main">,</span> <span class="entity">i</span><span class="main">)</span> <span class="main">=</span> <span class="entity">bn</span> $ <span class="main">(</span>nth <span class="entity">args</span> <span class="entity">i</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">combine_fn</span><span class="main">,</span> <span class="entity">bind_fn</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">bmode</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">Lst</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">mk_append</span><span class="main">,</span> <span class="entity">bind_lst</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">Set</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">mk_union</span><span class="main">,</span>  <span class="entity">bind_set</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">Res</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">mk_union</span><span class="main">,</span>  <span class="entity">bind_set</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">binders</span>
    |&gt; map <span class="main">(</span><span class="entity">bind_fn</span> <span class="entity">lthy</span> <span class="entity">args</span><span class="main">)</span>
    |&gt; foldl1 <span class="entity">combine_fn</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* produces the term for an alpha with abstraction *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_alpha_term</span> <span class="entity">bmode</span> <span class="entity">fv</span> <span class="entity">alpha</span> <span class="entity">args</span> <span class="entity">args'</span> <span class="entity">binders</span> <span class="entity">binders'</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">alpha_name</span><span class="main">,</span> <span class="entity">binder_ty</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">bmode</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">Lst</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "alpha_lst"<span class="antiquote">}</span></span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"atom list"</span><span class="antiquote">}</span></span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">Set</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "alpha_set"<span class="antiquote">}</span></span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"atom set"</span><span class="antiquote">}</span></span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">Res</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "alpha_res"<span class="antiquote">}</span></span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"atom set"</span><span class="antiquote">}</span></span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty</span> <span class="main">=</span> fastype_of <span class="entity">args</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pair_ty</span> <span class="main">=</span> <span class="entity">HOLogic.mk_prodT</span> <span class="main">(</span><span class="entity">binder_ty</span><span class="main">,</span> <span class="entity">ty</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alpha_ty</span> <span class="main">=</span> <span class="main">[</span><span class="entity">ty</span><span class="main">,</span> <span class="entity">ty</span><span class="main">]</span> ---&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"bool"</span><span class="antiquote">}</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fv_ty</span> <span class="main">=</span> <span class="entity">ty</span> --&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"atom set"</span><span class="antiquote">}</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pair_lhs</span> <span class="main">=</span> <span class="entity">HOLogic.mk_prod</span> <span class="main">(</span><span class="entity">binders</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pair_rhs</span> <span class="main">=</span> <span class="entity">HOLogic.mk_prod</span> <span class="main">(</span><span class="entity">binders'</span><span class="main">,</span> <span class="entity">args'</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">HOLogic.exists_const</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">perm</span><span class="antiquote">}</span></span> $ Abs <span class="main">(</span><span class="inner_quoted">"p"</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">perm</span><span class="antiquote">}</span></span><span class="main">,</span>
      Const <span class="main">(</span><span class="entity">alpha_name</span><span class="main">,</span> <span class="main">[</span><span class="entity">pair_ty</span><span class="main">,</span> <span class="entity">alpha_ty</span><span class="main">,</span> <span class="entity">fv_ty</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"perm"</span><span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">pair_ty</span><span class="main">]</span> ---&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">bool</span><span class="antiquote">}</span></span><span class="main">)</span>
        $ <span class="entity">pair_lhs</span> $ <span class="entity">alpha</span> $ <span class="entity">fv</span> $ <span class="main">(</span>Bound <span class="inner_numeral">0</span><span class="main">)</span> $ <span class="entity">pair_rhs</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* for non-recursive binders we have to produce alpha_bn premises *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_alpha_bn_prem</span> <span class="entity">alpha_bn_map</span> <span class="entity">args</span> <span class="entity">args'</span> <span class="entity">bodies</span> <span class="entity">binder</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">binder</span> <span class="keyword2"><span class="keyword">of</span></span>
    <span class="main">(</span>NONE<span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span>
  <span class="main">|</span> <span class="main">(</span>SOME <span class="entity">bn</span><span class="main">,</span> <span class="entity">i</span><span class="main">)</span> <span class="main">=&gt;</span>
     <span class="keyword2"><span class="keyword">if</span></span> member <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span><span class="main">)</span> <span class="entity">bodies</span> <span class="entity">i</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
     <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="entity">lookup</span> <span class="entity">alpha_bn_map</span> <span class="entity">bn</span> $ nth <span class="entity">args</span> <span class="entity">i</span> $ nth <span class="entity">args'</span> <span class="entity">i</span><span class="main">]</span>

<span class="comment1">(* generate the premises for an alpha rule; mk_frees is used
   if no binders are present *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_alpha_prems</span> <span class="entity">lthy</span> <span class="entity">alpha_map</span> <span class="entity">alpha_bn_map</span> <span class="entity">is_rec</span> <span class="main">(</span><span class="entity">args</span><span class="main">,</span> <span class="entity">args'</span><span class="main">)</span> <span class="entity">bclause</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_frees</span> <span class="entity">i</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg</span> <span class="main">=</span> nth <span class="entity">args</span> <span class="entity">i</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg'</span> <span class="main">=</span> nth <span class="entity">args'</span> <span class="entity">i</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty</span> <span class="main">=</span> fastype_of <span class="entity">arg</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="keyword2"><span class="keyword">if</span></span> nth <span class="entity">is_rec</span> <span class="entity">i</span>
        <span class="keyword2"><span class="keyword">then</span></span> fst <span class="main">(</span><span class="entity">lookup</span> <span class="entity">alpha_map</span> <span class="entity">ty</span><span class="main">)</span> $ <span class="entity">arg</span> $ <span class="entity">arg'</span>
        <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">arg</span><span class="main">,</span> <span class="entity">arg'</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_alpha_fv</span> <span class="entity">i</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty</span> <span class="main">=</span> fastype_of <span class="main">(</span>nth <span class="entity">args</span> <span class="entity">i</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="keyword2"><span class="keyword">case</span></span> AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span><span class="main">)</span> <span class="entity">alpha_map</span> <span class="entity">ty</span> <span class="keyword2"><span class="keyword">of</span></span>
          NONE <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">HOLogic.eq_const</span> <span class="entity">ty</span><span class="main">,</span> <span class="entity">supp_const</span> <span class="entity">ty</span><span class="main">)</span>
        <span class="main">|</span> SOME <span class="main">(</span><span class="entity">alpha</span><span class="main">,</span> <span class="entity">fv</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">alpha</span><span class="main">,</span> <span class="entity">fv</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">bclause</span> <span class="keyword2"><span class="keyword">of</span></span>
      <span class="entity">BC</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">bodies</span><span class="main">)</span> <span class="main">=&gt;</span> map <span class="main">(</span><span class="entity">HOLogic.mk_Trueprop</span> o <span class="entity">mk_frees</span><span class="main">)</span> <span class="entity">bodies</span>
    <span class="main">|</span> <span class="entity">BC</span> <span class="main">(</span><span class="entity">bmode</span><span class="main">,</span> <span class="entity">binders</span><span class="main">,</span> <span class="entity">bodies</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">alphas</span><span class="main">,</span> <span class="entity">fvs</span><span class="main">)</span> <span class="main">=</span> split_list <span class="main">(</span>map <span class="entity">mk_alpha_fv</span> <span class="entity">bodies</span><span class="main">)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">comp_fv</span> <span class="main">=</span> foldl1 <span class="entity">mk_prod_fv</span> <span class="entity">fvs</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">comp_alpha</span> <span class="main">=</span> foldl1 <span class="entity">mk_prod_alpha</span> <span class="entity">alphas</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">comp_args</span> <span class="main">=</span> foldl1 <span class="entity">HOLogic.mk_prod</span> <span class="main">(</span>map <span class="main">(</span>nth <span class="entity">args</span><span class="main">)</span> <span class="entity">bodies</span><span class="main">)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">comp_args'</span> <span class="main">=</span> foldl1 <span class="entity">HOLogic.mk_prod</span> <span class="main">(</span>map <span class="main">(</span>nth <span class="entity">args'</span><span class="main">)</span> <span class="entity">bodies</span><span class="main">)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">comp_binders</span> <span class="main">=</span> <span class="entity">comb_binders</span> <span class="entity">lthy</span> <span class="entity">bmode</span> <span class="entity">args</span> <span class="entity">binders</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">comp_binders'</span> <span class="main">=</span> <span class="entity">comb_binders</span> <span class="entity">lthy</span> <span class="entity">bmode</span> <span class="entity">args'</span> <span class="entity">binders</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alpha_prem</span> <span class="main">=</span>
            <span class="entity">mk_alpha_term</span> <span class="entity">bmode</span> <span class="entity">comp_fv</span> <span class="entity">comp_alpha</span> <span class="entity">comp_args</span> <span class="entity">comp_args'</span> <span class="entity">comp_binders</span> <span class="entity">comp_binders'</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alpha_bn_prems</span> <span class="main">=</span> flat <span class="main">(</span>map <span class="main">(</span><span class="entity">mk_alpha_bn_prem</span> <span class="entity">alpha_bn_map</span> <span class="entity">args</span> <span class="entity">args'</span> <span class="entity">bodies</span><span class="main">)</span> <span class="entity">binders</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          map <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">alpha_prem</span>::<span class="entity">alpha_bn_prems</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* produces the introduction rule for an alpha rule *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_alpha_intros</span> <span class="entity">lthy</span> <span class="entity">alpha_map</span> <span class="entity">alpha_bn_map</span> <span class="main">(</span><span class="entity">constr</span><span class="main">,</span> <span class="entity">ty</span><span class="main">,</span> <span class="entity">arg_tys</span><span class="main">,</span> <span class="entity">is_rec</span><span class="main">)</span> <span class="entity">bclauses</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg_names</span> <span class="main">=</span> <span class="entity">Old_Datatype_Prop.make_tnames</span> <span class="entity">arg_tys</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg_names'</span> <span class="main">=</span> Name.variant_list <span class="entity">arg_names</span> <span class="entity">arg_names</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> map Free <span class="main">(</span><span class="entity">arg_names</span> ~~ <span class="entity">arg_tys</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args'</span> <span class="main">=</span> map Free <span class="main">(</span><span class="entity">arg_names'</span> ~~ <span class="entity">arg_tys</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alpha</span> <span class="main">=</span> fst <span class="main">(</span><span class="entity">lookup</span> <span class="entity">alpha_map</span> <span class="entity">ty</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">concl</span> <span class="main">=</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">alpha</span> $ list_comb <span class="main">(</span><span class="entity">constr</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span> $ list_comb <span class="main">(</span><span class="entity">constr</span><span class="main">,</span> <span class="entity">args'</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prems</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">mk_alpha_prems</span> <span class="entity">lthy</span> <span class="entity">alpha_map</span> <span class="entity">alpha_bn_map</span> <span class="entity">is_rec</span> <span class="main">(</span><span class="entity">args</span><span class="main">,</span> <span class="entity">args'</span><span class="main">)</span><span class="main">)</span> <span class="entity">bclauses</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Library.foldr Logic.mk_implies <span class="main">(</span>flat <span class="entity">prems</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* produces the premise of an alpha-bn rule; we only need to
   treat the case special where the binding clause is empty;

   - if the body is not included in the bn_info, then we either
     produce an equation or an alpha-premise

   - if the body is included in the bn_info, then we create
     either a recursive call to alpha-bn, or no premise  *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_alpha_bn</span> <span class="entity">lthy</span> <span class="entity">alpha_map</span> <span class="entity">alpha_bn_map</span> <span class="entity">bn_args</span> <span class="entity">is_rec</span> <span class="main">(</span><span class="entity">args</span><span class="main">,</span> <span class="entity">args'</span><span class="main">)</span> <span class="entity">bclause</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_alpha_bn_prem</span> <span class="entity">i</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg</span> <span class="main">=</span> nth <span class="entity">args</span> <span class="entity">i</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg'</span> <span class="main">=</span> nth <span class="entity">args'</span> <span class="entity">i</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty</span> <span class="main">=</span> fastype_of <span class="entity">arg</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="keyword2"><span class="keyword">case</span></span> AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span><span class="main">)</span> <span class="entity">bn_args</span> <span class="entity">i</span> <span class="keyword2"><span class="keyword">of</span></span>
          NONE <span class="main">=&gt;</span> <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="main">(</span>AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span><span class="main">)</span> <span class="entity">alpha_map</span> <span class="entity">ty</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
                     NONE <span class="main">=&gt;</span>  <span class="main">[</span><span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">arg</span><span class="main">,</span> <span class="entity">arg'</span><span class="main">)</span><span class="main">]</span>
                   <span class="main">|</span> SOME <span class="main">(</span><span class="entity">alpha</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="entity">alpha</span> $ <span class="entity">arg</span> $ <span class="entity">arg'</span><span class="main">]</span><span class="main">)</span>
        <span class="main">|</span> SOME <span class="main">(</span>NONE<span class="main">)</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span>
        <span class="main">|</span> SOME <span class="main">(</span>SOME <span class="entity">bn</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="entity">lookup</span> <span class="entity">alpha_bn_map</span> <span class="entity">bn</span> $ <span class="entity">arg</span> $ <span class="entity">arg'</span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">bclause</span> <span class="keyword2"><span class="keyword">of</span></span>
      <span class="entity">BC</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">bodies</span><span class="main">)</span> <span class="main">=&gt;</span>
        map <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span>flat <span class="main">(</span>map <span class="entity">mk_alpha_bn_prem</span> <span class="entity">bodies</span><span class="main">)</span><span class="main">)</span>
    <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">mk_alpha_prems</span> <span class="entity">lthy</span> <span class="entity">alpha_map</span> <span class="entity">alpha_bn_map</span> <span class="entity">is_rec</span> <span class="main">(</span><span class="entity">args</span><span class="main">,</span> <span class="entity">args'</span><span class="main">)</span> <span class="entity">bclause</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_alpha_bn_intro</span> <span class="entity">lthy</span> <span class="entity">bn_trm</span> <span class="entity">alpha_map</span> <span class="entity">alpha_bn_map</span> <span class="main">(</span><span class="entity">bn_args</span><span class="main">,</span> <span class="main">(</span><span class="entity">constr</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">arg_tys</span><span class="main">,</span> <span class="entity">is_rec</span><span class="main">)</span><span class="main">)</span> <span class="entity">bclauses</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg_names</span> <span class="main">=</span> <span class="entity">Old_Datatype_Prop.make_tnames</span> <span class="entity">arg_tys</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg_names'</span> <span class="main">=</span> Name.variant_list <span class="entity">arg_names</span> <span class="entity">arg_names</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> map Free <span class="main">(</span><span class="entity">arg_names</span> ~~ <span class="entity">arg_tys</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args'</span> <span class="main">=</span> map Free <span class="main">(</span><span class="entity">arg_names'</span> ~~ <span class="entity">arg_tys</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alpha_bn</span> <span class="main">=</span> <span class="entity">lookup</span> <span class="entity">alpha_bn_map</span> <span class="entity">bn_trm</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">concl</span> <span class="main">=</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">alpha_bn</span> $ list_comb <span class="main">(</span><span class="entity">constr</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span> $ list_comb <span class="main">(</span><span class="entity">constr</span><span class="main">,</span> <span class="entity">args'</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prems</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">mk_alpha_bn</span> <span class="entity">lthy</span> <span class="entity">alpha_map</span> <span class="entity">alpha_bn_map</span> <span class="entity">bn_args</span> <span class="entity">is_rec</span> <span class="main">(</span><span class="entity">args</span><span class="main">,</span> <span class="entity">args'</span><span class="main">)</span><span class="main">)</span> <span class="entity">bclauses</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Library.foldr Logic.mk_implies <span class="main">(</span>flat <span class="entity">prems</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_alpha_bn_intros</span> <span class="entity">lthy</span> <span class="entity">alpha_map</span> <span class="entity">alpha_bn_map</span> <span class="entity">constrs_info</span> <span class="entity">bclausesss</span> <span class="main">(</span><span class="entity">bn_trm</span><span class="main">,</span> <span class="entity">bn_n</span><span class="main">,</span> <span class="entity">bn_argss</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nth_constrs_info</span> <span class="main">=</span> nth <span class="entity">constrs_info</span> <span class="entity">bn_n</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nth_bclausess</span> <span class="main">=</span> nth <span class="entity">bclausesss</span> <span class="entity">bn_n</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    map2 <span class="main">(</span><span class="entity">mk_alpha_bn_intro</span> <span class="entity">lthy</span> <span class="entity">bn_trm</span> <span class="entity">alpha_map</span> <span class="entity">alpha_bn_map</span><span class="main">)</span> <span class="main">(</span><span class="entity">bn_argss</span> ~~ <span class="entity">nth_constrs_info</span><span class="main">)</span> <span class="entity">nth_bclausess</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">define_raw_alpha</span> <span class="entity">raw_dt_info</span> <span class="entity">bn_info</span> <span class="entity">bclausesss</span> <span class="entity">fvs</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">RawDtInfo</span> <span class="main">{</span><span class="entity">raw_dt_names</span><span class="main">,</span> <span class="entity">raw_tys</span><span class="main">,</span> <span class="entity">raw_cns_info</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">raw_dt_info</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alpha_names</span> <span class="main">=</span> map <span class="main">(</span>prefix <span class="inner_quoted">"alpha_"</span> o Long_Name.base_name<span class="main">)</span> <span class="entity">raw_dt_names</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alpha_tys</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ty</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="entity">ty</span><span class="main">,</span> <span class="entity">ty</span><span class="main">]</span> ---&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">bool</span><span class="antiquote">}</span></span><span class="main">)</span> <span class="entity">raw_tys</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alpha_frees</span> <span class="main">=</span> map Free <span class="main">(</span><span class="entity">alpha_names</span> ~~ <span class="entity">alpha_tys</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alpha_map</span> <span class="main">=</span> <span class="entity">raw_tys</span> ~~ <span class="main">(</span><span class="entity">alpha_frees</span> ~~ <span class="entity">fvs</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">bns</span><span class="main">,</span> <span class="entity">bn_tys</span><span class="main">)</span> <span class="main">=</span> split_list <span class="main">(</span>map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">bn</span><span class="main">,</span> <span class="entity">i</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">bn</span><span class="main">,</span> <span class="entity">i</span><span class="main">)</span><span class="main">)</span> <span class="entity">bn_info</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">bn_names</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">bn</span> <span class="main">=&gt;</span> Long_Name.base_name <span class="main">(</span>fst <span class="main">(</span>dest_Const <span class="entity">bn</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">bns</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alpha_bn_names</span> <span class="main">=</span> map <span class="main">(</span>prefix <span class="inner_quoted">"alpha_"</span><span class="main">)</span> <span class="entity">bn_names</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alpha_bn_arg_tys</span> <span class="main">=</span> map <span class="main">(</span>nth <span class="entity">raw_tys</span><span class="main">)</span> <span class="entity">bn_tys</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alpha_bn_tys</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ty</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="entity">ty</span><span class="main">,</span> <span class="entity">ty</span><span class="main">]</span> ---&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"bool"</span><span class="antiquote">}</span></span><span class="main">)</span> <span class="entity">alpha_bn_arg_tys</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alpha_bn_frees</span> <span class="main">=</span> map Free <span class="main">(</span><span class="entity">alpha_bn_names</span> ~~ <span class="entity">alpha_bn_tys</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alpha_bn_map</span> <span class="main">=</span> <span class="entity">bns</span> ~~ <span class="entity">alpha_bn_frees</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alpha_intros</span> <span class="main">=</span> map2 <span class="main">(</span>map2 <span class="main">(</span><span class="entity">mk_alpha_intros</span> <span class="entity">lthy</span> <span class="entity">alpha_map</span> <span class="entity">alpha_bn_map</span><span class="main">)</span><span class="main">)</span> <span class="entity">raw_cns_info</span> <span class="entity">bclausesss</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alpha_bn_intros</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">mk_alpha_bn_intros</span> <span class="entity">lthy</span> <span class="entity">alpha_map</span> <span class="entity">alpha_bn_map</span> <span class="entity">raw_cns_info</span> <span class="entity">bclausesss</span><span class="main">)</span> <span class="entity">bn_info</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_alpha_names</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">ty</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">(</span>Binding.name <span class="entity">a</span><span class="main">,</span> <span class="entity">ty</span><span class="main">)</span><span class="main">,</span> NoSyn<span class="main">)</span><span class="main">)</span>
      <span class="main">(</span><span class="entity">alpha_names</span> @ <span class="entity">alpha_bn_names</span> ~~ <span class="entity">alpha_tys</span> @ <span class="entity">alpha_bn_tys</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_alpha_intros</span> <span class="main">=</span> map <span class="main">(</span>pair Binding.empty_atts<span class="main">)</span> <span class="main">(</span>flat <span class="entity">alpha_intros</span> @ flat <span class="entity">alpha_bn_intros</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">alpha_info</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">lthy</span>
      |&gt; Local_Theory.begin_nested
      |&gt; snd
      |&gt; <span class="entity">Inductive.add_inductive</span>
         <span class="main">{</span>quiet_mode <span class="main">=</span> true<span class="main">,</span> verbose <span class="main">=</span> false<span class="main">,</span> alt_name <span class="main">=</span> Binding.empty<span class="main">,</span>
          coind <span class="main">=</span> false<span class="main">,</span> no_elim <span class="main">=</span> false<span class="main">,</span> no_ind <span class="main">=</span> false<span class="main">,</span> skip_mono <span class="main">=</span> false<span class="main">}</span>
           <span class="entity">all_alpha_names</span> <span class="main">[</span><span class="main">]</span> <span class="entity">all_alpha_intros</span> <span class="main">[</span><span class="main">]</span>
      |&gt; Local_Theory.end_nested_result <span class="entity">Inductive.transform_result</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">phi</span> <span class="main">=</span>
      Proof_Context.export_morphism <span class="entity">lthy'</span>
        <span class="main">(</span>Proof_Context.transfer <span class="main">(</span>Proof_Context.theory_of <span class="entity">lthy'</span><span class="main">)</span> <span class="entity">lthy</span><span class="main">)</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alpha_info_global</span> <span class="main">=</span> <span class="entity">Inductive.transform_result</span> <span class="entity">phi</span> <span class="entity">alpha_info</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_alpha_trms</span> <span class="main">=</span> <span class="main">#</span>preds <span class="entity">alpha_info_global</span> |&gt; map Type.legacy_freeze <span class="comment1">(*FIXME*)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alpha_raw_induct</span> <span class="main">=</span> <span class="main">#</span>raw_induct <span class="entity">alpha_info_global</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alpha_intros</span> <span class="main">=</span> <span class="main">#</span>intrs <span class="entity">alpha_info_global</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alpha_cases</span> <span class="main">=</span> <span class="main">#</span>elims <span class="entity">alpha_info_global</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">alpha_trms</span><span class="main">,</span> <span class="entity">alpha_bn_trms</span><span class="main">)</span> <span class="main">=</span> chop <span class="main">(</span>length <span class="entity">fvs</span><span class="main">)</span> <span class="entity">all_alpha_trms</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alpha_tys</span> <span class="main">=</span> map <span class="main">(</span>domain_type o fastype_of<span class="main">)</span> <span class="entity">alpha_trms</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alpha_bn_tys</span> <span class="main">=</span> map <span class="main">(</span>domain_type o fastype_of<span class="main">)</span> <span class="entity">alpha_bn_trms</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alpha_names</span> <span class="main">=</span> map <span class="main">(</span>fst o dest_Const<span class="main">)</span> <span class="entity">alpha_trms</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alpha_bn_names</span> <span class="main">=</span> map <span class="main">(</span>fst o dest_Const<span class="main">)</span> <span class="entity">alpha_bn_trms</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="entity">AlphaResult</span>
      <span class="main">{</span>alpha_names <span class="main">=</span> <span class="entity">alpha_names</span><span class="main">,</span>
       alpha_trms <span class="main">=</span> <span class="entity">alpha_trms</span><span class="main">,</span>
       alpha_tys <span class="main">=</span> <span class="entity">alpha_tys</span><span class="main">,</span>
       alpha_bn_names <span class="main">=</span> <span class="entity">alpha_bn_names</span><span class="main">,</span>
       alpha_bn_trms <span class="main">=</span> <span class="entity">alpha_bn_trms</span><span class="main">,</span>
       alpha_bn_tys <span class="main">=</span> <span class="entity">alpha_bn_tys</span><span class="main">,</span>
       alpha_intros <span class="main">=</span> <span class="entity">alpha_intros</span><span class="main">,</span>
       alpha_cases <span class="main">=</span> <span class="entity">alpha_cases</span><span class="main">,</span>
       alpha_raw_induct <span class="main">=</span> <span class="entity">alpha_raw_induct</span><span class="main">}</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="comment1">(** induction proofs **)</span>


<span class="comment1">(* proof by structural induction over data types *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">induct_prove</span> <span class="entity">tys</span> <span class="entity">props</span> <span class="entity">induct_thm</span> <span class="entity">cases_tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">arg_names</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span>
      Variable.variant_fixes <span class="main">(</span>replicate <span class="main">(</span>length <span class="entity">tys</span><span class="main">)</span> <span class="inner_quoted">"x"</span><span class="main">)</span> <span class="entity">ctxt</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> map2 <span class="main">(</span>curry Free<span class="main">)</span> <span class="entity">arg_names</span> <span class="entity">tys</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">true_trms</span> <span class="main">=</span> replicate <span class="main">(</span>length <span class="entity">tys</span><span class="main">)</span> <span class="main">(</span>K <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">True</span><span class="antiquote">}</span></span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">apply_all</span> <span class="entity">x</span> <span class="entity">fs</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">f</span> <span class="main">=&gt;</span> <span class="entity">f</span> <span class="entity">x</span><span class="main">)</span> <span class="entity">fs</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goals</span> <span class="main">=</span>
        <span class="entity">group</span> <span class="main">(</span><span class="entity">props</span> @ <span class="main">(</span><span class="entity">tys</span> ~~ <span class="entity">true_trms</span><span class="main">)</span><span class="main">)</span>
        |&gt; map snd
        |&gt; map2 <span class="entity">apply_all</span> <span class="entity">args</span>
        |&gt; map <span class="entity">fold_conj</span>
        |&gt; foldr1 <span class="entity">HOLogic.mk_conj</span>
        |&gt; <span class="entity">HOLogic.mk_Trueprop</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
      HEADGOAL
        <span class="main">(</span>DETERM o <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">induct_thm</span><span class="main">]</span><span class="main">)</span>
         THEN_ALL_NEW
           <span class="main">(</span>REPEAT_ALL_NEW <span class="main">(</span>FIRST' <span class="main">[</span>resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> TrueI conjI<span class="antiquote">}</span></span></span><span class="main">,</span> <span class="entity">cases_tac</span> <span class="entity">ctxt</span><span class="main">]</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Goal.prove <span class="entity">ctxt'</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">goals</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span><span class="entity">context</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span> <span class="entity">tac</span> <span class="entity">context</span><span class="main">)</span>
    |&gt; singleton <span class="main">(</span>Proof_Context.export <span class="entity">ctxt'</span> <span class="entity">ctxt</span><span class="main">)</span>
    |&gt; <span class="entity">Old_Datatype_Aux.split_conj_thm</span>
    |&gt; map <span class="entity">Old_Datatype_Aux.split_conj_thm</span>
    |&gt; flat
    |&gt; filter_out <span class="main">(</span><span class="entity">is_true</span> o Thm.concl_of<span class="main">)</span>
    |&gt; map zero_var_indexes
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* proof by rule induction over the alpha-definitions *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">alpha_prove</span> <span class="entity">alphas</span> <span class="entity">props</span> <span class="entity">alpha_induct_thm</span> <span class="entity">cases_tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg_tys</span> <span class="main">=</span> map <span class="main">(</span>domain_type o fastype_of<span class="main">)</span> <span class="entity">alphas</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">arg_names1</span><span class="main">,</span> <span class="entity">arg_names2</span><span class="main">)</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">ctxt</span>
      |&gt; Variable.variant_fixes <span class="main">(</span>replicate <span class="main">(</span>length <span class="entity">alphas</span><span class="main">)</span> <span class="inner_quoted">"x"</span><span class="main">)</span>
      ||&gt;&gt; Variable.variant_fixes <span class="main">(</span>replicate <span class="main">(</span>length <span class="entity">alphas</span><span class="main">)</span> <span class="inner_quoted">"y"</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args1</span> <span class="main">=</span> map2 <span class="main">(</span>curry Free<span class="main">)</span> <span class="entity">arg_names1</span> <span class="entity">arg_tys</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args2</span> <span class="main">=</span> map2 <span class="main">(</span>curry Free<span class="main">)</span> <span class="entity">arg_names2</span> <span class="entity">arg_tys</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">true_trms</span> <span class="main">=</span> replicate <span class="main">(</span>length <span class="entity">alphas</span><span class="main">)</span> <span class="main">(</span>K <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">True</span><span class="antiquote">}</span></span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">apply_all</span> <span class="entity">x</span> <span class="entity">fs</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">f</span> <span class="main">=&gt;</span> <span class="entity">f</span> <span class="entity">x</span><span class="main">)</span> <span class="entity">fs</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goals_rhs</span> <span class="main">=</span>
        <span class="entity">group</span> <span class="main">(</span><span class="entity">props</span> @ <span class="main">(</span><span class="entity">alphas</span> ~~ <span class="entity">true_trms</span><span class="main">)</span><span class="main">)</span>
        |&gt; map snd
        |&gt; map2 <span class="entity">apply_all</span> <span class="main">(</span><span class="entity">args1</span> ~~ <span class="entity">args2</span><span class="main">)</span>
        |&gt; map <span class="entity">fold_conj</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">apply_trm_pair</span> <span class="entity">t</span> <span class="main">(</span><span class="entity">ar1</span><span class="main">,</span> <span class="entity">ar2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">t</span> $ <span class="entity">ar1</span> $ <span class="entity">ar2</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goals_lhs</span> <span class="main">=</span> map2 <span class="entity">apply_trm_pair</span> <span class="entity">alphas</span> <span class="main">(</span><span class="entity">args1</span> ~~ <span class="entity">args2</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goals</span> <span class="main">=</span>
      <span class="main">(</span>map2 <span class="main">(</span>curry <span class="entity">HOLogic.mk_imp</span><span class="main">)</span> <span class="entity">goals_lhs</span> <span class="entity">goals_rhs</span><span class="main">)</span>
      |&gt; foldr1 <span class="entity">HOLogic.mk_conj</span>
      |&gt; <span class="entity">HOLogic.mk_Trueprop</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
      HEADGOAL
        <span class="main">(</span>DETERM o <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">alpha_induct_thm</span><span class="main">]</span><span class="main">)</span>
         THEN_ALL_NEW FIRST' <span class="main">[</span>resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> TrueI<span class="antiquote">}</span></span></span><span class="main">,</span> <span class="entity">cases_tac</span> <span class="entity">ctxt</span><span class="main">]</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Goal.prove <span class="entity">ctxt'</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">goals</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span><span class="entity">context</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span> <span class="entity">tac</span> <span class="entity">context</span><span class="main">)</span>
    |&gt; singleton <span class="main">(</span>Proof_Context.export <span class="entity">ctxt'</span> <span class="entity">ctxt</span><span class="main">)</span>
    |&gt; <span class="entity">Old_Datatype_Aux.split_conj_thm</span>
    |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">th</span> <span class="main">=&gt;</span> <span class="entity">th</span> RS <span class="entity">mp</span><span class="main">)</span>
    |&gt; map <span class="entity">Old_Datatype_Aux.split_conj_thm</span>
    |&gt; flat
    |&gt; filter_out <span class="main">(</span><span class="entity">is_true</span> o Thm.concl_of<span class="main">)</span>
    |&gt; map zero_var_indexes
  <span class="keyword2"><span class="keyword">end</span></span>



<span class="comment1">(** produces the distinctness theorems **)</span>


<span class="comment1">(* transforms the distinctness theorems of the constructors
   into "not-alphas" of the constructors *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_distinct_goal</span> <span class="entity">ty_trm_assoc</span> <span class="entity">neq</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "HOL.eq"<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">ty_eq</span><span class="main">)</span> $ <span class="entity">lhs</span> $ <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">HOLogic.dest_not</span> <span class="main">(</span><span class="entity">HOLogic.dest_Trueprop</span> <span class="entity">neq</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty_str</span> <span class="main">=</span> fst <span class="main">(</span>dest_Type <span class="main">(</span>domain_type <span class="entity">ty_eq</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Const <span class="main">(</span><span class="entity">lookup</span> <span class="entity">ty_trm_assoc</span> <span class="entity">ty_str</span><span class="main">,</span> <span class="entity">ty_eq</span><span class="main">)</span> $ <span class="entity">lhs</span> $ <span class="entity">rhs</span>
    |&gt; <span class="entity">HOLogic.mk_not</span>
    |&gt; <span class="entity">HOLogic.mk_Trueprop</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">distinct_tac</span> <span class="entity">ctxt</span> <span class="entity">cases_thms</span> <span class="entity">distinct_thms</span> <span class="main">=</span>
  resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">notI</span><span class="main">]</span> THEN' eresolve_tac <span class="entity">ctxt</span> <span class="entity">cases_thms</span>
  THEN_ALL_NEW <span class="entity">asm_full_simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_ss</span> <span class="entity">ctxt</span> addsimps <span class="entity">distinct_thms</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">raw_prove_alpha_distincts</span> <span class="entity">ctxt</span> <span class="entity">alpha_result</span> <span class="entity">raw_dt_info</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">AlphaResult</span> <span class="main">{</span><span class="entity">alpha_names</span><span class="main">,</span> <span class="entity">alpha_cases</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">alpha_result</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">RawDtInfo</span> <span class="main">{</span><span class="entity">raw_dt_names</span><span class="main">,</span> <span class="entity">raw_distinct_thms</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">raw_dt_info</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty_trm_assoc</span> <span class="main">=</span> <span class="entity">raw_dt_names</span> ~~ <span class="entity">alpha_names</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_alpha_distinct</span> <span class="entity">raw_distinct_trm</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goal</span> <span class="main">=</span> <span class="entity">mk_distinct_goal</span> <span class="entity">ty_trm_assoc</span> <span class="entity">raw_distinct_trm</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      Goal.prove <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">goal</span>
        <span class="main">(</span>K <span class="main">(</span><span class="entity">distinct_tac</span> <span class="entity">ctxt</span> <span class="entity">alpha_cases</span> <span class="entity">raw_distinct_thms</span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">in</span></span>
    map <span class="main">(</span><span class="entity">mk_alpha_distinct</span> o Thm.prop_of<span class="main">)</span> <span class="entity">raw_distinct_thms</span>
  <span class="keyword2"><span class="keyword">end</span></span>



<span class="comment1">(** produces the alpha_eq_iff simplification rules **)</span>

<span class="comment1">(* in case a theorem is of the form (Rel Const Const), it will be
   rewritten to ((Rel Const = Const) = True)
*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_simp_rule</span> <span class="entity">thm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">case</span></span> Thm.prop_of <span class="entity">thm</span> <span class="keyword2"><span class="keyword">of</span></span>
    <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"Trueprop"</span><span class="antiquote">}</span></span> $ <span class="main">(</span><span class="main">_</span> $ Const <span class="main">_</span> $ Const <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">thm</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> eqTrueI<span class="antiquote">}</span></span></span>
  <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">thm</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">alpha_eq_iff_tac</span> <span class="entity">ctxt</span> <span class="entity">dist_inj</span> <span class="entity">intros</span> <span class="entity">elims</span> <span class="main">=</span>
  SOLVED' <span class="main">(</span><span class="entity">asm_full_simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_ss</span> <span class="entity">ctxt</span> addsimps <span class="entity">intros</span><span class="main">)</span><span class="main">)</span> ORELSE'
  <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> iffI<span class="antiquote">}</span></span></span> THEN'
    RANGE <span class="main">[</span>eresolve_tac <span class="entity">ctxt</span> <span class="entity">elims</span> THEN_ALL_NEW <span class="entity">asm_full_simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_ss</span> <span class="entity">ctxt</span> addsimps <span class="entity">dist_inj</span><span class="main">)</span><span class="main">,</span>
           <span class="entity">asm_full_simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_ss</span> <span class="entity">ctxt</span> addsimps <span class="entity">intros</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_alpha_eq_iff_goal</span> <span class="entity">thm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prop</span> <span class="main">=</span> Thm.prop_of <span class="entity">thm</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">concl</span> <span class="main">=</span> <span class="entity">HOLogic.dest_Trueprop</span> <span class="main">(</span>Logic.strip_imp_concl <span class="entity">prop</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">hyps</span> <span class="main">=</span> map <span class="entity">HOLogic.dest_Trueprop</span> <span class="main">(</span>Logic.strip_imp_prems <span class="entity">prop</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">list_conj</span> <span class="entity">l</span> <span class="main">=</span> foldr1 <span class="entity">HOLogic.mk_conj</span> <span class="entity">l</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">hyps</span> <span class="main">=</span> <span class="main">[</span><span class="main">]</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="entity">concl</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">concl</span><span class="main">,</span> <span class="entity">list_conj</span> <span class="entity">hyps</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">raw_prove_alpha_eq_iff</span> <span class="entity">ctxt</span> <span class="entity">alpha_result</span> <span class="entity">raw_dt_info</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">AlphaResult</span> <span class="main">{</span><span class="entity">alpha_intros</span><span class="main">,</span> <span class="entity">alpha_cases</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">alpha_result</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">RawDtInfo</span> <span class="main">{</span><span class="entity">raw_distinct_thms</span><span class="main">,</span> <span class="entity">raw_inject_thms</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">raw_dt_info</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">thms_imp</span><span class="main">)</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> Variable.import false <span class="entity">alpha_intros</span> <span class="entity">ctxt</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goals</span> <span class="main">=</span> map <span class="entity">mk_alpha_eq_iff_goal</span> <span class="entity">thms_imp</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tac</span> <span class="main">=</span> <span class="entity">alpha_eq_iff_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">raw_distinct_thms</span> @ <span class="entity">raw_inject_thms</span><span class="main">)</span> <span class="entity">alpha_intros</span> <span class="entity">alpha_cases</span> <span class="inner_numeral">1</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thms</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">goal</span> <span class="main">=&gt;</span> Goal.prove <span class="entity">ctxt'</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">goal</span> <span class="main">(</span>K <span class="entity">tac</span><span class="main">)</span><span class="main">)</span> <span class="entity">goals</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Variable.export <span class="entity">ctxt'</span> <span class="entity">ctxt</span> <span class="entity">thms</span>
    |&gt; map <span class="entity">mk_simp_rule</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="comment1">(** reflexivity proof for the alphas **)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">exi_zero</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">lemma</span> <span class="quoted">"<span class="free">P</span> <span class="main">(</span><span class="main">0</span><span class="main">::</span>perm<span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span>"</span> <span class="keyword1"><span class="keyword">by</span></span> <span class="operator">auto</span><span class="antiquote">}</span></span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">cases_tac</span> <span class="entity">intros</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prod_simps</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> split_conv prod_alpha_def rel_prod_conv<span class="antiquote">}</span></span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">unbound_tac</span> <span class="main">=</span> REPEAT o <span class="main">(</span>eresolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> conjE<span class="antiquote">}</span></span></span><span class="main">)</span> THEN' assume_tac <span class="entity">ctxt</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">bound_tac</span> <span class="main">=</span>
      EVERY' <span class="main">[</span> resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">exi_zero</span><span class="main">]</span><span class="main">,</span>
               resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> alpha_refl<span class="antiquote">}</span></span></span><span class="main">,</span>
               <span class="entity">asm_full_simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_ss</span> <span class="entity">ctxt</span> addsimps <span class="entity">prod_simps</span><span class="main">)</span> <span class="main">]</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    resolve_tac <span class="entity">ctxt</span> <span class="entity">intros</span> THEN_ALL_NEW
      FIRST' <span class="main">[</span>resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> refl<span class="antiquote">}</span></span></span><span class="main">,</span> <span class="entity">unbound_tac</span><span class="main">,</span> <span class="entity">bound_tac</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">raw_prove_refl</span> <span class="entity">ctxt</span> <span class="entity">alpha_result</span> <span class="entity">raw_dt_induct</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">AlphaResult</span> <span class="main">{</span><span class="entity">alpha_trms</span><span class="main">,</span> <span class="entity">alpha_tys</span><span class="main">,</span> <span class="entity">alpha_bn_trms</span><span class="main">,</span> <span class="entity">alpha_bn_tys</span><span class="main">,</span> <span class="entity">alpha_intros</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span>
      <span class="entity">alpha_result</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">props</span> <span class="main">=</span>
      map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">ty</span><span class="main">,</span> <span class="entity">c</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">ty</span><span class="main">,</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="entity">c</span> $ <span class="entity">x</span> $ <span class="entity">x</span><span class="main">)</span><span class="main">)</span>
        <span class="main">(</span><span class="main">(</span><span class="entity">alpha_tys</span> ~~ <span class="entity">alpha_trms</span><span class="main">)</span> @ <span class="main">(</span><span class="entity">alpha_bn_tys</span> ~~ <span class="entity">alpha_bn_trms</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">induct_prove</span> <span class="entity">alpha_tys</span> <span class="entity">props</span> <span class="entity">raw_dt_induct</span> <span class="main">(</span><span class="entity">cases_tac</span> <span class="entity">alpha_intros</span><span class="main">)</span> <span class="entity">ctxt</span>
  <span class="keyword2"><span class="keyword">end</span></span>



<span class="comment1">(** symmetry proof for the alphas **)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">exi_neg</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">lemma</span> <span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="main">(</span><span class="bound">p</span><span class="main">::</span>perm<span class="main">)</span><span class="main">.</span> <span class="free">P</span> <span class="bound">p</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">⋀</span><span class="bound">q</span><span class="main">.</span> <span class="free">P</span> <span class="bound">q</span> <span class="main">⟹</span> <span class="free">Q</span> <span class="main">(</span><span class="main">-</span> <span class="bound">q</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">p</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">p</span>"</span>
  <span class="keyword1"><span class="keyword">by</span></span> <span class="main">(</span><span class="operator">erule</span> exE<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule_tac</span> x<span class="main">=</span><span class="quoted">"<span class="main">-</span><span class="improper">p</span>"</span> <span class="quasi_keyword">in</span> exI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span><span class="antiquote">}</span></span></span>

<span class="comment1">(* for premises that contain binders *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prem_bound_tac</span> <span class="entity">pred_names</span> <span class="entity">alpha_eqvt</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">trans_prem_tac</span> <span class="entity">pred_names</span> <span class="entity">ctxt</span> <span class="main">=</span>
      <span class="entity">SUBPROOF</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span><span class="entity">prems</span><span class="main">,</span> context <span class="main">=</span> <span class="entity">ctxt'</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prems'</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">transform_prem1</span> <span class="entity">ctxt'</span> <span class="entity">pred_names</span><span class="main">)</span> <span class="entity">prems</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          resolve_tac <span class="entity">ctxt'</span> <span class="entity">prems'</span> <span class="inner_numeral">1</span>
        <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span> <span class="entity">ctxt</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prod_simps</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> split_conv permute_prod.simps prod_alpha_def rel_prod_conv alphas<span class="antiquote">}</span></span></span>
  <span class="keyword2"><span class="keyword">in</span></span>
    EVERY'
      <span class="main">[</span> eresolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">exi_neg</span><span class="main">]</span><span class="main">,</span>
        resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> alpha_sym_eqvt<span class="antiquote">}</span></span></span><span class="main">,</span>
        <span class="entity">asm_full_simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_ss</span> <span class="entity">ctxt</span> addsimps <span class="entity">prod_simps</span><span class="main">)</span><span class="main">,</span>
        <span class="entity">eqvt_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">eqvt_relaxed_config</span> <span class="entity">addpres</span> <span class="entity">alpha_eqvt</span><span class="main">)</span> THEN'
        resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> refl<span class="antiquote">}</span></span></span><span class="main">,</span>
        <span class="entity">trans_prem_tac</span> <span class="entity">pred_names</span> <span class="entity">ctxt</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">raw_prove_sym</span> <span class="entity">ctxt</span> <span class="entity">alpha_result</span> <span class="entity">alpha_eqvt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">AlphaResult</span> <span class="main">{</span><span class="entity">alpha_names</span><span class="main">,</span> <span class="entity">alpha_trms</span><span class="main">,</span> <span class="entity">alpha_bn_names</span><span class="main">,</span> <span class="entity">alpha_bn_trms</span><span class="main">,</span>
      <span class="entity">alpha_intros</span><span class="main">,</span> <span class="entity">alpha_raw_induct</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">alpha_result</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alpha_trms</span> <span class="main">=</span> <span class="entity">alpha_trms</span> @ <span class="entity">alpha_bn_trms</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alpha_names</span> <span class="main">=</span> <span class="entity">alpha_names</span> @ <span class="entity">alpha_bn_names</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">props</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">t</span> $ <span class="entity">y</span> $ <span class="entity">x</span><span class="main">)</span> <span class="entity">alpha_trms</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
      resolve_tac <span class="entity">ctxt</span> <span class="entity">alpha_intros</span> THEN_ALL_NEW
      FIRST' <span class="main">[</span>assume_tac <span class="entity">ctxt</span><span class="main">,</span>
        resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> sym<span class="antiquote">}</span></span></span> THEN' assume_tac <span class="entity">ctxt</span><span class="main">,</span>
        <span class="entity">prem_bound_tac</span> <span class="entity">alpha_names</span> <span class="entity">alpha_eqvt</span> <span class="entity">ctxt</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">alpha_prove</span> <span class="entity">alpha_trms</span> <span class="main">(</span><span class="entity">alpha_trms</span> ~~ <span class="entity">props</span><span class="main">)</span> <span class="entity">alpha_raw_induct</span> <span class="entity">tac</span> <span class="entity">ctxt</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="comment1">(** transitivity proof for alphas **)</span>

<span class="comment1">(* applies cases rules and resolves them with the last premise *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ecases_tac</span> <span class="entity">cases</span> <span class="main">=</span>
  <span class="entity">Subgoal.FOCUS</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="entity">prems</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
    HEADGOAL <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="entity">cases</span> THEN' resolve_tac <span class="entity">ctxt</span> <span class="main">[</span>List.last <span class="entity">prems</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">aatac</span> <span class="entity">pred_names</span> <span class="main">=</span>
  <span class="entity">SUBPROOF</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="entity">prems</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
    HEADGOAL <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="main">(</span>map <span class="main">(</span><span class="entity">transform_prem1</span> <span class="entity">ctxt</span> <span class="entity">pred_names</span><span class="main">)</span> <span class="entity">prems</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="comment1">(* instantiates exI with the permutation p + q *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">perm_inst_tac</span> <span class="main">=</span>
  <span class="entity">Subgoal.FOCUS</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="entity">params</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">p</span><span class="main">,</span> <span class="entity">q</span><span class="main">)</span> <span class="main">=</span> apply2 snd <span class="main">(</span><span class="entity">last2</span> <span class="entity">params</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pq_inst</span> <span class="main">=</span> foldl1 <span class="main">(</span>uncurry Thm.apply<span class="main">)</span> <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">cterm</span> <span class="quoted">"plus<span class="main">::</span>perm <span class="main">=&gt;</span> perm <span class="main">=&gt;</span> perm"</span><span class="antiquote">}</span></span></span><span class="main">,</span> <span class="entity">p</span><span class="main">,</span> <span class="entity">q</span><span class="main">]</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">exi_inst</span> <span class="main">=</span> Thm.instantiate' <span class="main">[</span>SOME <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">ctyp</span> <span class="quoted">"perm"</span><span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">]</span> <span class="main">[</span>NONE<span class="main">,</span> SOME <span class="entity">pq_inst</span><span class="main">]</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> exI<span class="antiquote">}</span></span></span>
    <span class="keyword2"><span class="keyword">in</span></span>
      HEADGOAL <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">exi_inst</span><span class="main">]</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">non_trivial_cases_tac</span> <span class="entity">pred_names</span> <span class="entity">intros</span> <span class="entity">alpha_eqvt</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prod_simps</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> split_conv alphas permute_prod.simps prod_alpha_def rel_prod_conv<span class="antiquote">}</span></span></span>
  <span class="keyword2"><span class="keyword">in</span></span>
    resolve_tac <span class="entity">ctxt</span> <span class="entity">intros</span>
    THEN_ALL_NEW <span class="main">(</span><span class="entity">asm_simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span><span class="main">)</span> THEN'
      TRY o EVERY'   <span class="comment1">(* if binders are present *)</span>
        <span class="main">[</span> eresolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> exE<span class="antiquote">}</span></span></span><span class="main">,</span>
          eresolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> exE<span class="antiquote">}</span></span></span><span class="main">,</span>
          <span class="entity">perm_inst_tac</span> <span class="entity">ctxt</span><span class="main">,</span>
          resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> alpha_trans_eqvt<span class="antiquote">}</span></span></span><span class="main">,</span>
          assume_tac <span class="entity">ctxt</span><span class="main">,</span>
          <span class="entity">aatac</span> <span class="entity">pred_names</span> <span class="entity">ctxt</span><span class="main">,</span>
          <span class="entity">eqvt_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">eqvt_relaxed_config</span> <span class="entity">addpres</span> <span class="entity">alpha_eqvt</span><span class="main">)</span> THEN'
          resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> refl<span class="antiquote">}</span></span></span><span class="main">,</span>
          <span class="entity">asm_full_simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_ss</span> <span class="entity">ctxt</span> addsimps <span class="entity">prod_simps</span><span class="main">)</span> <span class="main">]</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_trans_tac</span> <span class="entity">alpha_result</span> <span class="entity">raw_dt_thms</span> <span class="entity">alpha_eqvt</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">AlphaResult</span> <span class="main">{</span><span class="entity">alpha_names</span><span class="main">,</span> <span class="entity">alpha_bn_names</span><span class="main">,</span> <span class="entity">alpha_intros</span><span class="main">,</span> <span class="entity">alpha_cases</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">alpha_result</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alpha_names</span> <span class="main">=</span> <span class="entity">alpha_names</span> @ <span class="entity">alpha_bn_names</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">all_cases</span> <span class="entity">ctxt</span> <span class="main">=</span>
      <span class="entity">asm_full_simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span> addsimps <span class="entity">raw_dt_thms</span><span class="main">)</span>
      THEN' TRY o <span class="entity">non_trivial_cases_tac</span> <span class="entity">alpha_names</span> <span class="entity">alpha_intros</span> <span class="entity">alpha_eqvt</span> <span class="entity">ctxt</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    EVERY' <span class="main">[</span> resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> allI<span class="antiquote">}</span></span></span><span class="main">,</span>
      resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> impI<span class="antiquote">}</span></span></span><span class="main">,</span>
      <span class="entity">ecases_tac</span> <span class="entity">alpha_cases</span> <span class="entity">ctxt</span> THEN_ALL_NEW <span class="entity">all_cases</span> <span class="entity">ctxt</span> <span class="main">]</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prep_trans_goal</span> <span class="entity">alpha_trm</span> <span class="main">(</span><span class="entity">arg1</span><span class="main">,</span> <span class="entity">arg2</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg_ty</span> <span class="main">=</span> fastype_of <span class="entity">arg1</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mid</span> <span class="main">=</span> <span class="entity">alpha_trm</span> $ <span class="entity">arg2</span> $ <span class="main">(</span>Bound <span class="inner_numeral">0</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> <span class="entity">alpha_trm</span> $ <span class="entity">arg1</span> $ <span class="main">(</span>Bound <span class="inner_numeral">0</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">HOLogic.all_const</span> <span class="entity">arg_ty</span> $ Abs <span class="main">(</span><span class="inner_quoted">"z"</span><span class="main">,</span> <span class="entity">arg_ty</span><span class="main">,</span> <span class="entity">HOLogic.mk_imp</span> <span class="main">(</span><span class="entity">mid</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">raw_prove_trans</span> <span class="entity">ctxt</span> <span class="entity">alpha_result</span> <span class="entity">raw_dt_thms</span> <span class="entity">alpha_eqvt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">AlphaResult</span> <span class="main">{</span><span class="entity">alpha_trms</span><span class="main">,</span> <span class="entity">alpha_bn_trms</span><span class="main">,</span>
      <span class="entity">alpha_raw_induct</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">alpha_result</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alpha_trms</span> <span class="main">=</span> <span class="entity">alpha_trms</span> @ <span class="entity">alpha_bn_trms</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">props</span> <span class="main">=</span> map <span class="entity">prep_trans_goal</span> <span class="entity">alpha_trms</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">alpha_prove</span> <span class="entity">alpha_trms</span> <span class="main">(</span><span class="entity">alpha_trms</span> ~~ <span class="entity">props</span><span class="main">)</span> <span class="entity">alpha_raw_induct</span>
      <span class="main">(</span><span class="entity">prove_trans_tac</span> <span class="entity">alpha_result</span> <span class="entity">raw_dt_thms</span> <span class="entity">alpha_eqvt</span><span class="main">)</span> <span class="entity">ctxt</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="comment1">(** proves the equivp predicate for all alphas **)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">reflp_def'</span> <span class="main">=</span>
  <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">lemma</span> <span class="quoted">"reflp <span class="free">R</span> <span class="main">==</span> <span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">R</span> <span class="bound">x</span> <span class="bound">x</span>"</span> <span class="keyword1"><span class="keyword">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main">:</span> reflp_def refl_on_def<span class="main">)</span><span class="antiquote">}</span></span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">symp_def'</span> <span class="main">=</span>
  <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">lemma</span> <span class="quoted">"symp <span class="free">R</span> <span class="main">≡</span> <span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span> <span class="main">.</span> <span class="free">R</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">--&gt;</span> <span class="free">R</span> <span class="bound">y</span> <span class="bound">x</span>"</span> <span class="keyword1"><span class="keyword">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main">:</span> symp_def sym_def<span class="main">)</span><span class="antiquote">}</span></span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">transp_def'</span> <span class="main">=</span>
  <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">lemma</span> <span class="quoted">"transp <span class="free">R</span> <span class="main">≡</span> <span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">R</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∀</span><span class="bound">z</span><span class="main">.</span> <span class="free">R</span> <span class="bound">y</span> <span class="bound">z</span> <span class="main">⟶</span> <span class="free">R</span> <span class="bound">x</span> <span class="bound">z</span><span class="main">)</span>"</span>
    <span class="keyword1"><span class="keyword">by</span></span> <span class="main">(</span><span class="operator">rule</span> eq_reflection<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main">:</span> trans_def transp_def<span class="main">)</span><span class="antiquote">}</span></span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">raw_prove_equivp</span> <span class="entity">ctxt</span> <span class="entity">alpha_result</span> <span class="entity">refl</span> <span class="entity">symm</span> <span class="entity">trans</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">AlphaResult</span> <span class="main">{</span><span class="entity">alpha_trms</span><span class="main">,</span> <span class="entity">alpha_bn_trms</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">alpha_result</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">refl'</span> <span class="main">=</span> map <span class="main">(</span>fold_rule <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">reflp_def'</span><span class="main">]</span> o <span class="entity">atomize</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">refl</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">symm'</span> <span class="main">=</span> map <span class="main">(</span>fold_rule <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">symp_def'</span><span class="main">]</span> o <span class="entity">atomize</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">symm</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">trans'</span> <span class="main">=</span> map <span class="main">(</span>fold_rule <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">transp_def'</span><span class="main">]</span> o <span class="entity">atomize</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">trans</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prep_goal</span> <span class="entity">t</span> <span class="main">=</span>
      <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "equivp"<span class="antiquote">}</span></span><span class="main">,</span> fastype_of <span class="entity">t</span> --&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">bool</span><span class="antiquote">}</span></span><span class="main">)</span> $ <span class="entity">t</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Goal.prove_common <span class="entity">ctxt</span> NONE <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span>map <span class="entity">prep_goal</span> <span class="main">(</span><span class="entity">alpha_trms</span> @ <span class="entity">alpha_bn_trms</span><span class="main">)</span><span class="main">)</span>
    <span class="main">(</span>K <span class="main">(</span>HEADGOAL <span class="main">(</span>Goal.conjunction_tac THEN_ALL_NEW <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> equivpI<span class="antiquote">}</span></span></span> THEN'
       RANGE <span class="main">[</span>resolve_tac <span class="entity">ctxt</span> <span class="entity">refl'</span><span class="main">,</span> resolve_tac <span class="entity">ctxt</span> <span class="entity">symm'</span><span class="main">,</span> resolve_tac <span class="entity">ctxt</span> <span class="entity">trans'</span><span class="main">]</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    |&gt; chop <span class="main">(</span>length <span class="entity">alpha_trms</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="comment1">(* proves that alpha_raw implies alpha_bn *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">raw_prove_bn_imp_tac</span> <span class="entity">alpha_result</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="entity">SUBPROOF</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span><span class="entity">prems</span><span class="main">,</span> context <span class="main">=</span> <span class="entity">ctxt'</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">AlphaResult</span> <span class="main">{</span><span class="entity">alpha_names</span><span class="main">,</span> <span class="entity">alpha_intros</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">alpha_result</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prems'</span> <span class="main">=</span> flat <span class="main">(</span>map <span class="entity">Old_Datatype_Aux.split_conj_thm</span> <span class="entity">prems</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prems''</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">transform_prem1</span> <span class="entity">ctxt'</span> <span class="entity">alpha_names</span><span class="main">)</span> <span class="entity">prems'</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      HEADGOAL
        <span class="main">(</span>REPEAT_ALL_NEW
           <span class="main">(</span>FIRST' <span class="main">[</span> resolve_tac <span class="entity">ctxt'</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> TrueI<span class="antiquote">}</span></span></span><span class="main">,</span>
                     resolve_tac <span class="entity">ctxt'</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> conjI<span class="antiquote">}</span></span></span><span class="main">,</span>
                     resolve_tac <span class="entity">ctxt'</span> <span class="entity">prems'</span><span class="main">,</span>
                     resolve_tac <span class="entity">ctxt'</span> <span class="entity">prems''</span><span class="main">,</span>
                     resolve_tac <span class="entity">ctxt'</span> <span class="entity">alpha_intros</span> <span class="main">]</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span> <span class="entity">ctxt</span>


<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">raw_prove_bn_imp</span> <span class="entity">ctxt</span> <span class="entity">alpha_result</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">AlphaResult</span> <span class="main">{</span><span class="entity">alpha_trms</span><span class="main">,</span> <span class="entity">alpha_tys</span><span class="main">,</span> <span class="entity">alpha_bn_trms</span><span class="main">,</span> <span class="entity">alpha_raw_induct</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">alpha_result</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg_ty</span> <span class="main">=</span> domain_type o fastype_of
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty_assoc</span> <span class="main">=</span> <span class="entity">alpha_tys</span> ~~ <span class="entity">alpha_trms</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">props</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">lookup</span> <span class="entity">ty_assoc</span> <span class="main">(</span><span class="entity">arg_ty</span> <span class="entity">t</span><span class="main">)</span><span class="main">,</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">t</span> $ <span class="entity">x</span> $ <span class="entity">y</span><span class="main">)</span><span class="main">)</span> <span class="entity">alpha_bn_trms</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">alpha_prove</span> <span class="main">(</span><span class="entity">alpha_trms</span> @ <span class="entity">alpha_bn_trms</span><span class="main">)</span> <span class="entity">props</span> <span class="entity">alpha_raw_induct</span>
      <span class="main">(</span><span class="entity">raw_prove_bn_imp_tac</span> <span class="entity">alpha_result</span><span class="main">)</span> <span class="entity">ctxt</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="comment1">(* respectfulness for fv_raw / bn_raw *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">raw_fv_bn_rsp_aux</span> <span class="entity">ctxt</span> <span class="entity">alpha_result</span> <span class="entity">fvs</span> <span class="entity">bns</span> <span class="entity">fv_bns</span> <span class="entity">simps</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">AlphaResult</span> <span class="main">{</span><span class="entity">alpha_trms</span><span class="main">,</span> <span class="entity">alpha_tys</span><span class="main">,</span> <span class="entity">alpha_bn_trms</span><span class="main">,</span> <span class="entity">alpha_raw_induct</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">alpha_result</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg_ty</span> <span class="main">=</span> domain_type o fastype_of
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty_assoc</span> <span class="main">=</span> <span class="entity">alpha_tys</span> ~~ <span class="entity">alpha_trms</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_eq'</span> <span class="entity">t</span> <span class="entity">x</span> <span class="entity">y</span> <span class="main">=</span> <span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">t</span> $ <span class="entity">x</span><span class="main">,</span> <span class="entity">t</span> $ <span class="entity">y</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prop1</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">lookup</span> <span class="entity">ty_assoc</span> <span class="main">(</span><span class="entity">arg_ty</span> <span class="entity">t</span><span class="main">)</span><span class="main">,</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">mk_eq'</span> <span class="entity">t</span> <span class="entity">x</span> <span class="entity">y</span><span class="main">)</span><span class="main">)</span> <span class="entity">fvs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prop2</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">lookup</span> <span class="entity">ty_assoc</span> <span class="main">(</span><span class="entity">arg_ty</span> <span class="entity">t</span><span class="main">)</span><span class="main">,</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">mk_eq'</span> <span class="entity">t</span> <span class="entity">x</span> <span class="entity">y</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">bns</span> @ <span class="entity">fv_bns</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prop3</span> <span class="main">=</span> map2 <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t1</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t2</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">mk_eq'</span> <span class="entity">t2</span> <span class="entity">x</span> <span class="entity">y</span><span class="main">)</span><span class="main">)</span> <span class="entity">alpha_bn_trms</span> <span class="entity">fv_bns</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simpset</span> <span class="main">=</span>
      put_simpset <span class="entity">HOL_ss</span> <span class="entity">ctxt</span> addsimps <span class="main">(</span><span class="entity">simps</span> @ <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> alphas prod_fv.simps set_simps append.simps<span class="antiquote">}</span></span></span>
      @ <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> Un_assoc Un_insert_left Un_empty_right Un_empty_left<span class="antiquote">}</span></span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">alpha_prove</span> <span class="main">(</span><span class="entity">alpha_trms</span> @ <span class="entity">alpha_bn_trms</span><span class="main">)</span> <span class="main">(</span><span class="entity">prop1</span> @ <span class="entity">prop2</span> @ <span class="entity">prop3</span><span class="main">)</span> <span class="entity">alpha_raw_induct</span>
      <span class="main">(</span>K <span class="main">(</span><span class="entity">asm_full_simp_tac</span> <span class="entity">simpset</span><span class="main">)</span><span class="main">)</span> <span class="entity">ctxt</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="comment1">(* respectfulness for size *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">raw_size_rsp_aux</span> <span class="entity">ctxt</span> <span class="entity">alpha_result</span> <span class="entity">simps</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">AlphaResult</span> <span class="main">{</span><span class="entity">alpha_trms</span><span class="main">,</span> <span class="entity">alpha_tys</span><span class="main">,</span> <span class="entity">alpha_bn_trms</span><span class="main">,</span> <span class="entity">alpha_bn_tys</span><span class="main">,</span> <span class="entity">alpha_raw_induct</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span>
      <span class="entity">alpha_result</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_prop</span> <span class="entity">ty</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span> <span class="main">=</span> <span class="entity">HOLogic.mk_eq</span>
      <span class="main">(</span><span class="entity">HOLogic.size_const</span> <span class="entity">ty</span> $ <span class="entity">x</span><span class="main">,</span> <span class="entity">HOLogic.size_const</span> <span class="entity">ty</span> $ <span class="entity">y</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">props</span> <span class="main">=</span> <span class="main">(</span><span class="entity">alpha_trms</span> @ <span class="entity">alpha_bn_trms</span><span class="main">)</span> ~~ <span class="main">(</span>map <span class="entity">mk_prop</span> <span class="main">(</span><span class="entity">alpha_tys</span> @ <span class="entity">alpha_bn_tys</span><span class="main">)</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simpset</span> <span class="main">=</span>
      put_simpset <span class="entity">HOL_ss</span> <span class="entity">ctxt</span> addsimps <span class="main">(</span><span class="entity">simps</span> @ <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> alphas prod_alpha_def rel_prod_conv
      permute_prod_def prod.case prod.rec<span class="antiquote">}</span></span></span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tac</span> <span class="main">=</span> <span class="main">(</span>TRY o REPEAT o eresolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> exE<span class="antiquote">}</span></span></span><span class="main">)</span> THEN' <span class="entity">asm_full_simp_tac</span> <span class="entity">simpset</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">alpha_prove</span> <span class="main">(</span><span class="entity">alpha_trms</span> @ <span class="entity">alpha_bn_trms</span><span class="main">)</span> <span class="entity">props</span> <span class="entity">alpha_raw_induct</span> <span class="main">(</span>K <span class="entity">tac</span><span class="main">)</span> <span class="entity">ctxt</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="comment1">(* respectfulness for constructors *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">raw_constr_rsp_tac</span> <span class="entity">ctxt</span> <span class="entity">alpha_intros</span> <span class="entity">simps</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pre_simpset</span> <span class="main">=</span> put_simpset <span class="entity">HOL_ss</span> <span class="entity">ctxt</span> addsimps <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> rel_fun_def<span class="antiquote">}</span></span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">post_simpset</span> <span class="main">=</span> put_simpset <span class="entity">HOL_ss</span> <span class="entity">ctxt</span> addsimps <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> alphas prod_alpha_def rel_prod_conv
      prod_fv.simps fresh_star_zero permute_zero prod.case<span class="antiquote">}</span></span></span> @ <span class="entity">simps</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">asm_full_simp_tac</span> <span class="entity">pre_simpset</span>
    THEN' REPEAT o <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> allI impI<span class="antiquote">}</span></span></span><span class="main">)</span>
    THEN' resolve_tac <span class="entity">ctxt</span> <span class="entity">alpha_intros</span>
    THEN_ALL_NEW <span class="main">(</span>TRY o <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">exi_zero</span><span class="main">]</span><span class="main">)</span> THEN' <span class="entity">asm_full_simp_tac</span> <span class="entity">post_simpset</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">raw_constrs_rsp</span> <span class="entity">ctxt</span> <span class="entity">alpha_result</span> <span class="entity">constrs</span> <span class="entity">simps</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">AlphaResult</span> <span class="main">{</span><span class="entity">alpha_trms</span><span class="main">,</span> <span class="entity">alpha_tys</span><span class="main">,</span> <span class="entity">alpha_intros</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">alpha_result</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">lookup</span> <span class="entity">ty</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">case</span></span> AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span><span class="main">)</span> <span class="main">(</span><span class="entity">alpha_tys</span> ~~ <span class="entity">alpha_trms</span><span class="main">)</span> <span class="entity">ty</span> <span class="keyword2"><span class="keyword">of</span></span>
        NONE <span class="main">=&gt;</span> <span class="entity">HOLogic.eq_const</span> <span class="entity">ty</span>
      <span class="main">|</span> SOME <span class="entity">alpha</span> <span class="main">=&gt;</span> <span class="entity">alpha</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rel_fun_app</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span>
      Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "rel_fun"<span class="antiquote">}</span></span><span class="main">,</span> dummyT<span class="main">)</span> $ <span class="entity">t1</span> $ <span class="entity">t2</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prep_goal</span> <span class="entity">trm</span> <span class="main">=</span>
      <span class="entity">trm</span>
      |&gt; strip_type o fastype_of
      |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">tys</span><span class="main">,</span> <span class="entity">ty</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">tys</span> @ <span class="main">[</span><span class="entity">ty</span><span class="main">]</span><span class="main">)</span>
      |&gt; map <span class="entity">lookup</span>
      |&gt; foldr1 <span class="entity">rel_fun_app</span>
      |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> <span class="entity">t</span> $ <span class="entity">trm</span> $ <span class="entity">trm</span><span class="main">)</span>
      |&gt; Syntax.check_term <span class="entity">ctxt</span>
      |&gt; <span class="entity">HOLogic.mk_Trueprop</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">constrs</span> <span class="main">=&gt;</span>
    Goal.prove_common <span class="entity">ctxt</span> NONE <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span>map <span class="entity">prep_goal</span> <span class="entity">constrs</span><span class="main">)</span>
      <span class="main">(</span>K <span class="main">(</span>HEADGOAL
        <span class="main">(</span>Goal.conjunction_tac THEN_ALL_NEW <span class="entity">raw_constr_rsp_tac</span> <span class="entity">ctxt</span> <span class="entity">alpha_intros</span> <span class="entity">simps</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">constrs</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="comment1">(* rsp lemmas for alpha_bn relations *)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rsp_equivp</span> <span class="main">=</span>
  <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">lemma</span> <span class="quoted">"<span class="main">[|</span>equivp <span class="free">Q</span><span class="main">;</span> <span class="main">!!</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">R</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">==&gt;</span> <span class="free">Q</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">|]</span> <span class="main">==&gt;</span> <span class="main">(</span><span class="free">R</span> <span class="main">===&gt;</span> <span class="free">R</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="free">Q</span> <span class="free">Q</span>"</span>
    <span class="keyword1"><span class="keyword">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main">:</span> rel_fun_def equivp_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">metis</span><span class="main">)</span><span class="antiquote">}</span></span></span>


<span class="comment1">(* we have to reorder the alpha_bn_imps theorems in order
   to be in order with alpha_bn_trms *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">raw_alpha_bn_rsp</span> <span class="entity">alpha_result</span> <span class="entity">alpha_bn_equivp</span> <span class="entity">alpha_bn_imps</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">AlphaResult</span> <span class="main">{</span><span class="entity">alpha_bn_trms</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">alpha_result</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_map</span> <span class="entity">thm</span> <span class="main">=</span>
      <span class="entity">thm</span> |&gt; `Thm.prop_of
          |&gt;&gt; List.last  o snd o strip_comb
          |&gt;&gt; <span class="entity">HOLogic.dest_Trueprop</span>
          |&gt;&gt; head_of
          |&gt;&gt; fst o dest_Const

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alpha_bn_imps'</span> <span class="main">=</span>
      map <span class="main">(</span><span class="entity">lookup</span> <span class="main">(</span>map <span class="entity">mk_map</span> <span class="entity">alpha_bn_imps</span><span class="main">)</span> o fst o dest_Const<span class="main">)</span> <span class="entity">alpha_bn_trms</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_thm</span> <span class="entity">thm1</span> <span class="entity">thm2</span> <span class="main">=</span>
      <span class="main">(</span>forall_intr_vars <span class="entity">thm2</span><span class="main">)</span> COMP <span class="main">(</span><span class="entity">thm1</span> RS <span class="entity">rsp_equivp</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    map2 <span class="entity">mk_thm</span> <span class="entity">alpha_bn_equivp</span> <span class="entity">alpha_bn_imps'</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="comment1">(* rsp for permute_bn functions *)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">perm_bn_rsp</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">lemma</span> <span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span> <span class="bound">p</span><span class="main">.</span> <span class="free">R</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">⟶</span> <span class="free">R</span> <span class="main">(</span><span class="free">f</span> <span class="bound">p</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">f</span> <span class="bound">p</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> <span class="free">R</span> <span class="main">===&gt;</span> <span class="free">R</span><span class="main">)</span> <span class="free">f</span> <span class="free">f</span>"</span>
 <span class="keyword1"><span class="keyword">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main">:</span> rel_fun_def<span class="main">)</span><span class="antiquote">}</span></span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">raw_prove_perm_bn_tac</span> <span class="entity">alpha_result</span> <span class="entity">simps</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="entity">SUBPROOF</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span><span class="entity">prems</span><span class="main">,</span> context <span class="main">=</span> <span class="entity">ctxt'</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">AlphaResult</span> <span class="main">{</span><span class="entity">alpha_names</span><span class="main">,</span> <span class="entity">alpha_bn_names</span><span class="main">,</span> <span class="entity">alpha_intros</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">alpha_result</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prems'</span> <span class="main">=</span> flat <span class="main">(</span>map <span class="entity">Old_Datatype_Aux.split_conj_thm</span> <span class="entity">prems</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prems''</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">transform_prem1</span> <span class="entity">ctxt'</span> <span class="main">(</span><span class="entity">alpha_names</span> @ <span class="entity">alpha_bn_names</span><span class="main">)</span><span class="main">)</span> <span class="entity">prems'</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      HEADGOAL
        <span class="main">(</span><span class="entity">simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt'</span> addsimps <span class="main">(</span><span class="entity">simps</span> @ <span class="entity">prems'</span><span class="main">)</span><span class="main">)</span>
         THEN' TRY o REPEAT_ALL_NEW
           <span class="main">(</span>FIRST' <span class="main">[</span> resolve_tac <span class="entity">ctxt'</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> TrueI<span class="antiquote">}</span></span></span><span class="main">,</span>
                     resolve_tac <span class="entity">ctxt'</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> conjI<span class="antiquote">}</span></span></span><span class="main">,</span>
                     resolve_tac <span class="entity">ctxt'</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> refl<span class="antiquote">}</span></span></span><span class="main">,</span>
                     resolve_tac <span class="entity">ctxt'</span> <span class="entity">prems'</span><span class="main">,</span>
                     resolve_tac <span class="entity">ctxt'</span> <span class="entity">prems''</span><span class="main">,</span>
                     resolve_tac <span class="entity">ctxt'</span> <span class="entity">alpha_intros</span> <span class="main">]</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span> <span class="entity">ctxt</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">raw_perm_bn_rsp</span> <span class="entity">ctxt</span> <span class="entity">alpha_result</span> <span class="entity">perm_bns</span> <span class="entity">simps</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">AlphaResult</span> <span class="main">{</span><span class="entity">alpha_trms</span><span class="main">,</span> <span class="entity">alpha_tys</span><span class="main">,</span> <span class="entity">alpha_bn_trms</span><span class="main">,</span> <span class="entity">alpha_bn_tys</span><span class="main">,</span> <span class="entity">alpha_raw_induct</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span>
      <span class="entity">alpha_result</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">perm_bn_ty</span> <span class="main">=</span> range_type o range_type o fastype_of
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty_assoc</span> <span class="main">=</span> <span class="main">(</span><span class="entity">alpha_tys</span> @ <span class="entity">alpha_bn_tys</span><span class="main">)</span> ~~ <span class="main">(</span><span class="entity">alpha_trms</span> @ <span class="entity">alpha_bn_trms</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">[</span><span class="entity">p</span><span class="main">]</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> Variable.variant_fixes <span class="main">[</span><span class="inner_quoted">"p"</span><span class="main">]</span> <span class="entity">ctxt</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">p</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">p</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">perm</span><span class="antiquote">}</span></span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_prop</span> <span class="entity">t</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alpha_trm</span> <span class="main">=</span> <span class="entity">lookup</span> <span class="entity">ty_assoc</span> <span class="main">(</span><span class="entity">perm_bn_ty</span> <span class="entity">t</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="entity">alpha_trm</span><span class="main">,</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">alpha_trm</span> $ <span class="main">(</span><span class="entity">t</span> $ <span class="entity">p</span> $ <span class="entity">x</span><span class="main">)</span> $ <span class="main">(</span><span class="entity">t</span> $ <span class="entity">p</span> $ <span class="entity">y</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goals</span> <span class="main">=</span> map <span class="entity">mk_prop</span> <span class="entity">perm_bns</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">alpha_prove</span> <span class="main">(</span><span class="entity">alpha_trms</span> @ <span class="entity">alpha_bn_trms</span><span class="main">)</span> <span class="entity">goals</span> <span class="entity">alpha_raw_induct</span>
      <span class="main">(</span><span class="entity">raw_prove_perm_bn_tac</span> <span class="entity">alpha_result</span> <span class="entity">simps</span><span class="main">)</span> <span class="entity">ctxt</span>
     |&gt; Proof_Context.export <span class="entity">ctxt'</span> <span class="entity">ctxt</span>
     |&gt; map <span class="main">(</span><span class="entity">atomize</span> <span class="entity">ctxt</span><span class="main">)</span>
     |&gt; map single
     |&gt; map <span class="main">(</span>curry <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> OF<span class="main">)</span> <span class="entity">perm_bn_rsp</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>



<span class="comment1">(* transformation of the natural rsp-lemmas into standard form *)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fun_rsp</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">lemma</span>
  <span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">R</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">⟶</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">f</span> <span class="bound">y</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">R</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="free">f</span> <span class="free">f</span>"</span> <span class="keyword1"><span class="keyword">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main">:</span> rel_fun_def<span class="main">)</span><span class="antiquote">}</span></span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_funs_rsp</span> <span class="entity">ctxt</span> <span class="entity">thm</span> <span class="main">=</span>
  <span class="entity">thm</span>
  |&gt; <span class="entity">atomize</span> <span class="entity">ctxt</span>
  |&gt; single
  |&gt; curry <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> OF<span class="main">)</span> <span class="entity">fun_rsp</span>


<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">permute_rsp</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">lemma</span>
  <span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span> <span class="bound">p</span><span class="main">.</span> <span class="free">R</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">⟶</span> <span class="free">R</span> <span class="main">(</span>permute <span class="bound">p</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span>permute <span class="bound">p</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>
     <span class="main">==&gt;</span> <span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> <span class="free">R</span> <span class="main">===&gt;</span> <span class="free">R</span><span class="main">)</span> permute permute"</span>  <span class="keyword1"><span class="keyword">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main">:</span> rel_fun_def<span class="main">)</span><span class="antiquote">}</span></span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_alpha_permute_rsp</span> <span class="entity">ctxt</span> <span class="entity">thm</span> <span class="main">=</span>
  <span class="entity">thm</span>
  |&gt; <span class="entity">atomize</span> <span class="entity">ctxt</span>
  |&gt; single
  |&gt; curry <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> OF<span class="main">)</span> <span class="entity">permute_rsp</span>




<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* structure *)</span>
</pre>
</div><div id="files/nominal_dt_quot.ML">
<div class="head">
<h1>File ‹nominal_dt_quot.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      nominal_dt_alpha.ML
    Author:     Christian Urban
    Author:     Cezary Kaliszyk

  Performing quotient constructions, lifting theorems and
  deriving support properties for the quotient types.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">NOMINAL_DT_QUOT</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> define_qtypes<span class="main">:</span> <span class="main">(</span>string list * binding * mixfix<span class="main">)</span> list <span class="main">-&gt;</span> typ list <span class="main">-&gt;</span> term list <span class="main">-&gt;</span>
    thm list <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> <span class="entity">Quotient_Info.quotients</span> list * local_theory

  <span class="keyword1"><span class="keyword">val</span></span> define_qconsts<span class="main">:</span> typ list <span class="main">-&gt;</span> <span class="main">(</span>string  * term * mixfix * thm<span class="main">)</span> list <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span>
    <span class="entity">Quotient_Info.quotconsts</span> list * local_theory

  <span class="keyword1"><span class="keyword">val</span></span> define_qperms<span class="main">:</span> typ list <span class="main">-&gt;</span> string list <span class="main">-&gt;</span> <span class="main">(</span>string * sort<span class="main">)</span> list <span class="main">-&gt;</span>
    <span class="main">(</span>string * term * mixfix * thm<span class="main">)</span> list <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> local_theory

  <span class="keyword1"><span class="keyword">val</span></span> define_qsizes<span class="main">:</span> typ list <span class="main">-&gt;</span> string list <span class="main">-&gt;</span> <span class="main">(</span>string * sort<span class="main">)</span> list <span class="main">-&gt;</span>
    <span class="main">(</span>string * term * mixfix * thm<span class="main">)</span> list <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> local_theory

  <span class="keyword1"><span class="keyword">val</span></span> lift_thms<span class="main">:</span> typ list <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm list * <span class="entity">Proof.context</span>

  <span class="keyword1"><span class="keyword">val</span></span> prove_supports<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> thm list
  <span class="keyword1"><span class="keyword">val</span></span> prove_fsupp<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> typ list <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> thm list

  <span class="keyword1"><span class="keyword">val</span></span> fs_instance<span class="main">:</span> typ list <span class="main">-&gt;</span> string list <span class="main">-&gt;</span> <span class="main">(</span>string * sort<span class="main">)</span> list <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span>
    local_theory <span class="main">-&gt;</span> local_theory

  <span class="keyword1"><span class="keyword">val</span></span> prove_fv_supp<span class="main">:</span> typ list <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span>
    thm list <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> <span class="entity">bclause</span> list list <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm list

  <span class="keyword1"><span class="keyword">val</span></span> prove_bns_finite<span class="main">:</span> typ list <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm list

  <span class="keyword1"><span class="keyword">val</span></span> prove_perm_bn_alpha_thms<span class="main">:</span> typ list <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span>
    thm list <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm list

  <span class="keyword1"><span class="keyword">val</span></span> prove_permute_bn_thms<span class="main">:</span> typ list <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span>
    thm list <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm list

  <span class="keyword1"><span class="keyword">val</span></span> prove_strong_exhausts<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> <span class="entity">bclause</span> list list list <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span>
    thm list <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> thm list

  <span class="keyword1"><span class="keyword">val</span></span> prove_strong_induct<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> <span class="entity">bclause</span> list list list <span class="main">-&gt;</span>
    thm list
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Nominal_Dt_Quot</span><span class="main">:</span> <span class="entity">NOMINAL_DT_QUOT</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword3"><span class="keyword">open</span></span> Nominal_Permeq

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">lookup</span> <span class="entity">xs</span> <span class="entity">x</span> <span class="main">=</span> the <span class="main">(</span>AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span><span class="main">)</span> <span class="entity">xs</span> <span class="entity">x</span><span class="main">)</span>


<span class="comment1">(* defines the quotient types *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">define_qtypes</span> <span class="entity">qtys_descr</span> <span class="entity">alpha_tys</span> <span class="entity">alpha_trms</span> <span class="entity">alpha_equivp_thms</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">qty_args1</span> <span class="main">=</span> map2 <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ty</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">trm</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">ty</span><span class="main">,</span> <span class="entity">trm</span><span class="main">,</span> false<span class="main">)</span><span class="main">)</span> <span class="entity">alpha_tys</span> <span class="entity">alpha_trms</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">qty_args2</span> <span class="main">=</span> map2 <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">descr</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">args1</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">descr</span><span class="main">,</span> <span class="entity">args1</span><span class="main">,</span> <span class="main">(</span>NONE<span class="main">,</span> NONE<span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">qtys_descr</span> <span class="entity">qty_args1</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">qty_args3</span> <span class="main">=</span> <span class="entity">qty_args2</span> ~~ <span class="entity">alpha_equivp_thms</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    fold_map <span class="main">(</span><span class="entity">Quotient_Type.add_quotient_type</span> <span class="main">{</span>overloaded <span class="main">=</span> false<span class="main">}</span><span class="main">)</span> <span class="entity">qty_args3</span> <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* a wrapper for lifting a raw constant *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">lift_raw_const</span> <span class="entity">qtys</span> <span class="main">(</span><span class="entity">qconst_name</span><span class="main">,</span> <span class="entity">rconst</span><span class="main">,</span> <span class="entity">mx'</span><span class="main">,</span> <span class="entity">rsp_thm</span><span class="main">)</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rty</span> <span class="main">=</span> fastype_of <span class="entity">rconst</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">qty</span> <span class="main">=</span> <span class="entity">Quotient_Term.derive_qtyp</span> <span class="entity">lthy</span> <span class="entity">qtys</span> <span class="entity">rty</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs_raw</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">qconst_name</span><span class="main">,</span> <span class="entity">qty</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs_raw</span> <span class="main">=</span> <span class="entity">rconst</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_var</span> <span class="main">=</span> <span class="main">(</span>Binding.name <span class="entity">qconst_name</span><span class="main">,</span> NONE<span class="main">,</span> <span class="entity">mx'</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">binding</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">mx</span><span class="main">)</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="main">=</span> Proof_Context.cert_var <span class="entity">raw_var</span> <span class="entity">lthy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs</span> <span class="main">=</span> Syntax.check_term <span class="entity">ctxt</span> <span class="entity">lhs_raw</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> Syntax.check_term <span class="entity">ctxt</span> <span class="entity">rhs_raw</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs_str</span><span class="main">,</span> <span class="entity">lhs_ty</span><span class="main">)</span> <span class="main">=</span> dest_Free <span class="entity">lhs</span> <span class="keyword3"><span class="keyword">handle</span></span> TERM <span class="main">_</span> <span class="main">=&gt;</span> error <span class="inner_quoted">"Constant already defined."</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> null <span class="main">(</span>strip_abs_vars <span class="entity">rhs</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> error <span class="inner_quoted">"The definiens cannot be an abstraction"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> is_Const <span class="entity">rhs</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> warning <span class="inner_quoted">"The definiens is not a constant"</span>

  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">Quotient_Def.add_quotient_def</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">binding</span><span class="main">,</span> <span class="entity">mx</span><span class="main">)</span><span class="main">,</span> Binding.empty_atts<span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span><span class="main">)</span> <span class="entity">rsp_thm</span>  <span class="entity">ctxt</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="comment1">(* defines quotient constants *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">define_qconsts</span> <span class="entity">qtys</span> <span class="entity">consts_specs</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">qconst_infos</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span>
      fold_map <span class="main">(</span><span class="entity">lift_raw_const</span> <span class="entity">qtys</span><span class="main">)</span> <span class="entity">consts_specs</span> <span class="entity">lthy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">phi</span> <span class="main">=</span>
      Proof_Context.export_morphism <span class="entity">lthy'</span>
        <span class="main">(</span>Proof_Context.transfer <span class="main">(</span>Proof_Context.theory_of <span class="entity">lthy'</span><span class="main">)</span> <span class="entity">lthy</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span>map <span class="main">(</span><span class="entity">Quotient_Info.transform_quotconsts</span> <span class="entity">phi</span><span class="main">)</span> <span class="entity">qconst_infos</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="comment1">(* defines the quotient permutations and proves pt-class *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">define_qperms</span> <span class="entity">qtys</span> <span class="entity">qfull_ty_names</span> <span class="entity">tvs</span> <span class="entity">perm_specs</span> <span class="entity">raw_perm_laws</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lthy1</span> <span class="main">=</span>
      <span class="entity">lthy</span>
      |&gt; Local_Theory.exit_global
      |&gt; <span class="entity">Class.instantiation</span> <span class="main">(</span><span class="entity">qfull_ty_names</span><span class="main">,</span> <span class="entity">tvs</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">pt</span><span class="antiquote">}</span></span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">lthy2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">define_qconsts</span> <span class="entity">qtys</span> <span class="entity">perm_specs</span> <span class="entity">lthy1</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">raw_perm_laws'</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy3</span><span class="main">)</span> <span class="main">=</span> Variable.importT <span class="entity">raw_perm_laws</span> <span class="entity">lthy2</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lifted_perm_laws</span> <span class="main">=</span>
      map <span class="main">(</span><span class="entity">Quotient_Tacs.lifted</span> <span class="entity">lthy3</span> <span class="entity">qtys</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="entity">raw_perm_laws'</span>
      |&gt; Variable.exportT <span class="entity">lthy3</span> <span class="entity">lthy2</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
      <span class="entity">Class.intro_classes_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> THEN
        <span class="main">(</span>ALLGOALS <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="entity">lifted_perm_laws</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">lthy2</span>
    |&gt; <span class="entity">Class.prove_instantiation_exit</span> <span class="entity">tac</span>
    |&gt; <span class="entity">Named_Target.theory_init</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="comment1">(* defines the size functions and proves size-class *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">define_qsizes</span> <span class="entity">qtys</span> <span class="entity">qfull_ty_names</span> <span class="entity">tvs</span> <span class="entity">size_specs</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tac</span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="entity">Class.intro_classes_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">lthy</span>
    |&gt; Local_Theory.exit_global
    |&gt; <span class="entity">Class.instantiation</span> <span class="main">(</span><span class="entity">qfull_ty_names</span><span class="main">,</span> <span class="entity">tvs</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">size</span><span class="antiquote">}</span></span><span class="main">)</span>
    |&gt; snd o <span class="main">(</span><span class="entity">define_qconsts</span> <span class="entity">qtys</span> <span class="entity">size_specs</span><span class="main">)</span>
    |&gt; <span class="entity">Class.prove_instantiation_exit</span> <span class="entity">tac</span>
    |&gt; <span class="entity">Named_Target.theory_init</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="comment1">(* lifts a theorem and cleans all "_raw" parts
   from variable names *)</span>

<span class="keyword2"><span class="keyword">local</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">any</span> <span class="main">=</span> Scan.one <span class="main">(</span>Symbol.not_eof<span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw</span> <span class="main">=</span> Scan.this_string <span class="inner_quoted">"_raw"</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">exclude</span> <span class="main">=</span>
    Scan.repeat <span class="main">(</span>Scan.unless <span class="entity">raw</span> <span class="entity">any</span><span class="main">)</span> --| <span class="entity">raw</span> &gt;&gt; implode
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parser</span> <span class="main">=</span> Scan.repeat <span class="main">(</span><span class="entity">exclude</span> || <span class="entity">any</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">in</span></span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">unraw_str</span> <span class="entity">s</span> <span class="main">=</span>
    <span class="entity">s</span> |&gt; raw_explode
      |&gt; Scan.finite Symbol.stopper <span class="entity">parser</span> &gt;&gt; implode
      |&gt; fst
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">unraw_vars_thm</span> <span class="entity">ctxt</span> <span class="entity">thm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">unraw_var_str</span> <span class="main">(</span><span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="entity">i</span><span class="main">)</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="entity">unraw_str</span> <span class="entity">s</span><span class="main">,</span> <span class="entity">i</span><span class="main">)</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vars</span> <span class="main">=</span> Term.add_vars <span class="main">(</span>Thm.prop_of <span class="entity">thm</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vars'</span> <span class="main">=</span> map <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> o Var o <span class="entity">unraw_var_str</span><span class="main">)</span> <span class="entity">vars</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Thm.instantiate <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">(</span><span class="entity">vars</span> ~~ <span class="entity">vars'</span><span class="main">)</span><span class="main">)</span> <span class="entity">thm</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">unraw_bounds_thm</span> <span class="entity">th</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">trm</span> <span class="main">=</span> Thm.prop_of <span class="entity">th</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">trm'</span> <span class="main">=</span> Term.map_abs_vars <span class="entity">unraw_str</span> <span class="entity">trm</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Thm.rename_boundvars <span class="entity">trm</span> <span class="entity">trm'</span> <span class="entity">th</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">lift_thms</span> <span class="entity">qtys</span> <span class="entity">simps</span> <span class="entity">thms</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="main">(</span>map <span class="main">(</span><span class="entity">Quotient_Tacs.lifted</span> <span class="entity">ctxt</span> <span class="entity">qtys</span> <span class="entity">simps</span>
        #&gt; <span class="entity">unraw_bounds_thm</span>
        #&gt; <span class="entity">unraw_vars_thm</span> <span class="entity">ctxt</span>
        #&gt; Drule.zero_var_indexes<span class="main">)</span> <span class="entity">thms</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span>



<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_supports_goal</span> <span class="entity">ctxt</span> <span class="entity">qtrm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vs</span> <span class="main">=</span> <span class="entity">fresh_args</span> <span class="entity">ctxt</span> <span class="entity">qtrm</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> list_comb <span class="main">(</span><span class="entity">qtrm</span><span class="main">,</span> <span class="entity">vs</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs</span> <span class="main">=</span> fold <span class="main">(</span>curry <span class="entity">HOLogic.mk_prod</span><span class="main">)</span> <span class="entity">vs</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="main">()</span>"</span><span class="antiquote">}</span></span>
      |&gt; <span class="entity">mk_supp</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">mk_supports</span> <span class="entity">lhs</span> <span class="entity">rhs</span>
    |&gt; <span class="entity">HOLogic.mk_Trueprop</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">supports_tac</span> <span class="entity">ctxt</span> <span class="entity">perm_simps</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simpset1</span> <span class="main">=</span>
      put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span> addsimps <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> supports_def fresh_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span><span class="antiquote">}</span></span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simpset2</span> <span class="main">=</span>
      put_simpset <span class="entity">HOL_ss</span> <span class="entity">ctxt</span> addsimps <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> swap_fresh_fresh fresh_Pair<span class="antiquote">}</span></span></span>
  <span class="keyword2"><span class="keyword">in</span></span>
    EVERY' <span class="main">[</span> <span class="entity">simp_tac</span> <span class="entity">simpset1</span><span class="main">,</span>
             <span class="entity">eqvt_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">eqvt_strict_config</span> <span class="entity">addpres</span> <span class="entity">perm_simps</span><span class="main">)</span><span class="main">,</span>
             <span class="entity">simp_tac</span> <span class="entity">simpset2</span> <span class="main">]</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_supports_single</span> <span class="entity">ctxt</span> <span class="entity">perm_simps</span> <span class="entity">qtrm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goal</span> <span class="main">=</span> <span class="entity">mk_supports_goal</span> <span class="entity">ctxt</span> <span class="entity">qtrm</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt'</span> <span class="main">=</span> Proof_Context.augment <span class="entity">goal</span> <span class="entity">ctxt</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Goal.prove <span class="entity">ctxt'</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">goal</span>
      <span class="main">(</span>K <span class="main">(</span>HEADGOAL <span class="main">(</span><span class="entity">supports_tac</span> <span class="entity">ctxt</span> <span class="entity">perm_simps</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    |&gt; singleton <span class="main">(</span>Proof_Context.export <span class="entity">ctxt'</span> <span class="entity">ctxt</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_supports</span> <span class="entity">ctxt</span> <span class="entity">perm_simps</span> <span class="entity">qtrms</span> <span class="main">=</span>
  map <span class="main">(</span><span class="entity">prove_supports_single</span> <span class="entity">ctxt</span> <span class="entity">perm_simps</span><span class="main">)</span> <span class="entity">qtrms</span>


<span class="comment1">(* finite supp lemmas for qtypes *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_fsupp</span> <span class="entity">ctxt</span> <span class="entity">qtys</span> <span class="entity">qinduct</span> <span class="entity">qsupports_thms</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">vs</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> Variable.variant_fixes <span class="main">(</span>replicate <span class="main">(</span>length <span class="entity">qtys</span><span class="main">)</span> <span class="inner_quoted">"x"</span><span class="main">)</span> <span class="entity">ctxt</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goals</span> <span class="main">=</span> <span class="entity">vs</span> ~~ <span class="entity">qtys</span>
      |&gt; map Free
      |&gt; map <span class="main">(</span><span class="entity">mk_finite</span> o <span class="entity">mk_supp</span><span class="main">)</span>
      |&gt; foldr1 <span class="main">(</span><span class="entity">HOLogic.mk_conj</span><span class="main">)</span>
      |&gt; <span class="entity">HOLogic.mk_Trueprop</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tac</span> <span class="main">=</span>
      EVERY' <span class="main">[</span> resolve_tac <span class="entity">ctxt'</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> supports_finite<span class="antiquote">}</span></span></span><span class="main">,</span>
               resolve_tac <span class="entity">ctxt'</span> <span class="entity">qsupports_thms</span><span class="main">,</span>
               <span class="entity">asm_simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_ss</span> <span class="entity">ctxt'</span>
                addsimps <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> finite_supp supp_Pair finite_Un<span class="antiquote">}</span></span></span><span class="main">)</span> <span class="main">]</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Goal.prove <span class="entity">ctxt'</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">goals</span>
      <span class="main">(</span>K <span class="main">(</span>HEADGOAL <span class="main">(</span>resolve_tac <span class="entity">ctxt'</span> <span class="main">[</span><span class="entity">qinduct</span><span class="main">]</span> THEN_ALL_NEW <span class="entity">tac</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    |&gt; singleton <span class="main">(</span>Proof_Context.export <span class="entity">ctxt'</span> <span class="entity">ctxt</span><span class="main">)</span>
    |&gt; <span class="entity">Old_Datatype_Aux.split_conj_thm</span>
    |&gt; map zero_var_indexes
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="comment1">(* finite supp instances *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">fs_instance</span> <span class="entity">qtys</span> <span class="entity">qfull_ty_names</span> <span class="entity">tvs</span> <span class="entity">qfsupp_thms</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lthy1</span> <span class="main">=</span>
      <span class="entity">lthy</span>
      |&gt; Local_Theory.exit_global
      |&gt; <span class="entity">Class.instantiation</span> <span class="main">(</span><span class="entity">qfull_ty_names</span><span class="main">,</span> <span class="entity">tvs</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">fs</span><span class="antiquote">}</span></span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
      <span class="entity">Class.intro_classes_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> THEN
        <span class="main">(</span>ALLGOALS <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="entity">qfsupp_thms</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">lthy1</span>
    |&gt; <span class="entity">Class.prove_instantiation_exit</span> <span class="entity">tac</span>
    |&gt; <span class="entity">Named_Target.theory_init</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="comment1">(* proves that fv and fv_bn equals supp *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">gen_mk_goals</span> <span class="entity">fv</span> <span class="entity">supp</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg_ty</span> <span class="main">=</span>
      fastype_of <span class="entity">fv</span>
      |&gt; domain_type
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="entity">arg_ty</span><span class="main">,</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">fv</span> $ <span class="entity">x</span><span class="main">,</span> <span class="entity">supp</span> <span class="entity">x</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_fvs_goals</span> <span class="entity">fv</span> <span class="main">=</span> <span class="entity">gen_mk_goals</span> <span class="entity">fv</span> <span class="entity">mk_supp</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_fv_bns_goals</span> <span class="entity">fv_bn</span> <span class="entity">alpha_bn</span> <span class="main">=</span> <span class="entity">gen_mk_goals</span> <span class="entity">fv_bn</span> <span class="main">(</span><span class="entity">mk_supp_rel</span> <span class="entity">alpha_bn</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_simpset</span> <span class="entity">ctxt</span> <span class="entity">thms</span> <span class="main">=</span> put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span> addsimps <span class="entity">thms</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">symmetric</span> <span class="entity">thms</span> <span class="main">=</span>
  map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">thm</span> <span class="main">=&gt;</span> <span class="entity">thm</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> sym<span class="antiquote">}</span></span></span><span class="main">)</span> <span class="entity">thms</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">supp_Abs_set</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> supp_Abs<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span><span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">supp_Abs_res</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> supp_Abs<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span><span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">supp_Abs_lst</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> supp_Abs<span class="main">(</span>3<span class="main">)</span><span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span><span class="antiquote">}</span></span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_supp_abs</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">BC</span> <span class="main">(</span><span class="entity">Set</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">EqSubst.eqsubst_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span> <span class="entity">supp_Abs_set</span>
  <span class="main">|</span> <span class="entity">mk_supp_abs</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">BC</span> <span class="main">(</span><span class="entity">Res</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">EqSubst.eqsubst_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span> <span class="entity">supp_Abs_res</span>
  <span class="main">|</span> <span class="entity">mk_supp_abs</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">BC</span> <span class="main">(</span><span class="entity">Lst</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">EqSubst.eqsubst_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span> <span class="entity">supp_Abs_lst</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_supp_abs_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="main">]</span>
  <span class="main">|</span> <span class="entity">mk_supp_abs_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">BC</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span>::<span class="entity">xs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mk_supp_abs_tac</span> <span class="entity">ctxt</span> <span class="entity">xs</span>
  <span class="main">|</span> <span class="entity">mk_supp_abs_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">bc</span>::<span class="entity">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>DETERM o <span class="entity">mk_supp_abs</span> <span class="entity">ctxt</span> <span class="entity">bc</span><span class="main">)</span>::<span class="entity">mk_supp_abs_tac</span> <span class="entity">ctxt</span> <span class="entity">xs</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_bn_supp_abs_tac</span> <span class="entity">ctxt</span> <span class="entity">trm</span> <span class="main">=</span>
  <span class="entity">trm</span>
  |&gt; fastype_of
  |&gt; body_type
  |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ty</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ty</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"atom set"</span><span class="antiquote">}</span></span>  <span class="main">=&gt;</span> <span class="entity">simp_tac</span> <span class="main">(</span><span class="entity">add_simpset</span> <span class="entity">ctxt</span> <span class="entity">supp_Abs_set</span><span class="main">)</span>
      <span class="main">|</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"atom list"</span><span class="antiquote">}</span></span> <span class="main">=&gt;</span> <span class="entity">simp_tac</span> <span class="main">(</span><span class="entity">add_simpset</span> <span class="entity">ctxt</span> <span class="entity">supp_Abs_lst</span><span class="main">)</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> TERM <span class="main">(</span><span class="inner_quoted">"mk_bn_supp_abs_tac"</span><span class="main">,</span> <span class="main">[</span><span class="entity">trm</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>


<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thms1</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> supp_Pair supp_eqvt<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> Un_assoc conj_assoc<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thms2</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> de_Morgan_conj Collect_disj_eq finite_Un<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thms3</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> alphas prod_alpha_def prod_fv.simps rel_prod_conv permute_prod_def
  prod.rec prod.case prod.inject not_True_eq_False empty_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> finite.emptyI<span class="antiquote">}</span></span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_fv_supp</span> <span class="entity">qtys</span> <span class="entity">qtrms</span> <span class="entity">fvs</span> <span class="entity">fv_bns</span> <span class="entity">alpha_bns</span> <span class="entity">fv_simps</span> <span class="entity">eq_iffs</span> <span class="entity">perm_simps</span>
  <span class="entity">fv_bn_eqvts</span> <span class="entity">qinduct</span> <span class="entity">bclausess</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goals1</span> <span class="main">=</span> map <span class="entity">mk_fvs_goals</span> <span class="entity">fvs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goals2</span> <span class="main">=</span> map2 <span class="entity">mk_fv_bns_goals</span> <span class="entity">fv_bns</span> <span class="entity">alpha_bns</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
      SUBGOAL <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">goal</span><span class="main">,</span> <span class="entity">i</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">fv_fun</span><span class="main">,</span> <span class="entity">arg</span><span class="main">)</span> <span class="main">=</span>
            <span class="entity">goal</span> |&gt; Envir.eta_contract
                 |&gt; Logic.strip_assums_concl
                 |&gt; <span class="entity">HOLogic.dest_Trueprop</span>
                 |&gt; fst o <span class="entity">HOLogic.dest_eq</span>
                 |&gt; dest_comb
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">supp_abs_tac</span> <span class="main">=</span>
            <span class="keyword2"><span class="keyword">case</span></span> <span class="main">(</span>AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span><span class="main">)</span> <span class="main">(</span><span class="entity">qtrms</span> ~~ <span class="entity">bclausess</span><span class="main">)</span> <span class="main">(</span>head_of <span class="entity">arg</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
              SOME <span class="entity">bclauses</span> <span class="main">=&gt;</span> EVERY' <span class="main">(</span><span class="entity">mk_supp_abs_tac</span> <span class="entity">ctxt</span> <span class="entity">bclauses</span><span class="main">)</span>
            <span class="main">|</span> NONE <span class="main">=&gt;</span> <span class="entity">mk_bn_supp_abs_tac</span> <span class="entity">ctxt</span> <span class="entity">fv_fun</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eqvt_rconfig</span> <span class="main">=</span> <span class="entity">eqvt_relaxed_config</span> <span class="entity">addpres</span> <span class="main">(</span><span class="entity">perm_simps</span> @ <span class="entity">fv_bn_eqvts</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          EVERY' <span class="main">[</span> TRY o <span class="entity">asm_full_simp_tac</span> <span class="main">(</span><span class="entity">add_simpset</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> supp_Pair<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span><span class="antiquote">}</span></span></span>::<span class="entity">fv_simps</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
                   TRY o <span class="entity">supp_abs_tac</span><span class="main">,</span>
                   TRY o <span class="entity">simp_tac</span> <span class="main">(</span><span class="entity">add_simpset</span> <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> supp_def supp_rel_def<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span>
                   TRY o <span class="entity">eqvt_tac</span> <span class="entity">ctxt</span> <span class="entity">eqvt_rconfig</span><span class="main">,</span>
                   TRY o <span class="entity">simp_tac</span> <span class="main">(</span><span class="entity">add_simpset</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> Abs_eq_iff<span class="antiquote">}</span></span></span> @ <span class="entity">eq_iffs</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
                   TRY o <span class="entity">asm_full_simp_tac</span> <span class="main">(</span><span class="entity">add_simpset</span> <span class="entity">ctxt</span> <span class="entity">thms3</span><span class="main">)</span><span class="main">,</span>
                   TRY o <span class="entity">simp_tac</span> <span class="main">(</span><span class="entity">add_simpset</span> <span class="entity">ctxt</span> <span class="entity">thms2</span><span class="main">)</span><span class="main">,</span>
                   TRY o <span class="entity">asm_full_simp_tac</span> <span class="main">(</span><span class="entity">add_simpset</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">thms1</span> @ <span class="main">(</span><span class="entity">symmetric</span> <span class="entity">fv_bn_eqvts</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">]</span> <span class="entity">i</span>
        <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">induct_prove</span> <span class="entity">qtys</span> <span class="main">(</span><span class="entity">goals1</span> @ <span class="entity">goals2</span><span class="main">)</span> <span class="entity">qinduct</span> <span class="entity">tac</span> <span class="entity">ctxt</span>
    |&gt; map <span class="main">(</span><span class="entity">atomize</span> <span class="entity">ctxt</span><span class="main">)</span>
    |&gt; map <span class="main">(</span><span class="entity">simplify</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span> addsimps <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> fun_eq_iff<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span><span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_bns_finite</span> <span class="entity">qtys</span> <span class="entity">qbns</span> <span class="entity">qinduct</span> <span class="entity">qbn_simps</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_goal</span> <span class="entity">qbn</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg_ty</span> <span class="main">=</span> domain_type <span class="main">(</span>fastype_of <span class="entity">qbn</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">finite</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"finite <span class="main">::</span> atom set <span class="main">=&gt;</span> bool"</span><span class="antiquote">}</span></span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="entity">arg_ty</span><span class="main">,</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="entity">finite</span> $ <span class="main">(</span><span class="entity">to_set</span> <span class="main">(</span><span class="entity">qbn</span> $ <span class="entity">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">props</span> <span class="main">=</span> map <span class="entity">mk_goal</span> <span class="entity">qbns</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ss_tac</span> <span class="main">=</span> <span class="entity">asm_full_simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span> addsimps <span class="main">(</span><span class="entity">qbn_simps</span> @
      <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> set_simps set_append finite_insert finite.emptyI finite_Un<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">induct_prove</span> <span class="entity">qtys</span> <span class="entity">props</span> <span class="entity">qinduct</span> <span class="main">(</span>K <span class="entity">ss_tac</span><span class="main">)</span> <span class="entity">ctxt</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_perm_bn_alpha_thms</span> <span class="entity">qtys</span> <span class="entity">qperm_bns</span> <span class="entity">alpha_bns</span> <span class="entity">qinduct</span> <span class="entity">qperm_bn_simps</span> <span class="entity">qeq_iffs</span> <span class="entity">qalpha_refls</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">[</span><span class="entity">p</span><span class="main">]</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> Variable.variant_fixes <span class="main">[</span><span class="inner_quoted">"p"</span><span class="main">]</span> <span class="entity">ctxt</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">p</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">p</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">perm</span><span class="antiquote">}</span></span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_goal</span> <span class="entity">qperm_bn</span> <span class="entity">alpha_bn</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg_ty</span> <span class="main">=</span> domain_type <span class="main">(</span>fastype_of <span class="entity">alpha_bn</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="entity">arg_ty</span><span class="main">,</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">mk_id</span> <span class="main">(</span>Abs <span class="main">(</span><span class="inner_quoted">""</span><span class="main">,</span> <span class="entity">arg_ty</span><span class="main">,</span> <span class="entity">alpha_bn</span> $ Bound <span class="inner_numeral">0</span> $ <span class="main">(</span><span class="entity">qperm_bn</span> $ <span class="entity">p</span> $ Bound <span class="inner_numeral">0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> $ <span class="entity">x</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">props</span> <span class="main">=</span> map2 <span class="entity">mk_goal</span> <span class="entity">qperm_bns</span> <span class="entity">alpha_bns</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ss</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> id_def<span class="antiquote">}</span></span></span>::<span class="entity">qperm_bn_simps</span> @ <span class="entity">qeq_iffs</span> @ <span class="entity">qalpha_refls</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ss_tac</span> <span class="main">=</span> <span class="entity">asm_full_simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_ss</span> <span class="entity">ctxt</span> addsimps <span class="entity">ss</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">induct_prove</span> <span class="entity">qtys</span> <span class="entity">props</span> <span class="entity">qinduct</span> <span class="main">(</span>K <span class="entity">ss_tac</span><span class="main">)</span> <span class="entity">ctxt'</span>
    |&gt; Proof_Context.export <span class="entity">ctxt'</span> <span class="entity">ctxt</span>
    |&gt; map <span class="main">(</span><span class="entity">simplify</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span> addsimps <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> id_def<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_permute_bn_thms</span> <span class="entity">qtys</span> <span class="entity">qbns</span> <span class="entity">qperm_bns</span> <span class="entity">qinduct</span> <span class="entity">qperm_bn_simps</span> <span class="entity">qbn_defs</span> <span class="entity">qbn_eqvts</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">[</span><span class="entity">p</span><span class="main">]</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> Variable.variant_fixes <span class="main">[</span><span class="inner_quoted">"p"</span><span class="main">]</span> <span class="entity">ctxt</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">p</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">p</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">perm</span><span class="antiquote">}</span></span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_goal</span> <span class="entity">qbn</span> <span class="entity">qperm_bn</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg_ty</span> <span class="main">=</span> domain_type <span class="main">(</span>fastype_of <span class="entity">qbn</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="entity">arg_ty</span><span class="main">,</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span>
          <span class="main">(</span><span class="entity">mk_id</span> <span class="main">(</span>Abs <span class="main">(</span><span class="inner_quoted">""</span><span class="main">,</span> <span class="entity">arg_ty</span><span class="main">,</span>
             <span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">mk_perm</span> <span class="entity">p</span> <span class="main">(</span><span class="entity">qbn</span> $ Bound <span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span> <span class="entity">qbn</span> $ <span class="main">(</span><span class="entity">qperm_bn</span> $ <span class="entity">p</span> $ Bound <span class="inner_numeral">0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> $ <span class="entity">x</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">props</span> <span class="main">=</span> map2 <span class="entity">mk_goal</span> <span class="entity">qbns</span> <span class="entity">qperm_bns</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ss</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> id_def<span class="antiquote">}</span></span></span>::<span class="entity">qperm_bn_simps</span> @ <span class="entity">qbn_defs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ss_tac</span> <span class="main">=</span>
      EVERY' <span class="main">[</span><span class="entity">asm_full_simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt'</span> addsimps <span class="entity">ss</span><span class="main">)</span><span class="main">,</span>
              TRY o <span class="entity">eqvt_tac</span> <span class="entity">ctxt'</span> <span class="main">(</span><span class="entity">eqvt_strict_config</span> <span class="entity">addpres</span> <span class="entity">qbn_eqvts</span><span class="main">)</span><span class="main">,</span>
              TRY o <span class="entity">asm_full_simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt'</span><span class="main">)</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">induct_prove</span> <span class="entity">qtys</span> <span class="entity">props</span> <span class="entity">qinduct</span> <span class="main">(</span>K <span class="entity">ss_tac</span><span class="main">)</span> <span class="entity">ctxt'</span>
    |&gt; Proof_Context.export <span class="entity">ctxt'</span> <span class="entity">ctxt</span>
    |&gt; map <span class="main">(</span><span class="entity">simplify</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span> addsimps <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> id_def<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>



<span class="comment1">(*** proves strong exhauts theorems ***)</span>

<span class="comment1">(* fixme: move into nominal_library *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">abs_const</span> <span class="entity">bmode</span> <span class="entity">ty</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">const_name</span><span class="main">,</span> <span class="entity">binder_ty</span><span class="main">,</span> <span class="entity">abs_ty</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">bmode</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">Lst</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "Abs_lst"<span class="antiquote">}</span></span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"atom list"</span><span class="antiquote">}</span></span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> abs_lst<span class="antiquote">}</span></span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">Set</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "Abs_set"<span class="antiquote">}</span></span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"atom set"</span><span class="antiquote">}</span></span><span class="main">,</span>  <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> abs_set<span class="antiquote">}</span></span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">Res</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "Abs_res"<span class="antiquote">}</span></span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"atom set"</span><span class="antiquote">}</span></span><span class="main">,</span>  <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> abs_res<span class="antiquote">}</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Const <span class="main">(</span><span class="entity">const_name</span><span class="main">,</span> <span class="main">[</span><span class="entity">binder_ty</span><span class="main">,</span> <span class="entity">ty</span><span class="main">]</span> ---&gt; Type <span class="main">(</span><span class="entity">abs_ty</span><span class="main">,</span> <span class="main">[</span><span class="entity">ty</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_abs</span> <span class="entity">bmode</span> <span class="entity">trm1</span> <span class="entity">trm2</span> <span class="main">=</span>
  <span class="entity">abs_const</span> <span class="entity">bmode</span> <span class="main">(</span>fastype_of <span class="entity">trm2</span><span class="main">)</span> $ <span class="entity">trm1</span> $ <span class="entity">trm2</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_abs_eq</span> <span class="entity">thm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_abs</span> <span class="entity">trm</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="main">(</span>head_of <span class="entity">trm</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
        Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "Abs_set"<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> true
      <span class="main">|</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "Abs_lst"<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> true
      <span class="main">|</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "Abs_res"<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> true
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">thm</span> |&gt; Thm.prop_of
        |&gt; <span class="entity">HOLogic.dest_Trueprop</span>
        |&gt; <span class="entity">HOLogic.dest_eq</span>
        |&gt; fst
        |&gt; <span class="entity">is_abs</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="comment1">(* adds a freshness condition to the assumptions *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_ecase_prems</span> <span class="entity">lthy</span> <span class="entity">c</span> <span class="main">(</span><span class="entity">params</span><span class="main">,</span> <span class="entity">prems</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span> <span class="entity">bclauses</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tys</span> <span class="main">=</span> map snd <span class="entity">params</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">binders</span> <span class="main">=</span> <span class="entity">get_all_binders</span> <span class="entity">bclauses</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prep_binder</span> <span class="main">(</span><span class="entity">opt</span><span class="main">,</span> <span class="entity">i</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Bound <span class="main">(</span>length <span class="entity">tys</span> - <span class="entity">i</span> - <span class="inner_numeral">1</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">opt</span> <span class="keyword2"><span class="keyword">of</span></span>
          NONE <span class="main">=&gt;</span> <span class="entity">setify_ty</span> <span class="entity">lthy</span> <span class="main">(</span>nth <span class="entity">tys</span> <span class="entity">i</span><span class="main">)</span> <span class="entity">t</span>
        <span class="main">|</span> SOME <span class="entity">bn</span> <span class="main">=&gt;</span> <span class="entity">to_set_ty</span> <span class="main">(</span>fastype_of1 <span class="main">(</span><span class="entity">tys</span><span class="main">,</span> <span class="entity">bn</span> $ <span class="entity">t</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">bn</span> $ <span class="entity">t</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prems'</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">binders</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="entity">prems</span>                        <span class="comment1">(* case: no binders *)</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">binders</span>                       <span class="comment1">(* case: binders *)</span>
          |&gt; map <span class="entity">prep_binder</span>
          |&gt; <span class="entity">fold_union_env</span> <span class="entity">tys</span>
          |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> <span class="entity">mk_fresh_star</span> <span class="entity">t</span> <span class="entity">c</span><span class="main">)</span>
          |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="entity">t</span> :: <span class="entity">prems</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">mk_full_horn</span> <span class="entity">params</span> <span class="entity">prems'</span> <span class="entity">concl</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="comment1">(* derives the freshness theorem that there exists a p, such that
   (p o as) #* (c, t1,..., tn) *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">fresh_thm</span> <span class="entity">ctxt</span> <span class="entity">c</span> <span class="entity">parms</span> <span class="entity">binders</span> <span class="entity">bn_finite_thms</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prep_binder</span> <span class="main">(</span><span class="entity">opt</span><span class="main">,</span> <span class="entity">i</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">opt</span> <span class="keyword2"><span class="keyword">of</span></span>
        NONE <span class="main">=&gt;</span> <span class="entity">setify</span> <span class="entity">ctxt</span> <span class="main">(</span>nth <span class="entity">parms</span> <span class="entity">i</span><span class="main">)</span>
      <span class="main">|</span> SOME <span class="entity">bn</span> <span class="main">=&gt;</span> <span class="entity">to_set</span> <span class="main">(</span><span class="entity">bn</span> $ <span class="main">(</span>nth <span class="entity">parms</span> <span class="entity">i</span><span class="main">)</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prep_binder2</span> <span class="main">(</span><span class="entity">opt</span><span class="main">,</span> <span class="entity">i</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">opt</span> <span class="keyword2"><span class="keyword">of</span></span>
        NONE <span class="main">=&gt;</span> <span class="entity">atomify</span> <span class="entity">ctxt</span> <span class="main">(</span>nth <span class="entity">parms</span> <span class="entity">i</span><span class="main">)</span>
      <span class="main">|</span> SOME <span class="entity">bn</span> <span class="main">=&gt;</span> <span class="entity">bn</span> $ <span class="main">(</span>nth <span class="entity">parms</span> <span class="entity">i</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> <span class="entity">HOLogic.mk_tuple</span> <span class="main">(</span><span class="main">[</span><span class="entity">c</span><span class="main">]</span> @ <span class="entity">parms</span> @ <span class="main">(</span>map <span class="entity">prep_binder2</span> <span class="entity">binders</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs</span> <span class="main">=</span> <span class="entity">binders</span>
      |&gt; map <span class="entity">prep_binder</span>
      |&gt; <span class="entity">fold_union</span>
      |&gt; <span class="entity">mk_perm</span> <span class="main">(</span>Bound <span class="inner_numeral">0</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goal</span> <span class="main">=</span> <span class="entity">mk_fresh_star</span> <span class="entity">lhs</span> <span class="entity">rhs</span>
      |&gt; <span class="entity">mk_exists</span> <span class="main">(</span><span class="inner_quoted">"p"</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">perm</span><span class="antiquote">}</span></span><span class="main">)</span>
      |&gt; <span class="entity">HOLogic.mk_Trueprop</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ss</span> <span class="main">=</span> <span class="entity">bn_finite_thms</span> @ <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> supp_Pair finite_supp finite_sets_supp<span class="antiquote">}</span></span></span>
      @ <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> finite.intros finite_Un finite_set finite_fset<span class="antiquote">}</span></span></span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Goal.prove <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">goal</span>
      <span class="main">(</span>K <span class="main">(</span>HEADGOAL <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> at_set_avoiding1<span class="antiquote">}</span></span></span>
          THEN_ALL_NEW <span class="main">(</span><span class="entity">simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_ss</span> <span class="entity">ctxt</span> addsimps <span class="entity">ss</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="comment1">(* derives an abs_eq theorem of the form

   Exists q. [as].x = [p o as].(q o x)  for non-recursive binders
   Exists q. [as].x = [q o as].(q o x)  for recursive binders
*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">abs_eq_thm</span> <span class="entity">ctxt</span> <span class="entity">fprops</span> <span class="entity">p</span> <span class="entity">parms</span> <span class="entity">bn_eqvt</span> <span class="entity">permute_bns</span> <span class="main">(</span><span class="entity">bclause</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">(</span><span class="entity">BC</span> <span class="main">(</span><span class="entity">bmode</span><span class="main">,</span> <span class="entity">binders</span><span class="main">,</span> <span class="entity">bodies</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">binders</span> <span class="keyword2"><span class="keyword">of</span></span>
    <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span>
  <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rec_flag</span> <span class="main">=</span> <span class="entity">is_recursive_binder</span> <span class="entity">bclause</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">binder_trm</span> <span class="main">=</span> <span class="entity">comb_binders</span> <span class="entity">ctxt</span> <span class="entity">bmode</span> <span class="entity">parms</span> <span class="entity">binders</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">body_trm</span> <span class="main">=</span> foldl1 <span class="entity">HOLogic.mk_prod</span> <span class="main">(</span>map <span class="main">(</span>nth <span class="entity">parms</span><span class="main">)</span> <span class="entity">bodies</span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">abs_lhs</span> <span class="main">=</span> <span class="entity">mk_abs</span> <span class="entity">bmode</span> <span class="entity">binder_trm</span> <span class="entity">body_trm</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">abs_rhs</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">rec_flag</span>
          <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">mk_abs</span> <span class="entity">bmode</span> <span class="main">(</span><span class="entity">mk_perm</span> <span class="main">(</span>Bound <span class="inner_numeral">0</span><span class="main">)</span> <span class="entity">binder_trm</span><span class="main">)</span> <span class="main">(</span><span class="entity">mk_perm</span> <span class="main">(</span>Bound <span class="inner_numeral">0</span><span class="main">)</span> <span class="entity">body_trm</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">mk_abs</span> <span class="entity">bmode</span> <span class="main">(</span><span class="entity">mk_perm</span> <span class="entity">p</span> <span class="entity">binder_trm</span><span class="main">)</span> <span class="main">(</span><span class="entity">mk_perm</span> <span class="main">(</span>Bound <span class="inner_numeral">0</span><span class="main">)</span> <span class="entity">body_trm</span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">abs_eq</span> <span class="main">=</span> <span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">abs_lhs</span><span class="main">,</span> <span class="entity">abs_rhs</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">peq</span> <span class="main">=</span> <span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">mk_perm</span> <span class="main">(</span>Bound <span class="inner_numeral">0</span><span class="main">)</span> <span class="entity">binder_trm</span><span class="main">,</span> <span class="entity">mk_perm</span> <span class="entity">p</span> <span class="entity">binder_trm</span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goal</span> <span class="main">=</span> <span class="entity">HOLogic.mk_conj</span> <span class="main">(</span><span class="entity">abs_eq</span><span class="main">,</span> <span class="entity">peq</span><span class="main">)</span>
          |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> <span class="entity">HOLogic.mk_exists</span> <span class="main">(</span><span class="inner_quoted">"q"</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"perm"</span><span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span>
          |&gt; <span class="entity">HOLogic.mk_Trueprop</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ss</span> <span class="main">=</span> <span class="entity">fprops</span> @ <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> set_simps set_append union_eqvt<span class="antiquote">}</span></span></span>
          @ <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> fresh_star_Un fresh_star_Pair fresh_star_list fresh_star_singleton fresh_star_fset
          fresh_star_set<span class="antiquote">}</span></span></span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tac1</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">rec_flag</span>
          <span class="keyword2"><span class="keyword">then</span></span> resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> Abs_rename_set' Abs_rename_res' Abs_rename_lst'<span class="antiquote">}</span></span></span>
          <span class="keyword2"><span class="keyword">else</span></span> resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> Abs_rename_set  Abs_rename_res  Abs_rename_lst<span class="antiquote">}</span></span></span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tac2</span> <span class="main">=</span>
          EVERY' <span class="main">[</span><span class="entity">simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span> addsimps <span class="entity">ss</span><span class="main">)</span><span class="main">,</span>
            TRY o <span class="entity">simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_ss</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">]</span>
     <span class="keyword2"><span class="keyword">in</span></span>
       <span class="main">[</span> Goal.prove <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">goal</span> <span class="main">(</span>K <span class="main">(</span>HEADGOAL <span class="main">(</span><span class="entity">tac1</span> THEN_ALL_NEW <span class="entity">tac2</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
         |&gt; <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">rec_flag</span>
             <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">eqvt_rule</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">eqvt_strict_config</span> <span class="entity">addpres</span> <span class="entity">bn_eqvt</span><span class="main">)</span>
             <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">eqvt_rule</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">eqvt_strict_config</span> <span class="entity">addpres</span> <span class="entity">permute_bns</span><span class="main">)</span><span class="main">)</span> <span class="main">]</span>
     <span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">setify</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">lemma</span> <span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="free">ys</span> <span class="main">==&gt;</span> set <span class="free">xs</span> <span class="main">=</span> set <span class="free">ys</span>"</span> <span class="keyword1"><span class="keyword">by</span></span> <span class="operator">simp</span><span class="antiquote">}</span></span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">case_tac</span> <span class="entity">ctxt</span> <span class="entity">c</span> <span class="entity">bn_finite_thms</span> <span class="entity">eq_iff_thms</span> <span class="entity">bn_eqvt</span> <span class="entity">permute_bns</span> <span class="entity">perm_bn_alphas</span>
  <span class="entity">prems</span> <span class="entity">bclausess</span> <span class="entity">qexhaust_thm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">aux_tac</span> <span class="entity">prem</span> <span class="entity">bclauses</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="main">(</span><span class="entity">get_all_binders</span> <span class="entity">bclauses</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> EVERY' <span class="main">[</span>resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">prem</span><span class="main">]</span><span class="main">,</span> assume_tac <span class="entity">ctxt</span><span class="main">]</span>
      <span class="main">|</span> <span class="entity">binders</span> <span class="main">=&gt;</span> <span class="entity">Subgoal.SUBPROOF</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span><span class="entity">params</span><span class="main">,</span> <span class="entity">prems</span><span class="main">,</span> <span class="entity">concl</span><span class="main">,</span> context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parms</span> <span class="main">=</span> map <span class="main">(</span>Thm.term_of o snd<span class="main">)</span> <span class="entity">params</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fthm</span> <span class="main">=</span> <span class="entity">fresh_thm</span> <span class="entity">ctxt</span> <span class="entity">c</span> <span class="entity">parms</span> <span class="entity">binders</span> <span class="entity">bn_finite_thms</span>

            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ss</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> fresh_star_Pair union_eqvt fresh_star_Un<span class="antiquote">}</span></span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="main">[</span><span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">fperm</span><span class="main">)</span><span class="main">]</span><span class="main">,</span> <span class="entity">fprops</span><span class="main">)</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Obtain.result</span>
              <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt'</span> <span class="main">=&gt;</span> EVERY1 <span class="main">[</span>eresolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">exE</span><span class="main">]</span><span class="main">,</span>
                            <span class="entity">full_simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt'</span> addsimps <span class="entity">ss</span><span class="main">)</span><span class="main">,</span>
                            REPEAT o <span class="main">(</span>eresolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> conjE<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="main">[</span><span class="entity">fthm</span><span class="main">]</span> <span class="entity">ctxt</span>

            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">abs_eq_thms</span> <span class="main">=</span> flat
             <span class="main">(</span>map <span class="main">(</span><span class="entity">abs_eq_thm</span> <span class="entity">ctxt'</span> <span class="entity">fprops</span> <span class="main">(</span>Thm.term_of <span class="entity">fperm</span><span class="main">)</span> <span class="entity">parms</span> <span class="entity">bn_eqvt</span> <span class="entity">permute_bns</span><span class="main">)</span> <span class="entity">bclauses</span><span class="main">)</span>

            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">eqs</span><span class="main">)</span><span class="main">,</span> <span class="entity">ctxt''</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Obtain.result</span>
              <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt''</span> <span class="main">=&gt;</span> EVERY1
                   <span class="main">[</span> REPEAT o <span class="main">(</span>eresolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> exE<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span>
                     REPEAT o <span class="main">(</span>eresolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> conjE<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span>
                     REPEAT o <span class="main">(</span>dresolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">setify</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
                     <span class="entity">full_simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt''</span>
                      addsimps <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> set_append set_simps<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="entity">abs_eq_thms</span> <span class="entity">ctxt'</span>

            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">abs_eqs</span><span class="main">,</span> <span class="entity">peqs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">split_filter</span> <span class="entity">is_abs_eq</span> <span class="entity">eqs</span>

            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fprops'</span> <span class="main">=</span>
              map <span class="main">(</span><span class="entity">eqvt_rule</span> <span class="entity">ctxt''</span> <span class="main">(</span><span class="entity">eqvt_strict_config</span> <span class="entity">addpres</span> <span class="entity">permute_bns</span><span class="main">)</span><span class="main">)</span> <span class="entity">fprops</span>
              @ map <span class="main">(</span><span class="entity">eqvt_rule</span> <span class="entity">ctxt''</span> <span class="main">(</span><span class="entity">eqvt_strict_config</span> <span class="entity">addpres</span> <span class="entity">bn_eqvt</span><span class="main">)</span><span class="main">)</span> <span class="entity">fprops</span>

            <span class="comment1">(* for freshness conditions *)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tac1</span> <span class="main">=</span> SOLVED' <span class="main">(</span>EVERY'
              <span class="main">[</span> <span class="entity">simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt''</span> addsimps <span class="entity">peqs</span><span class="main">)</span><span class="main">,</span>
                rewrite_goal_tac <span class="entity">ctxt''</span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> fresh_star_Un<span class="main">[</span><span class="operator">THEN</span> eq_reflection<span class="main">]</span><span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span>
                <span class="entity">conj_tac</span> <span class="entity">ctxt''</span> <span class="main">(</span>DETERM o resolve_tac <span class="entity">ctxt''</span> <span class="entity">fprops'</span><span class="main">)</span> <span class="main">]</span><span class="main">)</span>

            <span class="comment1">(* for equalities between constructors *)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tac2</span> <span class="main">=</span> SOLVED' <span class="main">(</span>EVERY'
              <span class="main">[</span> resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> ssubst<span class="antiquote">}</span></span></span> OF <span class="entity">prems</span><span class="main">]</span><span class="main">,</span>
                rewrite_goal_tac <span class="entity">ctxt''</span> <span class="main">(</span>map <span class="entity">safe_mk_equiv</span> <span class="entity">eq_iff_thms</span><span class="main">)</span><span class="main">,</span>
                rewrite_goal_tac <span class="entity">ctxt''</span> <span class="main">(</span>map <span class="entity">safe_mk_equiv</span> <span class="entity">abs_eqs</span><span class="main">)</span><span class="main">,</span>
                <span class="entity">conj_tac</span> <span class="entity">ctxt''</span> <span class="main">(</span>DETERM o resolve_tac <span class="entity">ctxt''</span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> refl<span class="antiquote">}</span></span></span> @ <span class="entity">perm_bn_alphas</span><span class="main">)</span><span class="main">)</span> <span class="main">]</span><span class="main">)</span>

            <span class="comment1">(* proves goal "P" *)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">side_thm</span> <span class="main">=</span> Goal.prove <span class="entity">ctxt''</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span>Thm.term_of <span class="entity">concl</span><span class="main">)</span>
              <span class="main">(</span>K <span class="main">(</span>EVERY1 <span class="main">[</span> resolve_tac <span class="entity">ctxt''</span> <span class="main">[</span><span class="entity">prem</span><span class="main">]</span><span class="main">,</span> RANGE <span class="main">[</span><span class="entity">tac1</span><span class="main">,</span> <span class="entity">tac2</span><span class="main">]</span> <span class="main">]</span><span class="main">)</span><span class="main">)</span>
              |&gt; singleton <span class="main">(</span>Proof_Context.export <span class="entity">ctxt''</span> <span class="entity">ctxt</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">side_thm</span><span class="main">]</span> <span class="inner_numeral">1</span>
          <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span> <span class="entity">ctxt</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    EVERY1 <span class="main">[</span>resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">qexhaust_thm</span><span class="main">]</span><span class="main">,</span> RANGE <span class="main">(</span>map2 <span class="entity">aux_tac</span> <span class="entity">prems</span> <span class="entity">bclausess</span><span class="main">)</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_strong_exhausts</span> <span class="entity">lthy</span> <span class="entity">exhausts</span> <span class="entity">bclausesss</span> <span class="entity">bn_finite_thms</span> <span class="entity">eq_iff_thms</span> <span class="entity">bn_eqvt</span> <span class="entity">permute_bns</span>
  <span class="entity">perm_bn_alphas</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">exhausts'</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span> Variable.import true <span class="entity">exhausts</span> <span class="entity">lthy</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">[</span><span class="entity">c</span><span class="main">,</span> <span class="entity">a</span><span class="main">]</span><span class="main">,</span> <span class="entity">lthy''</span><span class="main">)</span> <span class="main">=</span> Variable.variant_fixes <span class="main">[</span><span class="inner_quoted">"c"</span><span class="main">,</span> <span class="inner_quoted">"'a"</span><span class="main">]</span> <span class="entity">lthy'</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">c</span><span class="main">,</span> TFree <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">fs</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ecases</span><span class="main">,</span> <span class="entity">main_concls</span><span class="main">)</span> <span class="main">=</span> <span class="entity">exhausts'</span> <span class="comment1">(* ecases are of the form (params, prems, concl) *)</span>
      |&gt; map Thm.prop_of
      |&gt; map Logic.strip_horn
      |&gt; split_list

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ecases'</span> <span class="main">=</span> <span class="main">(</span>map o map<span class="main">)</span> <span class="entity">strip_full_horn</span> <span class="entity">ecases</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">premss</span> <span class="main">=</span> <span class="main">(</span>map2 o map2<span class="main">)</span> <span class="main">(</span><span class="entity">mk_ecase_prems</span> <span class="entity">lthy''</span> <span class="entity">c</span><span class="main">)</span> <span class="entity">ecases'</span> <span class="entity">bclausesss</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tac</span> <span class="entity">bclausess</span> <span class="entity">exhaust</span> <span class="main">{</span><span class="entity">prems</span><span class="main">,</span> <span class="entity">context</span><span class="main">}</span> <span class="main">=</span>
      <span class="entity">case_tac</span> <span class="entity">context</span> <span class="entity">c</span> <span class="entity">bn_finite_thms</span> <span class="entity">eq_iff_thms</span> <span class="entity">bn_eqvt</span> <span class="entity">permute_bns</span> <span class="entity">perm_bn_alphas</span>
        <span class="entity">prems</span> <span class="entity">bclausess</span> <span class="entity">exhaust</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove</span> <span class="entity">prems</span> <span class="entity">bclausess</span> <span class="entity">exhaust</span> <span class="entity">concl</span> <span class="main">=</span>
      Goal.prove <span class="entity">lthy''</span> <span class="main">[</span><span class="main">]</span> <span class="entity">prems</span> <span class="entity">concl</span> <span class="main">(</span><span class="entity">tac</span> <span class="entity">bclausess</span> <span class="entity">exhaust</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">map4</span> <span class="entity">prove</span> <span class="entity">premss</span> <span class="entity">bclausesss</span> <span class="entity">exhausts'</span> <span class="entity">main_concls</span>
    |&gt; Proof_Context.export <span class="entity">lthy''</span> <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">end</span></span>



<span class="comment1">(** strong induction theorems **)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_c_prop</span> <span class="entity">c</span> <span class="entity">c_ty</span> <span class="entity">trm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">P</span><span class="main">,</span> <span class="entity">arg</span><span class="main">)</span> <span class="main">=</span> dest_comb <span class="entity">trm</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">P_name</span><span class="main">,</span> <span class="entity">P_ty</span><span class="main">)</span> <span class="main">=</span> dest_Free <span class="entity">P</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ty_args</span><span class="main">,</span> <span class="entity">bool</span><span class="main">)</span> <span class="main">=</span> strip_type <span class="entity">P_ty</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Free <span class="main">(</span><span class="entity">P_name</span><span class="main">,</span> <span class="main">(</span><span class="entity">c_ty</span> :: <span class="entity">ty_args</span><span class="main">)</span> ---&gt; <span class="entity">bool</span><span class="main">)</span> $ <span class="entity">c</span> $ <span class="entity">arg</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_qnt_c_prop</span> <span class="entity">c_name</span> <span class="entity">c_ty</span> <span class="entity">trm</span> <span class="main">=</span>
  <span class="entity">trm</span> |&gt; <span class="entity">HOLogic.dest_Trueprop</span>
      |&gt; incr_boundvars <span class="inner_numeral">1</span>
      |&gt; <span class="entity">add_c_prop</span> <span class="main">(</span>Bound <span class="inner_numeral">0</span><span class="main">)</span> <span class="entity">c_ty</span>
      |&gt; <span class="entity">HOLogic.mk_Trueprop</span>
      |&gt; <span class="entity">mk_all</span> <span class="main">(</span><span class="entity">c_name</span><span class="main">,</span> <span class="entity">c_ty</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prep_prem</span> <span class="entity">lthy</span> <span class="entity">c</span> <span class="entity">c_name</span> <span class="entity">c_ty</span> <span class="entity">bclauses</span> <span class="main">(</span><span class="entity">params</span><span class="main">,</span> <span class="entity">prems</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tys</span> <span class="main">=</span> map snd <span class="entity">params</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">binders</span> <span class="main">=</span> <span class="entity">get_all_binders</span> <span class="entity">bclauses</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prep_binder</span> <span class="main">(</span><span class="entity">opt</span><span class="main">,</span> <span class="entity">i</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Bound <span class="main">(</span>length <span class="entity">tys</span> - <span class="entity">i</span> - <span class="inner_numeral">1</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">opt</span> <span class="keyword2"><span class="keyword">of</span></span>
          NONE <span class="main">=&gt;</span> <span class="entity">setify_ty</span> <span class="entity">lthy</span> <span class="main">(</span>nth <span class="entity">tys</span> <span class="entity">i</span><span class="main">)</span> <span class="entity">t</span>
        <span class="main">|</span> SOME <span class="entity">bn</span> <span class="main">=&gt;</span> <span class="entity">to_set_ty</span> <span class="main">(</span>fastype_of1 <span class="main">(</span><span class="entity">tys</span><span class="main">,</span> <span class="entity">bn</span> $ <span class="entity">t</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">bn</span> $ <span class="entity">t</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prems'</span> <span class="main">=</span> <span class="entity">prems</span>
      |&gt; map <span class="main">(</span>incr_boundvars <span class="inner_numeral">1</span><span class="main">)</span>
      |&gt; map <span class="main">(</span><span class="entity">add_qnt_c_prop</span> <span class="entity">c_name</span> <span class="entity">c_ty</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prems''</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">binders</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="entity">prems'</span>                       <span class="comment1">(* case: no binders *)</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">binders</span>                       <span class="comment1">(* case: binders *)</span>
          |&gt; map <span class="entity">prep_binder</span>
          |&gt; <span class="entity">fold_union_env</span> <span class="entity">tys</span>
          |&gt; incr_boundvars <span class="inner_numeral">1</span>
          |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> <span class="entity">mk_fresh_star_ty</span> <span class="entity">c_ty</span> <span class="entity">t</span> <span class="main">(</span>Bound <span class="inner_numeral">0</span><span class="main">)</span><span class="main">)</span>
          |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="entity">t</span> :: <span class="entity">prems'</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">concl'</span> <span class="main">=</span> <span class="entity">concl</span>
      |&gt; <span class="entity">HOLogic.dest_Trueprop</span>
      |&gt; incr_boundvars <span class="inner_numeral">1</span>
      |&gt; <span class="entity">add_c_prop</span> <span class="main">(</span>Bound <span class="inner_numeral">0</span><span class="main">)</span> <span class="entity">c_ty</span>
      |&gt; <span class="entity">HOLogic.mk_Trueprop</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">mk_full_horn</span> <span class="main">(</span><span class="entity">params</span> @ <span class="main">[</span><span class="main">(</span><span class="entity">c_name</span><span class="main">,</span> <span class="entity">c_ty</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="entity">prems''</span> <span class="entity">concl'</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_strong_induct</span> <span class="entity">lthy</span> <span class="entity">induct</span> <span class="entity">exhausts</span> <span class="entity">size_thms</span> <span class="entity">bclausesss</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">[</span><span class="entity">induct'</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span> Variable.import true <span class="main">[</span><span class="entity">induct</span><span class="main">]</span> <span class="entity">lthy</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">[</span><span class="entity">c_name</span><span class="main">,</span> <span class="entity">a</span><span class="main">]</span><span class="main">,</span> <span class="entity">lthy''</span><span class="main">)</span> <span class="main">=</span> Variable.variant_fixes <span class="main">[</span><span class="inner_quoted">"c"</span><span class="main">,</span> <span class="inner_quoted">"'a"</span><span class="main">]</span> <span class="entity">lthy'</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c_ty</span> <span class="main">=</span> TFree <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">fs</span><span class="antiquote">}</span></span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">c_name</span><span class="main">,</span> <span class="entity">c_ty</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">prems</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span> <span class="main">=</span> <span class="entity">induct'</span>
      |&gt; Thm.prop_of
      |&gt; Logic.strip_horn

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">concls</span> <span class="main">=</span> <span class="entity">concl</span>
      |&gt; <span class="entity">HOLogic.dest_Trueprop</span>
      |&gt; <span class="entity">HOLogic.dest_conj</span>
      |&gt; map <span class="main">(</span><span class="entity">add_c_prop</span> <span class="entity">c</span> <span class="entity">c_ty</span><span class="main">)</span>
      |&gt; map <span class="entity">HOLogic.mk_Trueprop</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prems'</span> <span class="main">=</span> <span class="entity">prems</span>
      |&gt; map <span class="entity">strip_full_horn</span>
      |&gt; map2 <span class="main">(</span><span class="entity">prep_prem</span> <span class="entity">lthy''</span> <span class="entity">c</span> <span class="entity">c_name</span> <span class="entity">c_ty</span><span class="main">)</span> <span class="main">(</span>flat <span class="entity">bclausesss</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pat_tac</span> <span class="entity">ctxt</span> <span class="entity">thm</span> <span class="main">=</span>
      <span class="entity">Subgoal.FOCUS</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span><span class="entity">params</span><span class="main">,</span> context <span class="main">=</span> <span class="entity">ctxt'</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty_parms</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span>fastype_of <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span><span class="main">)</span> <span class="entity">params</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vs</span> <span class="main">=</span> Term.add_vars <span class="main">(</span>Thm.prop_of <span class="entity">thm</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vs_tys</span> <span class="main">=</span> map <span class="main">(</span>Type.legacy_freeze_type o snd<span class="main">)</span> <span class="entity">vs</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">assigns</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">lookup</span> <span class="entity">ty_parms</span><span class="main">)</span> <span class="entity">vs_tys</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm'</span> <span class="main">=</span> infer_instantiate <span class="entity">ctxt'</span> <span class="main">(</span>map <span class="main">#</span><span class="inner_numeral">1</span> <span class="entity">vs</span> ~~ <span class="entity">assigns</span><span class="main">)</span> <span class="entity">thm</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          resolve_tac <span class="entity">ctxt'</span> <span class="main">[</span><span class="entity">thm'</span><span class="main">]</span> <span class="inner_numeral">1</span>
        <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span> <span class="entity">ctxt</span>
      THEN_ALL_NEW <span class="entity">asm_full_simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">size_simp_tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
      <span class="entity">simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">size_ss</span> <span class="entity">ctxt</span> addsimps <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> comp_def snd_conv<span class="antiquote">}</span></span></span> @ <span class="entity">size_thms</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Goal.prove_common <span class="entity">lthy''</span> NONE <span class="main">[</span><span class="main">]</span> <span class="entity">prems'</span> <span class="entity">concls</span>
      <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span><span class="entity">prems</span><span class="main">,</span> context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">}</span> <span class="main">=&gt;</span>
        <span class="entity">Induction_Schema.induction_schema_tac</span> <span class="entity">ctxt</span> <span class="entity">prems</span>
        THEN RANGE <span class="main">(</span>map <span class="main">(</span><span class="entity">pat_tac</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">exhausts</span><span class="main">)</span> <span class="inner_numeral">1</span>
        THEN <span class="entity">prove_termination_ind</span> <span class="entity">ctxt</span> <span class="inner_numeral">1</span>
        THEN ALLGOALS <span class="main">(</span><span class="entity">size_simp_tac</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span>
    |&gt; Proof_Context.export <span class="entity">lthy''</span> <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* structure *)</span>
</pre>
</div><div id="files/nominal_induct.ML">
<div class="head">
<h1>File ‹nominal_induct.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*  Author:     Christian Urban and Makarius

The nominal induct proof method.
*)</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">NominalInduct</span><span class="main">:</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> nominal_induct_tac<span class="main">:</span> bool <span class="main">-&gt;</span> <span class="main">(</span>binding option * <span class="main">(</span>term * bool<span class="main">)</span><span class="main">)</span> option list list <span class="main">-&gt;</span>
    <span class="main">(</span>string * typ<span class="main">)</span> list <span class="main">-&gt;</span> <span class="main">(</span>string * typ<span class="main">)</span> list list <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> int <span class="main">-&gt;</span> <span class="entity">context_tactic</span>
  <span class="keyword1"><span class="keyword">val</span></span> nominal_induct_method<span class="main">:</span> <span class="main">(</span><span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Proof.method</span><span class="main">)</span> context_parser
<span class="keyword2"><span class="keyword">end</span></span> <span class="main">=</span>

<span class="keyword2"><span class="keyword">struct</span></span>

<span class="comment1">(* proper tuples -- nested left *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tupleT</span> <span class="entity">Ts</span> <span class="main">=</span> <span class="entity">HOLogic.unitT</span> |&gt; fold <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">T</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">U</span> <span class="main">=&gt;</span> <span class="entity">HOLogic.mk_prodT</span> <span class="main">(</span><span class="entity">U</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span> <span class="entity">Ts</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tuple</span> <span class="entity">ts</span> <span class="main">=</span> <span class="entity">HOLogic.unit</span> |&gt; fold <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">u</span> <span class="main">=&gt;</span> <span class="entity">HOLogic.mk_prod</span> <span class="main">(</span><span class="entity">u</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span> <span class="entity">ts</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tuple_fun</span> <span class="entity">Ts</span> <span class="main">(</span><span class="entity">xi</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=</span>
  Library.funpow <span class="main">(</span>length <span class="entity">Ts</span><span class="main">)</span> <span class="entity">HOLogic.mk_case_prod</span>
    <span class="main">(</span>Var <span class="main">(</span><span class="entity">xi</span><span class="main">,</span> <span class="main">(</span><span class="entity">HOLogic.unitT</span> :: <span class="entity">Ts</span><span class="main">)</span> ---&gt; Term.range_type <span class="entity">T</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">split_all_tuples</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="entity">Simplifier.full_simplify</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span> addsimps
    <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> split_conv split_paired_all unit_all_eq1<span class="antiquote">}</span></span></span> @
    <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> fresh_Unit_elim fresh_Pair_elim<span class="antiquote">}</span></span></span> @
    <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> fresh_star_Unit_elim fresh_star_Pair_elim fresh_star_Un_elim<span class="antiquote">}</span></span></span> @
    <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> fresh_star_insert_elim fresh_star_empty_elim<span class="antiquote">}</span></span></span><span class="main">)</span>


<span class="comment1">(* prepare rule *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">inst_mutual_rule</span> <span class="entity">ctxt</span> <span class="entity">insts</span> <span class="entity">avoiding</span> <span class="entity">rules</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">nconcls</span><span class="main">,</span> <span class="entity">joined_rule</span><span class="main">)</span> <span class="main">=</span> Rule_Cases.strict_mutual_rule <span class="entity">ctxt</span> <span class="entity">rules</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">concls</span> <span class="main">=</span> Logic.dest_conjunctions <span class="main">(</span>Thm.concl_of <span class="entity">joined_rule</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">cases</span><span class="main">,</span> <span class="entity">consumes</span><span class="main">)</span> <span class="main">=</span> Rule_Cases.get <span class="entity">joined_rule</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">l</span> <span class="main">=</span> length <span class="entity">rules</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">insts</span> <span class="main">=</span> <span class="entity">l</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span> error <span class="main">(</span><span class="inner_quoted">"Bad number of instantiations for "</span> ^ string_of_int <span class="entity">l</span> ^ <span class="inner_quoted">" rules"</span><span class="main">)</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">subst</span> <span class="entity">inst</span> <span class="entity">concl</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vars</span> <span class="main">=</span> <span class="entity">Induct.vars_of</span> <span class="entity">concl</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">m</span> <span class="main">=</span> length <span class="entity">vars</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="entity">n</span> <span class="main">=</span> length <span class="entity">inst</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">m</span> &gt;= <span class="entity">n</span> + <span class="inner_numeral">2</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> error <span class="inner_quoted">"Too few variables in conclusion of rule"</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">P</span> :: <span class="entity">x</span> :: <span class="entity">ys</span> <span class="main">=</span> <span class="entity">vars</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">zs</span> <span class="main">=</span> drop <span class="main">(</span><span class="entity">m</span> - <span class="entity">n</span> - <span class="inner_numeral">2</span><span class="main">)</span> <span class="entity">ys</span><span class="main">;</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="entity">P</span><span class="main">,</span> <span class="entity">tuple_fun</span> <span class="main">(</span>map <span class="main">#</span><span class="inner_numeral">2</span> <span class="entity">avoiding</span><span class="main">)</span> <span class="main">(</span>Term.dest_Var <span class="entity">P</span><span class="main">)</span><span class="main">)</span> ::
        <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">tuple</span> <span class="main">(</span>map Free <span class="entity">avoiding</span><span class="main">)</span><span class="main">)</span> ::
        map_filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">z</span><span class="main">,</span> SOME <span class="entity">t</span><span class="main">)</span> <span class="main">=&gt;</span> SOME <span class="main">(</span><span class="entity">z</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> NONE<span class="main">)</span> <span class="main">(</span><span class="entity">zs</span> ~~ <span class="entity">inst</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
     <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">substs</span> <span class="main">=</span>
       map2 <span class="entity">subst</span> <span class="entity">insts</span> <span class="entity">concls</span> |&gt; flat |&gt; distinct <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span>
       |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">u</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">#</span><span class="inner_numeral">1</span> <span class="main">(</span>dest_Var <span class="entity">t</span><span class="main">)</span><span class="main">,</span> Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">u</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">cases</span><span class="main">,</span> <span class="entity">nconcls</span><span class="main">)</span><span class="main">,</span> <span class="entity">consumes</span><span class="main">)</span><span class="main">,</span> infer_instantiate <span class="entity">ctxt</span> <span class="entity">substs</span> <span class="entity">joined_rule</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rename_params_rule</span> <span class="entity">internal</span> <span class="entity">xs</span> <span class="entity">rule</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tune</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">internal</span> <span class="keyword2"><span class="keyword">then</span></span> Name.internal
      <span class="keyword2"><span class="keyword">else</span></span> perhaps <span class="main">(</span>try Name.dest_internal<span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">n</span> <span class="main">=</span> length <span class="entity">xs</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rename</span> <span class="entity">prem</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ps</span> <span class="main">=</span> Logic.strip_params <span class="entity">prem</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">p</span> <span class="main">=</span> length <span class="entity">ps</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ys</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">p</span> &lt; <span class="entity">n</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
          <span class="keyword2"><span class="keyword">else</span></span> map <span class="main">(</span><span class="entity">tune</span> o <span class="main">#</span><span class="inner_numeral">1</span><span class="main">)</span> <span class="main">(</span>take <span class="main">(</span><span class="entity">p</span> - <span class="entity">n</span><span class="main">)</span> <span class="entity">ps</span><span class="main">)</span> @ <span class="entity">xs</span><span class="main">;</span>
      <span class="keyword2"><span class="keyword">in</span></span> Logic.list_rename_params <span class="entity">ys</span> <span class="entity">prem</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rename_prems</span> <span class="entity">prop</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">As</span><span class="main">,</span> <span class="entity">C</span><span class="main">)</span> <span class="main">=</span> Logic.strip_horn <span class="entity">prop</span>
      <span class="keyword2"><span class="keyword">in</span></span> Logic.list_implies <span class="main">(</span>map <span class="entity">rename</span> <span class="entity">As</span><span class="main">,</span> <span class="entity">C</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> Thm.renamed_prop <span class="main">(</span><span class="entity">rename_prems</span> <span class="main">(</span>Thm.prop_of <span class="entity">rule</span><span class="main">)</span><span class="main">)</span> <span class="entity">rule</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>


<span class="comment1">(* nominal_induct_tac *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">nominal_induct_tac</span> <span class="entity">simp</span> <span class="entity">def_insts</span> <span class="entity">avoiding</span> <span class="entity">fixings</span> <span class="entity">rules</span> <span class="entity">facts</span> <span class="entity">i</span> <span class="main">(</span><span class="entity">ctxt</span><span class="main">,</span> <span class="entity">st</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">insts</span><span class="main">,</span> <span class="entity">defs</span><span class="main">)</span><span class="main">,</span> <span class="entity">defs_ctxt</span><span class="main">)</span> <span class="main">=</span> fold_map <span class="entity">Induct.add_defs</span> <span class="entity">def_insts</span> <span class="entity">ctxt</span> |&gt;&gt; split_list<span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">atomized_defs</span> <span class="main">=</span> map <span class="main">(</span>map <span class="main">(</span>Conv.fconv_rule <span class="main">(</span><span class="entity">Induct.atomize_cterm</span> <span class="entity">defs_ctxt</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">defs</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">finish_rule</span> <span class="main">=</span>
      <span class="entity">split_all_tuples</span> <span class="entity">defs_ctxt</span>
      #&gt; <span class="entity">rename_params_rule</span> true
        <span class="main">(</span>map <span class="main">(</span>Name.clean o Variable.revert_fixed <span class="entity">defs_ctxt</span> o fst<span class="main">)</span> <span class="entity">avoiding</span><span class="main">)</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rule_cases</span> <span class="entity">ctxt</span> <span class="entity">r</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">r'</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">simp</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">Induct.simplified_rule</span> <span class="entity">ctxt</span> <span class="entity">r</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">r</span>
      <span class="keyword2"><span class="keyword">in</span></span> Rule_Cases.make_nested <span class="entity">ctxt</span> <span class="main">(</span>Thm.prop_of <span class="entity">r'</span><span class="main">)</span> <span class="main">(</span><span class="entity">Induct.rulified_term</span> <span class="entity">ctxt</span> <span class="entity">r'</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">context_tac</span> <span class="main">_</span> <span class="main">_</span> <span class="main">=</span>
      <span class="entity">rules</span>
      |&gt; <span class="entity">inst_mutual_rule</span> <span class="entity">ctxt</span> <span class="entity">insts</span> <span class="entity">avoiding</span>
      |&gt; Rule_Cases.consume <span class="entity">ctxt</span> <span class="main">(</span>flat <span class="entity">defs</span><span class="main">)</span> <span class="entity">facts</span>
      |&gt; Seq.maps <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">cases</span><span class="main">,</span> <span class="entity">concls</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">more_consumes</span><span class="main">,</span> <span class="entity">more_facts</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="entity">rule</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="main">(</span>PRECISE_CONJUNCTS <span class="main">(</span>length <span class="entity">concls</span><span class="main">)</span> <span class="main">(</span>ALLGOALS <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">j</span> <span class="main">=&gt;</span>
          <span class="main">(</span>CONJUNCTS <span class="main">(</span>ALLGOALS
            <span class="keyword2"><span class="keyword">let</span></span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">adefs</span> <span class="main">=</span> nth_list <span class="entity">atomized_defs</span> <span class="main">(</span><span class="entity">j</span> - <span class="inner_numeral">1</span><span class="main">)</span><span class="main">;</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">frees</span> <span class="main">=</span> fold <span class="main">(</span>Term.add_frees o Thm.prop_of<span class="main">)</span> <span class="entity">adefs</span> <span class="main">[</span><span class="main">]</span><span class="main">;</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xs</span> <span class="main">=</span> nth_list <span class="entity">fixings</span> <span class="main">(</span><span class="entity">j</span> - <span class="inner_numeral">1</span><span class="main">)</span><span class="main">;</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">k</span> <span class="main">=</span> nth <span class="entity">concls</span> <span class="main">(</span><span class="entity">j</span> - <span class="inner_numeral">1</span><span class="main">)</span> + <span class="entity">more_consumes</span>
            <span class="keyword2"><span class="keyword">in</span></span>
              <span class="entity">Method.insert_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">more_facts</span> @ <span class="entity">adefs</span><span class="main">)</span> THEN'
                <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">simp</span> <span class="keyword2"><span class="keyword">then</span></span>
                   <span class="entity">Induct.rotate_tac</span> <span class="entity">k</span> <span class="main">(</span>length <span class="entity">adefs</span><span class="main">)</span> THEN'
                   <span class="entity">Induct.arbitrary_tac</span> <span class="entity">defs_ctxt</span> <span class="entity">k</span>
                     <span class="main">(</span>List.partition <span class="main">(</span>member <span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span> <span class="entity">frees</span><span class="main">)</span> <span class="entity">xs</span> |&gt; <span class="keyword1"><span class="keyword">op</span></span> @<span class="main">)</span>
                 <span class="keyword2"><span class="keyword">else</span></span>
                   <span class="entity">Induct.arbitrary_tac</span> <span class="entity">defs_ctxt</span> <span class="entity">k</span> <span class="entity">xs</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>
          THEN' <span class="entity">Induct.inner_atomize_tac</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">j</span><span class="main">)</span><span class="main">)</span>
        THEN' <span class="entity">Induct.atomize_tac</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">i</span> <span class="entity">st</span> |&gt; Seq.maps <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">st'</span> <span class="main">=&gt;</span>
            <span class="entity">Induct.guess_instance</span> <span class="entity">ctxt</span>
              <span class="main">(</span><span class="entity">finish_rule</span> <span class="main">(</span><span class="entity">Induct.internalize</span> <span class="entity">ctxt</span> <span class="entity">more_consumes</span> <span class="entity">rule</span><span class="main">)</span><span class="main">)</span> <span class="entity">i</span> <span class="entity">st'</span>
            |&gt; Seq.maps <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">rule'</span> <span class="main">=&gt;</span>
              <span class="entity">CONTEXT_CASES</span> <span class="main">(</span><span class="entity">rule_cases</span> <span class="entity">ctxt</span> <span class="entity">rule'</span> <span class="entity">cases</span><span class="main">)</span>
                <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">rename_params_rule</span> false <span class="main">[</span><span class="main">]</span> <span class="entity">rule'</span><span class="main">]</span> <span class="entity">i</span> THEN
                  PRIMITIVE
                    <span class="main">(</span>singleton <span class="main">(</span>Proof_Context.export <span class="entity">defs_ctxt</span>
                      <span class="main">(</span>Proof_Context.transfer <span class="main">(</span>Proof_Context.theory_of <span class="entity">defs_ctxt</span><span class="main">)</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">ctxt</span><span class="main">,</span> <span class="entity">st'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="entity">context_tac</span> <span class="entity">CONTEXT_THEN_ALL_NEW</span>
      <span class="main">(</span><span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">simp</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">Induct.simplify_tac</span> <span class="entity">ctxt</span> THEN' <span class="main">(</span>TRY o <span class="entity">Induct.trivial_tac</span> <span class="entity">ctxt</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">else</span></span> K all_tac<span class="main">)</span> THEN_ALL_NEW <span class="entity">Induct.rulify_tac</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span> <span class="entity">i</span> <span class="main">(</span><span class="entity">ctxt</span><span class="main">,</span> <span class="entity">st</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>


<span class="comment1">(* concrete syntax *)</span>

<span class="keyword2"><span class="keyword">local</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">avoidingN</span> <span class="main">=</span> <span class="inner_quoted">"avoiding"</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fixingN</span> <span class="main">=</span> <span class="inner_quoted">"arbitrary"</span><span class="main">;</span>  <span class="comment1">(* to be consistent with induct; hopefully this changes again *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ruleN</span> <span class="main">=</span> <span class="inner_quoted">"rule"</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inst</span> <span class="main">=</span> Scan.lift <span class="main">(</span>Args.$$$ <span class="inner_quoted">"_"</span><span class="main">)</span> &gt;&gt; K NONE ||
  Args.term &gt;&gt; <span class="main">(</span>SOME o rpair false<span class="main">)</span> ||
  Scan.lift <span class="main">(</span>Args.$$$ <span class="inner_quoted">"("</span><span class="main">)</span> |-- <span class="main">(</span>Args.term &gt;&gt; <span class="main">(</span>SOME o rpair true<span class="main">)</span><span class="main">)</span> --|
    Scan.lift <span class="main">(</span>Args.$$$ <span class="inner_quoted">")"</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">def_inst</span> <span class="main">=</span>
  <span class="main">(</span><span class="main">(</span>Scan.lift <span class="main">(</span>Args.binding --| <span class="main">(</span>Args.$$$ <span class="inner_quoted">"≡"</span> || Args.$$$ <span class="inner_quoted">"=="</span><span class="main">)</span><span class="main">)</span> &gt;&gt; SOME<span class="main">)</span>
      -- <span class="main">(</span>Args.term &gt;&gt; rpair false<span class="main">)</span><span class="main">)</span> &gt;&gt; SOME ||
    <span class="entity">inst</span> &gt;&gt; Option.map <span class="main">(</span>pair NONE<span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">free</span> <span class="main">=</span> Args.context -- Args.term &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> Free <span class="entity">v</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">v</span> <span class="main">|</span> <span class="main">(</span><span class="entity">ctxt</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="main">=&gt;</span>
  error <span class="main">(</span><span class="inner_quoted">"Bad free variable: "</span> ^ Syntax.string_of_term <span class="entity">ctxt</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">unless_more_args</span> <span class="entity">scan</span> <span class="main">=</span> Scan.unless <span class="main">(</span>Scan.lift
  <span class="main">(</span><span class="main">(</span>Args.$$$ <span class="entity">avoidingN</span> || Args.$$$ <span class="entity">fixingN</span> || Args.$$$ <span class="entity">ruleN</span><span class="main">)</span> -- Args.colon<span class="main">)</span><span class="main">)</span> <span class="entity">scan</span><span class="main">;</span>


<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">avoiding</span> <span class="main">=</span> Scan.optional <span class="main">(</span>Scan.lift <span class="main">(</span>Args.$$$ <span class="entity">avoidingN</span> -- Args.colon<span class="main">)</span> |--
  Scan.repeat <span class="main">(</span><span class="entity">unless_more_args</span> <span class="entity">free</span><span class="main">)</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fixing</span> <span class="main">=</span> Scan.optional <span class="main">(</span>Scan.lift <span class="main">(</span>Args.$$$ <span class="entity">fixingN</span> -- Args.colon<span class="main">)</span> |--
  Parse.and_list' <span class="main">(</span>Scan.repeat <span class="main">(</span><span class="entity">unless_more_args</span> <span class="entity">free</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rule_spec</span> <span class="main">=</span> Scan.lift <span class="main">(</span>Args.$$$ <span class="inner_quoted">"rule"</span> -- Args.colon<span class="main">)</span> |-- <span class="entity">Attrib.thms</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">in</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nominal_induct_method</span> <span class="main">=</span>
  Scan.lift <span class="main">(</span>Args.mode <span class="entity">Induct.no_simpN</span><span class="main">)</span> --
    <span class="main">(</span>Parse.and_list' <span class="main">(</span>Scan.repeat <span class="main">(</span><span class="entity">unless_more_args</span> <span class="entity">def_inst</span><span class="main">)</span><span class="main">)</span> --
      <span class="entity">avoiding</span> -- <span class="entity">fixing</span> -- <span class="entity">rule_spec</span><span class="main">)</span> &gt;&gt;
  <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">no_simp</span><span class="main">,</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span><span class="main">,</span> <span class="entity">z</span><span class="main">)</span><span class="main">,</span> <span class="entity">w</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">facts</span> <span class="main">=&gt;</span>
    <span class="entity">nominal_induct_tac</span> <span class="main">(</span>not <span class="entity">no_simp</span><span class="main">)</span> <span class="entity">x</span> <span class="entity">y</span> <span class="entity">z</span> <span class="entity">w</span> <span class="entity">facts</span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
</pre>
</div><div id="files/nominal_inductive.ML">
<div class="head">
<h1>File ‹nominal_inductive.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      nominal_inductive.ML
    Author:     Christian Urban
    Author:     Tjark Weber

    Infrastructure for proving strong induction theorems
    for inductive predicates involving nominal datatypes.

    Code based on an earlier version by Stefan Berghofer.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">NOMINAL_INDUCTIVE</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> prove_strong_inductive<span class="main">:</span> string list <span class="main">-&gt;</span> string list <span class="main">-&gt;</span> term list list <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span>
    <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Proof.state</span>
  <span class="keyword1"><span class="keyword">val</span></span> prove_strong_inductive_cmd<span class="main">:</span> xstring * <span class="main">(</span>string * string list<span class="main">)</span> list <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Proof.state</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Nominal_Inductive</span> <span class="main">:</span> <span class="entity">NOMINAL_INDUCTIVE</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_cplus</span> <span class="entity">p</span> <span class="entity">q</span> <span class="main">=</span>
  Thm.apply <span class="main">(</span>Thm.apply <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">cterm</span> <span class="quoted">"plus <span class="main">::</span> perm <span class="main">=&gt;</span> perm <span class="main">=&gt;</span> perm"</span><span class="antiquote">}</span></span></span> <span class="entity">p</span><span class="main">)</span> <span class="entity">q</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_cminus</span> <span class="entity">p</span> <span class="main">=</span>
  Thm.apply <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">cterm</span> <span class="quoted">"uminus <span class="main">::</span> perm <span class="main">=&gt;</span> perm"</span><span class="antiquote">}</span></span></span> <span class="entity">p</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">minus_permute_intro_tac</span> <span class="entity">ctxt</span> <span class="entity">p</span> <span class="main">=</span>
  resolve_tac <span class="entity">ctxt</span> <span class="main">[</span>Thm.instantiate' <span class="main">[</span><span class="main">]</span> <span class="main">[</span>SOME <span class="main">(</span><span class="entity">mk_cminus</span> <span class="entity">p</span><span class="main">)</span><span class="main">]</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> permute_boolE<span class="antiquote">}</span></span></span><span class="main">]</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">minus_permute_elim</span> <span class="entity">p</span> <span class="entity">thm</span> <span class="main">=</span>
  <span class="entity">thm</span> RS <span class="main">(</span>Thm.instantiate' <span class="main">[</span><span class="main">]</span> <span class="main">[</span>NONE<span class="main">,</span> SOME <span class="main">(</span><span class="entity">mk_cminus</span> <span class="entity">p</span><span class="main">)</span><span class="main">]</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> permute_boolI<span class="antiquote">}</span></span></span><span class="main">)</span>

<span class="comment1">(* fixme: move to nominal_library *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">real_head_of</span> <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">Trueprop</span><span class="antiquote">}</span></span> $ <span class="entity">t</span><span class="main">)</span> <span class="main">=</span> <span class="entity">real_head_of</span> <span class="entity">t</span>
  <span class="main">|</span> <span class="entity">real_head_of</span> <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Pure.imp<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">_</span> $ <span class="entity">t</span><span class="main">)</span> <span class="main">=</span> <span class="entity">real_head_of</span> <span class="entity">t</span>
  <span class="main">|</span> <span class="entity">real_head_of</span> <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Pure.all<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ Abs <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">real_head_of</span> <span class="entity">t</span>
  <span class="main">|</span> <span class="entity">real_head_of</span> <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> All<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ Abs <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">real_head_of</span> <span class="entity">t</span>
  <span class="main">|</span> <span class="entity">real_head_of</span> <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> HOL.induct_forall<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ Abs <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">real_head_of</span> <span class="entity">t</span>
  <span class="main">|</span> <span class="entity">real_head_of</span> <span class="entity">t</span> <span class="main">=</span> head_of <span class="entity">t</span>


<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_vc_compat</span> <span class="main">(</span><span class="entity">avoid</span><span class="main">,</span> <span class="entity">avoid_trm</span><span class="main">)</span> <span class="entity">prems</span> <span class="entity">concl_args</span> <span class="entity">params</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">avoid</span> <span class="keyword2"><span class="keyword">then</span></span>
    <span class="main">[</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">else</span></span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vc_goal</span> <span class="main">=</span> <span class="entity">concl_args</span>
        |&gt; <span class="entity">HOLogic.mk_tuple</span>
        |&gt; <span class="entity">mk_fresh_star</span> <span class="entity">avoid_trm</span>
        |&gt; <span class="entity">HOLogic.mk_Trueprop</span>
        |&gt; <span class="main">(</span>curry Logic.list_implies<span class="main">)</span> <span class="entity">prems</span>
        |&gt; fold_rev <span class="main">(</span>Logic.all o Free<span class="main">)</span> <span class="entity">params</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">finite_goal</span> <span class="main">=</span> <span class="entity">avoid_trm</span>
        |&gt; <span class="entity">mk_finite</span>
        |&gt; <span class="entity">HOLogic.mk_Trueprop</span>
        |&gt; <span class="main">(</span>curry Logic.list_implies<span class="main">)</span> <span class="entity">prems</span>
        |&gt; fold_rev <span class="main">(</span>Logic.all o Free<span class="main">)</span> <span class="entity">params</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">[</span><span class="entity">vc_goal</span><span class="main">,</span> <span class="entity">finite_goal</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* fixme: move to nominal_library *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_term</span> <span class="entity">prop</span> <span class="entity">f</span> <span class="entity">trm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">prop</span> <span class="entity">trm</span>
  <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">f</span> <span class="entity">trm</span>
  <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">trm</span> <span class="keyword2"><span class="keyword">of</span></span>
    <span class="main">(</span><span class="entity">t1</span> $ <span class="entity">t2</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">map_term</span> <span class="entity">prop</span> <span class="entity">f</span> <span class="entity">t1</span> $ <span class="entity">map_term</span> <span class="entity">prop</span> <span class="entity">f</span> <span class="entity">t2</span>
  <span class="main">|</span> Abs <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="main">=&gt;</span> Abs <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">map_term</span> <span class="entity">prop</span> <span class="entity">f</span> <span class="entity">t</span><span class="main">)</span>
  <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">trm</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_p_c</span> <span class="entity">p</span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">c_ty</span><span class="main">)</span> <span class="entity">trm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">P</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span> <span class="main">=</span> strip_comb <span class="entity">trm</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">P_name</span><span class="main">,</span> <span class="entity">P_ty</span><span class="main">)</span> <span class="main">=</span> dest_Free <span class="entity">P</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ty_args</span><span class="main">,</span> <span class="entity">bool</span><span class="main">)</span> <span class="main">=</span> strip_type <span class="entity">P_ty</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args'</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">mk_perm</span> <span class="entity">p</span><span class="main">)</span> <span class="entity">args</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    list_comb <span class="main">(</span>Free <span class="main">(</span><span class="entity">P_name</span><span class="main">,</span> <span class="main">(</span><span class="entity">c_ty</span> :: <span class="entity">ty_args</span><span class="main">)</span> ---&gt; <span class="entity">bool</span><span class="main">)</span><span class="main">,</span>  <span class="entity">c</span> :: <span class="entity">args'</span><span class="main">)</span>
    |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> <span class="entity">HOLogic.all_const</span> <span class="entity">c_ty</span> $ lambda <span class="entity">c</span> <span class="entity">t</span> <span class="main">)</span>
    |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> <span class="entity">HOLogic.all_const</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">perm</span><span class="antiquote">}</span></span> $  lambda <span class="entity">p</span> <span class="entity">t</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">induct_forall_const</span> <span class="entity">T</span> <span class="main">=</span>
  Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> HOL.induct_forall<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">(</span><span class="entity">T</span> --&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">bool</span><span class="antiquote">}</span></span><span class="main">)</span> --&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">bool</span><span class="antiquote">}</span></span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_induct_forall</span> <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="entity">t</span> <span class="main">=</span>
  <span class="entity">induct_forall_const</span> <span class="entity">T</span> $ Abs <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_c_prop</span> <span class="entity">qnt</span> <span class="entity">Ps</span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">c_name</span><span class="main">,</span> <span class="entity">c_ty</span><span class="main">)</span> <span class="entity">trm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add</span> <span class="entity">t</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">P</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span> <span class="main">=</span> strip_comb <span class="entity">t</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">P_name</span><span class="main">,</span> <span class="entity">P_ty</span><span class="main">)</span> <span class="main">=</span> dest_Free <span class="entity">P</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ty_args</span><span class="main">,</span> <span class="entity">bool</span><span class="main">)</span> <span class="main">=</span> strip_type <span class="entity">P_ty</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args'</span> <span class="main">=</span> <span class="entity">args</span>
          |&gt; <span class="entity">qnt</span> ? map <span class="main">(</span>incr_boundvars <span class="inner_numeral">1</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        list_comb <span class="main">(</span>Free <span class="main">(</span><span class="entity">P_name</span><span class="main">,</span> <span class="main">(</span><span class="entity">c_ty</span> :: <span class="entity">ty_args</span><span class="main">)</span> ---&gt; <span class="entity">bool</span><span class="main">)</span><span class="main">,</span> <span class="entity">c</span> :: <span class="entity">args'</span><span class="main">)</span>
          |&gt; <span class="entity">qnt</span> ? <span class="entity">mk_induct_forall</span> <span class="main">(</span><span class="entity">c_name</span><span class="main">,</span> <span class="entity">c_ty</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">map_term</span> <span class="main">(</span>member <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">Ps</span> o head_of<span class="main">)</span> <span class="entity">add</span> <span class="entity">trm</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prep_prem</span> <span class="entity">Ps</span> <span class="entity">c_name</span> <span class="entity">c_ty</span> <span class="main">(</span><span class="entity">avoid</span><span class="main">,</span> <span class="entity">avoid_trm</span><span class="main">)</span> <span class="main">(</span><span class="entity">params</span><span class="main">,</span> <span class="entity">prems</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prems'</span> <span class="main">=</span> <span class="entity">prems</span>
      |&gt; map <span class="main">(</span>incr_boundvars <span class="inner_numeral">1</span><span class="main">)</span>
      |&gt; map <span class="main">(</span><span class="entity">add_c_prop</span> true <span class="entity">Ps</span> <span class="main">(</span>Bound <span class="inner_numeral">0</span><span class="main">,</span> <span class="entity">c_name</span><span class="main">,</span> <span class="entity">c_ty</span><span class="main">)</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">avoid_trm'</span> <span class="main">=</span> <span class="entity">avoid_trm</span>
      |&gt; fold_rev absfree <span class="main">(</span><span class="entity">params</span> @ <span class="main">[</span><span class="main">(</span><span class="entity">c_name</span><span class="main">,</span> <span class="entity">c_ty</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>
      |&gt; strip_abs_body
      |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> <span class="entity">mk_fresh_star_ty</span> <span class="entity">c_ty</span> <span class="entity">t</span> <span class="main">(</span>Bound <span class="inner_numeral">0</span><span class="main">)</span><span class="main">)</span>
      |&gt; <span class="entity">HOLogic.mk_Trueprop</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prems''</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">avoid</span>
      <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">prems'</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">avoid_trm'</span> :: <span class="entity">prems'</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">concl'</span> <span class="main">=</span> <span class="entity">concl</span>
      |&gt; incr_boundvars <span class="inner_numeral">1</span>
      |&gt; <span class="entity">add_c_prop</span> false <span class="entity">Ps</span> <span class="main">(</span>Bound <span class="inner_numeral">0</span><span class="main">,</span> <span class="entity">c_name</span><span class="main">,</span> <span class="entity">c_ty</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">mk_full_horn</span> <span class="main">(</span><span class="entity">params</span> @ <span class="main">[</span><span class="main">(</span><span class="entity">c_name</span><span class="main">,</span> <span class="entity">c_ty</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="entity">prems''</span> <span class="entity">concl'</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* fixme: move to nominal_library *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">same_name</span> <span class="main">(</span>Free <span class="main">(</span><span class="entity">a1</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> Free <span class="main">(</span><span class="entity">a2</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">a1</span> <span class="main">=</span> <span class="entity">a2</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">same_name</span> <span class="main">(</span>Var <span class="main">(</span><span class="entity">a1</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> Var <span class="main">(</span><span class="entity">a2</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">a1</span> <span class="main">=</span> <span class="entity">a2</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">same_name</span> <span class="main">(</span>Const <span class="main">(</span><span class="entity">a1</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> Const <span class="main">(</span><span class="entity">a2</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">a1</span> <span class="main">=</span> <span class="entity">a2</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">same_name</span> <span class="main">_</span> <span class="main">=</span> false

<span class="comment1">(* fixme: move to nominal_library *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map7</span> <span class="main">_</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="main">]</span>
  <span class="main">|</span> <span class="entity">map7</span> <span class="entity">f</span> <span class="main">(</span><span class="entity">x</span> :: <span class="entity">xs</span><span class="main">)</span> <span class="main">(</span><span class="entity">y</span> :: <span class="entity">ys</span><span class="main">)</span> <span class="main">(</span><span class="entity">z</span> :: <span class="entity">zs</span><span class="main">)</span> <span class="main">(</span><span class="entity">u</span> :: <span class="entity">us</span><span class="main">)</span> <span class="main">(</span><span class="entity">v</span> :: <span class="entity">vs</span><span class="main">)</span> <span class="main">(</span><span class="entity">r</span> :: <span class="entity">rs</span><span class="main">)</span> <span class="main">(</span><span class="entity">s</span> :: <span class="entity">ss</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">f</span> <span class="entity">x</span> <span class="entity">y</span> <span class="entity">z</span> <span class="entity">u</span> <span class="entity">v</span> <span class="entity">r</span> <span class="entity">s</span> :: <span class="entity">map7</span> <span class="entity">f</span> <span class="entity">xs</span> <span class="entity">ys</span> <span class="entity">zs</span> <span class="entity">us</span> <span class="entity">vs</span> <span class="entity">rs</span> <span class="entity">ss</span>

<span class="comment1">(* local abbreviations *)</span>

<span class="keyword2"><span class="keyword">local</span></span>
  <span class="keyword3"><span class="keyword">open</span></span> Nominal_Permeq
<span class="keyword2"><span class="keyword">in</span></span>

  <span class="comment1">(* by default eqvt_strict_config contains unwanted @{thm permute_pure} *)</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eqvt_sconfig</span> <span class="main">=</span> <span class="entity">eqvt_strict_config</span> <span class="entity">addpres</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> permute_minus_cancel<span class="antiquote">}</span></span></span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eqvt_stac</span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="entity">eqvt_tac</span> <span class="entity">ctxt</span> <span class="entity">eqvt_sconfig</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eqvt_srule</span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="entity">eqvt_rule</span> <span class="entity">ctxt</span> <span class="entity">eqvt_sconfig</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_elims</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">spec'</span> <span class="entity">ct</span> <span class="main">=</span>
      Thm.instantiate' <span class="main">[</span>SOME <span class="main">(</span>Thm.ctyp_of_cterm <span class="entity">ct</span><span class="main">)</span><span class="main">]</span> <span class="main">[</span>NONE<span class="main">,</span> SOME <span class="entity">ct</span><span class="main">]</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> spec<span class="antiquote">}</span></span></span>
  <span class="keyword2"><span class="keyword">in</span></span>
    fold <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ct</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">th</span> <span class="main">=&gt;</span> <span class="entity">th</span> RS <span class="entity">spec'</span> <span class="entity">ct</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">helper_tac</span> <span class="entity">flag</span> <span class="entity">prm</span> <span class="entity">p</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="entity">Subgoal.SUBPROOF</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt'</span><span class="main">,</span> <span class="entity">prems</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prems'</span> <span class="main">=</span> <span class="entity">prems</span>
        |&gt; map <span class="main">(</span><span class="entity">minus_permute_elim</span> <span class="entity">p</span><span class="main">)</span>
        |&gt; map <span class="main">(</span><span class="entity">eqvt_srule</span> <span class="entity">ctxt'</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prm'</span> <span class="main">=</span> <span class="main">(</span><span class="entity">prems'</span> MRS <span class="entity">prm</span><span class="main">)</span>
        |&gt; <span class="entity">flag</span> ? <span class="main">(</span><span class="entity">all_elims</span> <span class="main">[</span><span class="entity">p</span><span class="main">]</span><span class="main">)</span>
        |&gt; <span class="entity">flag</span> ? <span class="main">(</span><span class="entity">eqvt_srule</span> <span class="entity">ctxt'</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">asm_full_simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_ss</span> <span class="entity">ctxt'</span> addsimps <span class="main">(</span><span class="entity">prm'</span> :: <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> HOL.induct_forall_def<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">)</span> <span class="inner_numeral">1</span>
    <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span> <span class="entity">ctxt</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">non_binder_tac</span> <span class="entity">prem</span> <span class="entity">intr_cvars</span> <span class="entity">Ps</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="entity">Subgoal.SUBPROOF</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt'</span><span class="main">,</span> <span class="entity">params</span><span class="main">,</span> <span class="entity">prems</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">prms</span><span class="main">,</span> <span class="entity">p</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">split_last2</span> <span class="main">(</span>map snd <span class="entity">params</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prm_tys</span> <span class="main">=</span> map <span class="main">(</span>fastype_of o Thm.term_of<span class="main">)</span> <span class="entity">prms</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cperms</span> <span class="main">=</span> map <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt'</span> o <span class="entity">perm_const</span><span class="main">)</span> <span class="entity">prm_tys</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">p_prms</span> <span class="main">=</span> map2 <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ct1</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ct2</span> <span class="main">=&gt;</span> Thm.mk_binop <span class="entity">ct1</span> <span class="entity">p</span> <span class="entity">ct2</span><span class="main">)</span> <span class="entity">cperms</span> <span class="entity">prms</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prem'</span> <span class="main">=</span> <span class="entity">prem</span>
        |&gt; infer_instantiate <span class="entity">ctxt'</span> <span class="main">(</span>map <span class="main">(</span><span class="main">#</span><span class="inner_numeral">1</span> o dest_Var o Thm.term_of<span class="main">)</span> <span class="entity">intr_cvars</span> ~~ <span class="entity">p_prms</span><span class="main">)</span>
        |&gt; <span class="entity">eqvt_srule</span> <span class="entity">ctxt'</span>

      <span class="comment1">(* for inductive-premises*)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tac1</span> <span class="entity">prm</span> <span class="main">=</span> <span class="entity">helper_tac</span> true <span class="entity">prm</span> <span class="entity">p</span> <span class="entity">ctxt'</span>

      <span class="comment1">(* for non-inductive premises *)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tac2</span> <span class="entity">prm</span> <span class="main">=</span>
        EVERY' <span class="main">[</span> <span class="entity">minus_permute_intro_tac</span> <span class="entity">ctxt'</span> <span class="entity">p</span><span class="main">,</span>
                 <span class="entity">eqvt_stac</span> <span class="entity">ctxt'</span><span class="main">,</span>
                 <span class="entity">helper_tac</span> false <span class="entity">prm</span> <span class="entity">p</span> <span class="entity">ctxt'</span> <span class="main">]</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">select</span> <span class="entity">prm</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">i</span><span class="main">)</span> <span class="main">=</span>
        <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> member <span class="entity">same_name</span> <span class="entity">Ps</span> <span class="main">(</span><span class="entity">real_head_of</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">tac1</span> <span class="entity">prm</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">tac2</span> <span class="entity">prm</span><span class="main">)</span> <span class="entity">i</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      EVERY1 <span class="main">[</span> <span class="entity">eqvt_stac</span> <span class="entity">ctxt'</span><span class="main">,</span>
               resolve_tac <span class="entity">ctxt'</span> <span class="main">[</span><span class="entity">prem'</span><span class="main">]</span><span class="main">,</span>
               RANGE <span class="main">(</span>map <span class="main">(</span>SUBGOAL o <span class="entity">select</span><span class="main">)</span> <span class="entity">prems</span><span class="main">)</span> <span class="main">]</span>
    <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span> <span class="entity">ctxt</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">fresh_thm</span> <span class="entity">ctxt</span> <span class="entity">user_thm</span> <span class="entity">p</span> <span class="entity">c</span> <span class="entity">concl_args</span> <span class="entity">avoid_trm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">conj1</span> <span class="main">=</span>
      <span class="entity">mk_fresh_star</span> <span class="main">(</span><span class="entity">mk_perm</span> <span class="main">(</span>Bound <span class="inner_numeral">0</span><span class="main">)</span> <span class="main">(</span><span class="entity">mk_perm</span> <span class="entity">p</span> <span class="entity">avoid_trm</span><span class="main">)</span><span class="main">)</span> <span class="entity">c</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">conj2</span> <span class="main">=</span>
      <span class="entity">mk_fresh_star_ty</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">perm</span><span class="antiquote">}</span></span> <span class="main">(</span><span class="entity">mk_supp</span> <span class="main">(</span><span class="entity">HOLogic.mk_tuple</span> <span class="main">(</span>map <span class="main">(</span><span class="entity">mk_perm</span> <span class="entity">p</span><span class="main">)</span> <span class="entity">concl_args</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Bound <span class="inner_numeral">0</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fresh_goal</span> <span class="main">=</span> <span class="entity">mk_exists</span> <span class="main">(</span><span class="inner_quoted">"q"</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">perm</span><span class="antiquote">}</span></span><span class="main">)</span> <span class="main">(</span><span class="entity">HOLogic.mk_conj</span> <span class="main">(</span><span class="entity">conj1</span><span class="main">,</span> <span class="entity">conj2</span><span class="main">)</span><span class="main">)</span>
      |&gt; <span class="entity">HOLogic.mk_Trueprop</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ss</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> finite_supp supp_Pair finite_Un permute_finite<span class="antiquote">}</span></span></span> @
             <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> fresh_star_Pair fresh_star_permute_iff<span class="antiquote">}</span></span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simp</span> <span class="main">=</span> <span class="entity">asm_full_simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_ss</span> <span class="entity">ctxt</span> addsimps <span class="entity">ss</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Goal.prove <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">fresh_goal</span>
      <span class="main">(</span>K <span class="main">(</span>HEADGOAL <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> at_set_avoiding2<span class="antiquote">}</span></span></span>
          THEN_ALL_NEW EVERY' <span class="main">[</span>cut_facts_tac <span class="entity">user_thm</span><span class="main">,</span> REPEAT o
            eresolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> conjE<span class="antiquote">}</span></span></span><span class="main">,</span> <span class="entity">simp</span><span class="main">]</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">supp_perm_eq'</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">lemma</span> <span class="quoted">"fresh_star <span class="main">(</span>supp <span class="main">(</span>permute <span class="free">p</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span> <span class="free">q</span> <span class="main">==&gt;</span> permute <span class="free">p</span> <span class="free">x</span> <span class="main">==</span> permute <span class="main">(</span><span class="free">q</span> <span class="main">+</span> <span class="free">p</span><span class="main">)</span> <span class="free">x</span>"</span>
  <span class="keyword1"><span class="keyword">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main">:</span> supp_perm_eq<span class="main">)</span><span class="antiquote">}</span></span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fresh_star_plus</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">lemma</span> <span class="quoted">"fresh_star <span class="main">(</span>permute <span class="free">q</span> <span class="main">(</span>permute <span class="free">p</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span> <span class="free">c</span> <span class="main">==&gt;</span> fresh_star <span class="main">(</span>permute <span class="main">(</span><span class="free">q</span> <span class="main">+</span> <span class="free">p</span><span class="main">)</span> <span class="free">x</span><span class="main">)</span> <span class="free">c</span>"</span>
  <span class="keyword1"><span class="keyword">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main">:</span> permute_plus<span class="main">)</span><span class="antiquote">}</span></span></span>


<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">binder_tac</span> <span class="entity">prem</span> <span class="entity">intr_cvars</span> <span class="entity">param_trms</span> <span class="entity">Ps</span> <span class="entity">user_thm</span> <span class="entity">avoid_trm</span> <span class="entity">concl_args</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="entity">Subgoal.FOCUS</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="entity">params</span><span class="main">,</span> <span class="entity">prems</span><span class="main">,</span> <span class="entity">concl</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">prms</span><span class="main">,</span> <span class="entity">p</span><span class="main">,</span> <span class="entity">c</span><span class="main">)</span> <span class="main">=</span> <span class="entity">split_last2</span> <span class="main">(</span>map snd <span class="entity">params</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prm_trms</span> <span class="main">=</span> map Thm.term_of <span class="entity">prms</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prm_tys</span> <span class="main">=</span> map fastype_of <span class="entity">prm_trms</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">avoid_trm'</span> <span class="main">=</span> subst_free <span class="main">(</span><span class="entity">param_trms</span> ~~ <span class="entity">prm_trms</span><span class="main">)</span> <span class="entity">avoid_trm</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">concl_args'</span> <span class="main">=</span> map <span class="main">(</span>subst_free <span class="main">(</span><span class="entity">param_trms</span> ~~ <span class="entity">prm_trms</span><span class="main">)</span><span class="main">)</span> <span class="entity">concl_args</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">user_thm'</span> <span class="main">=</span> map <span class="main">(</span>infer_instantiate <span class="entity">ctxt</span> <span class="main">(</span>map <span class="main">(</span><span class="main">#</span><span class="inner_numeral">1</span> o dest_Var o Thm.term_of<span class="main">)</span> <span class="entity">intr_cvars</span> ~~ <span class="entity">prms</span><span class="main">)</span><span class="main">)</span> <span class="entity">user_thm</span>
        |&gt; map <span class="main">(</span><span class="entity">full_simplify</span> <span class="main">(</span>put_simpset <span class="entity">HOL_ss</span> <span class="entity">ctxt</span> addsimps <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> fresh_star_Pair<span class="antiquote">}</span></span></span>::<span class="entity">prems</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fthm</span> <span class="main">=</span> <span class="entity">fresh_thm</span> <span class="entity">ctxt</span> <span class="entity">user_thm'</span> <span class="main">(</span>Thm.term_of <span class="entity">p</span><span class="main">)</span> <span class="main">(</span>Thm.term_of <span class="entity">c</span><span class="main">)</span> <span class="entity">concl_args'</span> <span class="entity">avoid_trm'</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="main">[</span><span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">q</span><span class="main">)</span><span class="main">]</span><span class="main">,</span> <span class="entity">fprop</span> :: <span class="entity">fresh_eqs</span><span class="main">)</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Obtain.result</span>
              <span class="main">(</span>K <span class="main">(</span>EVERY1 <span class="main">[</span>eresolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> exE<span class="antiquote">}</span></span></span><span class="main">,</span>
                          <span class="entity">full_simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span>
                            addsimps <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> supp_Pair fresh_star_Un<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span>
                          REPEAT o eresolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> conjE<span class="antiquote">}</span></span></span><span class="main">,</span>
                          dresolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">fresh_star_plus</span><span class="main">]</span><span class="main">,</span>
                          REPEAT o dresolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">supp_perm_eq'</span><span class="main">]</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">[</span><span class="entity">fthm</span><span class="main">]</span> <span class="entity">ctxt</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">expand_conv</span> <span class="main">=</span> Conv.try_conv <span class="main">(</span>Conv.rewrs_conv <span class="entity">fresh_eqs</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">expand_conv_bot</span> <span class="entity">ctxt</span> <span class="main">=</span> Conv.bottom_conv <span class="main">(</span>K <span class="entity">expand_conv</span><span class="main">)</span> <span class="entity">ctxt</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cperms</span> <span class="main">=</span> map <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt'</span> o <span class="entity">perm_const</span><span class="main">)</span> <span class="entity">prm_tys</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">qp_prms</span> <span class="main">=</span> map2 <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ct1</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ct2</span> <span class="main">=&gt;</span> Thm.mk_binop <span class="entity">ct1</span> <span class="main">(</span><span class="entity">mk_cplus</span> <span class="entity">q</span> <span class="entity">p</span><span class="main">)</span> <span class="entity">ct2</span><span class="main">)</span> <span class="entity">cperms</span> <span class="entity">prms</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prem'</span> <span class="main">=</span> <span class="entity">prem</span>
        |&gt; infer_instantiate <span class="entity">ctxt'</span> <span class="main">(</span>map <span class="main">(</span><span class="main">#</span><span class="inner_numeral">1</span> o dest_Var o Thm.term_of<span class="main">)</span> <span class="entity">intr_cvars</span> ~~ <span class="entity">qp_prms</span><span class="main">)</span>
        |&gt; <span class="entity">eqvt_srule</span> <span class="entity">ctxt'</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fprop'</span> <span class="main">=</span> <span class="entity">eqvt_srule</span> <span class="entity">ctxt'</span> <span class="entity">fprop</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tac_fresh</span> <span class="main">=</span> <span class="entity">simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt'</span> addsimps <span class="main">[</span><span class="entity">fprop'</span><span class="main">]</span><span class="main">)</span>

      <span class="comment1">(* for inductive-premises*)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tac1</span> <span class="entity">prm</span> <span class="main">=</span> <span class="entity">helper_tac</span> true <span class="entity">prm</span> <span class="main">(</span><span class="entity">mk_cplus</span> <span class="entity">q</span> <span class="entity">p</span><span class="main">)</span> <span class="entity">ctxt'</span>

      <span class="comment1">(* for non-inductive premises *)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tac2</span> <span class="entity">prm</span> <span class="main">=</span>
        EVERY' <span class="main">[</span> <span class="entity">minus_permute_intro_tac</span> <span class="entity">ctxt'</span> <span class="main">(</span><span class="entity">mk_cplus</span> <span class="entity">q</span> <span class="entity">p</span><span class="main">)</span><span class="main">,</span>
                 <span class="entity">eqvt_stac</span> <span class="entity">ctxt'</span><span class="main">,</span>
                 <span class="entity">helper_tac</span> false <span class="entity">prm</span> <span class="main">(</span><span class="entity">mk_cplus</span> <span class="entity">q</span> <span class="entity">p</span><span class="main">)</span> <span class="entity">ctxt'</span> <span class="main">]</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">select</span> <span class="entity">prm</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">i</span><span class="main">)</span> <span class="main">=</span>
        <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> member <span class="entity">same_name</span> <span class="entity">Ps</span> <span class="main">(</span><span class="entity">real_head_of</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">tac1</span> <span class="entity">prm</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">tac2</span> <span class="entity">prm</span><span class="main">)</span> <span class="entity">i</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">side_thm</span> <span class="main">=</span> Goal.prove <span class="entity">ctxt'</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span>Thm.term_of <span class="entity">concl</span><span class="main">)</span>
        <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt''</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
           EVERY1 <span class="main">[</span> CONVERSION <span class="main">(</span><span class="entity">expand_conv_bot</span> <span class="entity">ctxt''</span><span class="main">)</span><span class="main">,</span>
                    <span class="entity">eqvt_stac</span> <span class="entity">ctxt''</span><span class="main">,</span>
                    resolve_tac <span class="entity">ctxt''</span> <span class="main">[</span><span class="entity">prem'</span><span class="main">]</span><span class="main">,</span>
                    RANGE <span class="main">(</span><span class="entity">tac_fresh</span> :: map <span class="main">(</span>SUBGOAL o <span class="entity">select</span><span class="main">)</span> <span class="entity">prems</span><span class="main">)</span> <span class="main">]</span><span class="main">)</span>
        |&gt; singleton <span class="main">(</span>Proof_Context.export <span class="entity">ctxt'</span> <span class="entity">ctxt</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">side_thm</span><span class="main">]</span> <span class="inner_numeral">1</span>
    <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span> <span class="entity">ctxt</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">case_tac</span> <span class="entity">ctxt</span> <span class="entity">Ps</span> <span class="entity">avoid</span> <span class="entity">avoid_trm</span> <span class="entity">intr_cvars</span> <span class="entity">param_trms</span> <span class="entity">prem</span> <span class="entity">user_thm</span> <span class="entity">concl_args</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tac1</span> <span class="main">=</span> <span class="entity">non_binder_tac</span> <span class="entity">prem</span> <span class="entity">intr_cvars</span> <span class="entity">Ps</span> <span class="entity">ctxt</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tac2</span> <span class="main">=</span> <span class="entity">binder_tac</span> <span class="entity">prem</span> <span class="entity">intr_cvars</span> <span class="entity">param_trms</span> <span class="entity">Ps</span> <span class="entity">user_thm</span> <span class="entity">avoid_trm</span> <span class="entity">concl_args</span> <span class="entity">ctxt</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    EVERY' <span class="main">[</span> resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> allI<span class="antiquote">}</span></span></span><span class="main">,</span> resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> allI<span class="antiquote">}</span></span></span><span class="main">,</span>
             <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">avoid</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">tac1</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">tac2</span> <span class="main">]</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_sinduct_tac</span> <span class="entity">raw_induct</span> <span class="entity">user_thms</span> <span class="entity">Ps</span> <span class="entity">avoids</span> <span class="entity">avoid_trms</span> <span class="entity">intr_cvars</span> <span class="entity">param_trms</span> <span class="entity">concl_args</span>
  <span class="main">{</span><span class="entity">prems</span><span class="main">,</span> context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">}</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cases_tac</span> <span class="main">=</span>
      <span class="entity">map7</span> <span class="main">(</span><span class="entity">case_tac</span> <span class="entity">ctxt</span> <span class="entity">Ps</span><span class="main">)</span> <span class="entity">avoids</span> <span class="entity">avoid_trms</span> <span class="entity">intr_cvars</span> <span class="entity">param_trms</span> <span class="entity">prems</span> <span class="entity">user_thms</span> <span class="entity">concl_args</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    EVERY1 <span class="main">[</span> DETERM o resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">raw_induct</span><span class="main">]</span><span class="main">,</span> RANGE <span class="entity">cases_tac</span> <span class="main">]</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">normalise</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">lemma</span> <span class="quoted">"<span class="main">(</span><span class="free">Q</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∀</span><span class="bound">p</span> <span class="bound">c</span><span class="main">.</span> <span class="free">P</span> <span class="bound">p</span> <span class="bound">c</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">⋀</span><span class="bound">c</span><span class="main">.</span> <span class="free">Q</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span><span class="main">0</span><span class="main">::</span>perm<span class="main">)</span> <span class="bound">c</span><span class="main">)</span>"</span> <span class="keyword1"><span class="keyword">by</span></span> <span class="operator">simp</span><span class="antiquote">}</span></span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_strong_inductive</span> <span class="entity">pred_names</span> <span class="entity">rule_names</span> <span class="entity">avoids</span> <span class="entity">raw_induct</span> <span class="entity">intrs</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">[</span><span class="entity">raw_induct'</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> Variable.import true <span class="main">[</span><span class="entity">raw_induct</span><span class="main">]</span> <span class="entity">ctxt</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ind_prems</span><span class="main">,</span> <span class="entity">ind_concl</span><span class="main">)</span> <span class="main">=</span> <span class="entity">raw_induct'</span>
      |&gt; Thm.prop_of
      |&gt; Logic.strip_horn
      |&gt;&gt; map <span class="entity">strip_full_horn</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">params</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">x</span><span class="main">)</span> <span class="entity">ind_prems</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">param_trms</span> <span class="main">=</span> <span class="main">(</span>map o map<span class="main">)</span> Free <span class="entity">params</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">intr_vars_tys</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> rev <span class="main">(</span>Term.add_vars <span class="main">(</span>Thm.prop_of <span class="entity">t</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="entity">intrs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">intr_vars</span> <span class="main">=</span> <span class="main">(</span>map o map<span class="main">)</span> fst <span class="entity">intr_vars_tys</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">intr_vars_substs</span> <span class="main">=</span> map2 <span class="main">(</span>curry <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> ~~<span class="main">)</span><span class="main">)</span> <span class="entity">intr_vars</span> <span class="entity">param_trms</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">intr_cvars</span> <span class="main">=</span> <span class="main">(</span>map o map<span class="main">)</span> <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> o Var<span class="main">)</span> <span class="entity">intr_vars_tys</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">intr_prems</span><span class="main">,</span> <span class="entity">intr_concls</span><span class="main">)</span> <span class="main">=</span> <span class="entity">intrs</span>
      |&gt; map Thm.prop_of
      |&gt; map2 subst_Vars <span class="entity">intr_vars_substs</span>
      |&gt; map Logic.strip_horn
      |&gt; split_list

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">intr_concls_args</span> <span class="main">=</span>
      map <span class="main">(</span>snd o <span class="entity">fixed_nonfixed_args</span> <span class="entity">ctxt'</span> o <span class="entity">HOLogic.dest_Trueprop</span><span class="main">)</span> <span class="entity">intr_concls</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">avoid_trms</span> <span class="main">=</span> <span class="entity">avoids</span>
      |&gt; <span class="main">(</span>map o map<span class="main">)</span> <span class="main">(</span><span class="entity">setify</span> <span class="entity">ctxt'</span><span class="main">)</span>
      |&gt; map <span class="entity">fold_union</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vc_compat_goals</span> <span class="main">=</span>
      <span class="entity">map4</span> <span class="entity">mk_vc_compat</span> <span class="main">(</span><span class="entity">avoids</span> ~~ <span class="entity">avoid_trms</span><span class="main">)</span> <span class="entity">intr_prems</span> <span class="entity">intr_concls_args</span> <span class="entity">params</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">[</span><span class="entity">c_name</span><span class="main">,</span> <span class="entity">a</span><span class="main">,</span> <span class="entity">p</span><span class="main">]</span><span class="main">,</span> <span class="entity">ctxt''</span><span class="main">)</span> <span class="main">=</span> Variable.variant_fixes <span class="main">[</span><span class="inner_quoted">"c"</span><span class="main">,</span> <span class="inner_quoted">"'a"</span><span class="main">,</span> <span class="inner_quoted">"p"</span><span class="main">]</span> <span class="entity">ctxt'</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c_ty</span> <span class="main">=</span> TFree <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">fs</span><span class="antiquote">}</span></span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">c_name</span><span class="main">,</span> <span class="entity">c_ty</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">p</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">p</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">perm</span><span class="antiquote">}</span></span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">preconds</span><span class="main">,</span> <span class="entity">ind_concls</span><span class="main">)</span> <span class="main">=</span> <span class="entity">ind_concl</span>
      |&gt; <span class="entity">HOLogic.dest_Trueprop</span>
      |&gt; <span class="entity">HOLogic.dest_conj</span>
      |&gt; map <span class="entity">HOLogic.dest_imp</span>
      |&gt; split_list

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Ps</span> <span class="main">=</span> map <span class="main">(</span>fst o strip_comb<span class="main">)</span> <span class="entity">ind_concls</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ind_concl'</span> <span class="main">=</span> <span class="entity">ind_concls</span>
      |&gt; map <span class="main">(</span><span class="entity">add_p_c</span> <span class="entity">p</span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">c_ty</span><span class="main">)</span><span class="main">)</span>
      |&gt; <span class="main">(</span>curry <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> ~~<span class="main">)</span><span class="main">)</span> <span class="entity">preconds</span>
      |&gt; map <span class="entity">HOLogic.mk_imp</span>
      |&gt; <span class="entity">fold_conj</span>
      |&gt; <span class="entity">HOLogic.mk_Trueprop</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ind_prems'</span> <span class="main">=</span> <span class="entity">ind_prems</span>
      |&gt; map2 <span class="main">(</span><span class="entity">prep_prem</span> <span class="entity">Ps</span> <span class="entity">c_name</span> <span class="entity">c_ty</span><span class="main">)</span> <span class="main">(</span><span class="entity">avoids</span> ~~ <span class="entity">avoid_trms</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">after_qed</span> <span class="entity">ctxt_outside</span> <span class="entity">user_thms</span> <span class="entity">ctxt</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">strong_ind_thms</span> <span class="main">=</span> Goal.prove <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="entity">ind_prems'</span> <span class="entity">ind_concl'</span>
        <span class="main">(</span><span class="entity">prove_sinduct_tac</span> <span class="entity">raw_induct</span> <span class="entity">user_thms</span> <span class="entity">Ps</span> <span class="entity">avoids</span> <span class="entity">avoid_trms</span> <span class="entity">intr_cvars</span> <span class="entity">param_trms</span> <span class="entity">intr_concls_args</span><span class="main">)</span>
          |&gt; singleton <span class="main">(</span>Proof_Context.export <span class="entity">ctxt</span> <span class="entity">ctxt_outside</span><span class="main">)</span>
          |&gt; <span class="entity">Old_Datatype_Aux.split_conj_thm</span>
          |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">thm</span> <span class="main">=&gt;</span> <span class="entity">thm</span> RS <span class="entity">normalise</span><span class="main">)</span>
          |&gt; map <span class="main">(</span><span class="entity">asm_full_simplify</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span>
              addsimps <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> permute_zero induct_rulify<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">)</span>
          |&gt; map <span class="main">(</span>Drule.rotate_prems <span class="main">(</span>length <span class="entity">ind_prems'</span><span class="main">)</span><span class="main">)</span>
          |&gt; map zero_var_indexes

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">qualified_thm_name</span> <span class="main">=</span> <span class="entity">pred_names</span>
          |&gt; map Long_Name.base_name
          |&gt; space_implode <span class="inner_quoted">"_"</span>
          |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">s</span> <span class="main">=&gt;</span> Binding.qualify false <span class="entity">s</span> <span class="main">(</span>Binding.name <span class="inner_quoted">"strong_induct"</span><span class="main">)</span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">attrs</span> <span class="main">=</span>
          <span class="main">[</span> <span class="entity">Attrib.internal</span> <span class="main">(</span>K <span class="main">(</span>Rule_Cases.consumes <span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
            <span class="entity">Attrib.internal</span> <span class="main">(</span>K <span class="main">(</span>Rule_Cases.case_names <span class="entity">rule_names</span><span class="main">)</span><span class="main">)</span> <span class="main">]</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="entity">ctxt</span>
        |&gt; Local_Theory.note <span class="main">(</span><span class="main">(</span><span class="entity">qualified_thm_name</span><span class="main">,</span> <span class="entity">attrs</span><span class="main">)</span><span class="main">,</span> <span class="entity">strong_ind_thms</span><span class="main">)</span>
        |&gt; snd
      <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">Proof.theorem</span> NONE <span class="main">(</span><span class="entity">after_qed</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span>map o map<span class="main">)</span> <span class="main">(</span>rpair <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="entity">vc_compat_goals</span><span class="main">)</span> <span class="entity">ctxt''</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_strong_inductive_cmd</span> <span class="main">(</span><span class="entity">pred_name</span><span class="main">,</span> <span class="entity">avoids</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">{</span><span class="entity">names</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">,</span> <span class="main">{</span><span class="entity">raw_induct</span><span class="main">,</span> <span class="entity">intrs</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">Inductive.the_inductive_global</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">long_name</span> <span class="entity">ctxt</span> <span class="entity">pred_name</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rule_names</span> <span class="main">=</span> hd <span class="entity">names</span>
      |&gt; the o <span class="entity">Induct.lookup_inductP</span> <span class="entity">ctxt</span>
      |&gt; fst o Rule_Cases.get
      |&gt; map <span class="main">(</span>fst o fst<span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">case_names</span> <span class="main">=</span> map fst <span class="entity">avoids</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> duplicates <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">case_names</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">xs</span> <span class="main">=&gt;</span> error <span class="main">(</span><span class="inner_quoted">"Duplicate case names: "</span> ^ commas_quote <span class="entity">xs</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> subtract <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">rule_names</span> <span class="entity">case_names</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">xs</span> <span class="main">=&gt;</span> error <span class="main">(</span><span class="inner_quoted">"No such case(s) in inductive definition: "</span> ^ commas_quote <span class="entity">xs</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">avoids_ordered</span> <span class="main">=</span> <span class="entity">order_default</span> <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span> <span class="entity">rule_names</span> <span class="entity">avoids</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">read_avoids</span> <span class="entity">avoid_trms</span> <span class="entity">intr</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="comment1">(* fixme hack *)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">ctrms</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> Variable.import true <span class="main">[</span><span class="entity">intr</span><span class="main">]</span> <span class="entity">ctxt</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">trms</span> <span class="main">=</span> map <span class="main">(</span>Thm.term_of o snd<span class="main">)</span> <span class="entity">ctrms</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt''</span> <span class="main">=</span> fold Variable.declare_term <span class="entity">trms</span> <span class="entity">ctxt'</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        map <span class="main">(</span>Syntax.read_term <span class="entity">ctxt''</span><span class="main">)</span> <span class="entity">avoid_trms</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">avoid_trms</span> <span class="main">=</span> map2 <span class="entity">read_avoids</span> <span class="entity">avoids_ordered</span> <span class="entity">intrs</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">prove_strong_inductive</span> <span class="entity">names</span> <span class="entity">rule_names</span> <span class="entity">avoid_trms</span> <span class="entity">raw_induct</span> <span class="entity">intrs</span> <span class="entity">ctxt</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* outer syntax *)</span>
<span class="keyword2"><span class="keyword">local</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">single_avoid_parser</span> <span class="main">=</span>
    Parse.name -- <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">:</span>"<span class="antiquote">}</span></span></span> |-- Parse.and_list1 Parse.term<span class="main">)</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">avoids_parser</span> <span class="main">=</span>
    Scan.optional <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">avoids</span>"<span class="antiquote">}</span></span></span> |-- Parse.enum1 <span class="inner_quoted">"|"</span> <span class="entity">single_avoid_parser</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">main_parser</span> <span class="main">=</span> Parse.name -- <span class="entity">avoids_parser</span>
<span class="keyword2"><span class="keyword">in</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
    <span class="entity">Outer_Syntax.local_theory_to_proof</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> <span class="keyword1">nominal_inductive</span><span class="antiquote">}</span></span></span>
      <span class="inner_quoted">"prove strong induction theorem for inductive predicate involving nominal datatypes"</span>
        <span class="main">(</span><span class="entity">main_parser</span> &gt;&gt; <span class="entity">prove_strong_inductive_cmd</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/nominal_function_common.ML">
<div class="head">
<h1>File ‹nominal_function_common.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*  Nominal Function Common
    Author: Christian Urban

    heavily based on the code of Alexander Krauss
    (code forked on 5 June 2011)

Redefinition of config datatype
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">NOMINAL_FUNCTION_DATA</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">nominal_info</span> <span class="main">=</span>
 <span class="main">{</span>is_partial <span class="main">:</span> bool<span class="main">,</span>
  defname <span class="main">:</span> string<span class="main">,</span>
    <span class="comment1">(* contains no logical entities: invariant under morphisms: *)</span>
  add_simps <span class="main">:</span> <span class="main">(</span>binding <span class="main">-&gt;</span> binding<span class="main">)</span> <span class="main">-&gt;</span> string <span class="main">-&gt;</span> <span class="main">(</span>binding <span class="main">-&gt;</span> binding<span class="main">)</span> <span class="main">-&gt;</span>
    Token.src list <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> thm list * local_theory<span class="main">,</span>
  case_names <span class="main">:</span> string list<span class="main">,</span>
  fs <span class="main">:</span> term list<span class="main">,</span>
  R <span class="main">:</span> term<span class="main">,</span>
  psimps<span class="main">:</span> thm list<span class="main">,</span>
  pinducts<span class="main">:</span> thm list<span class="main">,</span>
  simps <span class="main">:</span> thm list option<span class="main">,</span>
  inducts <span class="main">:</span> thm list option<span class="main">,</span>
  termination<span class="main">:</span> thm<span class="main">,</span>
  eqvts<span class="main">:</span> thm list<span class="main">}</span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Nominal_Function_Common</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">nominal_info</span> <span class="main">=</span>
 <span class="main">{</span>is_partial <span class="main">:</span> bool<span class="main">,</span>
  defname <span class="main">:</span> string<span class="main">,</span>
    <span class="comment1">(* contains no logical entities: invariant under morphisms: *)</span>
  add_simps <span class="main">:</span> <span class="main">(</span>binding <span class="main">-&gt;</span> binding<span class="main">)</span> <span class="main">-&gt;</span> string <span class="main">-&gt;</span> <span class="main">(</span>binding <span class="main">-&gt;</span> binding<span class="main">)</span> <span class="main">-&gt;</span>
    Token.src list <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> thm list * local_theory<span class="main">,</span>
  case_names <span class="main">:</span> string list<span class="main">,</span>
  fs <span class="main">:</span> term list<span class="main">,</span>
  R <span class="main">:</span> term<span class="main">,</span>
  psimps<span class="main">:</span> thm list<span class="main">,</span>
  pinducts<span class="main">:</span> thm list<span class="main">,</span>
  simps <span class="main">:</span> thm list option<span class="main">,</span>
  inducts <span class="main">:</span> thm list option<span class="main">,</span>
  termination<span class="main">:</span> thm<span class="main">,</span>
  eqvts<span class="main">:</span> thm list<span class="main">}</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">morph_function_data</span> <span class="main">(</span><span class="main">{</span><span class="entity">add_simps</span><span class="main">,</span> <span class="entity">case_names</span><span class="main">,</span> <span class="entity">fs</span><span class="main">,</span> <span class="entity">R</span><span class="main">,</span> <span class="entity">psimps</span><span class="main">,</span> <span class="entity">pinducts</span><span class="main">,</span>
  <span class="entity">simps</span><span class="main">,</span> <span class="entity">inducts</span><span class="main">,</span> <span class="entity">termination</span><span class="main">,</span> <span class="entity">defname</span><span class="main">,</span> <span class="entity">is_partial</span><span class="main">,</span> <span class="entity">eqvts</span><span class="main">}</span> <span class="main">:</span> <span class="entity">nominal_info</span><span class="main">)</span> <span class="entity">phi</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">term</span> <span class="main">=</span> Morphism.term <span class="entity">phi</span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm</span> <span class="main">=</span> Morphism.thm <span class="entity">phi</span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fact</span> <span class="main">=</span> Morphism.fact <span class="entity">phi</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">name</span> <span class="main">=</span> Binding.name_of o Morphism.binding <span class="entity">phi</span> o Binding.name
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">{</span> add_simps <span class="main">=</span> <span class="entity">add_simps</span><span class="main">,</span> case_names <span class="main">=</span> <span class="entity">case_names</span><span class="main">,</span>
        fs <span class="main">=</span> map <span class="entity">term</span> <span class="entity">fs</span><span class="main">,</span> R <span class="main">=</span> <span class="entity">term</span> <span class="entity">R</span><span class="main">,</span> psimps <span class="main">=</span> <span class="entity">fact</span> <span class="entity">psimps</span><span class="main">,</span>
        pinducts <span class="main">=</span> <span class="entity">fact</span> <span class="entity">pinducts</span><span class="main">,</span> simps <span class="main">=</span> Option.map <span class="entity">fact</span> <span class="entity">simps</span><span class="main">,</span>
        inducts <span class="main">=</span> Option.map <span class="entity">fact</span> <span class="entity">inducts</span><span class="main">,</span> termination <span class="main">=</span> <span class="entity">thm</span> <span class="entity">termination</span><span class="main">,</span>
        defname <span class="main">=</span> <span class="entity">name</span> <span class="entity">defname</span><span class="main">,</span> is_partial<span class="main">=</span><span class="entity">is_partial</span><span class="main">,</span> eqvts <span class="main">=</span> <span class="entity">fact</span> <span class="entity">eqvts</span> <span class="main">}</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">NominalFunctionData</span> <span class="main">=</span> Generic_Data
<span class="main">(</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="main">(</span>term * <span class="entity">nominal_info</span><span class="main">)</span> Item_Net.T<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">empty</span> <span class="main">:</span> <span class="entity">T</span> <span class="main">=</span> Item_Net.init <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv o apply2 fst<span class="main">)</span> <span class="main">(</span>single o fst<span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">extend</span> <span class="main">=</span> I<span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">merge</span> <span class="entity">tabs</span> <span class="main">:</span> <span class="entity">T</span> <span class="main">=</span> Item_Net.merge <span class="entity">tabs</span><span class="main">;</span>
<span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">get_function</span> <span class="main">=</span> NominalFunctionData.get o Context.Proof<span class="main">;</span>


<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">lift_morphism</span> <span class="entity">ctxt</span> <span class="entity">f</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">term</span> <span class="entity">t</span> <span class="main">=</span> Thm.term_of <span class="main">(</span>Drule.cterm_rule <span class="entity">f</span> <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Morphism.morphism <span class="inner_quoted">"lift_morphism"</span>
      <span class="main">{</span>binding <span class="main">=</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span>
       typ <span class="main">=</span> <span class="main">[</span>Logic.type_map <span class="entity">term</span><span class="main">]</span><span class="main">,</span>
       term <span class="main">=</span> <span class="main">[</span><span class="entity">term</span><span class="main">]</span><span class="main">,</span>
       fact <span class="main">=</span> <span class="main">[</span>map <span class="entity">f</span><span class="main">]</span><span class="main">}</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">import_function_data</span> <span class="entity">t</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ct</span> <span class="main">=</span> Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">t</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inst_morph</span> <span class="main">=</span> <span class="entity">lift_morphism</span> <span class="entity">ctxt</span> o Thm.instantiate

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">match</span> <span class="main">(</span><span class="entity">trm</span><span class="main">,</span> <span class="entity">data</span><span class="main">)</span> <span class="main">=</span>
      SOME <span class="main">(</span><span class="entity">morph_function_data</span> <span class="entity">data</span> <span class="main">(</span><span class="entity">inst_morph</span> <span class="main">(</span>Thm.match <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">trm</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword3"><span class="keyword">handle</span></span> Pattern.MATCH <span class="main">=&gt;</span> NONE
  <span class="keyword2"><span class="keyword">in</span></span>
    get_first <span class="entity">match</span> <span class="main">(</span>Item_Net.retrieve <span class="main">(</span><span class="entity">get_function</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">t</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">import_last_function</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">case</span></span> Item_Net.content <span class="main">(</span><span class="entity">get_function</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
    <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> NONE
  <span class="main">|</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">data</span><span class="main">)</span> :: <span class="main">_</span> <span class="main">=&gt;</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">[</span><span class="entity">t'</span><span class="main">]</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> Variable.import_terms true <span class="main">[</span><span class="entity">t</span><span class="main">]</span> <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">import_function_data</span> <span class="entity">t'</span> <span class="entity">ctxt'</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_function_data</span> <span class="main">=</span> Item_Net.content o <span class="entity">get_function</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_function_data</span> <span class="main">(</span><span class="entity">data</span> <span class="main">:</span> <span class="entity">nominal_info</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span><span class="entity">fs</span><span class="main">,</span> <span class="entity">termination</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
  NominalFunctionData.map <span class="main">(</span>fold <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">f</span> <span class="main">=&gt;</span> Item_Net.update <span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="entity">data</span><span class="main">)</span><span class="main">)</span> <span class="entity">fs</span><span class="main">)</span>
  #&gt; <span class="entity">Function_Common.store_termination_rule</span> <span class="entity">termination</span>




<span class="comment1">(* Configuration management *)</span>
<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">nominal_function_opt</span>
  <span class="main">=</span> <span class="entity">Sequential</span>
  <span class="main">|</span> <span class="entity">Default</span> <span class="keyword2"><span class="keyword">of</span></span> string
  <span class="main">|</span> <span class="entity">DomIntros</span>
  <span class="main">|</span> <span class="entity">No_Partials</span>
  <span class="main">|</span> <span class="entity">Invariant</span> <span class="keyword2"><span class="keyword">of</span></span> string

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">nominal_function_config</span> <span class="main">=</span> <span class="entity">NominalFunctionConfig</span> <span class="keyword2"><span class="keyword">of</span></span>
 <span class="main">{</span>sequential<span class="main">:</span> bool<span class="main">,</span>
  default<span class="main">:</span> string option<span class="main">,</span>
  domintros<span class="main">:</span> bool<span class="main">,</span>
  partials<span class="main">:</span> bool<span class="main">,</span>
  inv<span class="main">:</span> string option<span class="main">}</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">apply_opt</span> <span class="entity">Sequential</span> <span class="main">(</span><span class="entity">NominalFunctionConfig</span> <span class="main">{</span><span class="entity">sequential</span><span class="main">,</span> <span class="entity">default</span><span class="main">,</span> <span class="entity">domintros</span><span class="main">,</span> <span class="entity">partials</span><span class="main">,</span> <span class="entity">inv</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">NominalFunctionConfig</span>
      <span class="main">{</span>sequential<span class="main">=</span>true<span class="main">,</span> default<span class="main">=</span><span class="entity">default</span><span class="main">,</span> domintros<span class="main">=</span><span class="entity">domintros</span><span class="main">,</span> partials<span class="main">=</span><span class="entity">partials</span><span class="main">,</span> inv<span class="main">=</span><span class="entity">inv</span><span class="main">}</span>
  <span class="main">|</span> <span class="entity">apply_opt</span> <span class="main">(</span><span class="entity">Default</span> <span class="entity">d</span><span class="main">)</span> <span class="main">(</span><span class="entity">NominalFunctionConfig</span> <span class="main">{</span><span class="entity">sequential</span><span class="main">,</span> <span class="entity">default</span><span class="main">,</span> <span class="entity">domintros</span><span class="main">,</span> <span class="entity">partials</span><span class="main">,</span> <span class="entity">inv</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">NominalFunctionConfig</span>
      <span class="main">{</span>sequential<span class="main">=</span><span class="entity">sequential</span><span class="main">,</span> default<span class="main">=</span>SOME <span class="entity">d</span><span class="main">,</span> domintros<span class="main">=</span><span class="entity">domintros</span><span class="main">,</span> partials<span class="main">=</span><span class="entity">partials</span><span class="main">,</span> inv<span class="main">=</span><span class="entity">inv</span><span class="main">}</span>
  <span class="main">|</span> <span class="entity">apply_opt</span> <span class="entity">DomIntros</span> <span class="main">(</span><span class="entity">NominalFunctionConfig</span> <span class="main">{</span><span class="entity">sequential</span><span class="main">,</span> <span class="entity">default</span><span class="main">,</span> <span class="entity">domintros</span><span class="main">,</span> <span class="entity">partials</span><span class="main">,</span> <span class="entity">inv</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">NominalFunctionConfig</span>
      <span class="main">{</span>sequential<span class="main">=</span><span class="entity">sequential</span><span class="main">,</span> default<span class="main">=</span><span class="entity">default</span><span class="main">,</span> domintros<span class="main">=</span>true<span class="main">,</span> partials<span class="main">=</span><span class="entity">partials</span><span class="main">,</span> inv<span class="main">=</span><span class="entity">inv</span><span class="main">}</span>
  <span class="main">|</span> <span class="entity">apply_opt</span> <span class="entity">No_Partials</span> <span class="main">(</span><span class="entity">NominalFunctionConfig</span> <span class="main">{</span><span class="entity">sequential</span><span class="main">,</span> <span class="entity">default</span><span class="main">,</span> <span class="entity">domintros</span><span class="main">,</span> <span class="entity">partials</span><span class="main">,</span> <span class="entity">inv</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">NominalFunctionConfig</span>
      <span class="main">{</span>sequential<span class="main">=</span><span class="entity">sequential</span><span class="main">,</span> default<span class="main">=</span><span class="entity">default</span><span class="main">,</span> domintros<span class="main">=</span><span class="entity">domintros</span><span class="main">,</span> partials<span class="main">=</span>false<span class="main">,</span> inv<span class="main">=</span><span class="entity">inv</span><span class="main">}</span>
  <span class="main">|</span> <span class="entity">apply_opt</span> <span class="main">(</span><span class="entity">Invariant</span> <span class="entity">s</span><span class="main">)</span> <span class="main">(</span><span class="entity">NominalFunctionConfig</span> <span class="main">{</span><span class="entity">sequential</span><span class="main">,</span> <span class="entity">default</span><span class="main">,</span> <span class="entity">domintros</span><span class="main">,</span> <span class="entity">partials</span><span class="main">,</span> <span class="entity">inv</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">NominalFunctionConfig</span>
      <span class="main">{</span>sequential<span class="main">=</span><span class="entity">sequential</span><span class="main">,</span> default<span class="main">=</span><span class="entity">default</span><span class="main">,</span> domintros<span class="main">=</span><span class="entity">domintros</span><span class="main">,</span> partials<span class="main">=</span><span class="entity">partials</span><span class="main">,</span> inv <span class="main">=</span> SOME <span class="entity">s</span><span class="main">}</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nominal_default_config</span> <span class="main">=</span>
  <span class="entity">NominalFunctionConfig</span> <span class="main">{</span> sequential<span class="main">=</span>false<span class="main">,</span> default<span class="main">=</span>NONE<span class="main">,</span>
    domintros<span class="main">=</span>false<span class="main">,</span> partials<span class="main">=</span>true<span class="main">,</span> inv<span class="main">=</span>NONE<span class="main">}</span>

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">nominal_function_result</span> <span class="main">=</span> <span class="entity">NominalFunctionResult</span> <span class="keyword2"><span class="keyword">of</span></span>
 <span class="main">{</span>fs<span class="main">:</span> term list<span class="main">,</span>
  G<span class="main">:</span> term<span class="main">,</span>
  R<span class="main">:</span> term<span class="main">,</span>
  psimps <span class="main">:</span> thm list<span class="main">,</span>
  simple_pinducts <span class="main">:</span> thm list<span class="main">,</span>
  cases <span class="main">:</span> thm<span class="main">,</span>
  termination <span class="main">:</span> thm<span class="main">,</span>
  domintros <span class="main">:</span> thm list option<span class="main">,</span>
  eqvts <span class="main">:</span> thm list<span class="main">}</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/nominal_function_core.ML">
<div class="head">
<h1>File ‹nominal_function_core.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*  Nominal Function Core
    Author:  Christian Urban

    heavily based on the code of Alexander Krauss
    (code forked on 14 January 2011)

Core of the nominal function package.
*)</span>


<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">NOMINAL_FUNCTION_CORE</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> trace<span class="main">:</span> bool Unsynchronized.ref

  <span class="keyword1"><span class="keyword">val</span></span> prepare_nominal_function <span class="main">:</span> <span class="entity">Nominal_Function_Common.nominal_function_config</span>
    <span class="main">-&gt;</span> string <span class="comment1">(* defname *)</span>
    <span class="main">-&gt;</span> <span class="main">(</span><span class="main">(</span>bstring * typ<span class="main">)</span> * mixfix<span class="main">)</span> list <span class="comment1">(* defined symbol *)</span>
    <span class="main">-&gt;</span> <span class="main">(</span><span class="main">(</span>bstring * typ<span class="main">)</span> list * term list * term * term<span class="main">)</span> list <span class="comment1">(* specification *)</span>
    <span class="main">-&gt;</span> local_theory
    <span class="main">-&gt;</span> <span class="main">(</span>term   <span class="comment1">(* f *)</span>
        * term <span class="comment1">(* G(raph) *)</span>
        * thm list <span class="comment1">(* GIntros *)</span>
        * thm <span class="comment1">(* Ginduct *)</span>
        * thm  <span class="comment1">(* goalstate *)</span>
        * <span class="main">(</span><span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> <span class="entity">Nominal_Function_Common.nominal_function_result</span><span class="main">)</span> <span class="comment1">(* continuation *)</span>
       <span class="main">)</span> * local_theory

  <span class="keyword1"><span class="keyword">val</span></span> inductive_def <span class="main">:</span> <span class="main">(</span>binding * typ<span class="main">)</span> * mixfix <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> local_theory
    <span class="main">-&gt;</span> <span class="main">(</span>term * thm list * thm * thm<span class="main">)</span> * local_theory
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Nominal_Function_Core</span> <span class="main">:</span> <span class="entity">NOMINAL_FUNCTION_CORE</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">trace</span> <span class="main">=</span> Unsynchronized.ref false
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">trace_msg</span> <span class="entity">msg</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> ! <span class="entity">trace</span> <span class="keyword2"><span class="keyword">then</span></span> tracing <span class="main">(</span><span class="entity">msg</span> <span class="main">(</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">boolT</span> <span class="main">=</span> <span class="entity">HOLogic.boolT</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mk_eq</span> <span class="main">=</span> <span class="entity">HOLogic.mk_eq</span>

<span class="keyword3"><span class="keyword">open</span></span> Function_Lib
<span class="keyword3"><span class="keyword">open</span></span> Function_Common
<span class="keyword3"><span class="keyword">open</span></span> Nominal_Function_Common

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">globals</span> <span class="main">=</span> <span class="entity">Globals</span> <span class="keyword2"><span class="keyword">of</span></span>
 <span class="main">{</span>fvar<span class="main">:</span> term<span class="main">,</span>
  domT<span class="main">:</span> typ<span class="main">,</span>
  ranT<span class="main">:</span> typ<span class="main">,</span>
  h<span class="main">:</span> term<span class="main">,</span>
  y<span class="main">:</span> term<span class="main">,</span>
  x<span class="main">:</span> term<span class="main">,</span>
  z<span class="main">:</span> term<span class="main">,</span>
  a<span class="main">:</span> term<span class="main">,</span>
  P<span class="main">:</span> term<span class="main">,</span>
  D<span class="main">:</span> term<span class="main">,</span>
  Pbool<span class="main">:</span>term<span class="main">}</span>

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">rec_call_info</span> <span class="main">=</span> <span class="entity">RCInfo</span> <span class="keyword2"><span class="keyword">of</span></span>
 <span class="main">{</span>RIvs<span class="main">:</span> <span class="main">(</span>string * typ<span class="main">)</span> list<span class="main">,</span>  <span class="comment1">(* Call context: fixes and assumes *)</span>
  CCas<span class="main">:</span> thm list<span class="main">,</span>
  rcarg<span class="main">:</span> term<span class="main">,</span>                 <span class="comment1">(* The recursive argument *)</span>
  llRI<span class="main">:</span> thm<span class="main">,</span>
  h_assum<span class="main">:</span> term<span class="main">}</span>


<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">clause_context</span> <span class="main">=</span> <span class="entity">ClauseContext</span> <span class="keyword2"><span class="keyword">of</span></span>
 <span class="main">{</span>ctxt <span class="main">:</span> Proof.context<span class="main">,</span>
  qs <span class="main">:</span> term list<span class="main">,</span>
  gs <span class="main">:</span> term list<span class="main">,</span>
  lhs<span class="main">:</span> term<span class="main">,</span>
  rhs<span class="main">:</span> term<span class="main">,</span>
  cqs<span class="main">:</span> cterm list<span class="main">,</span>
  ags<span class="main">:</span> thm list<span class="main">,</span>
  case_hyp <span class="main">:</span> thm<span class="main">}</span>


<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">transfer_clause_ctx</span> <span class="entity">thy</span> <span class="main">(</span><span class="entity">ClauseContext</span> <span class="main">{</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="entity">qs</span><span class="main">,</span> <span class="entity">gs</span><span class="main">,</span> <span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">,</span> <span class="entity">cqs</span><span class="main">,</span> <span class="entity">ags</span><span class="main">,</span> <span class="entity">case_hyp</span> <span class="main">}</span><span class="main">)</span> <span class="main">=</span>
  <span class="entity">ClauseContext</span> <span class="main">{</span> ctxt <span class="main">=</span> Proof_Context.transfer <span class="entity">thy</span> <span class="entity">ctxt</span><span class="main">,</span>
    qs <span class="main">=</span> <span class="entity">qs</span><span class="main">,</span> gs <span class="main">=</span> <span class="entity">gs</span><span class="main">,</span> lhs <span class="main">=</span> <span class="entity">lhs</span><span class="main">,</span> rhs <span class="main">=</span> <span class="entity">rhs</span><span class="main">,</span> cqs <span class="main">=</span> <span class="entity">cqs</span><span class="main">,</span> ags <span class="main">=</span> <span class="entity">ags</span><span class="main">,</span> case_hyp <span class="main">=</span> <span class="entity">case_hyp</span> <span class="main">}</span>


<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">clause_info</span> <span class="main">=</span> <span class="entity">ClauseInfo</span> <span class="keyword2"><span class="keyword">of</span></span>
 <span class="main">{</span>no<span class="main">:</span> int<span class="main">,</span>
  qglr <span class="main">:</span> <span class="main">(</span><span class="main">(</span>string * typ<span class="main">)</span> list * term list * term * term<span class="main">)</span><span class="main">,</span>
  cdata <span class="main">:</span> clause_context<span class="main">,</span>
  tree<span class="main">:</span> Function_Context_Tree.ctx_tree<span class="main">,</span>
  lGI<span class="main">:</span> thm<span class="main">,</span>
  RCs<span class="main">:</span> rec_call_info list<span class="main">}</span>


<span class="comment1">(* Theory dependencies. *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">acc_induct_rule</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> accp_induct_rule<span class="antiquote">}</span></span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ex1_implies_ex</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Fun_Def.fundef_ex1_existence<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ex1_implies_un</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Fun_Def.fundef_ex1_uniqueness<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ex1_implies_iff</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Fun_Def.fundef_ex1_iff<span class="antiquote">}</span></span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">acc_downward</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> accp_downward<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">accI</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> accp.accI<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">case_split</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> HOL.case_split<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fundef_default_value</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Fun_Def.fundef_default_value<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">not_acc_down</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> not_accp_down<span class="antiquote">}</span></span></span>



<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">find_calls</span> <span class="entity">tree</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_Ri</span> <span class="main">(</span><span class="entity">fixes</span><span class="main">,</span><span class="entity">assumes</span><span class="main">)</span> <span class="main">(</span><span class="main">_</span> $ <span class="entity">arg</span><span class="main">)</span> <span class="main">_</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">xs</span><span class="main">)</span> <span class="main">=</span>
      <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">(</span><span class="entity">fixes</span><span class="main">,</span> <span class="entity">assumes</span><span class="main">,</span> <span class="entity">arg</span><span class="main">)</span> :: <span class="entity">xs</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">add_Ri</span> <span class="main">_</span> <span class="main">_</span> <span class="main">_</span> <span class="main">_</span> <span class="main">=</span> <span class="keyword3"><span class="keyword">raise</span></span> Match
  <span class="keyword2"><span class="keyword">in</span></span>
    rev <span class="main">(</span><span class="entity">Function_Context_Tree.traverse_tree</span> <span class="entity">add_Ri</span> <span class="entity">tree</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* nominal *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_eqvt_at</span> <span class="main">(</span><span class="entity">f_trm</span><span class="main">,</span> <span class="entity">arg_trm</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">f_ty</span> <span class="main">=</span> fastype_of <span class="entity">f_trm</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg_ty</span> <span class="main">=</span> domain_type <span class="entity">f_ty</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> eqvt_at<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">[</span><span class="entity">f_ty</span><span class="main">,</span> <span class="entity">arg_ty</span><span class="main">]</span> ---&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">bool</span><span class="antiquote">}</span></span><span class="main">)</span> $ <span class="entity">f_trm</span> $ <span class="entity">arg_trm</span>
    |&gt; <span class="entity">HOLogic.mk_Trueprop</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_eqvt</span> <span class="entity">trm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty</span> <span class="main">=</span> fastype_of <span class="entity">trm</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> eqvt<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">ty</span> --&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">bool</span><span class="antiquote">}</span></span><span class="main">)</span> $ <span class="entity">trm</span>
    |&gt; <span class="entity">HOLogic.mk_Trueprop</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_inv</span> <span class="entity">inv</span> <span class="main">(</span><span class="entity">f_trm</span><span class="main">,</span> <span class="entity">arg_trm</span><span class="main">)</span> <span class="main">=</span>
  betapplys <span class="main">(</span><span class="entity">inv</span><span class="main">,</span> <span class="main">[</span><span class="entity">arg_trm</span><span class="main">,</span> <span class="main">(</span><span class="entity">f_trm</span> $ <span class="entity">arg_trm</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>
  |&gt; <span class="entity">HOLogic.mk_Trueprop</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_invariant</span> <span class="main">(</span><span class="entity">Globals</span> <span class="main">{</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="entity">G</span> <span class="entity">invariant</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prem</span> <span class="main">=</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">G</span> $ <span class="entity">x</span> $ <span class="entity">y</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">concl</span> <span class="main">=</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span>betapplys <span class="main">(</span><span class="entity">invariant</span><span class="main">,</span> <span class="main">[</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Logic.mk_implies <span class="main">(</span><span class="entity">prem</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span>
    |&gt; <span class="entity">mk_forall_rename</span> <span class="main">(</span><span class="inner_quoted">"y"</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span>
    |&gt; <span class="entity">mk_forall_rename</span> <span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> <span class="entity">x</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(** building proof obligations *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_eqvt_proof_obligation</span> <span class="entity">qs</span> <span class="entity">fvar</span> <span class="main">(</span><span class="entity">vs</span><span class="main">,</span> <span class="entity">assms</span><span class="main">,</span> <span class="entity">arg</span><span class="main">)</span> <span class="main">=</span>
  <span class="entity">mk_eqvt_at</span> <span class="main">(</span><span class="entity">fvar</span><span class="main">,</span> <span class="entity">arg</span><span class="main">)</span>
  |&gt; curry Logic.list_implies <span class="main">(</span>map Thm.prop_of <span class="entity">assms</span><span class="main">)</span>
  |&gt; fold_rev <span class="main">(</span>Logic.all o Free<span class="main">)</span> <span class="entity">vs</span>
  |&gt; fold_rev absfree <span class="entity">qs</span>
  |&gt; strip_abs_body

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_inv_proof_obligation</span> <span class="entity">inv</span> <span class="entity">qs</span> <span class="entity">fvar</span> <span class="main">(</span><span class="entity">vs</span><span class="main">,</span> <span class="entity">assms</span><span class="main">,</span> <span class="entity">arg</span><span class="main">)</span> <span class="main">=</span>
  <span class="entity">mk_inv</span> <span class="entity">inv</span> <span class="main">(</span><span class="entity">fvar</span><span class="main">,</span> <span class="entity">arg</span><span class="main">)</span>
  |&gt; curry Logic.list_implies <span class="main">(</span>map Thm.prop_of <span class="entity">assms</span><span class="main">)</span>
  |&gt; fold_rev <span class="main">(</span>Logic.all o Free<span class="main">)</span> <span class="entity">vs</span>
  |&gt; fold_rev absfree <span class="entity">qs</span>
  |&gt; strip_abs_body

<span class="comment1">(** building proof obligations *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_compat_proof_obligations</span> <span class="entity">domT</span> <span class="entity">ranT</span> <span class="entity">fvar</span> <span class="entity">f</span> <span class="entity">RCss</span> <span class="entity">inv</span> <span class="entity">glrs</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_impl</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">qs</span><span class="main">,</span> <span class="entity">gs</span><span class="main">,</span> <span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span><span class="main">,</span> <span class="entity">RCs_lhs</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">(</span><span class="entity">qs'</span><span class="main">,</span> <span class="entity">gs'</span><span class="main">,</span> <span class="entity">lhs'</span><span class="main">,</span> <span class="entity">rhs'</span><span class="main">)</span><span class="main">,</span> <span class="entity">RCs_rhs</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">shift</span> <span class="main">=</span> incr_boundvars <span class="main">(</span>length <span class="entity">qs'</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eqvts_obligations_lhs</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">shift</span> o <span class="entity">mk_eqvt_proof_obligation</span> <span class="entity">qs</span> <span class="entity">fvar</span><span class="main">)</span> <span class="entity">RCs_lhs</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eqvts_obligations_rhs</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">mk_eqvt_proof_obligation</span> <span class="entity">qs'</span> <span class="entity">fvar</span><span class="main">)</span> <span class="entity">RCs_rhs</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">invs_obligations_lhs</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">shift</span> o <span class="entity">mk_inv_proof_obligation</span> <span class="entity">inv</span> <span class="entity">qs</span> <span class="entity">fvar</span><span class="main">)</span> <span class="entity">RCs_lhs</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">invs_obligations_rhs</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">mk_inv_proof_obligation</span> <span class="entity">inv</span> <span class="entity">qs'</span> <span class="entity">fvar</span><span class="main">)</span> <span class="entity">RCs_rhs</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        Logic.mk_implies
          <span class="main">(</span><span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">HOLogic.eq_const</span> <span class="entity">domT</span> $ <span class="entity">shift</span> <span class="entity">lhs</span> $ <span class="entity">lhs'</span><span class="main">)</span><span class="main">,</span>
            <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">HOLogic.eq_const</span> <span class="entity">ranT</span> $ <span class="entity">shift</span> <span class="entity">rhs</span> $ <span class="entity">rhs'</span><span class="main">)</span><span class="main">)</span>
        |&gt; fold_rev <span class="main">(</span>curry Logic.mk_implies<span class="main">)</span> <span class="main">(</span>map <span class="entity">shift</span> <span class="entity">gs</span> @ <span class="entity">gs'</span><span class="main">)</span>
        |&gt; fold_rev <span class="main">(</span>curry Logic.mk_implies<span class="main">)</span> <span class="entity">invs_obligations_rhs</span> <span class="comment1">(* nominal *)</span>
        |&gt; fold_rev <span class="main">(</span>curry Logic.mk_implies<span class="main">)</span> <span class="entity">invs_obligations_lhs</span> <span class="comment1">(* nominal *)</span>
        |&gt; fold_rev <span class="main">(</span>curry Logic.mk_implies<span class="main">)</span> <span class="entity">eqvts_obligations_rhs</span> <span class="comment1">(* nominal *)</span>
        |&gt; fold_rev <span class="main">(</span>curry Logic.mk_implies<span class="main">)</span> <span class="entity">eqvts_obligations_lhs</span> <span class="comment1">(* nominal *)</span>
        |&gt; fold_rev <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">n</span><span class="main">,</span><span class="entity">T</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">b</span> <span class="main">=&gt;</span> Logic.all_const <span class="entity">T</span> $ Abs<span class="main">(</span><span class="entity">n</span><span class="main">,</span><span class="entity">T</span><span class="main">,</span><span class="entity">b</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">qs</span> @ <span class="entity">qs'</span><span class="main">)</span>
        |&gt; curry abstract_over <span class="entity">fvar</span>
        |&gt; curry subst_bound <span class="entity">f</span>
      <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">in</span></span>
    map <span class="entity">mk_impl</span> <span class="main">(</span><span class="entity">unordered_pairs</span> <span class="main">(</span><span class="entity">glrs</span> ~~ <span class="entity">RCss</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_completeness</span> <span class="main">(</span><span class="entity">Globals</span> <span class="main">{</span><span class="entity">x</span><span class="main">,</span> <span class="entity">Pbool</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="entity">clauses</span> <span class="entity">qglrs</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_case</span> <span class="main">(</span><span class="entity">ClauseContext</span> <span class="main">{</span><span class="entity">qs</span><span class="main">,</span> <span class="entity">gs</span><span class="main">,</span> <span class="entity">lhs</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">,</span> <span class="main">(</span><span class="entity">oqs</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">HOLogic.mk_Trueprop</span> <span class="entity">Pbool</span>
      |&gt; curry Logic.mk_implies <span class="main">(</span><span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">mk_eq</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">lhs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      |&gt; fold_rev <span class="main">(</span>curry Logic.mk_implies<span class="main">)</span> <span class="entity">gs</span>
      |&gt; fold_rev <span class="entity">mk_forall_rename</span> <span class="main">(</span>map fst <span class="entity">oqs</span> ~~ <span class="entity">qs</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">HOLogic.mk_Trueprop</span> <span class="entity">Pbool</span>
    |&gt; fold_rev <span class="main">(</span>curry Logic.mk_implies o <span class="entity">mk_case</span><span class="main">)</span> <span class="main">(</span><span class="entity">clauses</span> ~~ <span class="entity">qglrs</span><span class="main">)</span>
    |&gt; <span class="entity">mk_forall_rename</span> <span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> <span class="entity">x</span><span class="main">)</span>
    |&gt; <span class="entity">mk_forall_rename</span> <span class="main">(</span><span class="inner_quoted">"P"</span><span class="main">,</span> <span class="entity">Pbool</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(** making a context with it's own local bindings **)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_clause_context</span> <span class="entity">x</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">pre_qs</span><span class="main">,</span><span class="entity">pre_gs</span><span class="main">,</span><span class="entity">pre_lhs</span><span class="main">,</span><span class="entity">pre_rhs</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">qs</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> Variable.variant_fixes <span class="main">(</span>map fst <span class="entity">pre_qs</span><span class="main">)</span> <span class="entity">ctxt</span>
      |&gt;&gt; map2 <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">n</span> <span class="main">=&gt;</span> Free <span class="main">(</span><span class="entity">n</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span> <span class="entity">pre_qs</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">inst</span> <span class="entity">t</span> <span class="main">=</span> subst_bounds <span class="main">(</span>rev <span class="entity">qs</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">gs</span> <span class="main">=</span> map <span class="entity">inst</span> <span class="entity">pre_gs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs</span> <span class="main">=</span> <span class="entity">inst</span> <span class="entity">pre_lhs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> <span class="entity">inst</span> <span class="entity">pre_rhs</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cqs</span> <span class="main">=</span> map <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt'</span><span class="main">)</span> <span class="entity">qs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ags</span> <span class="main">=</span> map <span class="main">(</span>Thm.assume o Thm.cterm_of <span class="entity">ctxt'</span><span class="main">)</span> <span class="entity">gs</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">case_hyp</span> <span class="main">=</span> Thm.assume <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt'</span> <span class="main">(</span><span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">mk_eq</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">lhs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">ClauseContext</span> <span class="main">{</span> ctxt <span class="main">=</span> <span class="entity">ctxt'</span><span class="main">,</span> qs <span class="main">=</span> <span class="entity">qs</span><span class="main">,</span> gs <span class="main">=</span> <span class="entity">gs</span><span class="main">,</span> lhs <span class="main">=</span> <span class="entity">lhs</span><span class="main">,</span> rhs <span class="main">=</span> <span class="entity">rhs</span><span class="main">,</span>
      cqs <span class="main">=</span> <span class="entity">cqs</span><span class="main">,</span> ags <span class="main">=</span> <span class="entity">ags</span><span class="main">,</span> case_hyp <span class="main">=</span> <span class="entity">case_hyp</span> <span class="main">}</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="comment1">(* lowlevel term function. FIXME: remove *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">abstract_over_list</span> <span class="entity">vs</span> <span class="entity">body</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">abs</span> <span class="entity">lev</span> <span class="entity">v</span> <span class="entity">tm</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">v</span> aconv <span class="entity">tm</span> <span class="keyword2"><span class="keyword">then</span></span> Bound <span class="entity">lev</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">tm</span> <span class="keyword2"><span class="keyword">of</span></span>
          Abs <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="main">=&gt;</span> Abs <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">abs</span> <span class="main">(</span><span class="entity">lev</span> + <span class="inner_numeral">1</span><span class="main">)</span> <span class="entity">v</span> <span class="entity">t</span><span class="main">)</span>
        <span class="main">|</span> <span class="entity">t</span> $ <span class="entity">u</span> <span class="main">=&gt;</span> <span class="entity">abs</span> <span class="entity">lev</span> <span class="entity">v</span> <span class="entity">t</span> $ <span class="entity">abs</span> <span class="entity">lev</span> <span class="entity">v</span> <span class="entity">u</span>
        <span class="main">|</span> <span class="entity">t</span> <span class="main">=&gt;</span> <span class="entity">t</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    fold_index <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span> <span class="entity">v</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> <span class="entity">abs</span> <span class="entity">i</span> <span class="entity">v</span> <span class="entity">t</span><span class="main">)</span> <span class="entity">vs</span> <span class="entity">body</span>
  <span class="keyword2"><span class="keyword">end</span></span>



<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_clause_info</span> <span class="entity">globals</span> <span class="entity">G</span> <span class="entity">f</span> <span class="entity">no</span> <span class="entity">cdata</span> <span class="entity">qglr</span> <span class="entity">tree</span> <span class="entity">RCs</span> <span class="entity">GIntro_thm</span> <span class="entity">RIntro_thms</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Globals</span> <span class="main">{</span><span class="entity">h</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">globals</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ClauseContext</span> <span class="main">{</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="entity">qs</span><span class="main">,</span> <span class="entity">cqs</span><span class="main">,</span> <span class="entity">ags</span><span class="main">,</span> <span class="main">...</span> <span class="main">}</span> <span class="main">=</span> <span class="entity">cdata</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cert</span> <span class="main">=</span> Thm.cterm_of <span class="entity">ctxt</span>

    <span class="comment1">(* Instantiate the GIntro thm with "f" and import into the clause context. *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lGI</span> <span class="main">=</span> <span class="entity">GIntro_thm</span>
      |&gt; Thm.forall_elim <span class="main">(</span><span class="entity">cert</span> <span class="entity">f</span><span class="main">)</span>
      |&gt; fold Thm.forall_elim <span class="entity">cqs</span>
      |&gt; fold Thm.elim_implies <span class="entity">ags</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_call_info</span> <span class="main">(</span><span class="entity">rcfix</span><span class="main">,</span> <span class="entity">rcassm</span><span class="main">,</span> <span class="entity">rcarg</span><span class="main">)</span> <span class="entity">RI</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">llRI</span> <span class="main">=</span> <span class="entity">RI</span>
          |&gt; fold Thm.forall_elim <span class="entity">cqs</span>
          |&gt; fold <span class="main">(</span>Thm.forall_elim o <span class="entity">cert</span> o Free<span class="main">)</span> <span class="entity">rcfix</span>
          |&gt; fold Thm.elim_implies <span class="entity">ags</span>
          |&gt; fold Thm.elim_implies <span class="entity">rcassm</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">h_assum</span> <span class="main">=</span>
          <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">G</span> $ <span class="entity">rcarg</span> $ <span class="main">(</span><span class="entity">h</span> $ <span class="entity">rcarg</span><span class="main">)</span><span class="main">)</span>
          |&gt; fold_rev <span class="main">(</span>curry Logic.mk_implies o Thm.prop_of<span class="main">)</span> <span class="entity">rcassm</span>
          |&gt; fold_rev <span class="main">(</span>Logic.all o Free<span class="main">)</span> <span class="entity">rcfix</span>
          |&gt; Pattern.rewrite_term <span class="main">(</span>Proof_Context.theory_of <span class="entity">ctxt</span><span class="main">)</span> <span class="main">[</span><span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="entity">h</span><span class="main">)</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span>
          |&gt; <span class="entity">abstract_over_list</span> <span class="main">(</span>rev <span class="entity">qs</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="entity">RCInfo</span> <span class="main">{</span>RIvs<span class="main">=</span><span class="entity">rcfix</span><span class="main">,</span> rcarg<span class="main">=</span><span class="entity">rcarg</span><span class="main">,</span> CCas<span class="main">=</span><span class="entity">rcassm</span><span class="main">,</span> llRI<span class="main">=</span><span class="entity">llRI</span><span class="main">,</span> h_assum<span class="main">=</span><span class="entity">h_assum</span><span class="main">}</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">RC_infos</span> <span class="main">=</span> map2 <span class="entity">mk_call_info</span> <span class="entity">RCs</span> <span class="entity">RIntro_thms</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">ClauseInfo</span> <span class="main">{</span>no<span class="main">=</span><span class="entity">no</span><span class="main">,</span> cdata<span class="main">=</span><span class="entity">cdata</span><span class="main">,</span> qglr<span class="main">=</span><span class="entity">qglr</span><span class="main">,</span> lGI<span class="main">=</span><span class="entity">lGI</span><span class="main">,</span> RCs<span class="main">=</span><span class="entity">RC_infos</span><span class="main">,</span>
      tree<span class="main">=</span><span class="entity">tree</span><span class="main">}</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">store_compat_thms</span> <span class="inner_numeral">0</span> <span class="entity">thms</span> <span class="main">=</span> <span class="main">[</span><span class="main">]</span>
  <span class="main">|</span> <span class="entity">store_compat_thms</span> <span class="entity">n</span> <span class="entity">thms</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">thms1</span><span class="main">,</span> <span class="entity">thms2</span><span class="main">)</span> <span class="main">=</span> chop <span class="entity">n</span> <span class="entity">thms</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="entity">thms1</span> :: <span class="entity">store_compat_thms</span> <span class="main">(</span><span class="entity">n</span> - <span class="inner_numeral">1</span><span class="main">)</span> <span class="entity">thms2</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* expects i &lt;= j *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">lookup_compat_thm</span> <span class="entity">i</span> <span class="entity">j</span> <span class="entity">cts</span> <span class="main">=</span>
  nth <span class="main">(</span>nth <span class="entity">cts</span> <span class="main">(</span><span class="entity">i</span> - <span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">j</span> - <span class="entity">i</span><span class="main">)</span>

<span class="comment1">(* nominal *)</span>
<span class="comment1">(* Returns "Gsi, Gsj, lhs_i = lhs_j |-- rhs_j_f = rhs_i_f" *)</span>
<span class="comment1">(* if j &lt; i, then turn around *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_compat_thm</span> <span class="entity">ctxt</span> <span class="entity">cts</span> <span class="entity">eqvtsi</span> <span class="entity">eqvtsj</span> <span class="entity">invsi</span> <span class="entity">invsj</span> <span class="entity">i</span> <span class="entity">j</span> <span class="entity">ctxi</span> <span class="entity">ctxj</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ClauseContext</span> <span class="main">{</span>cqs<span class="main">=</span><span class="entity">cqsi</span><span class="main">,</span>ags<span class="main">=</span><span class="entity">agsi</span><span class="main">,</span>lhs<span class="main">=</span><span class="entity">lhsi</span><span class="main">,</span>case_hyp<span class="main">=</span><span class="entity">case_hypi</span><span class="main">,</span><span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">ctxi</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ClauseContext</span> <span class="main">{</span>cqs<span class="main">=</span><span class="entity">cqsj</span><span class="main">,</span>ags<span class="main">=</span><span class="entity">agsj</span><span class="main">,</span>lhs<span class="main">=</span><span class="entity">lhsj</span><span class="main">,</span>case_hyp<span class="main">=</span><span class="entity">case_hypj</span><span class="main">,</span><span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">ctxj</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhsi_eq_lhsj</span> <span class="main">=</span> Thm.cterm_of <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">mk_eq</span> <span class="main">(</span><span class="entity">lhsi</span><span class="main">,</span> <span class="entity">lhsj</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

  <span class="keyword2"><span class="keyword">in</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">j</span> &lt; <span class="entity">i</span> <span class="keyword2"><span class="keyword">then</span></span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">compat</span> <span class="main">=</span> <span class="entity">lookup_compat_thm</span> <span class="entity">j</span> <span class="entity">i</span> <span class="entity">cts</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">compat</span>         <span class="comment1">(* "!!qj qi. Gsj =&gt; Gsi =&gt; lhsj = lhsi ==&gt; rhsj = rhsi" *)</span>
      |&gt; fold Thm.forall_elim <span class="main">(</span><span class="entity">cqsj</span> @ <span class="entity">cqsi</span><span class="main">)</span> <span class="comment1">(* "Gsj =&gt; Gsi =&gt; lhsj = lhsi ==&gt; rhsj = rhsi" *)</span>
      |&gt; fold Thm.elim_implies <span class="entity">eqvtsj</span> <span class="comment1">(* nominal *)</span>
      |&gt; fold Thm.elim_implies <span class="entity">eqvtsi</span> <span class="comment1">(* nominal *)</span>
      |&gt; fold Thm.elim_implies <span class="entity">invsj</span> <span class="comment1">(* nominal *)</span>
      |&gt; fold Thm.elim_implies <span class="entity">invsi</span> <span class="comment1">(* nominal *)</span>
      |&gt; fold Thm.elim_implies <span class="entity">agsj</span>
      |&gt; fold Thm.elim_implies <span class="entity">agsi</span>
      |&gt; Thm.elim_implies <span class="main">(</span><span class="main">(</span>Thm.assume <span class="entity">lhsi_eq_lhsj</span><span class="main">)</span> RS <span class="entity">sym</span><span class="main">)</span> <span class="comment1">(* "Gsj, Gsi, lhsi = lhsj |-- rhsj = rhsi" *)</span>
    <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">else</span></span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">compat</span> <span class="main">=</span> <span class="entity">lookup_compat_thm</span> <span class="entity">i</span> <span class="entity">j</span> <span class="entity">cts</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">compat</span>        <span class="comment1">(* "!!qi qj. Gsi =&gt; Gsj =&gt; lhsi = lhsj ==&gt; rhsi = rhsj" *)</span>
      |&gt; fold Thm.forall_elim <span class="main">(</span><span class="entity">cqsi</span> @ <span class="entity">cqsj</span><span class="main">)</span> <span class="comment1">(* "Gsi =&gt; Gsj =&gt; lhsi = lhsj ==&gt; rhsi = rhsj" *)</span>
      |&gt; fold Thm.elim_implies <span class="entity">eqvtsi</span>  <span class="comment1">(* nominal *)</span>
      |&gt; fold Thm.elim_implies <span class="entity">eqvtsj</span>  <span class="comment1">(* nominal *)</span>
      |&gt; fold Thm.elim_implies <span class="entity">invsi</span>  <span class="comment1">(* nominal *)</span>
      |&gt; fold Thm.elim_implies <span class="entity">invsj</span>  <span class="comment1">(* nominal *)</span>
      |&gt; fold Thm.elim_implies <span class="entity">agsi</span>
      |&gt; fold Thm.elim_implies <span class="entity">agsj</span>
      |&gt; Thm.elim_implies <span class="main">(</span>Thm.assume <span class="entity">lhsi_eq_lhsj</span><span class="main">)</span>
      |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">thm</span> <span class="main">=&gt;</span> <span class="entity">thm</span> RS <span class="entity">sym</span><span class="main">)</span> <span class="comment1">(* "Gsi, Gsj, lhsi = lhsj |-- rhsj = rhsi" *)</span>
    <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="comment1">(* Generates the replacement lemma in fully quantified form. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_replacement_lemma</span> <span class="entity">ctxt</span> <span class="entity">h</span> <span class="entity">ih_elim</span> <span class="entity">clause</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ClauseInfo</span> <span class="main">{</span>cdata<span class="main">=</span><span class="entity">ClauseContext</span> <span class="main">{</span><span class="entity">qs</span><span class="main">,</span> <span class="entity">lhs</span><span class="main">,</span> <span class="entity">cqs</span><span class="main">,</span> <span class="entity">ags</span><span class="main">,</span> <span class="entity">case_hyp</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">,</span>
      <span class="entity">RCs</span><span class="main">,</span> <span class="entity">tree</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">clause</span>
    <span class="keyword2"><span class="keyword">local</span></span> <span class="keyword3"><span class="keyword">open</span></span> Conv <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ih_conv</span> <span class="main">=</span> arg1_conv o arg_conv o arg_conv
    <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ih_elim_case</span> <span class="main">=</span>
      Conv.fconv_rule <span class="main">(</span><span class="entity">ih_conv</span> <span class="main">(</span>K <span class="main">(</span><span class="entity">case_hyp</span> RS <span class="entity">eq_reflection</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">ih_elim</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Ris</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">RCInfo</span> <span class="main">{</span><span class="entity">llRI</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span> <span class="entity">llRI</span><span class="main">)</span> <span class="entity">RCs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">h_assums</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">RCInfo</span> <span class="main">{</span><span class="entity">h_assum</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
      Thm.assume <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="main">(</span>subst_bounds <span class="main">(</span>rev <span class="entity">qs</span><span class="main">,</span> <span class="entity">h_assum</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">RCs</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">eql</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">Function_Context_Tree.rewrite_by_tree</span> <span class="entity">ctxt</span>
        <span class="entity">h</span> <span class="entity">ih_elim_case</span> <span class="main">(</span><span class="entity">Ris</span> ~~ <span class="entity">h_assums</span><span class="main">)</span> <span class="entity">tree</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">replace_lemma</span> <span class="main">=</span> <span class="main">(</span><span class="entity">eql</span> RS <span class="entity">meta_eq_to_obj_eq</span><span class="main">)</span>
      |&gt; Thm.implies_intr <span class="main">(</span>Thm.cprop_of <span class="entity">case_hyp</span><span class="main">)</span>
      |&gt; fold_rev <span class="main">(</span>Thm.implies_intr o Thm.cprop_of<span class="main">)</span> <span class="entity">h_assums</span>
      |&gt; fold_rev <span class="main">(</span>Thm.implies_intr o Thm.cprop_of<span class="main">)</span> <span class="entity">ags</span>
      |&gt; fold_rev Thm.forall_intr <span class="entity">cqs</span>
      |&gt; Thm.close_derivation <span class="antiquoted"><span class="operator"><span class="entity">⌂</span></span></span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">replace_lemma</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* nominal *)</span>
<span class="comment1">(* Generates the eqvt lemmas for each clause *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_eqvt_lemma</span> <span class="entity">ctxt</span> <span class="entity">ih_eqvt</span> <span class="entity">clause</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ClauseInfo</span> <span class="main">{</span>cdata<span class="main">=</span><span class="entity">ClauseContext</span> <span class="main">{</span><span class="entity">cqs</span><span class="main">,</span> <span class="entity">ags</span><span class="main">,</span> <span class="entity">case_hyp</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">,</span> <span class="entity">RCs</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">clause</span>

    <span class="keyword2"><span class="keyword">local</span></span> <span class="keyword3"><span class="keyword">open</span></span> Conv <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ih_conv</span> <span class="main">=</span> arg1_conv o arg_conv o arg_conv
    <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ih_eqvt_case</span> <span class="main">=</span>
      Conv.fconv_rule <span class="main">(</span><span class="entity">ih_conv</span> <span class="main">(</span>K <span class="main">(</span><span class="entity">case_hyp</span> RS <span class="entity">eq_reflection</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">ih_eqvt</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prep_eqvt</span> <span class="main">(</span><span class="entity">RCInfo</span> <span class="main">{</span><span class="entity">llRI</span><span class="main">,</span> <span class="entity">RIvs</span><span class="main">,</span> <span class="entity">CCas</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
        <span class="main">(</span><span class="entity">llRI</span> RS <span class="entity">ih_eqvt_case</span><span class="main">)</span>
        |&gt; fold_rev <span class="main">(</span>Thm.implies_intr o Thm.cprop_of<span class="main">)</span> <span class="entity">CCas</span>
        |&gt; fold_rev <span class="main">(</span>Thm.forall_intr o Thm.cterm_of <span class="entity">ctxt</span> o Free<span class="main">)</span> <span class="entity">RIvs</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    map <span class="entity">prep_eqvt</span> <span class="entity">RCs</span>
    |&gt; map <span class="main">(</span>fold_rev <span class="main">(</span>Thm.implies_intr o Thm.cprop_of<span class="main">)</span> <span class="entity">ags</span><span class="main">)</span>
    |&gt; map <span class="main">(</span>Thm.implies_intr <span class="main">(</span>Thm.cprop_of <span class="entity">case_hyp</span><span class="main">)</span><span class="main">)</span>
    |&gt; map <span class="main">(</span>fold_rev Thm.forall_intr <span class="entity">cqs</span><span class="main">)</span>
    |&gt; map <span class="main">(</span>Thm.close_derivation <span class="antiquoted"><span class="operator"><span class="entity">⌂</span></span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* nominal *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_invariant_lemma</span> <span class="entity">ctxt</span> <span class="entity">ih_inv</span> <span class="entity">clause</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ClauseInfo</span> <span class="main">{</span>cdata<span class="main">=</span><span class="entity">ClauseContext</span> <span class="main">{</span><span class="entity">cqs</span><span class="main">,</span> <span class="entity">ags</span><span class="main">,</span> <span class="entity">case_hyp</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">,</span> <span class="entity">RCs</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">clause</span>

    <span class="keyword2"><span class="keyword">local</span></span> <span class="keyword3"><span class="keyword">open</span></span> Conv <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ih_conv</span> <span class="main">=</span> arg1_conv o arg_conv o arg_conv
    <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ih_inv_case</span> <span class="main">=</span>
      Conv.fconv_rule <span class="main">(</span><span class="entity">ih_conv</span> <span class="main">(</span>K <span class="main">(</span><span class="entity">case_hyp</span> RS <span class="entity">eq_reflection</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">ih_inv</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prep_inv</span> <span class="main">(</span><span class="entity">RCInfo</span> <span class="main">{</span><span class="entity">llRI</span><span class="main">,</span> <span class="entity">RIvs</span><span class="main">,</span> <span class="entity">CCas</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
        <span class="main">(</span><span class="entity">llRI</span> RS <span class="entity">ih_inv_case</span><span class="main">)</span>
        |&gt; fold_rev <span class="main">(</span>Thm.implies_intr o Thm.cprop_of<span class="main">)</span> <span class="entity">CCas</span>
        |&gt; fold_rev <span class="main">(</span>Thm.forall_intr o Thm.cterm_of <span class="entity">ctxt</span> o Free<span class="main">)</span> <span class="entity">RIvs</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    map <span class="entity">prep_inv</span> <span class="entity">RCs</span>
    |&gt; map <span class="main">(</span>fold_rev <span class="main">(</span>Thm.implies_intr o Thm.cprop_of<span class="main">)</span> <span class="entity">ags</span><span class="main">)</span>
    |&gt; map <span class="main">(</span>Thm.implies_intr <span class="main">(</span>Thm.cprop_of <span class="entity">case_hyp</span><span class="main">)</span><span class="main">)</span>
    |&gt; map <span class="main">(</span>fold_rev Thm.forall_intr <span class="entity">cqs</span><span class="main">)</span>
    |&gt; map <span class="main">(</span>Thm.close_derivation <span class="antiquoted"><span class="operator"><span class="entity">⌂</span></span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* nominal *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_uniqueness_clause</span> <span class="entity">ctxt</span> <span class="entity">globals</span> <span class="entity">compat_store</span> <span class="entity">eqvts</span> <span class="entity">invs</span> <span class="entity">clausei</span> <span class="entity">clausej</span> <span class="entity">RLj</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Globals</span> <span class="main">{</span><span class="entity">h</span><span class="main">,</span> <span class="entity">y</span><span class="main">,</span> <span class="entity">x</span><span class="main">,</span> <span class="entity">fvar</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">globals</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ClauseInfo</span> <span class="main">{</span>no<span class="main">=</span><span class="entity">i</span><span class="main">,</span> cdata<span class="main">=</span><span class="entity">cctxi</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="entity">ClauseContext</span> <span class="main">{</span>ctxt<span class="main">=</span><span class="entity">ctxti</span><span class="main">,</span> lhs<span class="main">=</span><span class="entity">lhsi</span><span class="main">,</span> <span class="entity">case_hyp</span><span class="main">,</span> cqs <span class="main">=</span> <span class="entity">cqsi</span><span class="main">,</span>
      ags <span class="main">=</span> <span class="entity">agsi</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">clausei</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ClauseInfo</span> <span class="main">{</span>no<span class="main">=</span><span class="entity">j</span><span class="main">,</span> qglr<span class="main">=</span><span class="entity">cdescj</span><span class="main">,</span> RCs<span class="main">=</span><span class="entity">RCsj</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">clausej</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cctxj</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="entity">ClauseContext</span> <span class="main">{</span>ags <span class="main">=</span> <span class="entity">agsj'</span><span class="main">,</span> lhs <span class="main">=</span> <span class="entity">lhsj'</span><span class="main">,</span> rhs <span class="main">=</span> <span class="entity">rhsj'</span><span class="main">,</span> qs <span class="main">=</span> <span class="entity">qsj'</span><span class="main">,</span> cqs <span class="main">=</span> <span class="entity">cqsj'</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span>
      <span class="entity">mk_clause_context</span> <span class="entity">x</span> <span class="entity">ctxti</span> <span class="entity">cdescj</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhsj'h</span> <span class="main">=</span> Pattern.rewrite_term <span class="entity">thy</span> <span class="main">[</span><span class="main">(</span><span class="entity">fvar</span><span class="main">,</span><span class="entity">h</span><span class="main">)</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">rhsj'</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Ghsj'</span> <span class="main">=</span> map
      <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">RCInfo</span> <span class="main">{</span><span class="entity">h_assum</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
        Thm.assume <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="main">(</span>subst_bounds <span class="main">(</span>rev <span class="entity">qsj'</span><span class="main">,</span> <span class="entity">h_assum</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">RCsj</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">y_eq_rhsj'h</span> <span class="main">=</span> Thm.assume <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">mk_eq</span> <span class="main">(</span><span class="entity">y</span><span class="main">,</span> <span class="entity">rhsj'h</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhsi_eq_lhsj'</span> <span class="main">=</span> Thm.assume <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">mk_eq</span> <span class="main">(</span><span class="entity">lhsi</span><span class="main">,</span> <span class="entity">lhsj'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
       <span class="comment1">(* lhs_i = lhs_j' |-- lhs_i = lhs_j' *)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">case_hypj'</span> <span class="main">=</span> <span class="entity">trans</span> OF <span class="main">[</span><span class="entity">case_hyp</span><span class="main">,</span> <span class="entity">lhsi_eq_lhsj'</span><span class="main">]</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">RLj_import</span> <span class="main">=</span> <span class="entity">RLj</span>
      |&gt; fold Thm.forall_elim <span class="entity">cqsj'</span>
      |&gt; fold Thm.elim_implies <span class="entity">agsj'</span>
      |&gt; fold Thm.elim_implies <span class="entity">Ghsj'</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eqvtsi</span> <span class="main">=</span> nth <span class="entity">eqvts</span> <span class="main">(</span><span class="entity">i</span> - <span class="inner_numeral">1</span><span class="main">)</span>
      |&gt; map <span class="main">(</span>fold Thm.forall_elim <span class="entity">cqsi</span><span class="main">)</span>
      |&gt; map <span class="main">(</span>fold Thm.elim_implies <span class="main">[</span><span class="entity">case_hyp</span><span class="main">]</span><span class="main">)</span>
      |&gt; map <span class="main">(</span>fold Thm.elim_implies <span class="entity">agsi</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eqvtsj</span> <span class="main">=</span> nth <span class="entity">eqvts</span> <span class="main">(</span><span class="entity">j</span> - <span class="inner_numeral">1</span><span class="main">)</span>
      |&gt; map <span class="main">(</span>fold Thm.forall_elim <span class="entity">cqsj'</span><span class="main">)</span>
      |&gt; map <span class="main">(</span>fold Thm.elim_implies <span class="main">[</span><span class="entity">case_hypj'</span><span class="main">]</span><span class="main">)</span>
      |&gt; map <span class="main">(</span>fold Thm.elim_implies <span class="entity">agsj'</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">invsi</span> <span class="main">=</span> nth <span class="entity">invs</span> <span class="main">(</span><span class="entity">i</span> - <span class="inner_numeral">1</span><span class="main">)</span>
      |&gt; map <span class="main">(</span>fold Thm.forall_elim <span class="entity">cqsi</span><span class="main">)</span>
      |&gt; map <span class="main">(</span>fold Thm.elim_implies <span class="main">[</span><span class="entity">case_hyp</span><span class="main">]</span><span class="main">)</span>
      |&gt; map <span class="main">(</span>fold Thm.elim_implies <span class="entity">agsi</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">invsj</span> <span class="main">=</span> nth <span class="entity">invs</span> <span class="main">(</span><span class="entity">j</span> - <span class="inner_numeral">1</span><span class="main">)</span>
      |&gt; map <span class="main">(</span>fold Thm.forall_elim <span class="entity">cqsj'</span><span class="main">)</span>
      |&gt; map <span class="main">(</span>fold Thm.elim_implies <span class="main">[</span><span class="entity">case_hypj'</span><span class="main">]</span><span class="main">)</span>
      |&gt; map <span class="main">(</span>fold Thm.elim_implies <span class="entity">agsj'</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">compat</span> <span class="main">=</span> <span class="entity">get_compat_thm</span> <span class="entity">ctxt</span> <span class="entity">compat_store</span> <span class="entity">eqvtsi</span> <span class="entity">eqvtsj</span> <span class="entity">invsi</span> <span class="entity">invsj</span> <span class="entity">i</span> <span class="entity">j</span> <span class="entity">cctxi</span> <span class="entity">cctxj</span>

  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="entity">trans</span> OF <span class="main">[</span><span class="entity">case_hyp</span><span class="main">,</span> <span class="entity">lhsi_eq_lhsj'</span><span class="main">]</span><span class="main">)</span> <span class="comment1">(* lhs_i = lhs_j' |-- x = lhs_j' *)</span>
    |&gt; Thm.implies_elim <span class="entity">RLj_import</span>
      <span class="comment1">(* Rj1' ... Rjk', lhs_i = lhs_j' |-- rhs_j'_h = rhs_j'_f *)</span>
    |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">it</span> <span class="main">=&gt;</span> <span class="entity">trans</span> OF <span class="main">[</span><span class="entity">it</span><span class="main">,</span> <span class="entity">compat</span><span class="main">]</span><span class="main">)</span>
      <span class="comment1">(* lhs_i = lhs_j', Gj', Rj1' ... Rjk' |-- rhs_j'_h = rhs_i_f *)</span>
    |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">it</span> <span class="main">=&gt;</span> <span class="entity">trans</span> OF <span class="main">[</span><span class="entity">y_eq_rhsj'h</span><span class="main">,</span> <span class="entity">it</span><span class="main">]</span><span class="main">)</span>
      <span class="comment1">(* lhs_i = lhs_j', Gj', Rj1' ... Rjk', y = rhs_j_h' |-- y = rhs_i_f *)</span>
    |&gt; fold_rev <span class="main">(</span>Thm.implies_intr o Thm.cprop_of<span class="main">)</span> <span class="entity">Ghsj'</span>
    |&gt; fold_rev <span class="main">(</span>Thm.implies_intr o Thm.cprop_of<span class="main">)</span> <span class="entity">agsj'</span>
      <span class="comment1">(* lhs_i = lhs_j' , y = rhs_j_h' |-- Gj', Rj1'...Rjk' ==&gt; y = rhs_i_f *)</span>
    |&gt; Thm.implies_intr <span class="main">(</span>Thm.cprop_of <span class="entity">y_eq_rhsj'h</span><span class="main">)</span>
    |&gt; Thm.implies_intr <span class="main">(</span>Thm.cprop_of <span class="entity">lhsi_eq_lhsj'</span><span class="main">)</span>
    |&gt; fold_rev Thm.forall_intr <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">h</span> :: <span class="entity">cqsj'</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* nominal *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_uniqueness_case</span> <span class="entity">ctxt</span>
    <span class="entity">globals</span> <span class="entity">G</span> <span class="entity">f</span> <span class="entity">ihyp</span> <span class="entity">ih_intro</span> <span class="entity">G_cases</span> <span class="entity">compat_store</span> <span class="entity">clauses</span> <span class="entity">replems</span> <span class="entity">eqvtlems</span> <span class="entity">invlems</span> <span class="entity">clausei</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Globals</span> <span class="main">{</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">,</span> <span class="entity">ranT</span><span class="main">,</span> <span class="entity">fvar</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">globals</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ClauseInfo</span> <span class="main">{</span>cdata <span class="main">=</span> <span class="entity">ClauseContext</span> <span class="main">{</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">,</span> <span class="entity">cqs</span><span class="main">,</span> <span class="entity">ags</span><span class="main">,</span> <span class="entity">case_hyp</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">,</span> <span class="entity">lGI</span><span class="main">,</span> <span class="entity">RCs</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">clausei</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhsC</span> <span class="main">=</span> Pattern.rewrite_term <span class="entity">thy</span> <span class="main">[</span><span class="main">(</span><span class="entity">fvar</span><span class="main">,</span> <span class="entity">f</span><span class="main">)</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">rhs</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ih_intro_case</span> <span class="main">=</span>
      <span class="entity">full_simplify</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span> addsimps <span class="main">[</span><span class="entity">case_hyp</span><span class="main">]</span><span class="main">)</span>
        <span class="entity">ih_intro</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prep_RC</span> <span class="main">(</span><span class="entity">RCInfo</span> <span class="main">{</span><span class="entity">llRI</span><span class="main">,</span> <span class="entity">RIvs</span><span class="main">,</span> <span class="entity">CCas</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
        <span class="main">(</span><span class="entity">llRI</span> RS <span class="entity">ih_intro_case</span><span class="main">)</span>
        |&gt; fold_rev <span class="main">(</span>Thm.implies_intr o Thm.cprop_of<span class="main">)</span> <span class="entity">CCas</span>
        |&gt; fold_rev <span class="main">(</span>Thm.forall_intr o Thm.cterm_of <span class="entity">ctxt</span> o Free<span class="main">)</span> <span class="entity">RIvs</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">existence</span> <span class="main">=</span> fold <span class="main">(</span>curry <span class="keyword1"><span class="keyword">op</span></span> COMP o <span class="entity">prep_RC</span><span class="main">)</span> <span class="entity">RCs</span> <span class="entity">lGI</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">P</span> <span class="main">=</span> Thm.cterm_of <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">mk_eq</span> <span class="main">(</span><span class="entity">y</span><span class="main">,</span> <span class="entity">rhsC</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">G_lhs_y</span> <span class="main">=</span> Thm.assume <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">G</span> $ <span class="entity">lhs</span> $ <span class="entity">y</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">unique_clauses</span> <span class="main">=</span>
      map2 <span class="main">(</span><span class="entity">mk_uniqueness_clause</span> <span class="entity">ctxt</span> <span class="entity">globals</span> <span class="entity">compat_store</span> <span class="entity">eqvtlems</span> <span class="entity">invlems</span> <span class="entity">clausei</span><span class="main">)</span> <span class="entity">clauses</span> <span class="entity">replems</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">elim_implies_eta</span> <span class="entity">A</span> <span class="entity">AB</span> <span class="main">=</span>
      Thm.bicompose NONE <span class="main">{</span>flatten <span class="main">=</span> false<span class="main">,</span> match <span class="main">=</span> true<span class="main">,</span> incremented <span class="main">=</span> false<span class="main">}</span> <span class="main">(</span>false<span class="main">,</span> <span class="entity">A</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span> <span class="inner_numeral">1</span> <span class="entity">AB</span>
      |&gt; Seq.list_of |&gt; the_single

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">uniqueness</span> <span class="main">=</span> <span class="entity">G_cases</span>
      |&gt; Thm.forall_elim <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">lhs</span><span class="main">)</span>
      |&gt; Thm.forall_elim <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">y</span><span class="main">)</span>
      |&gt; Thm.forall_elim <span class="entity">P</span>
      |&gt; Thm.elim_implies <span class="entity">G_lhs_y</span>
      |&gt; fold <span class="entity">elim_implies_eta</span> <span class="entity">unique_clauses</span>
      |&gt; Thm.implies_intr <span class="main">(</span>Thm.cprop_of <span class="entity">G_lhs_y</span><span class="main">)</span>
      |&gt; Thm.forall_intr <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">y</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">P2</span> <span class="main">=</span> Thm.cterm_of <span class="entity">ctxt</span> <span class="main">(</span>lambda <span class="entity">y</span> <span class="main">(</span><span class="entity">G</span> $ <span class="entity">lhs</span> $ <span class="entity">y</span><span class="main">)</span><span class="main">)</span> <span class="comment1">(* P2 y := (lhs, y): G *)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">exactly_one</span> <span class="main">=</span>
      <span class="entity">ex1I</span> |&gt; Thm.instantiate' <span class="main">[</span>SOME <span class="main">(</span>Thm.ctyp_of <span class="entity">ctxt</span> <span class="entity">ranT</span><span class="main">)</span><span class="main">]</span> <span class="main">[</span>SOME <span class="entity">P2</span><span class="main">,</span> SOME <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">rhsC</span><span class="main">)</span><span class="main">]</span>
      |&gt; curry <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> COMP<span class="main">)</span> <span class="entity">existence</span>
      |&gt; curry <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> COMP<span class="main">)</span> <span class="entity">uniqueness</span>
      |&gt; <span class="entity">simplify</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span> addsimps <span class="main">[</span><span class="entity">case_hyp</span> RS <span class="entity">sym</span><span class="main">]</span><span class="main">)</span>
      |&gt; Thm.implies_intr <span class="main">(</span>Thm.cprop_of <span class="entity">case_hyp</span><span class="main">)</span>
      |&gt; fold_rev <span class="main">(</span>Thm.implies_intr o Thm.cprop_of<span class="main">)</span> <span class="entity">ags</span>
      |&gt; fold_rev Thm.forall_intr <span class="entity">cqs</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">function_value</span> <span class="main">=</span>
      <span class="entity">existence</span>
      |&gt; Thm.implies_intr <span class="entity">ihyp</span>
      |&gt; Thm.implies_intr <span class="main">(</span>Thm.cprop_of <span class="entity">case_hyp</span><span class="main">)</span>
      |&gt; Thm.forall_intr <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">x</span><span class="main">)</span>
      |&gt; Thm.forall_elim <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">lhs</span><span class="main">)</span>
      |&gt; curry <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> RS<span class="main">)</span> <span class="entity">refl</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="entity">exactly_one</span><span class="main">,</span> <span class="entity">function_value</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="comment1">(* nominal *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_stuff</span> <span class="entity">ctxt</span>
    <span class="entity">globals</span> <span class="entity">G</span> <span class="entity">f</span> <span class="entity">R</span> <span class="entity">clauses</span> <span class="entity">complete</span> <span class="entity">compat</span> <span class="entity">compat_store</span> <span class="entity">G_elim</span> <span class="entity">G_eqvt</span> <span class="entity">invariant</span> <span class="entity">f_def</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Globals</span> <span class="main">{</span><span class="entity">h</span><span class="main">,</span> <span class="entity">domT</span><span class="main">,</span> <span class="entity">ranT</span><span class="main">,</span> <span class="entity">x</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">globals</span>

    <span class="comment1">(* Inductive Hypothesis: !!z. (z,x):R ==&gt; EX!y. (z,y):G *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ihyp</span> <span class="main">=</span> Logic.all_const <span class="entity">domT</span> $ Abs <span class="main">(</span><span class="inner_quoted">"z"</span><span class="main">,</span> <span class="entity">domT</span><span class="main">,</span>
      Logic.mk_implies <span class="main">(</span><span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">R</span> $ Bound <span class="inner_numeral">0</span> $ <span class="entity">x</span><span class="main">)</span><span class="main">,</span>
        <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Ex1<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">(</span><span class="entity">ranT</span> --&gt; <span class="entity">boolT</span><span class="main">)</span> --&gt; <span class="entity">boolT</span><span class="main">)</span> $
          Abs <span class="main">(</span><span class="inner_quoted">"y"</span><span class="main">,</span> <span class="entity">ranT</span><span class="main">,</span> <span class="entity">G</span> $ Bound <span class="inner_numeral">1</span> $ Bound <span class="inner_numeral">0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      |&gt; Thm.cterm_of <span class="entity">ctxt</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ihyp_thm</span> <span class="main">=</span> Thm.assume <span class="entity">ihyp</span> |&gt; Thm.forall_elim_vars <span class="inner_numeral">0</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ih_intro</span> <span class="main">=</span> <span class="entity">ihyp_thm</span> RS <span class="main">(</span><span class="entity">f_def</span> RS <span class="entity">ex1_implies_ex</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ih_elim</span> <span class="main">=</span> <span class="entity">ihyp_thm</span> RS <span class="main">(</span><span class="entity">f_def</span> RS <span class="entity">ex1_implies_un</span><span class="main">)</span>
      |&gt; Thm.instantiate' <span class="main">[</span><span class="main">]</span> <span class="main">[</span>NONE<span class="main">,</span> SOME <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">h</span><span class="main">)</span><span class="main">]</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ih_eqvt</span> <span class="main">=</span> <span class="entity">ihyp_thm</span> RS <span class="main">(</span><span class="entity">G_eqvt</span> RS <span class="main">(</span><span class="entity">f_def</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> fundef_ex1_eqvt_at<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ih_inv</span> <span class="main">=</span>  <span class="entity">ihyp_thm</span> RS <span class="main">(</span><span class="entity">invariant</span> COMP <span class="main">(</span><span class="entity">f_def</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> fundef_ex1_prop<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_msg</span> <span class="main">(</span>K <span class="inner_quoted">"Proving Replacement lemmas..."</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">repLemmas</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">mk_replacement_lemma</span> <span class="entity">ctxt</span> <span class="entity">h</span> <span class="entity">ih_elim</span><span class="main">)</span> <span class="entity">clauses</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_msg</span> <span class="main">(</span>K <span class="inner_quoted">"Proving Equivariance lemmas..."</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eqvtLemmas</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">mk_eqvt_lemma</span> <span class="entity">ctxt</span> <span class="entity">ih_eqvt</span><span class="main">)</span> <span class="entity">clauses</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_msg</span> <span class="main">(</span>K <span class="inner_quoted">"Proving Invariance lemmas..."</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">invLemmas</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">mk_invariant_lemma</span> <span class="entity">ctxt</span> <span class="entity">ih_inv</span><span class="main">)</span> <span class="entity">clauses</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_msg</span> <span class="main">(</span>K <span class="inner_quoted">"Proving cases for unique existence..."</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ex1s</span><span class="main">,</span> <span class="entity">values</span><span class="main">)</span> <span class="main">=</span>
      split_list <span class="main">(</span>map <span class="main">(</span><span class="entity">mk_uniqueness_case</span> <span class="entity">ctxt</span> <span class="entity">globals</span> <span class="entity">G</span> <span class="entity">f</span>
        <span class="entity">ihyp</span> <span class="entity">ih_intro</span> <span class="entity">G_elim</span> <span class="entity">compat_store</span> <span class="entity">clauses</span> <span class="entity">repLemmas</span> <span class="entity">eqvtLemmas</span> <span class="entity">invLemmas</span><span class="main">)</span> <span class="entity">clauses</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_msg</span> <span class="main">(</span>K <span class="inner_quoted">"Proving: Graph is a function"</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">graph_is_function</span> <span class="main">=</span> <span class="entity">complete</span>
      |&gt; Thm.forall_elim_vars <span class="inner_numeral">0</span>
      |&gt; fold <span class="main">(</span>curry <span class="keyword1"><span class="keyword">op</span></span> COMP<span class="main">)</span> <span class="entity">ex1s</span>
      |&gt; Thm.implies_intr <span class="entity">ihyp</span>
      |&gt; Thm.implies_intr <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">mk_acc</span> <span class="entity">domT</span> <span class="entity">R</span> $ <span class="entity">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      |&gt; Thm.forall_intr <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">x</span><span class="main">)</span>
      |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">it</span> <span class="main">=&gt;</span> Drule.compose <span class="main">(</span><span class="entity">it</span><span class="main">,</span> <span class="inner_numeral">2</span><span class="main">,</span> <span class="entity">acc_induct_rule</span><span class="main">)</span><span class="main">)</span> <span class="comment1">(* "EX! y. (?x,y):G" *)</span>
      |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">it</span> <span class="main">=&gt;</span>
          fold <span class="main">(</span>Thm.forall_intr o Thm.cterm_of <span class="entity">ctxt</span> o Var<span class="main">)</span> <span class="main">(</span>Term.add_vars <span class="main">(</span>Thm.prop_of <span class="entity">it</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="entity">it</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goalstate</span> <span class="main">=</span>
      Conjunction.intr <span class="main">(</span>Conjunction.intr <span class="main">(</span>Conjunction.intr <span class="entity">graph_is_function</span> <span class="entity">complete</span><span class="main">)</span> <span class="entity">invariant</span><span class="main">)</span> <span class="entity">G_eqvt</span>
      |&gt; Thm.close_derivation <span class="antiquoted"><span class="operator"><span class="entity">⌂</span></span></span>
      |&gt; Goal.protect <span class="inner_numeral">0</span>
      |&gt; fold_rev <span class="main">(</span>Thm.implies_intr o Thm.cprop_of<span class="main">)</span> <span class="entity">compat</span>
      |&gt; Thm.implies_intr <span class="main">(</span>Thm.cprop_of <span class="entity">complete</span><span class="main">)</span>
      |&gt; Thm.implies_intr <span class="main">(</span>Thm.cprop_of <span class="entity">invariant</span><span class="main">)</span>
      |&gt; Thm.implies_intr <span class="main">(</span>Thm.cprop_of <span class="entity">G_eqvt</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="entity">goalstate</span><span class="main">,</span> <span class="entity">values</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* wrapper -- restores quantifiers in rule specifications *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">inductive_def</span> <span class="main">(</span><span class="entity">binding</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">R</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="entity">intrs</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">{</span>intrs <span class="main">=</span> <span class="entity">intrs_gen</span><span class="main">,</span> elims <span class="main">=</span> <span class="main">[</span><span class="entity">elim_gen</span><span class="main">]</span><span class="main">,</span> preds <span class="main">=</span> <span class="main">[</span> <span class="entity">Rdef</span> <span class="main">]</span><span class="main">,</span> <span class="entity">induct</span><span class="main">,</span> <span class="entity">raw_induct</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">lthy</span>
      |&gt; Config.put <span class="entity">Inductive.inductive_internals</span> true
      |&gt; Proof_Context.concealed
      |&gt; <span class="entity">Inductive.add_inductive</span>
          <span class="main">{</span>quiet_mode <span class="main">=</span> true<span class="main">,</span>
            verbose <span class="main">=</span> ! <span class="entity">trace</span><span class="main">,</span>
            alt_name <span class="main">=</span> Binding.empty<span class="main">,</span>
            coind <span class="main">=</span> false<span class="main">,</span>
            no_elim <span class="main">=</span> false<span class="main">,</span>
            no_ind <span class="main">=</span> false<span class="main">,</span>
            skip_mono <span class="main">=</span> true<span class="main">}</span>
          <span class="main">[</span><span class="entity">binding</span><span class="main">]</span> <span class="comment1">(* relation *)</span>
          <span class="main">[</span><span class="main">]</span> <span class="comment1">(* no parameters *)</span>
          <span class="main">(</span>map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> <span class="main">(</span>Binding.empty_atts<span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span> <span class="entity">intrs</span><span class="main">)</span> <span class="comment1">(* intro rules *)</span>
          <span class="main">[</span><span class="main">]</span> <span class="comment1">(* no special monos *)</span>
      ||&gt; Proof_Context.restore_naming <span class="entity">lthy</span>
      ||&gt; Config.put <span class="entity">Inductive.inductive_internals</span> <span class="main">(</span>Config.get <span class="entity">lthy</span> <span class="entity">Inductive.inductive_internals</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cert</span> <span class="main">=</span> Thm.cterm_of <span class="entity">lthy</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">requantify</span> <span class="entity">orig_intro</span> <span class="entity">thm</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">qs</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_all_all</span> <span class="entity">orig_intro</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">frees</span> <span class="main">=</span> Variable.add_frees <span class="entity">lthy</span> <span class="entity">t</span> <span class="main">[</span><span class="main">]</span> |&gt; remove <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span>Binding.name_of <span class="entity">R</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vars</span> <span class="main">=</span> Term.add_vars <span class="main">(</span>Thm.prop_of <span class="entity">thm</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">varmap</span> <span class="main">=</span> AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span><span class="entity">frees</span> ~~ map fst <span class="entity">vars</span><span class="main">)</span>
           #&gt; the_default <span class="main">(</span><span class="inner_quoted">""</span><span class="main">,</span><span class="inner_numeral">0</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        fold_rev <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> Free <span class="main">(</span><span class="entity">n</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=&gt;</span>
          <span class="entity">forall_intr_rename</span> <span class="main">(</span><span class="entity">n</span><span class="main">,</span> <span class="entity">cert</span> <span class="main">(</span>Var <span class="main">(</span><span class="entity">varmap</span> <span class="main">(</span><span class="entity">n</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">qs</span> <span class="entity">thm</span>
      <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="main">(</span><span class="entity">Rdef</span><span class="main">,</span> map2 <span class="entity">requantify</span> <span class="entity">intrs</span> <span class="entity">intrs_gen</span><span class="main">,</span> forall_intr_vars <span class="entity">elim_gen</span><span class="main">,</span> <span class="entity">induct</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* nominal *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">define_graph</span> <span class="entity">Gname</span> <span class="entity">fvar</span> <span class="entity">domT</span> <span class="entity">ranT</span> <span class="entity">clauses</span> <span class="entity">RCss</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">GT</span> <span class="main">=</span> <span class="entity">domT</span> --&gt; <span class="entity">ranT</span> --&gt; <span class="entity">boolT</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">Gvar</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">(</span><span class="entity">n</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> singleton <span class="main">(</span>Variable.variant_frees <span class="entity">lthy</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="main">(</span><span class="entity">Gname</span><span class="main">,</span> <span class="entity">GT</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_GIntro</span> <span class="main">(</span><span class="entity">ClauseContext</span> <span class="main">{</span><span class="entity">qs</span><span class="main">,</span> <span class="entity">gs</span><span class="main">,</span> <span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="entity">RCs</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_h_assm</span> <span class="main">(</span><span class="entity">rcfix</span><span class="main">,</span> <span class="entity">rcassm</span><span class="main">,</span> <span class="entity">rcarg</span><span class="main">)</span> <span class="main">=</span>
          <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span>Free <span class="entity">Gvar</span> $ <span class="entity">rcarg</span> $ <span class="main">(</span><span class="entity">fvar</span> $ <span class="entity">rcarg</span><span class="main">)</span><span class="main">)</span>
          |&gt; fold_rev <span class="main">(</span>curry Logic.mk_implies o Thm.prop_of<span class="main">)</span> <span class="entity">rcassm</span>
          |&gt; fold_rev <span class="main">(</span>Logic.all o Free<span class="main">)</span> <span class="entity">rcfix</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span>Free <span class="entity">Gvar</span> $ <span class="entity">lhs</span> $ <span class="entity">rhs</span><span class="main">)</span>
        |&gt; fold_rev <span class="main">(</span>curry Logic.mk_implies o <span class="entity">mk_h_assm</span><span class="main">)</span> <span class="entity">RCs</span>
        |&gt; fold_rev <span class="main">(</span>curry Logic.mk_implies<span class="main">)</span> <span class="entity">gs</span>
        |&gt; fold_rev Logic.all <span class="main">(</span><span class="entity">fvar</span> :: <span class="entity">qs</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">G_intros</span> <span class="main">=</span> map2 <span class="entity">mk_GIntro</span> <span class="entity">clauses</span> <span class="entity">RCss</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">inductive_def</span> <span class="main">(</span><span class="main">(</span>Binding.name <span class="entity">n</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> NoSyn<span class="main">)</span> <span class="entity">G_intros</span> <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">define_function</span> <span class="entity">fdefname</span> <span class="main">(</span><span class="entity">fname</span><span class="main">,</span> <span class="entity">mixfix</span><span class="main">)</span> <span class="entity">domT</span> <span class="entity">ranT</span> <span class="entity">G</span> <span class="entity">default</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">f_def</span> <span class="main">=</span>
      Abs <span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> <span class="entity">domT</span><span class="main">,</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Fun_Def.THE_default<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">ranT</span> --&gt; <span class="main">(</span><span class="entity">ranT</span> --&gt; <span class="entity">boolT</span><span class="main">)</span> --&gt; <span class="entity">ranT</span><span class="main">)</span>
        $ <span class="main">(</span><span class="entity">default</span> $ Bound <span class="inner_numeral">0</span><span class="main">)</span> $ Abs <span class="main">(</span><span class="inner_quoted">"y"</span><span class="main">,</span> <span class="entity">ranT</span><span class="main">,</span> <span class="entity">G</span> $ Bound <span class="inner_numeral">1</span> $ Bound <span class="inner_numeral">0</span><span class="main">)</span><span class="main">)</span>
      |&gt; Syntax.check_term <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Local_Theory.define
      <span class="main">(</span><span class="main">(</span>Binding.name <span class="main">(</span><span class="entity">fname</span> ^ <span class="inner_quoted">"C"</span><span class="main">)</span><span class="main">,</span> <span class="entity">mixfix</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="main">(</span>Binding.concealed <span class="main">(</span>Binding.name <span class="entity">fdefname</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">f_def</span><span class="main">)</span><span class="main">)</span> <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* nominal *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">define_recursion_relation</span> <span class="entity">Rname</span> <span class="entity">domT</span> <span class="entity">qglrs</span> <span class="entity">clauses</span> <span class="entity">RCss</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">RT</span> <span class="main">=</span> <span class="entity">domT</span> --&gt; <span class="entity">domT</span> --&gt; <span class="entity">boolT</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">Rvar</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">(</span><span class="entity">n</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> singleton <span class="main">(</span>Variable.variant_frees <span class="entity">lthy</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="main">(</span><span class="entity">Rname</span><span class="main">,</span> <span class="entity">RT</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_RIntro</span> <span class="main">(</span><span class="entity">ClauseContext</span> <span class="main">{</span><span class="entity">qs</span><span class="main">,</span> <span class="entity">gs</span><span class="main">,</span> <span class="entity">lhs</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">,</span> <span class="main">(</span><span class="entity">oqs</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">rcfix</span><span class="main">,</span> <span class="entity">rcassm</span><span class="main">,</span> <span class="entity">rcarg</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span>Free <span class="entity">Rvar</span> $ <span class="entity">rcarg</span> $ <span class="entity">lhs</span><span class="main">)</span>
      |&gt; fold_rev <span class="main">(</span>curry Logic.mk_implies o Thm.prop_of<span class="main">)</span> <span class="entity">rcassm</span>
      |&gt; fold_rev <span class="main">(</span>curry Logic.mk_implies<span class="main">)</span> <span class="entity">gs</span>
      |&gt; fold_rev <span class="main">(</span>Logic.all o Free<span class="main">)</span> <span class="entity">rcfix</span>
      |&gt; fold_rev <span class="entity">mk_forall_rename</span> <span class="main">(</span>map fst <span class="entity">oqs</span> ~~ <span class="entity">qs</span><span class="main">)</span>
      <span class="comment1">(* "!!qs xs. CS ==&gt; G =&gt; (r, lhs) : R" *)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">R_intross</span> <span class="main">=</span> map2 <span class="main">(</span>map o <span class="entity">mk_RIntro</span><span class="main">)</span> <span class="main">(</span><span class="entity">clauses</span> ~~ <span class="entity">qglrs</span><span class="main">)</span> <span class="entity">RCss</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">R</span><span class="main">,</span> <span class="entity">RIntro_thms</span><span class="main">,</span> <span class="entity">R_elim</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">inductive_def</span> <span class="main">(</span><span class="main">(</span>Binding.name <span class="entity">n</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> NoSyn<span class="main">)</span> <span class="main">(</span>flat <span class="entity">R_intross</span><span class="main">)</span> <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="main">(</span><span class="entity">R</span><span class="main">,</span> Library.unflat <span class="entity">R_intross</span> <span class="entity">RIntro_thms</span><span class="main">,</span> <span class="entity">R_elim</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">fix_globals</span> <span class="entity">domT</span> <span class="entity">ranT</span> <span class="entity">fvar</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">[</span><span class="entity">h</span><span class="main">,</span> <span class="entity">y</span><span class="main">,</span> <span class="entity">x</span><span class="main">,</span> <span class="entity">z</span><span class="main">,</span> <span class="entity">a</span><span class="main">,</span> <span class="entity">D</span><span class="main">,</span> <span class="entity">P</span><span class="main">,</span> <span class="entity">Pbool</span><span class="main">]</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> Variable.variant_fixes
      <span class="main">[</span><span class="inner_quoted">"h_fd"</span><span class="main">,</span> <span class="inner_quoted">"y_fd"</span><span class="main">,</span> <span class="inner_quoted">"x_fd"</span><span class="main">,</span> <span class="inner_quoted">"z_fd"</span><span class="main">,</span> <span class="inner_quoted">"a_fd"</span><span class="main">,</span> <span class="inner_quoted">"D_fd"</span><span class="main">,</span> <span class="inner_quoted">"P_fd"</span><span class="main">,</span> <span class="inner_quoted">"Pb_fd"</span><span class="main">]</span> <span class="entity">ctxt</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="entity">Globals</span> <span class="main">{</span>h <span class="main">=</span> Free <span class="main">(</span><span class="entity">h</span><span class="main">,</span> <span class="entity">domT</span> --&gt; <span class="entity">ranT</span><span class="main">)</span><span class="main">,</span>
      y <span class="main">=</span> Free <span class="main">(</span><span class="entity">y</span><span class="main">,</span> <span class="entity">ranT</span><span class="main">)</span><span class="main">,</span>
      x <span class="main">=</span> Free <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">domT</span><span class="main">)</span><span class="main">,</span>
      z <span class="main">=</span> Free <span class="main">(</span><span class="entity">z</span><span class="main">,</span> <span class="entity">domT</span><span class="main">)</span><span class="main">,</span>
      a <span class="main">=</span> Free <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">domT</span><span class="main">)</span><span class="main">,</span>
      D <span class="main">=</span> Free <span class="main">(</span><span class="entity">D</span><span class="main">,</span> <span class="entity">domT</span> --&gt; <span class="entity">boolT</span><span class="main">)</span><span class="main">,</span>
      P <span class="main">=</span> Free <span class="main">(</span><span class="entity">P</span><span class="main">,</span> <span class="entity">domT</span> --&gt; <span class="entity">boolT</span><span class="main">)</span><span class="main">,</span>
      Pbool <span class="main">=</span> Free <span class="main">(</span><span class="entity">Pbool</span><span class="main">,</span> <span class="entity">boolT</span><span class="main">)</span><span class="main">,</span>
      fvar <span class="main">=</span> <span class="entity">fvar</span><span class="main">,</span>
      domT <span class="main">=</span> <span class="entity">domT</span><span class="main">,</span>
      ranT <span class="main">=</span> <span class="entity">ranT</span><span class="main">}</span><span class="main">,</span>
    <span class="entity">ctxt'</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">inst_RC</span> <span class="entity">ctxt</span> <span class="entity">fvar</span> <span class="entity">f</span> <span class="main">(</span><span class="entity">rcfix</span><span class="main">,</span> <span class="entity">rcassm</span><span class="main">,</span> <span class="entity">rcarg</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">inst_term</span> <span class="entity">t</span> <span class="main">=</span> subst_bound<span class="main">(</span><span class="entity">f</span><span class="main">,</span> abstract_over <span class="main">(</span><span class="entity">fvar</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="entity">rcfix</span><span class="main">,</span> map <span class="main">(</span>Thm.assume o Thm.cterm_of <span class="entity">ctxt</span> o <span class="entity">inst_term</span> o Thm.prop_of<span class="main">)</span> <span class="entity">rcassm</span><span class="main">,</span> <span class="entity">inst_term</span> <span class="entity">rcarg</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>



<span class="comment1">(**********************************************************
 *                   PROVING THE RULES
 **********************************************************)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_psimps</span> <span class="entity">ctxt</span> <span class="entity">globals</span> <span class="entity">R</span> <span class="entity">clauses</span> <span class="entity">valthms</span> <span class="entity">f_iff</span> <span class="entity">graph_is_function</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Globals</span> <span class="main">{</span><span class="entity">domT</span><span class="main">,</span> <span class="entity">z</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">globals</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_psimp</span> <span class="main">(</span><span class="entity">ClauseInfo</span> <span class="main">{</span>qglr <span class="main">=</span> <span class="main">(</span><span class="entity">oqs</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> cdata <span class="main">=</span> <span class="entity">ClauseContext</span> <span class="main">{</span><span class="entity">cqs</span><span class="main">,</span> <span class="entity">lhs</span><span class="main">,</span> <span class="entity">ags</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="entity">valthm</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs_acc</span> <span class="main">=</span> Thm.cterm_of <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">mk_acc</span> <span class="entity">domT</span> <span class="entity">R</span> $ <span class="entity">lhs</span><span class="main">)</span><span class="main">)</span> <span class="comment1">(* "acc R lhs" *)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">z_smaller</span> <span class="main">=</span> Thm.cterm_of <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">R</span> $ <span class="entity">z</span> $ <span class="entity">lhs</span><span class="main">)</span><span class="main">)</span> <span class="comment1">(* "R z lhs" *)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="main">(</span>Thm.assume <span class="entity">z_smaller</span><span class="main">)</span> RS <span class="main">(</span><span class="main">(</span>Thm.assume <span class="entity">lhs_acc</span><span class="main">)</span> RS <span class="entity">acc_downward</span><span class="main">)</span><span class="main">)</span>
        |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">it</span> <span class="main">=&gt;</span> <span class="entity">it</span> COMP <span class="entity">graph_is_function</span><span class="main">)</span>
        |&gt; Thm.implies_intr <span class="entity">z_smaller</span>
        |&gt; Thm.forall_intr <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">z</span><span class="main">)</span>
        |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">it</span> <span class="main">=&gt;</span> <span class="entity">it</span> COMP <span class="entity">valthm</span><span class="main">)</span>
        |&gt; Thm.implies_intr <span class="entity">lhs_acc</span>
        |&gt; <span class="entity">asm_simplify</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span> addsimps <span class="main">[</span><span class="entity">f_iff</span><span class="main">]</span><span class="main">)</span>
        |&gt; fold_rev <span class="main">(</span>Thm.implies_intr o Thm.cprop_of<span class="main">)</span> <span class="entity">ags</span>
        |&gt; fold_rev <span class="entity">forall_intr_rename</span> <span class="main">(</span>map fst <span class="entity">oqs</span> ~~ <span class="entity">cqs</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">in</span></span>
    map2 <span class="entity">mk_psimp</span> <span class="entity">clauses</span> <span class="entity">valthms</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="comment1">(** Induction rule **)</span>


<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">acc_subset_induct</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> predicate1I<span class="antiquote">}</span></span></span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> accp_subset_induct<span class="antiquote">}</span></span></span>


<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_partial_induct_rule</span> <span class="entity">ctxt</span> <span class="entity">globals</span> <span class="entity">R</span> <span class="entity">complete_thm</span> <span class="entity">clauses</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Globals</span> <span class="main">{</span><span class="entity">domT</span><span class="main">,</span> <span class="entity">x</span><span class="main">,</span> <span class="entity">z</span><span class="main">,</span> <span class="entity">a</span><span class="main">,</span> <span class="entity">P</span><span class="main">,</span> <span class="entity">D</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">globals</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">acc_R</span> <span class="main">=</span> <span class="entity">mk_acc</span> <span class="entity">domT</span> <span class="entity">R</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">x_D</span> <span class="main">=</span> Thm.assume <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">D</span> $ <span class="entity">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">a_D</span> <span class="main">=</span> Thm.cterm_of <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">D</span> $ <span class="entity">a</span><span class="main">)</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">D_subset</span> <span class="main">=</span> Thm.cterm_of <span class="entity">ctxt</span> <span class="main">(</span>Logic.all <span class="entity">x</span>
      <span class="main">(</span>Logic.mk_implies <span class="main">(</span><span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">D</span> $ <span class="entity">x</span><span class="main">)</span><span class="main">,</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">acc_R</span> $ <span class="entity">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">D_dcl</span> <span class="main">=</span> <span class="comment1">(* "!!x z. [| x: D; (z,x):R |] ==&gt; z:D" *)</span>
      Logic.all <span class="entity">x</span> <span class="main">(</span>Logic.all <span class="entity">z</span> <span class="main">(</span>Logic.mk_implies <span class="main">(</span><span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">D</span> $ <span class="entity">x</span><span class="main">)</span><span class="main">,</span>
        Logic.mk_implies <span class="main">(</span><span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">R</span> $ <span class="entity">z</span> $ <span class="entity">x</span><span class="main">)</span><span class="main">,</span>
          <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">D</span> $ <span class="entity">z</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      |&gt; Thm.cterm_of <span class="entity">ctxt</span>

    <span class="comment1">(* Inductive Hypothesis: !!z. (z,x):R ==&gt; P z *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ihyp</span> <span class="main">=</span> Logic.all_const <span class="entity">domT</span> $ Abs <span class="main">(</span><span class="inner_quoted">"z"</span><span class="main">,</span> <span class="entity">domT</span><span class="main">,</span>
      Logic.mk_implies <span class="main">(</span><span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">R</span> $ Bound <span class="inner_numeral">0</span> $ <span class="entity">x</span><span class="main">)</span><span class="main">,</span>
        <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">P</span> $ Bound <span class="inner_numeral">0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      |&gt; Thm.cterm_of <span class="entity">ctxt</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">aihyp</span> <span class="main">=</span> Thm.assume <span class="entity">ihyp</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_case</span> <span class="entity">clause</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ClauseInfo</span> <span class="main">{</span>cdata <span class="main">=</span> <span class="entity">ClauseContext</span> <span class="main">{</span>ctxt <span class="main">=</span> <span class="entity">ctxt'</span><span class="main">,</span> <span class="entity">qs</span><span class="main">,</span> <span class="entity">cqs</span><span class="main">,</span> <span class="entity">ags</span><span class="main">,</span> <span class="entity">gs</span><span class="main">,</span> <span class="entity">lhs</span><span class="main">,</span> <span class="entity">case_hyp</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">,</span>
          <span class="entity">RCs</span><span class="main">,</span> qglr <span class="main">=</span> <span class="main">(</span><span class="entity">oqs</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">clause</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">case_hyp_conv</span> <span class="main">=</span> K <span class="main">(</span><span class="entity">case_hyp</span> RS <span class="entity">eq_reflection</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">local</span></span> <span class="keyword3"><span class="keyword">open</span></span> Conv <span class="keyword2"><span class="keyword">in</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs_D</span> <span class="main">=</span> fconv_rule <span class="main">(</span>arg_conv <span class="main">(</span>arg_conv <span class="main">(</span><span class="entity">case_hyp_conv</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">x_D</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sih</span> <span class="main">=</span>
            fconv_rule <span class="main">(</span>Conv.binder_conv
              <span class="main">(</span>K <span class="main">(</span>arg1_conv <span class="main">(</span>arg_conv <span class="main">(</span>arg_conv <span class="entity">case_hyp_conv</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="entity">aihyp</span>
        <span class="keyword2"><span class="keyword">end</span></span>

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_Prec</span> <span class="main">(</span><span class="entity">RCInfo</span> <span class="main">{</span><span class="entity">llRI</span><span class="main">,</span> <span class="entity">RIvs</span><span class="main">,</span> <span class="entity">CCas</span><span class="main">,</span> <span class="entity">rcarg</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> <span class="entity">sih</span>
          |&gt; Thm.forall_elim <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">rcarg</span><span class="main">)</span>
          |&gt; Thm.elim_implies <span class="entity">llRI</span>
          |&gt; fold_rev <span class="main">(</span>Thm.implies_intr o Thm.cprop_of<span class="main">)</span> <span class="entity">CCas</span>
          |&gt; fold_rev <span class="main">(</span>Thm.forall_intr o Thm.cterm_of <span class="entity">ctxt</span> o Free<span class="main">)</span> <span class="entity">RIvs</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">P_recs</span> <span class="main">=</span> map <span class="entity">mk_Prec</span> <span class="entity">RCs</span>   <span class="comment1">(*  [P rec1, P rec2, ... ]  *)</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">step</span> <span class="main">=</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">P</span> $ <span class="entity">lhs</span><span class="main">)</span>
          |&gt; fold_rev <span class="main">(</span>curry Logic.mk_implies o Thm.prop_of<span class="main">)</span> <span class="entity">P_recs</span>
          |&gt; fold_rev <span class="main">(</span>curry Logic.mk_implies<span class="main">)</span> <span class="entity">gs</span>
          |&gt; curry Logic.mk_implies <span class="main">(</span><span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">D</span> $ <span class="entity">lhs</span><span class="main">)</span><span class="main">)</span>
          |&gt; fold_rev <span class="entity">mk_forall_rename</span> <span class="main">(</span>map fst <span class="entity">oqs</span> ~~ <span class="entity">qs</span><span class="main">)</span>
          |&gt; Thm.cterm_of <span class="entity">ctxt</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">P_lhs</span> <span class="main">=</span> Thm.assume <span class="entity">step</span>
          |&gt; fold Thm.forall_elim <span class="entity">cqs</span>
          |&gt; Thm.elim_implies <span class="entity">lhs_D</span>
          |&gt; fold Thm.elim_implies <span class="entity">ags</span>
          |&gt; fold Thm.elim_implies <span class="entity">P_recs</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">res</span> <span class="main">=</span>
          Thm.cterm_of <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">P</span> $ <span class="entity">x</span><span class="main">)</span><span class="main">)</span>
          |&gt; Conv.arg_conv <span class="main">(</span>Conv.arg_conv <span class="entity">case_hyp_conv</span><span class="main">)</span>
          |&gt; Thm.symmetric <span class="comment1">(* P lhs == P x *)</span>
          |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">eql</span> <span class="main">=&gt;</span> Thm.equal_elim <span class="entity">eql</span> <span class="entity">P_lhs</span><span class="main">)</span> <span class="comment1">(* "P x" *)</span>
          |&gt; Thm.implies_intr <span class="main">(</span>Thm.cprop_of <span class="entity">case_hyp</span><span class="main">)</span>
          |&gt; fold_rev <span class="main">(</span>Thm.implies_intr o Thm.cprop_of<span class="main">)</span> <span class="entity">ags</span>
          |&gt; fold_rev Thm.forall_intr <span class="entity">cqs</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="entity">res</span><span class="main">,</span> <span class="entity">step</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">cases</span><span class="main">,</span> <span class="entity">steps</span><span class="main">)</span> <span class="main">=</span> split_list <span class="main">(</span>map <span class="entity">prove_case</span> <span class="entity">clauses</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">istep</span> <span class="main">=</span> <span class="entity">complete_thm</span>
      |&gt; Thm.forall_elim_vars <span class="inner_numeral">0</span>
      |&gt; fold <span class="main">(</span>curry <span class="keyword1"><span class="keyword">op</span></span> COMP<span class="main">)</span> <span class="entity">cases</span> <span class="comment1">(*  P x  *)</span>
      |&gt; Thm.implies_intr <span class="entity">ihyp</span>
      |&gt; Thm.implies_intr <span class="main">(</span>Thm.cprop_of <span class="entity">x_D</span><span class="main">)</span>
      |&gt; Thm.forall_intr <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">x</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">subset_induct_rule</span> <span class="main">=</span>
      <span class="entity">acc_subset_induct</span>
      |&gt; <span class="main">(</span>curry <span class="keyword1"><span class="keyword">op</span></span> COMP<span class="main">)</span> <span class="main">(</span>Thm.assume <span class="entity">D_subset</span><span class="main">)</span>
      |&gt; <span class="main">(</span>curry <span class="keyword1"><span class="keyword">op</span></span> COMP<span class="main">)</span> <span class="main">(</span>Thm.assume <span class="entity">D_dcl</span><span class="main">)</span>
      |&gt; <span class="main">(</span>curry <span class="keyword1"><span class="keyword">op</span></span> COMP<span class="main">)</span> <span class="main">(</span>Thm.assume <span class="entity">a_D</span><span class="main">)</span>
      |&gt; <span class="main">(</span>curry <span class="keyword1"><span class="keyword">op</span></span> COMP<span class="main">)</span> <span class="entity">istep</span>
      |&gt; fold_rev Thm.implies_intr <span class="entity">steps</span>
      |&gt; Thm.implies_intr <span class="entity">a_D</span>
      |&gt; Thm.implies_intr <span class="entity">D_dcl</span>
      |&gt; Thm.implies_intr <span class="entity">D_subset</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simple_induct_rule</span> <span class="main">=</span>
      <span class="entity">subset_induct_rule</span>
      |&gt; Thm.forall_intr <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">D</span><span class="main">)</span>
      |&gt; Thm.forall_elim <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">acc_R</span><span class="main">)</span>
      |&gt; assume_tac <span class="entity">ctxt</span> <span class="inner_numeral">1</span> |&gt; Seq.hd
      |&gt; <span class="main">(</span>curry <span class="keyword1"><span class="keyword">op</span></span> COMP<span class="main">)</span> <span class="main">(</span><span class="entity">acc_downward</span>
        |&gt; <span class="main">(</span>Thm.instantiate' <span class="main">[</span>SOME <span class="main">(</span>Thm.ctyp_of <span class="entity">ctxt</span> <span class="entity">domT</span><span class="main">)</span><span class="main">]</span>
             <span class="main">(</span>map <span class="main">(</span>SOME o Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span> <span class="main">[</span><span class="entity">R</span><span class="main">,</span> <span class="entity">x</span><span class="main">,</span> <span class="entity">z</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
        |&gt; Thm.forall_intr <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">z</span><span class="main">)</span>
        |&gt; Thm.forall_intr <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">x</span><span class="main">)</span><span class="main">)</span>
      |&gt; Thm.forall_intr <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">a</span><span class="main">)</span>
      |&gt; Thm.forall_intr <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">P</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">simple_induct_rule</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="comment1">(* FIXME: broken by design *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_domain_intro</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">Globals</span> <span class="main">{</span><span class="entity">domT</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="entity">R</span> <span class="entity">R_cases</span> <span class="entity">clause</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ClauseInfo</span> <span class="main">{</span>cdata <span class="main">=</span> <span class="entity">ClauseContext</span> <span class="main">{</span><span class="entity">gs</span><span class="main">,</span> <span class="entity">lhs</span><span class="main">,</span> <span class="entity">cqs</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">,</span>
      qglr <span class="main">=</span> <span class="main">(</span><span class="entity">oqs</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">clause</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goal</span> <span class="main">=</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">mk_acc</span> <span class="entity">domT</span> <span class="entity">R</span> $ <span class="entity">lhs</span><span class="main">)</span>
      |&gt; fold_rev <span class="main">(</span>curry Logic.mk_implies<span class="main">)</span> <span class="entity">gs</span>
      |&gt; Thm.cterm_of <span class="entity">ctxt</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Goal.init <span class="entity">goal</span>
    |&gt; <span class="main">(</span>SINGLE <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">accI</span><span class="main">]</span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span> |&gt; the
    |&gt; <span class="main">(</span>SINGLE <span class="main">(</span>eresolve_tac <span class="entity">ctxt</span> <span class="main">[</span>Thm.forall_elim_vars <span class="inner_numeral">0</span> <span class="entity">R_cases</span><span class="main">]</span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span>  |&gt; the
    |&gt; <span class="main">(</span>SINGLE <span class="main">(</span><span class="entity">auto_tac</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span> |&gt; the
    |&gt; Goal.conclude
    |&gt; fold_rev <span class="entity">forall_intr_rename</span> <span class="main">(</span>map fst <span class="entity">oqs</span> ~~ <span class="entity">cqs</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>



<span class="comment1">(** Termination rule **)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">wf_induct_rule</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Wellfounded.wfP_induct_rule<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">wf_in_rel</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Fun_Def.wf_in_rel<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">in_rel_def</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Fun_Def.in_rel_def<span class="antiquote">}</span></span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_nest_term_case</span> <span class="entity">ctxt</span> <span class="entity">globals</span> <span class="entity">R'</span> <span class="entity">ihyp</span> <span class="entity">clause</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Globals</span> <span class="main">{</span><span class="entity">z</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">globals</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ClauseInfo</span> <span class="main">{</span>cdata <span class="main">=</span> <span class="entity">ClauseContext</span> <span class="main">{</span><span class="entity">qs</span><span class="main">,</span> <span class="entity">cqs</span><span class="main">,</span> <span class="entity">ags</span><span class="main">,</span> <span class="entity">lhs</span><span class="main">,</span> <span class="entity">case_hyp</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">,</span> <span class="entity">tree</span><span class="main">,</span>
      qglr<span class="main">=</span><span class="main">(</span><span class="entity">oqs</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">clause</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ih_case</span> <span class="main">=</span>
      <span class="entity">full_simplify</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span> addsimps <span class="main">[</span><span class="entity">case_hyp</span><span class="main">]</span><span class="main">)</span>
        <span class="entity">ihyp</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">step</span> <span class="main">(</span><span class="entity">fixes</span><span class="main">,</span> <span class="entity">assumes</span><span class="main">)</span> <span class="main">(</span><span class="main">_</span> $ <span class="entity">arg</span><span class="main">)</span> <span class="entity">u</span> <span class="main">(</span><span class="entity">sub</span><span class="main">,</span><span class="main">(</span><span class="entity">hyps</span><span class="main">,</span><span class="entity">thms</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">used</span> <span class="main">=</span> <span class="main">(</span><span class="entity">u</span> @ <span class="entity">sub</span><span class="main">)</span>
          |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">ctx</span><span class="main">,</span><span class="entity">thm</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">Function_Context_Tree.export_thm</span> <span class="entity">ctxt</span> <span class="entity">ctx</span> <span class="entity">thm</span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">hyp</span> <span class="main">=</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">R'</span> $ <span class="entity">arg</span> $ <span class="entity">lhs</span><span class="main">)</span>
          |&gt; fold_rev <span class="main">(</span>curry Logic.mk_implies o Thm.prop_of<span class="main">)</span> <span class="entity">used</span> <span class="comment1">(* additional hyps *)</span>
          |&gt; <span class="entity">Function_Context_Tree.export_term</span> <span class="main">(</span><span class="entity">fixes</span><span class="main">,</span> <span class="entity">assumes</span><span class="main">)</span>
          |&gt; fold_rev <span class="main">(</span>curry Logic.mk_implies o Thm.prop_of<span class="main">)</span> <span class="entity">ags</span>
          |&gt; fold_rev <span class="entity">mk_forall_rename</span> <span class="main">(</span>map fst <span class="entity">oqs</span> ~~ <span class="entity">qs</span><span class="main">)</span>
          |&gt; Thm.cterm_of <span class="entity">ctxt</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm</span> <span class="main">=</span> Thm.assume <span class="entity">hyp</span>
          |&gt; fold Thm.forall_elim <span class="entity">cqs</span>
          |&gt; fold Thm.elim_implies <span class="entity">ags</span>
          |&gt; <span class="entity">Function_Context_Tree.import_thm</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">fixes</span><span class="main">,</span> <span class="entity">assumes</span><span class="main">)</span>
          |&gt; fold Thm.elim_implies <span class="entity">used</span> <span class="comment1">(*  "(arg, lhs) : R'"  *)</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">z_eq_arg</span> <span class="main">=</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">mk_eq</span> <span class="main">(</span><span class="entity">z</span><span class="main">,</span> <span class="entity">arg</span><span class="main">)</span><span class="main">)</span>
          |&gt; Thm.cterm_of <span class="entity">ctxt</span> |&gt; Thm.assume

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">acc</span> <span class="main">=</span> <span class="entity">thm</span> COMP <span class="entity">ih_case</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">z_acc_local</span> <span class="main">=</span> <span class="entity">acc</span>
          |&gt; Conv.fconv_rule
              <span class="main">(</span>Conv.arg_conv <span class="main">(</span>Conv.arg_conv <span class="main">(</span>K <span class="main">(</span>Thm.symmetric <span class="main">(</span><span class="entity">z_eq_arg</span> RS <span class="entity">eq_reflection</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ethm</span> <span class="main">=</span> <span class="entity">z_acc_local</span>
          |&gt; <span class="entity">Function_Context_Tree.export_thm</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">fixes</span><span class="main">,</span>
               <span class="entity">z_eq_arg</span> :: <span class="entity">case_hyp</span> :: <span class="entity">ags</span> @ <span class="entity">assumes</span><span class="main">)</span>
          |&gt; fold_rev <span class="entity">forall_intr_rename</span> <span class="main">(</span>map fst <span class="entity">oqs</span> ~~ <span class="entity">cqs</span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sub'</span> <span class="main">=</span> <span class="entity">sub</span> @ <span class="main">[</span><span class="main">(</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span><span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">acc</span><span class="main">)</span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="entity">sub'</span><span class="main">,</span> <span class="main">(</span><span class="entity">hyp</span> :: <span class="entity">hyps</span><span class="main">,</span> <span class="entity">ethm</span> :: <span class="entity">thms</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
      <span class="main">|</span> <span class="entity">step</span> <span class="main">_</span> <span class="main">_</span> <span class="main">_</span> <span class="main">_</span> <span class="main">=</span> <span class="keyword3"><span class="keyword">raise</span></span> Match
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">Function_Context_Tree.traverse_tree</span> <span class="entity">step</span> <span class="entity">tree</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_nest_term_rule</span> <span class="entity">ctxt</span> <span class="entity">globals</span> <span class="entity">R</span> <span class="entity">R_cases</span> <span class="entity">clauses</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Globals</span> <span class="main">{</span> <span class="entity">domT</span><span class="main">,</span> <span class="entity">x</span><span class="main">,</span> <span class="entity">z</span><span class="main">,</span> <span class="main">...</span> <span class="main">}</span> <span class="main">=</span> <span class="entity">globals</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">acc_R</span> <span class="main">=</span> <span class="entity">mk_acc</span> <span class="entity">domT</span> <span class="entity">R</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">R'</span> <span class="main">=</span> Free <span class="main">(</span><span class="inner_quoted">"R"</span><span class="main">,</span> fastype_of <span class="entity">R</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Rrel</span> <span class="main">=</span> Free <span class="main">(</span><span class="inner_quoted">"R"</span><span class="main">,</span> <span class="entity">HOLogic.mk_setT</span> <span class="main">(</span><span class="entity">HOLogic.mk_prodT</span> <span class="main">(</span><span class="entity">domT</span><span class="main">,</span> <span class="entity">domT</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inrel_R</span> <span class="main">=</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Fun_Def.in_rel<span class="antiquote">}</span></span><span class="main">,</span>
      <span class="entity">HOLogic.mk_setT</span> <span class="main">(</span><span class="entity">HOLogic.mk_prodT</span> <span class="main">(</span><span class="entity">domT</span><span class="main">,</span> <span class="entity">domT</span><span class="main">)</span><span class="main">)</span> --&gt; fastype_of <span class="entity">R</span><span class="main">)</span> $ <span class="entity">Rrel</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">wfR'</span> <span class="main">=</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Wellfounded.wfP<span class="antiquote">}</span></span><span class="main">,</span>
      <span class="main">(</span><span class="entity">domT</span> --&gt; <span class="entity">domT</span> --&gt; <span class="entity">boolT</span><span class="main">)</span> --&gt; <span class="entity">boolT</span><span class="main">)</span> $ <span class="entity">R'</span><span class="main">)</span>
      |&gt; Thm.cterm_of <span class="entity">ctxt</span> <span class="comment1">(* "wf R'" *)</span>

    <span class="comment1">(* Inductive Hypothesis: !!z. (z,x):R' ==&gt; z : acc R *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ihyp</span> <span class="main">=</span> Logic.all_const <span class="entity">domT</span> $ Abs <span class="main">(</span><span class="inner_quoted">"z"</span><span class="main">,</span> <span class="entity">domT</span><span class="main">,</span>
      Logic.mk_implies <span class="main">(</span><span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">R'</span> $ Bound <span class="inner_numeral">0</span> $ <span class="entity">x</span><span class="main">)</span><span class="main">,</span>
        <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">acc_R</span> $ Bound <span class="inner_numeral">0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      |&gt; Thm.cterm_of <span class="entity">ctxt</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ihyp_a</span> <span class="main">=</span> Thm.assume <span class="entity">ihyp</span> |&gt; Thm.forall_elim_vars <span class="inner_numeral">0</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">R_z_x</span> <span class="main">=</span> Thm.cterm_of <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">R</span> $ <span class="entity">z</span> $ <span class="entity">x</span><span class="main">)</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">hyps</span><span class="main">,</span> <span class="entity">cases</span><span class="main">)</span> <span class="main">=</span> fold <span class="main">(</span><span class="entity">mk_nest_term_case</span> <span class="entity">ctxt</span> <span class="entity">globals</span> <span class="entity">R'</span> <span class="entity">ihyp_a</span><span class="main">)</span> <span class="entity">clauses</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">R_cases</span>
    |&gt; Thm.forall_elim <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">z</span><span class="main">)</span>
    |&gt; Thm.forall_elim <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">x</span><span class="main">)</span>
    |&gt; Thm.forall_elim <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">acc_R</span> $ <span class="entity">z</span><span class="main">)</span><span class="main">)</span>
    |&gt; curry <span class="keyword1"><span class="keyword">op</span></span> COMP <span class="main">(</span>Thm.assume <span class="entity">R_z_x</span><span class="main">)</span>
    |&gt; fold_rev <span class="main">(</span>curry <span class="keyword1"><span class="keyword">op</span></span> COMP<span class="main">)</span> <span class="entity">cases</span>
    |&gt; Thm.implies_intr <span class="entity">R_z_x</span>
    |&gt; Thm.forall_intr <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">z</span><span class="main">)</span>
    |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">it</span> <span class="main">=&gt;</span> <span class="entity">it</span> COMP <span class="entity">accI</span><span class="main">)</span>
    |&gt; Thm.implies_intr <span class="entity">ihyp</span>
    |&gt; Thm.forall_intr <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">x</span><span class="main">)</span>
    |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">it</span> <span class="main">=&gt;</span> Drule.compose <span class="main">(</span><span class="entity">it</span><span class="main">,</span> <span class="inner_numeral">2</span><span class="main">,</span> <span class="entity">wf_induct_rule</span><span class="main">)</span><span class="main">)</span>
    |&gt; curry <span class="keyword1"><span class="keyword">op</span></span> RS <span class="main">(</span>Thm.assume <span class="entity">wfR'</span><span class="main">)</span>
    |&gt; forall_intr_vars
    |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">it</span> <span class="main">=&gt;</span> <span class="entity">it</span> COMP <span class="entity">allI</span><span class="main">)</span>
    |&gt; fold Thm.implies_intr <span class="entity">hyps</span>
    |&gt; Thm.implies_intr <span class="entity">wfR'</span>
    |&gt; Thm.forall_intr <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">R'</span><span class="main">)</span>
    |&gt; Thm.forall_elim <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">inrel_R</span><span class="main">)</span><span class="main">)</span>
    |&gt; curry <span class="keyword1"><span class="keyword">op</span></span> RS <span class="entity">wf_in_rel</span>
    |&gt; <span class="entity">full_simplify</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span> addsimps <span class="main">[</span><span class="entity">in_rel_def</span><span class="main">]</span><span class="main">)</span>
    |&gt; Thm.forall_intr <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">Rrel</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>



<span class="comment1">(* nominal *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prepare_nominal_function</span> <span class="entity">config</span> <span class="entity">defname</span> <span class="main">[</span><span class="main">(</span><span class="main">(</span><span class="entity">fname</span><span class="main">,</span> <span class="entity">fT</span><span class="main">)</span><span class="main">,</span> <span class="entity">mixfix</span><span class="main">)</span><span class="main">]</span> <span class="entity">abstract_qglrs</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">NominalFunctionConfig</span> <span class="main">{</span><span class="entity">domintros</span><span class="main">,</span> default<span class="main">=</span><span class="entity">default_opt</span><span class="main">,</span> inv<span class="main">=</span><span class="entity">invariant_opt</span><span class="main">,</span><span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">config</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">default_str</span> <span class="main">=</span> the_default <span class="inner_quoted">"%x. undefined"</span> <span class="entity">default_opt</span> <span class="comment1">(*FIXME dynamic scoping*)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">invariant_str</span> <span class="main">=</span> the_default <span class="inner_quoted">"%x y. True"</span> <span class="entity">invariant_opt</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fvar</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">fname</span><span class="main">,</span> <span class="entity">fT</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">domT</span> <span class="main">=</span> domain_type <span class="entity">fT</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ranT</span> <span class="main">=</span> range_type <span class="entity">fT</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">default</span> <span class="main">=</span> Syntax.parse_term <span class="entity">lthy</span> <span class="entity">default_str</span>
      |&gt; Type.constraint <span class="entity">fT</span> |&gt; Syntax.check_term <span class="entity">lthy</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">invariant_trm</span> <span class="main">=</span> Syntax.parse_term <span class="entity">lthy</span> <span class="entity">invariant_str</span>
      |&gt; Type.constraint <span class="main">(</span><span class="main">[</span><span class="entity">domT</span><span class="main">,</span> <span class="entity">ranT</span><span class="main">]</span> ---&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">bool</span><span class="antiquote">}</span></span><span class="main">)</span> |&gt; Syntax.check_term <span class="entity">lthy</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">globals</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">fix_globals</span> <span class="entity">domT</span> <span class="entity">ranT</span> <span class="entity">fvar</span> <span class="entity">lthy</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Globals</span> <span class="main">{</span> <span class="entity">x</span><span class="main">,</span> <span class="entity">h</span><span class="main">,</span> <span class="main">...</span> <span class="main">}</span> <span class="main">=</span> <span class="entity">globals</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">clauses</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">mk_clause_context</span> <span class="entity">x</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="entity">abstract_qglrs</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">n</span> <span class="main">=</span> length <span class="entity">abstract_qglrs</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">build_tree</span> <span class="main">(</span><span class="entity">ClauseContext</span> <span class="main">{</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
       <span class="entity">Function_Context_Tree.mk_tree</span> <span class="main">(</span>Free <span class="main">(</span><span class="entity">fname</span><span class="main">,</span> <span class="entity">fT</span><span class="main">)</span><span class="main">)</span> <span class="entity">h</span> <span class="entity">ctxt</span> <span class="entity">rhs</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">trees</span> <span class="main">=</span> map <span class="entity">build_tree</span> <span class="entity">clauses</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">RCss</span> <span class="main">=</span> map <span class="entity">find_calls</span> <span class="entity">trees</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">G</span><span class="main">,</span> <span class="entity">GIntro_thms</span><span class="main">,</span> <span class="entity">G_elim</span><span class="main">,</span> <span class="entity">G_induct</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">PROFILE</span> <span class="inner_quoted">"def_graph"</span> <span class="main">(</span><span class="entity">define_graph</span> <span class="main">(</span><span class="entity">defname</span> ^ <span class="inner_quoted">"_graph"</span><span class="main">)</span> <span class="entity">fvar</span> <span class="entity">domT</span> <span class="entity">ranT</span> <span class="entity">clauses</span> <span class="entity">RCss</span><span class="main">)</span> <span class="entity">lthy</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">f_defthm</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">PROFILE</span> <span class="inner_quoted">"def_fun"</span> <span class="main">(</span><span class="entity">define_function</span> <span class="main">(</span><span class="entity">defname</span> ^ <span class="inner_quoted">"_sumC_def"</span><span class="main">)</span> <span class="main">(</span><span class="entity">fname</span><span class="main">,</span> <span class="entity">mixfix</span><span class="main">)</span> <span class="entity">domT</span> <span class="entity">ranT</span> <span class="entity">G</span> <span class="entity">default</span><span class="main">)</span> <span class="entity">lthy</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">RCss</span> <span class="main">=</span> map <span class="main">(</span>map <span class="main">(</span><span class="entity">inst_RC</span> <span class="entity">lthy</span> <span class="entity">fvar</span> <span class="entity">f</span><span class="main">)</span><span class="main">)</span> <span class="entity">RCss</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">trees</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">Function_Context_Tree.inst_tree</span> <span class="entity">lthy</span> <span class="entity">fvar</span> <span class="entity">f</span><span class="main">)</span> <span class="entity">trees</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">R</span><span class="main">,</span> <span class="entity">RIntro_thmss</span><span class="main">,</span> <span class="entity">R_elim</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">PROFILE</span> <span class="inner_quoted">"def_rel"</span> <span class="main">(</span><span class="entity">define_recursion_relation</span> <span class="main">(</span><span class="entity">defname</span> ^ <span class="inner_quoted">"_rel"</span><span class="main">)</span> <span class="entity">domT</span> <span class="entity">abstract_qglrs</span> <span class="entity">clauses</span> <span class="entity">RCss</span><span class="main">)</span> <span class="entity">lthy</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span>
      Local_Theory.abbrev Syntax.mode_default <span class="main">(</span><span class="main">(</span>Binding.name <span class="main">(</span><span class="entity">defname</span> ^ <span class="inner_quoted">"_dom"</span><span class="main">)</span><span class="main">,</span> NoSyn<span class="main">)</span><span class="main">,</span> <span class="entity">mk_acc</span> <span class="entity">domT</span> <span class="entity">R</span><span class="main">)</span> <span class="entity">lthy</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">newthy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">lthy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">clauses</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">transfer_clause_ctx</span> <span class="entity">newthy</span><span class="main">)</span> <span class="entity">clauses</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cert</span> <span class="main">=</span> Thm.cterm_of <span class="entity">lthy</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xclauses</span> <span class="main">=</span> <span class="entity">PROFILE</span> <span class="inner_quoted">"xclauses"</span>
      <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">map</span> 7<span class="antiquote">}</span></span></span> <span class="main">(</span><span class="entity">mk_clause_info</span> <span class="entity">globals</span> <span class="entity">G</span> <span class="entity">f</span><span class="main">)</span> <span class="main">(</span><span class="inner_numeral">1</span> upto <span class="entity">n</span><span class="main">)</span> <span class="entity">clauses</span> <span class="entity">abstract_qglrs</span> <span class="entity">trees</span>
        <span class="entity">RCss</span> <span class="entity">GIntro_thms</span><span class="main">)</span> <span class="entity">RIntro_thmss</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">complete</span> <span class="main">=</span>
      <span class="entity">mk_completeness</span> <span class="entity">globals</span> <span class="entity">clauses</span> <span class="entity">abstract_qglrs</span> |&gt; <span class="entity">cert</span> |&gt; Thm.assume

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">compat</span> <span class="main">=</span>
      <span class="entity">mk_compat_proof_obligations</span> <span class="entity">domT</span> <span class="entity">ranT</span> <span class="entity">fvar</span> <span class="entity">f</span> <span class="entity">RCss</span> <span class="entity">invariant_trm</span> <span class="entity">abstract_qglrs</span>
      |&gt; map <span class="main">(</span><span class="entity">cert</span> #&gt; Thm.assume<span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">G_eqvt</span> <span class="main">=</span> <span class="entity">mk_eqvt</span> <span class="entity">G</span> |&gt; <span class="entity">cert</span> |&gt; Thm.assume

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">invariant</span> <span class="main">=</span> <span class="entity">mk_invariant</span> <span class="entity">globals</span> <span class="entity">G</span> <span class="entity">invariant_trm</span> |&gt; <span class="entity">cert</span> |&gt; Thm.assume

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">compat_store</span> <span class="main">=</span> <span class="entity">store_compat_thms</span> <span class="entity">n</span> <span class="entity">compat</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">goalstate</span><span class="main">,</span> <span class="entity">values</span><span class="main">)</span> <span class="main">=</span> <span class="entity">PROFILE</span> <span class="inner_quoted">"prove_stuff"</span>
      <span class="main">(</span><span class="entity">prove_stuff</span> <span class="entity">lthy</span> <span class="entity">globals</span> <span class="entity">G</span> <span class="entity">f</span> <span class="entity">R</span> <span class="entity">xclauses</span> <span class="entity">complete</span> <span class="entity">compat</span>
         <span class="entity">compat_store</span> <span class="entity">G_elim</span> <span class="entity">G_eqvt</span> <span class="entity">invariant</span><span class="main">)</span> <span class="entity">f_defthm</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_partial_rules</span> <span class="entity">newctxt</span> <span class="entity">provedgoal</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">graph_is_function</span><span class="main">,</span> <span class="entity">complete_thm</span><span class="main">)</span><span class="main">,</span> <span class="entity">graph_is_eqvt</span><span class="main">)</span> <span class="main">=</span>
          <span class="entity">provedgoal</span>
          |&gt; Conjunction.elim
          |&gt;&gt; fst o Conjunction.elim
          |&gt;&gt; Conjunction.elim
          |&gt;&gt; apfst <span class="main">(</span>Thm.forall_elim_vars <span class="inner_numeral">0</span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">f_iff</span> <span class="main">=</span> <span class="entity">graph_is_function</span> RS <span class="main">(</span><span class="entity">f_defthm</span> RS <span class="entity">ex1_implies_iff</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">f_eqvt</span> <span class="main">=</span> <span class="entity">graph_is_function</span> RS <span class="main">(</span><span class="entity">graph_is_eqvt</span> RS <span class="main">(</span><span class="entity">f_defthm</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> fundef_ex1_eqvt<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">psimps</span> <span class="main">=</span> <span class="entity">PROFILE</span> <span class="inner_quoted">"Proving simplification rules"</span>
          <span class="main">(</span><span class="entity">mk_psimps</span> <span class="entity">newctxt</span> <span class="entity">globals</span> <span class="entity">R</span> <span class="entity">xclauses</span> <span class="entity">values</span> <span class="entity">f_iff</span><span class="main">)</span> <span class="entity">graph_is_function</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simple_pinduct</span> <span class="main">=</span> <span class="entity">PROFILE</span> <span class="inner_quoted">"Proving partial induction rule"</span>
          <span class="main">(</span><span class="entity">mk_partial_induct_rule</span> <span class="entity">newctxt</span> <span class="entity">globals</span> <span class="entity">R</span> <span class="entity">complete_thm</span><span class="main">)</span> <span class="entity">xclauses</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">total_intro</span> <span class="main">=</span> <span class="entity">PROFILE</span> <span class="inner_quoted">"Proving nested termination rule"</span>
          <span class="main">(</span><span class="entity">mk_nest_term_rule</span> <span class="entity">newctxt</span> <span class="entity">globals</span> <span class="entity">R</span> <span class="entity">R_elim</span><span class="main">)</span> <span class="entity">xclauses</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dom_intros</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">domintros</span> <span class="keyword2"><span class="keyword">then</span></span> SOME <span class="main">(</span><span class="entity">PROFILE</span> <span class="inner_quoted">"Proving domain introduction rules"</span>
             <span class="main">(</span>map <span class="main">(</span><span class="entity">mk_domain_intro</span> <span class="entity">lthy</span> <span class="entity">globals</span> <span class="entity">R</span> <span class="entity">R_elim</span><span class="main">)</span><span class="main">)</span> <span class="entity">xclauses</span><span class="main">)</span>
           <span class="keyword2"><span class="keyword">else</span></span> NONE

      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="entity">NominalFunctionResult</span> <span class="main">{</span>fs<span class="main">=</span><span class="main">[</span><span class="entity">f</span><span class="main">]</span><span class="main">,</span> G<span class="main">=</span><span class="entity">G</span><span class="main">,</span> R<span class="main">=</span><span class="entity">R</span><span class="main">,</span> cases<span class="main">=</span><span class="entity">complete_thm</span><span class="main">,</span>
          psimps<span class="main">=</span><span class="entity">psimps</span><span class="main">,</span> simple_pinducts<span class="main">=</span><span class="main">[</span><span class="entity">simple_pinduct</span><span class="main">]</span><span class="main">,</span>
          termination<span class="main">=</span><span class="entity">total_intro</span><span class="main">,</span> domintros<span class="main">=</span><span class="entity">dom_intros</span><span class="main">,</span> eqvts<span class="main">=</span><span class="main">[</span><span class="entity">f_eqvt</span><span class="main">]</span><span class="main">}</span>
      <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="entity">G</span><span class="main">,</span> <span class="entity">GIntro_thms</span><span class="main">,</span> <span class="entity">G_induct</span><span class="main">,</span> <span class="entity">goalstate</span><span class="main">,</span> <span class="entity">mk_partial_rules</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/nominal_mutual.ML">
<div class="head">
<h1>File ‹nominal_mutual.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*  Nominal Mutual Functions
    Author:  Christian Urban

    heavily based on the code of Alexander Krauss
    (code forked on 14 January 2011)

    Joachim Breitner helped with the auxiliary graph
    definitions (7 August 2012)

Mutual recursive nominal function definitions.
*)</span>


<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">NOMINAL_FUNCTION_MUTUAL</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> prepare_nominal_function_mutual <span class="main">:</span> <span class="entity">Nominal_Function_Common.nominal_function_config</span>
    <span class="main">-&gt;</span> string <span class="comment1">(* defname *)</span>
    <span class="main">-&gt;</span> <span class="main">(</span><span class="main">(</span>string * typ<span class="main">)</span> * mixfix<span class="main">)</span> list
    <span class="main">-&gt;</span> term list
    <span class="main">-&gt;</span> local_theory
    <span class="main">-&gt;</span> <span class="main">(</span><span class="main">(</span>thm <span class="comment1">(* goalstate *)</span>
        * <span class="main">(</span><span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> <span class="entity">Nominal_Function_Common.nominal_function_result</span><span class="main">)</span> <span class="comment1">(* proof continuation *)</span>
       <span class="main">)</span> * local_theory<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Nominal_Function_Mutual</span><span class="main">:</span> <span class="entity">NOMINAL_FUNCTION_MUTUAL</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword3"><span class="keyword">open</span></span> Function_Lib
<span class="keyword3"><span class="keyword">open</span></span> Function_Common
<span class="keyword3"><span class="keyword">open</span></span> Nominal_Function_Common

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">qgar</span> <span class="main">=</span> string * <span class="main">(</span>string * typ<span class="main">)</span> list * term list * term list * term

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">mutual_part</span> <span class="main">=</span> <span class="entity">MutualPart</span> <span class="keyword2"><span class="keyword">of</span></span>
 <span class="main">{</span>i <span class="main">:</span> int<span class="main">,</span>
  i' <span class="main">:</span> int<span class="main">,</span>
  fvar <span class="main">:</span> string * typ<span class="main">,</span>
  cargTs<span class="main">:</span> typ list<span class="main">,</span>
  f_def<span class="main">:</span> term<span class="main">,</span>
  f<span class="main">:</span> term option<span class="main">,</span>
  f_defthm <span class="main">:</span> thm option<span class="main">}</span>

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">mutual_info</span> <span class="main">=</span> <span class="entity">Mutual</span> <span class="keyword2"><span class="keyword">of</span></span>
 <span class="main">{</span>n <span class="main">:</span> int<span class="main">,</span>
  n' <span class="main">:</span> int<span class="main">,</span>
  fsum_var <span class="main">:</span> string * typ<span class="main">,</span>

  ST<span class="main">:</span> typ<span class="main">,</span>
  RST<span class="main">:</span> typ<span class="main">,</span>

  parts<span class="main">:</span> mutual_part list<span class="main">,</span>
  fqgars<span class="main">:</span> qgar list<span class="main">,</span>
  qglrs<span class="main">:</span> <span class="main">(</span><span class="main">(</span>string * typ<span class="main">)</span> list * term list * term * term<span class="main">)</span> list<span class="main">,</span>

  fsum <span class="main">:</span> term option<span class="main">}</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mutual_induct_Pnames</span> <span class="entity">n</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">n</span> &lt; <span class="inner_numeral">5</span> <span class="keyword2"><span class="keyword">then</span></span> fst <span class="main">(</span>chop <span class="entity">n</span> <span class="main">[</span><span class="inner_quoted">"P"</span><span class="main">,</span><span class="inner_quoted">"Q"</span><span class="main">,</span><span class="inner_quoted">"R"</span><span class="main">,</span><span class="inner_quoted">"S"</span><span class="main">]</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">else</span></span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">i</span> <span class="main">=&gt;</span> <span class="inner_quoted">"P"</span> ^ string_of_int <span class="entity">i</span><span class="main">)</span> <span class="main">(</span><span class="inner_numeral">1</span> upto <span class="entity">n</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_part</span> <span class="entity">fname</span> <span class="main">=</span>
  the o find_first <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">MutualPart</span> <span class="main">{</span>fvar<span class="main">=</span><span class="main">(</span><span class="entity">n</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">n</span> <span class="main">=</span> <span class="entity">fname</span><span class="main">)</span>

<span class="comment1">(* FIXME *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_prod_abs</span> <span class="entity">e</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">bTs</span> <span class="main">=</span> rev <span class="main">(</span>map snd <span class="entity">e</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">T1</span> <span class="main">=</span> fastype_of1 <span class="main">(</span><span class="entity">bTs</span><span class="main">,</span> <span class="entity">t1</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">T2</span> <span class="main">=</span> fastype_of1 <span class="main">(</span><span class="entity">bTs</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">HOLogic.pair_const</span> <span class="entity">T1</span> <span class="entity">T2</span> $ <span class="entity">t1</span> $ <span class="entity">t2</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">analyze_eqs</span> <span class="entity">ctxt</span> <span class="entity">defname</span> <span class="entity">fs</span> <span class="entity">eqs</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">num</span> <span class="main">=</span> length <span class="entity">fs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fqgars</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">split_def</span> <span class="entity">ctxt</span> <span class="main">(</span>K true<span class="main">)</span><span class="main">)</span> <span class="entity">eqs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arity_of</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">fname</span><span class="main">,</span><span class="main">_</span><span class="main">,</span><span class="main">_</span><span class="main">,</span><span class="entity">args</span><span class="main">,</span><span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">fname</span><span class="main">,</span> length <span class="entity">args</span><span class="main">)</span><span class="main">)</span> <span class="entity">fqgars</span>
      |&gt; AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> #&gt; the

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">curried_types</span> <span class="main">(</span><span class="entity">fname</span><span class="main">,</span> <span class="entity">fT</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">caTs</span><span class="main">,</span> <span class="entity">uaTs</span><span class="main">)</span> <span class="main">=</span> chop <span class="main">(</span><span class="entity">arity_of</span> <span class="entity">fname</span><span class="main">)</span> <span class="main">(</span>binder_types <span class="entity">fT</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="entity">caTs</span><span class="main">,</span> <span class="entity">uaTs</span> ---&gt; body_type <span class="entity">fT</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">caTss</span><span class="main">,</span> <span class="entity">resultTs</span><span class="main">)</span> <span class="main">=</span> split_list <span class="main">(</span>map <span class="entity">curried_types</span> <span class="entity">fs</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">argTs</span> <span class="main">=</span> map <span class="main">(</span>foldr1 <span class="entity">HOLogic.mk_prodT</span><span class="main">)</span> <span class="entity">caTss</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dresultTs</span> <span class="main">=</span> distinct <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">resultTs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">n'</span> <span class="main">=</span> length <span class="entity">dresultTs</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">RST</span> <span class="main">=</span> Balanced_Tree.make <span class="main">(</span>uncurry <span class="entity">Sum_Tree.mk_sumT</span><span class="main">)</span> <span class="entity">dresultTs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ST</span> <span class="main">=</span> Balanced_Tree.make <span class="main">(</span>uncurry <span class="entity">Sum_Tree.mk_sumT</span><span class="main">)</span> <span class="entity">argTs</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fsum_type</span> <span class="main">=</span> <span class="entity">ST</span> --&gt; <span class="entity">RST</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">[</span><span class="entity">fsum_var_name</span><span class="main">]</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> Variable.add_fixes <span class="main">[</span> <span class="entity">defname</span> ^ <span class="inner_quoted">"_sum"</span> <span class="main">]</span> <span class="entity">ctxt</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fsum_var</span> <span class="main">=</span> <span class="main">(</span><span class="entity">fsum_var_name</span><span class="main">,</span> <span class="entity">fsum_type</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">define</span> <span class="main">(</span><span class="entity">fvar</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">(</span><span class="entity">n</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="entity">caTs</span> <span class="entity">resultT</span> <span class="entity">i</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vars</span> <span class="main">=</span> map_index <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">j</span><span class="main">,</span><span class="entity">T</span><span class="main">)</span> <span class="main">=&gt;</span> Free <span class="main">(</span><span class="inner_quoted">"x"</span> ^ string_of_int <span class="entity">j</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span> <span class="entity">caTs</span> <span class="comment1">(* FIXME: Bind xs properly *)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">i'</span> <span class="main">=</span> find_index <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">Ta</span> <span class="main">=&gt;</span> <span class="entity">Ta</span> <span class="main">=</span> <span class="entity">resultT</span><span class="main">)</span> <span class="entity">dresultTs</span> + <span class="inner_numeral">1</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">f_exp</span> <span class="main">=</span> <span class="entity">Sum_Tree.mk_proj</span> <span class="entity">RST</span> <span class="entity">n'</span> <span class="entity">i'</span> <span class="main">(</span>Free <span class="entity">fsum_var</span> $ <span class="entity">Sum_Tree.mk_inj</span> <span class="entity">ST</span> <span class="entity">num</span> <span class="entity">i</span> <span class="main">(</span>foldr1 <span class="entity">HOLogic.mk_prod</span> <span class="entity">vars</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">def</span> <span class="main">=</span> Term.abstract_over <span class="main">(</span>Free <span class="entity">fsum_var</span><span class="main">,</span> fold_rev lambda <span class="entity">vars</span> <span class="entity">f_exp</span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rew</span> <span class="main">=</span> <span class="main">(</span><span class="entity">n</span><span class="main">,</span> fold_rev lambda <span class="entity">vars</span> <span class="entity">f_exp</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="entity">MutualPart</span> <span class="main">{</span>i<span class="main">=</span><span class="entity">i</span><span class="main">,</span> i'<span class="main">=</span><span class="entity">i'</span><span class="main">,</span> fvar<span class="main">=</span><span class="entity">fvar</span><span class="main">,</span>cargTs<span class="main">=</span><span class="entity">caTs</span><span class="main">,</span>f_def<span class="main">=</span><span class="entity">def</span><span class="main">,</span>f<span class="main">=</span>NONE<span class="main">,</span>f_defthm<span class="main">=</span>NONE<span class="main">}</span><span class="main">,</span> <span class="entity">rew</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">parts</span><span class="main">,</span> <span class="entity">rews</span><span class="main">)</span> <span class="main">=</span> split_list <span class="main">(</span><span class="entity">map4</span> <span class="entity">define</span> <span class="entity">fs</span> <span class="entity">caTss</span> <span class="entity">resultTs</span> <span class="main">(</span><span class="inner_numeral">1</span> upto <span class="entity">num</span><span class="main">)</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">convert_eqs</span> <span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="entity">qs</span><span class="main">,</span> <span class="entity">gs</span><span class="main">,</span> <span class="entity">args</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">MutualPart</span> <span class="main">{</span><span class="entity">i</span><span class="main">,</span> <span class="entity">i'</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">get_part</span> <span class="entity">f</span> <span class="entity">parts</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs'</span> <span class="main">=</span> <span class="entity">rhs</span>
             |&gt; map_aterms <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">as</span></span> Free <span class="main">(</span><span class="entity">n</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> the_default <span class="entity">t</span> <span class="main">(</span>AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">rews</span> <span class="entity">n</span><span class="main">)</span> <span class="main">|</span> <span class="entity">t</span> <span class="main">=&gt;</span> <span class="entity">t</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="entity">qs</span><span class="main">,</span> <span class="entity">gs</span><span class="main">,</span> <span class="entity">Sum_Tree.mk_inj</span> <span class="entity">ST</span> <span class="entity">num</span> <span class="entity">i</span> <span class="main">(</span>foldr1 <span class="main">(</span><span class="entity">mk_prod_abs</span> <span class="entity">qs</span><span class="main">)</span> <span class="entity">args</span><span class="main">)</span><span class="main">,</span>
         Envir.beta_norm <span class="main">(</span><span class="entity">Sum_Tree.mk_inj</span> <span class="entity">RST</span> <span class="entity">n'</span> <span class="entity">i'</span> <span class="entity">rhs'</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">qglrs</span> <span class="main">=</span> map <span class="entity">convert_eqs</span> <span class="entity">fqgars</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">Mutual</span> <span class="main">{</span>n<span class="main">=</span><span class="entity">num</span><span class="main">,</span> n'<span class="main">=</span><span class="entity">n'</span><span class="main">,</span> fsum_var<span class="main">=</span><span class="entity">fsum_var</span><span class="main">,</span> ST<span class="main">=</span><span class="entity">ST</span><span class="main">,</span> RST<span class="main">=</span><span class="entity">RST</span><span class="main">,</span>
      parts<span class="main">=</span><span class="entity">parts</span><span class="main">,</span> fqgars<span class="main">=</span><span class="entity">fqgars</span><span class="main">,</span> qglrs<span class="main">=</span><span class="entity">qglrs</span><span class="main">,</span> fsum<span class="main">=</span>NONE<span class="main">}</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">define_projections</span> <span class="entity">fixes</span> <span class="entity">mutual</span> <span class="entity">fsum</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">def</span> <span class="main">(</span><span class="main">(</span><span class="entity">MutualPart</span> <span class="main">{</span>i<span class="main">=</span><span class="entity">i</span><span class="main">,</span> i'<span class="main">=</span><span class="entity">i'</span><span class="main">,</span> fvar<span class="main">=</span><span class="main">(</span><span class="entity">fname</span><span class="main">,</span> <span class="entity">fT</span><span class="main">)</span><span class="main">,</span> <span class="entity">cargTs</span><span class="main">,</span> <span class="entity">f_def</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">mixfix</span><span class="main">)</span><span class="main">)</span> <span class="entity">lthy</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">f_defthm</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span>
          Local_Theory.define
            <span class="main">(</span><span class="main">(</span>Binding.name <span class="entity">fname</span><span class="main">,</span> <span class="entity">mixfix</span><span class="main">)</span><span class="main">,</span>
              <span class="main">(</span><span class="main">(</span>Binding.concealed <span class="main">(</span>Binding.name <span class="main">(</span><span class="entity">fname</span> ^ <span class="inner_quoted">"_def"</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
              Term.subst_bound <span class="main">(</span><span class="entity">fsum</span><span class="main">,</span> <span class="entity">f_def</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">lthy</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="entity">MutualPart</span> <span class="main">{</span>i<span class="main">=</span><span class="entity">i</span><span class="main">,</span> i'<span class="main">=</span><span class="entity">i'</span><span class="main">,</span> fvar<span class="main">=</span><span class="main">(</span><span class="entity">fname</span><span class="main">,</span> <span class="entity">fT</span><span class="main">)</span><span class="main">,</span> cargTs<span class="main">=</span><span class="entity">cargTs</span><span class="main">,</span> f_def<span class="main">=</span><span class="entity">f_def</span><span class="main">,</span>
           f<span class="main">=</span>SOME <span class="entity">f</span><span class="main">,</span> f_defthm<span class="main">=</span>SOME <span class="entity">f_defthm</span> <span class="main">}</span><span class="main">,</span>
         <span class="entity">lthy'</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Mutual</span> <span class="main">{</span> <span class="entity">n</span><span class="main">,</span> <span class="entity">n'</span><span class="main">,</span> <span class="entity">fsum_var</span><span class="main">,</span> <span class="entity">ST</span><span class="main">,</span> <span class="entity">RST</span><span class="main">,</span> <span class="entity">parts</span><span class="main">,</span> <span class="entity">fqgars</span><span class="main">,</span> <span class="entity">qglrs</span><span class="main">,</span> <span class="main">...</span> <span class="main">}</span> <span class="main">=</span> <span class="entity">mutual</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">parts'</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span> fold_map <span class="entity">def</span> <span class="main">(</span><span class="entity">parts</span> ~~ <span class="entity">fixes</span><span class="main">)</span> <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="entity">Mutual</span> <span class="main">{</span> n<span class="main">=</span><span class="entity">n</span><span class="main">,</span> n'<span class="main">=</span><span class="entity">n'</span><span class="main">,</span> fsum_var<span class="main">=</span><span class="entity">fsum_var</span><span class="main">,</span> ST<span class="main">=</span><span class="entity">ST</span><span class="main">,</span> RST<span class="main">=</span><span class="entity">RST</span><span class="main">,</span> parts<span class="main">=</span><span class="entity">parts'</span><span class="main">,</span>
       fqgars<span class="main">=</span><span class="entity">fqgars</span><span class="main">,</span> qglrs<span class="main">=</span><span class="entity">qglrs</span><span class="main">,</span> fsum<span class="main">=</span>SOME <span class="entity">fsum</span> <span class="main">}</span><span class="main">,</span>
     <span class="entity">lthy'</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">in_context</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="entity">pre_qs</span><span class="main">,</span> <span class="entity">pre_gs</span><span class="main">,</span> <span class="entity">pre_args</span><span class="main">,</span> <span class="entity">pre_rhs</span><span class="main">)</span> <span class="entity">F</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">oqnames</span> <span class="main">=</span> map fst <span class="entity">pre_qs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">qs</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> Variable.variant_fixes <span class="entity">oqnames</span> <span class="entity">ctxt</span>
      |&gt;&gt; map2 <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">n</span> <span class="main">=&gt;</span> Free <span class="main">(</span><span class="entity">n</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span> <span class="entity">pre_qs</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">inst</span> <span class="entity">t</span> <span class="main">=</span> subst_bounds <span class="main">(</span>rev <span class="entity">qs</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">gs</span> <span class="main">=</span> map <span class="entity">inst</span> <span class="entity">pre_gs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> map <span class="entity">inst</span> <span class="entity">pre_args</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> <span class="entity">inst</span> <span class="entity">pre_rhs</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cqs</span> <span class="main">=</span> map <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">qs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ags</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> fold_map Thm.assume_hyps <span class="main">(</span>map <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">gs</span><span class="main">)</span> <span class="entity">ctxt</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">import</span> <span class="main">=</span> fold Thm.forall_elim <span class="entity">cqs</span>
      #&gt; fold Thm.elim_implies <span class="entity">ags</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">export</span> <span class="main">=</span> fold_rev <span class="main">(</span>Thm.implies_intr o Thm.cprop_of<span class="main">)</span> <span class="entity">ags</span>
      #&gt; fold_rev <span class="entity">forall_intr_rename</span> <span class="main">(</span><span class="entity">oqnames</span> ~~ <span class="entity">cqs</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">F</span> <span class="entity">ctxt'</span> <span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="entity">qs</span><span class="main">,</span> <span class="entity">gs</span><span class="main">,</span> <span class="entity">args</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="entity">import</span> <span class="entity">export</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">recover_mutual_psimp</span> <span class="entity">all_orig_fdefs</span> <span class="entity">parts</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">fname</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">args</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span>
  <span class="entity">import</span> <span class="main">(</span><span class="entity">export</span> <span class="main">:</span> thm <span class="main">-&gt;</span> thm<span class="main">)</span> <span class="entity">sum_psimp_eq</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">MutualPart</span> <span class="main">{</span>f<span class="main">=</span>SOME <span class="entity">f</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> <span class="entity">get_part</span> <span class="entity">fname</span> <span class="entity">parts</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">psimp</span> <span class="main">=</span> <span class="entity">import</span> <span class="entity">sum_psimp_eq</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">simp</span><span class="main">,</span> <span class="entity">restore_cond</span><span class="main">)</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">case</span></span> cprems_of <span class="entity">psimp</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">(</span><span class="entity">psimp</span><span class="main">,</span> I<span class="main">)</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span>
      <span class="main">|</span> <span class="main">[</span><span class="entity">cond</span><span class="main">]</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">asm</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> Thm.assume_hyps <span class="entity">cond</span> <span class="entity">ctxt</span>
          <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="main">(</span>Thm.implies_elim <span class="entity">psimp</span> <span class="entity">asm</span><span class="main">,</span> Thm.implies_intr <span class="entity">cond</span><span class="main">)</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> General.Fail <span class="inner_quoted">"Too many conditions"</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Goal.prove <span class="entity">ctxt'</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span>
      <span class="main">(</span><span class="entity">HOLogic.Trueprop</span> $ <span class="entity">HOLogic.mk_eq</span> <span class="main">(</span>list_comb <span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span><span class="main">)</span>
      <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">(</span>Local_Defs.unfold_tac <span class="entity">ctxt'</span> <span class="entity">all_orig_fdefs</span><span class="main">)</span>
         THEN <span class="entity">EqSubst.eqsubst_tac</span> <span class="entity">ctxt'</span> <span class="main">[</span><span class="inner_numeral">0</span><span class="main">]</span> <span class="main">[</span><span class="entity">simp</span><span class="main">]</span> <span class="inner_numeral">1</span>
         THEN <span class="main">(</span><span class="entity">simp_tac</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="inner_numeral">1</span><span class="main">)</span>
    |&gt; <span class="entity">restore_cond</span>
    |&gt; <span class="entity">export</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inl_perm</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">lemma</span> <span class="quoted">"<span class="free">x</span> <span class="main">=</span> Inl <span class="free">y</span> <span class="main">==&gt;</span> projl <span class="main">(</span>permute <span class="free">p</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> permute <span class="free">p</span> <span class="main">(</span>projl <span class="free">x</span><span class="main">)</span>"</span> <span class="keyword1"><span class="keyword">by</span></span> <span class="operator">simp</span><span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inr_perm</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">lemma</span> <span class="quoted">"<span class="free">x</span> <span class="main">=</span> Inr <span class="free">y</span> <span class="main">==&gt;</span> projr <span class="main">(</span>permute <span class="free">p</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> permute <span class="free">p</span> <span class="main">(</span>projr <span class="free">x</span><span class="main">)</span>"</span> <span class="keyword1"><span class="keyword">by</span></span> <span class="operator">simp</span><span class="antiquote">}</span></span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">recover_mutual_eqvt</span> <span class="entity">eqvt_thm</span> <span class="entity">all_orig_fdefs</span> <span class="entity">parts</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">fname</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">args</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span>
  <span class="entity">import</span> <span class="main">(</span><span class="entity">export</span> <span class="main">:</span> thm <span class="main">-&gt;</span> thm<span class="main">)</span> <span class="entity">sum_psimp_eq</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">MutualPart</span> <span class="main">{</span>f<span class="main">=</span>SOME <span class="entity">f</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> <span class="entity">get_part</span> <span class="entity">fname</span> <span class="entity">parts</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">psimp</span> <span class="main">=</span> <span class="entity">import</span> <span class="entity">sum_psimp_eq</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">cond</span><span class="main">,</span> <span class="entity">simp</span><span class="main">,</span> <span class="entity">restore_cond</span><span class="main">)</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">case</span></span> cprems_of <span class="entity">psimp</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">psimp</span><span class="main">,</span> I<span class="main">)</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span>
      <span class="main">|</span> <span class="main">[</span><span class="entity">cond</span><span class="main">]</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">asm</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> Thm.assume_hyps <span class="entity">cond</span> <span class="entity">ctxt</span>
          <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="main">(</span><span class="main">[</span><span class="entity">asm</span><span class="main">]</span><span class="main">,</span> Thm.implies_elim <span class="entity">psimp</span> <span class="entity">asm</span><span class="main">,</span> Thm.implies_intr <span class="entity">cond</span><span class="main">)</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> General.Fail <span class="inner_quoted">"Too many conditions"</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">[</span><span class="entity">p</span><span class="main">]</span><span class="main">,</span> <span class="entity">ctxt''</span><span class="main">)</span> <span class="main">=</span> <span class="entity">ctxt'</span>
      |&gt; fold Variable.declare_term <span class="entity">args</span>
      |&gt; Variable.variant_fixes <span class="main">[</span><span class="inner_quoted">"p"</span><span class="main">]</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">p</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">p</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">perm</span><span class="antiquote">}</span></span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simpset</span> <span class="main">=</span>
      put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt''</span> addsimps
      <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> permute_sum.simps<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> Pair_eqvt<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> sum.sel<span class="antiquote">}</span></span></span> @
      <span class="main">[</span><span class="main">(</span><span class="entity">cond</span> MRS <span class="entity">eqvt_thm</span><span class="main">)</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> sym<span class="antiquote">}</span></span></span><span class="main">]</span> @
      <span class="main">[</span><span class="entity">inl_perm</span><span class="main">,</span> <span class="entity">inr_perm</span><span class="main">,</span> <span class="entity">simp</span><span class="main">]</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goal_lhs</span> <span class="main">=</span> <span class="entity">mk_perm</span> <span class="entity">p</span> <span class="main">(</span>list_comb <span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goal_rhs</span> <span class="main">=</span> list_comb <span class="main">(</span><span class="entity">f</span><span class="main">,</span> map <span class="main">(</span><span class="entity">mk_perm</span> <span class="entity">p</span><span class="main">)</span> <span class="entity">args</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Goal.prove <span class="entity">ctxt''</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="entity">HOLogic.Trueprop</span> $ <span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">goal_lhs</span><span class="main">,</span> <span class="entity">goal_rhs</span><span class="main">)</span><span class="main">)</span>
      <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> Local_Defs.unfold_tac <span class="entity">ctxt''</span> <span class="entity">all_orig_fdefs</span>
         THEN <span class="main">(</span><span class="entity">asm_full_simp_tac</span> <span class="entity">simpset</span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span>
    |&gt; singleton <span class="main">(</span>Proof_Context.export <span class="entity">ctxt''</span> <span class="entity">ctxt</span><span class="main">)</span>
    |&gt; <span class="entity">restore_cond</span>
    |&gt; <span class="entity">export</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_applied_form</span> <span class="entity">ctxt</span> <span class="entity">caTs</span> <span class="entity">thm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xs</span> <span class="main">=</span> map_index <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span><span class="entity">T</span><span class="main">)</span> <span class="main">=&gt;</span> Thm.cterm_of <span class="entity">ctxt</span> <span class="main">(</span>Free <span class="main">(</span><span class="inner_quoted">"x"</span> ^ string_of_int <span class="entity">i</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">caTs</span> <span class="comment1">(* FIXME: Bind xs properly *)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    fold <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">thm</span> <span class="main">=&gt;</span> Thm.combination <span class="entity">thm</span> <span class="main">(</span>Thm.reflexive <span class="entity">x</span><span class="main">)</span><span class="main">)</span> <span class="entity">xs</span> <span class="entity">thm</span>
    |&gt; Conv.fconv_rule <span class="main">(</span>Thm.beta_conversion true<span class="main">)</span>
    |&gt; fold_rev Thm.forall_intr <span class="entity">xs</span>
    |&gt; Thm.forall_elim_vars <span class="inner_numeral">0</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mutual_induct_rules</span> <span class="entity">ctxt</span> <span class="entity">induct</span> <span class="entity">all_f_defs</span> <span class="main">(</span><span class="entity">Mutual</span> <span class="main">{</span><span class="entity">n</span><span class="main">,</span> <span class="entity">ST</span><span class="main">,</span> <span class="entity">parts</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cert</span> <span class="main">=</span> Thm.cterm_of <span class="entity">ctxt</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">newPs</span> <span class="main">=</span>
      map2 <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">Pname</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">MutualPart</span> <span class="main">{</span><span class="entity">cargTs</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
          Free <span class="main">(</span><span class="entity">Pname</span><span class="main">,</span> <span class="entity">cargTs</span> ---&gt; <span class="entity">HOLogic.boolT</span><span class="main">)</span><span class="main">)</span>
        <span class="main">(</span><span class="entity">mutual_induct_Pnames</span> <span class="main">(</span>length <span class="entity">parts</span><span class="main">)</span><span class="main">)</span> <span class="entity">parts</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_P</span> <span class="main">(</span><span class="entity">MutualPart</span> <span class="main">{</span><span class="entity">cargTs</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="entity">P</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">avars</span> <span class="main">=</span> map_index <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span><span class="entity">T</span><span class="main">)</span> <span class="main">=&gt;</span> Var <span class="main">(</span><span class="main">(</span><span class="inner_quoted">"a"</span><span class="main">,</span> <span class="entity">i</span><span class="main">)</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span> <span class="entity">cargTs</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">atup</span> <span class="main">=</span> foldr1 <span class="entity">HOLogic.mk_prod</span> <span class="entity">avars</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="entity">HOLogic.tupled_lambda</span> <span class="entity">atup</span> <span class="main">(</span>list_comb <span class="main">(</span><span class="entity">P</span><span class="main">,</span> <span class="entity">avars</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Ps</span> <span class="main">=</span> map2 <span class="entity">mk_P</span> <span class="entity">parts</span> <span class="entity">newPs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">case_exp</span> <span class="main">=</span> <span class="entity">Sum_Tree.mk_sumcases</span> <span class="entity">HOLogic.boolT</span> <span class="entity">Ps</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">induct_inst</span> <span class="main">=</span>
      Thm.forall_elim <span class="main">(</span><span class="entity">cert</span> <span class="entity">case_exp</span><span class="main">)</span> <span class="entity">induct</span>
      |&gt; <span class="entity">full_simplify</span> <span class="main">(</span>put_simpset <span class="entity">Sum_Tree.sumcase_split_ss</span> <span class="entity">ctxt</span><span class="main">)</span>
      |&gt; <span class="entity">full_simplify</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span> addsimps <span class="entity">all_f_defs</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">project</span> <span class="entity">rule</span> <span class="main">(</span><span class="entity">MutualPart</span> <span class="main">{</span><span class="entity">cargTs</span><span class="main">,</span> <span class="entity">i</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="entity">k</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">afs</span> <span class="main">=</span> map_index <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">j</span><span class="main">,</span><span class="entity">T</span><span class="main">)</span> <span class="main">=&gt;</span> Free <span class="main">(</span><span class="inner_quoted">"a"</span> ^ string_of_int <span class="main">(</span><span class="entity">j</span> + <span class="entity">k</span><span class="main">)</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span> <span class="entity">cargTs</span> <span class="comment1">(* FIXME! *)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inj</span> <span class="main">=</span> <span class="entity">Sum_Tree.mk_inj</span> <span class="entity">ST</span> <span class="entity">n</span> <span class="entity">i</span> <span class="main">(</span>foldr1 <span class="entity">HOLogic.mk_prod</span> <span class="entity">afs</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="entity">rule</span>
         |&gt; Thm.forall_elim <span class="main">(</span><span class="entity">cert</span> <span class="entity">inj</span><span class="main">)</span>
         |&gt; <span class="entity">full_simplify</span> <span class="main">(</span>put_simpset <span class="entity">Sum_Tree.sumcase_split_ss</span> <span class="entity">ctxt</span><span class="main">)</span>
         |&gt; fold_rev <span class="main">(</span>Thm.forall_intr o <span class="entity">cert</span><span class="main">)</span> <span class="main">(</span><span class="entity">afs</span> @ <span class="entity">newPs</span><span class="main">)</span><span class="main">,</span>
         <span class="entity">k</span> + length <span class="entity">cargTs</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">in</span></span>
    fst <span class="main">(</span>fold_map <span class="main">(</span><span class="entity">project</span> <span class="entity">induct_inst</span><span class="main">)</span> <span class="entity">parts</span> <span class="inner_numeral">0</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">forall_elim</span> <span class="entity">s</span> <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Pure.all<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ Abs <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> subst_bound <span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">forall_elim</span> <span class="main">_</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">t</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">forall_elim_list</span> <span class="main">=</span> fold <span class="entity">forall_elim</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">split_conj_thm</span> <span class="entity">th</span> <span class="main">=</span>
  <span class="main">(</span><span class="entity">split_conj_thm</span> <span class="main">(</span><span class="entity">th</span> RS <span class="entity">conjunct1</span><span class="main">)</span><span class="main">)</span> @ <span class="main">(</span><span class="entity">split_conj_thm</span> <span class="main">(</span><span class="entity">th</span> RS <span class="entity">conjunct2</span><span class="main">)</span><span class="main">)</span> <span class="keyword3"><span class="keyword">handle</span></span> THM <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="entity">th</span><span class="main">]</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_eqvt</span> <span class="entity">ctxt</span> <span class="entity">fs</span> <span class="entity">argTss</span> <span class="entity">eqvts_thms</span> <span class="entity">induct_thms</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">aux</span> <span class="entity">argTs</span> <span class="entity">s</span> <span class="main">=</span> <span class="entity">argTs</span>
      |&gt; map <span class="main">(</span>pair <span class="entity">s</span><span class="main">)</span>
      |&gt; Variable.variant_frees <span class="entity">ctxt</span> <span class="entity">fs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">argss'</span> <span class="main">=</span> map2 <span class="entity">aux</span> <span class="entity">argTss</span> <span class="main">(</span>Name.invent <span class="main">(</span>Variable.names_of <span class="entity">ctxt</span><span class="main">)</span> <span class="inner_quoted">""</span> <span class="main">(</span>length <span class="entity">fs</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">argss</span> <span class="main">=</span> <span class="main">(</span>map o map<span class="main">)</span> Free <span class="entity">argss'</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg_namess</span> <span class="main">=</span> <span class="main">(</span>map o map<span class="main">)</span> fst <span class="entity">argss'</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">insts</span> <span class="main">=</span> <span class="main">(</span>map o map<span class="main">)</span> SOME <span class="entity">arg_namess</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">[</span><span class="entity">p_name</span><span class="main">]</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> Variable.variant_fixes <span class="main">[</span><span class="inner_quoted">"p"</span><span class="main">]</span> <span class="entity">ctxt</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">p</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">p_name</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">perm</span><span class="antiquote">}</span></span><span class="main">)</span>

    <span class="comment1">(* extracting the acc-premises from the induction theorems *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">acc_prems</span> <span class="main">=</span>
     map Thm.prop_of <span class="entity">induct_thms</span>
     |&gt; map2 <span class="entity">forall_elim_list</span> <span class="entity">argss</span>
     |&gt; map <span class="main">(</span>strip_qnt_body <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Pure.all<span class="antiquote">}</span></span><span class="main">)</span>
     |&gt; map <span class="main">(</span>curry Logic.nth_prem <span class="inner_numeral">1</span><span class="main">)</span>
     |&gt; map <span class="entity">HOLogic.dest_Trueprop</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_goal</span> <span class="entity">acc_prem</span> <span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goal_lhs</span> <span class="main">=</span> <span class="entity">mk_perm</span> <span class="entity">p</span> <span class="main">(</span>list_comb <span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goal_rhs</span> <span class="main">=</span> list_comb <span class="main">(</span><span class="entity">f</span><span class="main">,</span> map <span class="main">(</span><span class="entity">mk_perm</span> <span class="entity">p</span><span class="main">)</span> <span class="entity">args</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="entity">HOLogic.mk_imp</span> <span class="main">(</span><span class="entity">acc_prem</span><span class="main">,</span> <span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">goal_lhs</span><span class="main">,</span> <span class="entity">goal_rhs</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goal</span> <span class="main">=</span> <span class="entity">fold_conj_balanced</span> <span class="main">(</span>map2 <span class="entity">mk_goal</span> <span class="entity">acc_prems</span> <span class="main">(</span><span class="entity">fs</span> ~~ <span class="entity">argss</span><span class="main">)</span><span class="main">)</span>
      |&gt; <span class="entity">HOLogic.mk_Trueprop</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">induct_thm</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">induct_thms</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">[</span><span class="entity">thm</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="entity">thm</span>
          |&gt; Variable.gen_all <span class="entity">ctxt'</span>
          |&gt; Thm.permute_prems <span class="inner_numeral">0</span> <span class="inner_numeral">1</span>
          |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">thm</span> <span class="main">=&gt;</span> <span class="entity">atomize_rule</span> <span class="entity">ctxt'</span> <span class="main">(</span>length <span class="main">(</span>Thm.prems_of <span class="entity">thm</span><span class="main">)</span> - <span class="inner_numeral">1</span><span class="main">)</span> <span class="entity">thm</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">thms</span> <span class="main">=&gt;</span> <span class="entity">thms</span>
          |&gt; map <span class="main">(</span>Variable.gen_all <span class="entity">ctxt'</span><span class="main">)</span>
          |&gt; map <span class="main">(</span>Rule_Cases.add_consumes <span class="inner_numeral">1</span><span class="main">)</span>
          |&gt; snd o Rule_Cases.strict_mutual_rule <span class="entity">ctxt'</span>
          |&gt; <span class="entity">atomize_concl</span> <span class="entity">ctxt'</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tac</span> <span class="entity">ctxt</span> <span class="entity">thm</span> <span class="main">=</span>
      resolve_tac <span class="entity">ctxt</span> <span class="main">[</span>Variable.gen_all <span class="entity">ctxt</span> <span class="entity">thm</span><span class="main">]</span>
        THEN_ALL_NEW assume_tac <span class="entity">ctxt</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Goal.prove <span class="entity">ctxt'</span> <span class="main">(</span>flat <span class="entity">arg_namess</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span> <span class="entity">goal</span>
      <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt''</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
        HEADGOAL <span class="main">(</span>DETERM o <span class="main">(</span>resolve_tac <span class="entity">ctxt''</span> <span class="main">[</span><span class="entity">induct_thm</span><span class="main">]</span><span class="main">)</span> THEN'
          RANGE <span class="main">(</span>map <span class="main">(</span><span class="entity">tac</span> <span class="entity">ctxt''</span><span class="main">)</span> <span class="entity">eqvts_thms</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    |&gt; singleton <span class="main">(</span>Proof_Context.export <span class="entity">ctxt'</span> <span class="entity">ctxt</span><span class="main">)</span>
    |&gt; <span class="entity">split_conj_thm</span>
    |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">th</span> <span class="main">=&gt;</span> <span class="entity">th</span> RS <span class="entity">mp</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_partial_rules_mutual</span> <span class="entity">ctxt</span> <span class="entity">inner_cont</span> <span class="main">(</span><span class="entity">m</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="entity">Mutual</span> <span class="main">{</span><span class="entity">parts</span><span class="main">,</span> <span class="entity">fqgars</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="entity">proof</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">result</span> <span class="main">=</span> <span class="entity">inner_cont</span> <span class="entity">proof</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">NominalFunctionResult</span> <span class="main">{</span><span class="entity">G</span><span class="main">,</span> <span class="entity">R</span><span class="main">,</span> <span class="entity">cases</span><span class="main">,</span> <span class="entity">psimps</span><span class="main">,</span> simple_pinducts<span class="main">=</span><span class="main">[</span><span class="entity">simple_pinduct</span><span class="main">]</span><span class="main">,</span>
      <span class="entity">termination</span><span class="main">,</span> <span class="entity">domintros</span><span class="main">,</span> eqvts<span class="main">=</span><span class="main">[</span><span class="entity">eqvt</span><span class="main">]</span><span class="main">,</span><span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">result</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">all_f_defs</span><span class="main">,</span> <span class="entity">fs</span><span class="main">)</span> <span class="main">=</span>
      map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">MutualPart</span> <span class="main">{</span>f_defthm <span class="main">=</span> SOME <span class="entity">f_def</span><span class="main">,</span> f <span class="main">=</span> SOME <span class="entity">f</span><span class="main">,</span> <span class="entity">cargTs</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
          <span class="main">(</span><span class="entity">mk_applied_form</span> <span class="entity">ctxt</span> <span class="entity">cargTs</span> <span class="main">(</span>Thm.symmetric <span class="entity">f_def</span><span class="main">)</span><span class="main">,</span> <span class="entity">f</span><span class="main">)</span><span class="main">)</span>
      <span class="entity">parts</span>
      |&gt; split_list

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_orig_fdefs</span> <span class="main">=</span>
      map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">MutualPart</span> <span class="main">{</span>f_defthm <span class="main">=</span> SOME <span class="entity">f_def</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span> <span class="entity">f_def</span><span class="main">)</span> <span class="entity">parts</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cargTss</span> <span class="main">=</span>
      map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">MutualPart</span> <span class="main">{</span>f <span class="main">=</span> SOME <span class="entity">f</span><span class="main">,</span> <span class="entity">cargTs</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span> <span class="entity">cargTs</span><span class="main">)</span> <span class="entity">parts</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_mpsimp</span> <span class="entity">fqgar</span> <span class="entity">sum_psimp</span> <span class="main">=</span>
      <span class="entity">in_context</span> <span class="entity">ctxt</span> <span class="entity">fqgar</span> <span class="main">(</span><span class="entity">recover_mutual_psimp</span> <span class="entity">all_orig_fdefs</span> <span class="entity">parts</span><span class="main">)</span> <span class="entity">sum_psimp</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_meqvts</span> <span class="entity">fqgar</span> <span class="entity">sum_psimp</span> <span class="main">=</span>
      <span class="entity">in_context</span> <span class="entity">ctxt</span> <span class="entity">fqgar</span> <span class="main">(</span><span class="entity">recover_mutual_eqvt</span> <span class="entity">eqvt</span> <span class="entity">all_orig_fdefs</span> <span class="entity">parts</span><span class="main">)</span> <span class="entity">sum_psimp</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rew_simpset</span> <span class="main">=</span> put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span> addsimps <span class="entity">all_f_defs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mpsimps</span> <span class="main">=</span> map2 <span class="entity">mk_mpsimp</span> <span class="entity">fqgars</span> <span class="entity">psimps</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">minducts</span> <span class="main">=</span> <span class="entity">mutual_induct_rules</span> <span class="entity">ctxt</span> <span class="entity">simple_pinduct</span> <span class="entity">all_f_defs</span> <span class="entity">m</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mtermination</span> <span class="main">=</span> <span class="entity">full_simplify</span> <span class="entity">rew_simpset</span> <span class="entity">termination</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mdomintros</span> <span class="main">=</span> Option.map <span class="main">(</span>map <span class="main">(</span><span class="entity">full_simplify</span> <span class="entity">rew_simpset</span><span class="main">)</span><span class="main">)</span> <span class="entity">domintros</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">meqvts</span> <span class="main">=</span> map2 <span class="entity">mk_meqvts</span> <span class="entity">fqgars</span> <span class="entity">psimps</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">meqvt_funs</span> <span class="main">=</span> <span class="entity">prove_eqvt</span> <span class="entity">ctxt</span> <span class="entity">fs</span> <span class="entity">cargTss</span> <span class="entity">meqvts</span> <span class="entity">minducts</span>
 <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">NominalFunctionResult</span> <span class="main">{</span> fs<span class="main">=</span><span class="entity">fs</span><span class="main">,</span> G<span class="main">=</span><span class="entity">G</span><span class="main">,</span> R<span class="main">=</span><span class="entity">R</span><span class="main">,</span>
      psimps<span class="main">=</span><span class="entity">mpsimps</span><span class="main">,</span> simple_pinducts<span class="main">=</span><span class="entity">minducts</span><span class="main">,</span>
      cases<span class="main">=</span><span class="entity">cases</span><span class="main">,</span> termination<span class="main">=</span><span class="entity">mtermination</span><span class="main">,</span>
      domintros<span class="main">=</span><span class="entity">mdomintros</span><span class="main">,</span> eqvts<span class="main">=</span><span class="entity">meqvt_funs</span> <span class="main">}</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* nominal *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">subst_all</span> <span class="entity">s</span> <span class="main">(</span><span class="entity">Q</span> $ Abs<span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vs</span> <span class="main">=</span> map Free <span class="main">(</span>Term.add_frees <span class="entity">s</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    fold Logic.all <span class="entity">vs</span> <span class="main">(</span>subst_bound <span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_comp_dummy</span> <span class="entity">t</span> <span class="entity">s</span> <span class="main">=</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> comp<span class="antiquote">}</span></span><span class="main">,</span> dummyT<span class="main">)</span> $ <span class="entity">t</span> $ <span class="entity">s</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">all</span> <span class="entity">v</span> <span class="entity">t</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">T</span> <span class="main">=</span> Term.fastype_of <span class="entity">v</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Logic.all_const <span class="entity">T</span> $ absdummy <span class="entity">T</span> <span class="main">(</span>abstract_over <span class="main">(</span><span class="entity">v</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* nominal *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prepare_nominal_function_mutual</span> <span class="entity">config</span> <span class="entity">defname</span> <span class="entity">fixes</span> <span class="entity">eqss</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mutual</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="entity">Mutual</span> <span class="main">{</span>fsum_var<span class="main">=</span><span class="main">(</span><span class="entity">n</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> <span class="entity">qglrs</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span>
      <span class="entity">analyze_eqs</span> <span class="entity">lthy</span> <span class="entity">defname</span> <span class="main">(</span>map fst <span class="entity">fixes</span><span class="main">)</span> <span class="main">(</span>map Envir.beta_eta_contract <span class="entity">eqss</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">fsum</span><span class="main">,</span> <span class="entity">G</span><span class="main">,</span> <span class="entity">GIntro_thms</span><span class="main">,</span> <span class="entity">G_induct</span><span class="main">,</span> <span class="entity">goalstate</span><span class="main">,</span> <span class="entity">cont</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">Nominal_Function_Core.prepare_nominal_function</span> <span class="entity">config</span> <span class="entity">defname</span> <span class="main">[</span><span class="main">(</span><span class="main">(</span><span class="entity">n</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> NoSyn<span class="main">)</span><span class="main">]</span> <span class="entity">qglrs</span> <span class="entity">lthy</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">mutual'</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="entity">Mutual</span> <span class="main">{</span><span class="entity">n'</span><span class="main">,</span> <span class="entity">parts</span><span class="main">,</span> <span class="entity">ST</span><span class="main">,</span> <span class="entity">RST</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">,</span> <span class="entity">lthy''</span><span class="main">)</span> <span class="main">=</span> <span class="entity">define_projections</span> <span class="entity">fixes</span> <span class="entity">mutual</span> <span class="entity">fsum</span> <span class="entity">lthy'</span>

    <span class="comment1">(* defining the auxiliary graph *)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_cases</span> <span class="main">(</span><span class="entity">MutualPart</span> <span class="main">{</span><span class="entity">i'</span><span class="main">,</span> <span class="entity">fvar</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">(</span><span class="entity">n</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">tys</span><span class="main">,</span> <span class="entity">ty</span><span class="main">)</span> <span class="main">=</span> strip_type <span class="entity">T</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fun_var</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">n</span> ^ <span class="inner_quoted">"_aux"</span><span class="main">,</span> <span class="entity">HOLogic.mk_tupleT</span> <span class="entity">tys</span> --&gt; <span class="entity">ty</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inj_fun</span> <span class="main">=</span> absdummy dummyT <span class="main">(</span><span class="entity">Sum_Tree.mk_inj</span> <span class="entity">RST</span> <span class="entity">n'</span> <span class="entity">i'</span> <span class="main">(</span>Bound <span class="inner_numeral">0</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        Syntax.check_term <span class="entity">lthy''</span> <span class="main">(</span><span class="entity">mk_comp_dummy</span> <span class="entity">inj_fun</span> <span class="entity">fun_var</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">case_sum_exp</span> <span class="main">=</span> map <span class="entity">mk_cases</span> <span class="entity">parts</span>
      |&gt; <span class="entity">Sum_Tree.mk_sumcases</span> <span class="entity">RST</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">G_name</span><span class="main">,</span> <span class="entity">G_type</span><span class="main">)</span> <span class="main">=</span> dest_Free <span class="entity">G</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">G_name_aux</span> <span class="main">=</span> <span class="entity">G_name</span> ^ <span class="inner_quoted">"_aux"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">subst</span> <span class="main">=</span> <span class="main">[</span><span class="main">(</span><span class="entity">G</span><span class="main">,</span> Free <span class="main">(</span><span class="entity">G_name_aux</span><span class="main">,</span> <span class="entity">G_type</span><span class="main">)</span><span class="main">)</span><span class="main">]</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">GIntros_aux</span> <span class="main">=</span> <span class="entity">GIntro_thms</span>
      |&gt; map Thm.prop_of
      |&gt; map <span class="main">(</span>Term.subst_free <span class="entity">subst</span><span class="main">)</span>
      |&gt; map <span class="main">(</span><span class="entity">subst_all</span> <span class="entity">case_sum_exp</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">G_aux</span><span class="main">,</span> <span class="entity">GIntro_aux_thms</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">G_aux_induct</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy'''</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">Nominal_Function_Core.inductive_def</span> <span class="main">(</span><span class="main">(</span>Binding.name <span class="entity">G_name_aux</span><span class="main">,</span> <span class="entity">G_type</span><span class="main">)</span><span class="main">,</span> NoSyn<span class="main">)</span> <span class="entity">GIntros_aux</span> <span class="entity">lthy''</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mutual_cont</span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="entity">mk_partial_rules_mutual</span> <span class="entity">lthy'''</span> <span class="main">(</span><span class="entity">cont</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">mutual'</span>

    <span class="comment1">(* proof of equivalence between graph and auxiliary graph *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">x</span> <span class="main">=</span> Var<span class="main">(</span><span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span> <span class="entity">ST</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">y</span> <span class="main">=</span> Var<span class="main">(</span><span class="main">(</span><span class="inner_quoted">"y"</span><span class="main">,</span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">,</span> <span class="entity">RST</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">G_aux_prem</span> <span class="main">=</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">G_aux</span> $ <span class="entity">x</span> $ <span class="entity">y</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">G_prem</span> <span class="main">=</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">G</span> $ <span class="entity">x</span> $ <span class="entity">y</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_inj_goal</span>  <span class="main">(</span><span class="entity">MutualPart</span> <span class="main">{</span><span class="entity">i'</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">injs</span> <span class="main">=</span> <span class="entity">Sum_Tree.mk_inj</span> <span class="entity">ST</span> <span class="entity">n'</span> <span class="entity">i'</span> <span class="main">(</span>Bound <span class="inner_numeral">0</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">projs</span> <span class="main">=</span> <span class="entity">y</span>
          |&gt; <span class="entity">Sum_Tree.mk_proj</span> <span class="entity">RST</span> <span class="entity">n'</span> <span class="entity">i'</span>
          |&gt; <span class="entity">Sum_Tree.mk_inj</span> <span class="entity">RST</span> <span class="entity">n'</span> <span class="entity">i'</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "All"<span class="antiquote">}</span></span><span class="main">,</span> dummyT<span class="main">)</span> $ absdummy dummyT
          <span class="main">(</span><span class="entity">HOLogic.mk_imp</span> <span class="main">(</span><span class="entity">HOLogic.mk_eq</span><span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">injs</span><span class="main">)</span><span class="main">,</span> <span class="entity">HOLogic.mk_eq</span><span class="main">(</span><span class="entity">projs</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goal_inj</span> <span class="main">=</span> Logic.mk_implies <span class="main">(</span><span class="entity">G_aux_prem</span><span class="main">,</span>
      <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">fold_conj</span> <span class="main">(</span>map <span class="entity">mk_inj_goal</span> <span class="entity">parts</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      |&gt; <span class="entity">all</span> <span class="entity">x</span> |&gt; <span class="entity">all</span> <span class="entity">y</span>
      |&gt; Syntax.check_term <span class="entity">lthy'''</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goal_iff1</span> <span class="main">=</span> Logic.mk_implies <span class="main">(</span><span class="entity">G_aux_prem</span><span class="main">,</span> <span class="entity">G_prem</span><span class="main">)</span>
      |&gt; <span class="entity">all</span> <span class="entity">x</span> |&gt; <span class="entity">all</span> <span class="entity">y</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goal_iff2</span> <span class="main">=</span> Logic.mk_implies <span class="main">(</span><span class="entity">G_prem</span><span class="main">,</span> <span class="entity">G_aux_prem</span><span class="main">)</span>
      |&gt; <span class="entity">all</span> <span class="entity">x</span> |&gt; <span class="entity">all</span> <span class="entity">y</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simp_thms</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> sum.sel sum.inject sum.case sum.distinct o_apply<span class="antiquote">}</span></span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simpset0</span> <span class="main">=</span> put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">lthy'''</span> addsimps <span class="entity">simp_thms</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simpset1</span> <span class="main">=</span> put_simpset <span class="entity">HOL_ss</span> <span class="entity">lthy'''</span> addsimps <span class="entity">simp_thms</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inj_thm</span> <span class="main">=</span> Goal.prove <span class="entity">lthy'''</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">goal_inj</span>
      <span class="main">(</span>K <span class="main">(</span>HEADGOAL <span class="main">(</span>DETERM o eresolve_tac <span class="entity">lthy'''</span> <span class="main">[</span><span class="entity">G_aux_induct</span><span class="main">]</span>
        THEN_ALL_NEW <span class="entity">asm_simp_tac</span> <span class="entity">simpset1</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">aux_tac</span> <span class="entity">thm</span> <span class="main">=</span>
      resolve_tac <span class="entity">lthy'''</span> <span class="main">[</span>Variable.gen_all <span class="entity">lthy'''</span> <span class="entity">thm</span><span class="main">]</span> THEN_ALL_NEW
      <span class="entity">asm_full_simp_tac</span> <span class="main">(</span><span class="entity">simpset1</span> addsimps <span class="main">[</span><span class="entity">inj_thm</span><span class="main">]</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">iff1_thm</span> <span class="main">=</span> Goal.prove <span class="entity">lthy'''</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">goal_iff1</span>
      <span class="main">(</span>K <span class="main">(</span>HEADGOAL <span class="main">(</span>DETERM o eresolve_tac <span class="entity">lthy'''</span> <span class="main">[</span><span class="entity">G_aux_induct</span><span class="main">]</span>
        THEN' RANGE <span class="main">(</span>map <span class="entity">aux_tac</span> <span class="entity">GIntro_thms</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      |&gt; Variable.gen_all <span class="entity">lthy'''</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">iff2_thm</span> <span class="main">=</span> Goal.prove <span class="entity">lthy'''</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">goal_iff2</span>
      <span class="main">(</span>K <span class="main">(</span>HEADGOAL <span class="main">(</span>DETERM o eresolve_tac <span class="entity">lthy'''</span> <span class="main">[</span><span class="entity">G_induct</span><span class="main">]</span> THEN' RANGE
        <span class="main">(</span>map <span class="main">(</span><span class="entity">aux_tac</span> o <span class="entity">simplify</span> <span class="entity">simpset0</span><span class="main">)</span> <span class="entity">GIntro_aux_thms</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      |&gt; Variable.gen_all <span class="entity">lthy'''</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">iff_thm</span> <span class="main">=</span> Goal.prove <span class="entity">lthy'''</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">G</span><span class="main">,</span> <span class="entity">G_aux</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      <span class="main">(</span>K <span class="main">(</span>HEADGOAL <span class="main">(</span>EVERY' <span class="main">(</span><span class="main">(</span>map <span class="main">(</span>resolve_tac <span class="entity">lthy'''</span> o single<span class="main">)</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> ext ext iffI<span class="antiquote">}</span></span></span><span class="main">)</span> @
        <span class="main">[</span>eresolve_tac <span class="entity">lthy'''</span> <span class="main">[</span><span class="entity">iff2_thm</span><span class="main">]</span><span class="main">,</span> eresolve_tac <span class="entity">lthy'''</span> <span class="main">[</span><span class="entity">iff1_thm</span><span class="main">]</span><span class="main">]</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tac</span> <span class="main">=</span> HEADGOAL <span class="main">(</span><span class="entity">simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">lthy'''</span> addsimps <span class="main">[</span><span class="entity">iff_thm</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goalstate'</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="main">(</span>SINGLE <span class="entity">tac</span><span class="main">)</span> <span class="entity">goalstate</span> <span class="keyword2"><span class="keyword">of</span></span>
        NONE <span class="main">=&gt;</span> error <span class="inner_quoted">"auxiliary equivalence proof failed"</span>
      <span class="main">|</span> SOME <span class="entity">st</span> <span class="main">=&gt;</span> <span class="entity">st</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="main">(</span><span class="entity">goalstate'</span><span class="main">,</span> <span class="entity">mutual_cont</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy'''</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/nominal_function.ML">
<div class="head">
<h1>File ‹nominal_function.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*  Nominal Mutual Functions
    Author:  Christian Urban

    heavily based on the code of Alexander Krauss
    (code forked on 14 January 2011)

Main entry points to the nominal function package.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">NOMINAL_FUNCTION</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">include</span></span> <span class="entity">NOMINAL_FUNCTION_DATA</span>

  <span class="keyword1"><span class="keyword">val</span></span> add_nominal_function<span class="main">:</span> <span class="main">(</span>binding * typ option * mixfix<span class="main">)</span> list <span class="main">-&gt;</span>
    <span class="entity">Specification.multi_specs</span> <span class="main">-&gt;</span>  <span class="entity">Nominal_Function_Common.nominal_function_config</span> <span class="main">-&gt;</span>
    <span class="main">(</span><span class="entity">Proof.context</span> <span class="main">-&gt;</span> tactic<span class="main">)</span> <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> <span class="entity">nominal_info</span> * local_theory

  <span class="keyword1"><span class="keyword">val</span></span> add_nominal_function_cmd<span class="main">:</span> <span class="main">(</span>binding * string option * mixfix<span class="main">)</span> list <span class="main">-&gt;</span>
    <span class="entity">Specification.multi_specs_cmd</span> <span class="main">-&gt;</span>  <span class="entity">Nominal_Function_Common.nominal_function_config</span> <span class="main">-&gt;</span>
    <span class="main">(</span><span class="entity">Proof.context</span> <span class="main">-&gt;</span> tactic<span class="main">)</span> <span class="main">-&gt;</span> bool <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> <span class="entity">nominal_info</span> * local_theory

  <span class="keyword1"><span class="keyword">val</span></span> nominal_function<span class="main">:</span> <span class="main">(</span>binding * typ option * mixfix<span class="main">)</span> list <span class="main">-&gt;</span>
    <span class="entity">Specification.multi_specs</span> <span class="main">-&gt;</span>  <span class="entity">Nominal_Function_Common.nominal_function_config</span> <span class="main">-&gt;</span>
    local_theory <span class="main">-&gt;</span> <span class="entity">Proof.state</span>

  <span class="keyword1"><span class="keyword">val</span></span> nominal_function_cmd<span class="main">:</span> <span class="main">(</span>binding * string option * mixfix<span class="main">)</span> list <span class="main">-&gt;</span>
    <span class="entity">Specification.multi_specs_cmd</span> <span class="main">-&gt;</span>  <span class="entity">Nominal_Function_Common.nominal_function_config</span> <span class="main">-&gt;</span>
    bool <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> <span class="entity">Proof.state</span>

  <span class="keyword1"><span class="keyword">val</span></span> get_info <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> <span class="entity">nominal_info</span>
<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Nominal_Function</span> <span class="main">:</span> <span class="entity">NOMINAL_FUNCTION</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword3"><span class="keyword">open</span></span> Function_Lib
<span class="keyword3"><span class="keyword">open</span></span> Function_Common
<span class="keyword3"><span class="keyword">open</span></span> Nominal_Function_Common


<span class="comment1">(* Check for all sorts of errors in the input - nominal needs a different checking function *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">nominal_check_defs</span> <span class="entity">ctxt</span> <span class="entity">fixes</span> <span class="entity">eqs</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fnames</span> <span class="main">=</span> map <span class="main">(</span>fst o fst<span class="main">)</span> <span class="entity">fixes</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">check</span> <span class="entity">geq</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">input_error</span> <span class="entity">msg</span> <span class="main">=</span> error <span class="main">(</span>cat_lines <span class="main">[</span><span class="entity">msg</span><span class="main">,</span> Syntax.string_of_term <span class="entity">ctxt</span> <span class="entity">geq</span><span class="main">]</span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">check_head</span> <span class="entity">fname</span> <span class="main">=</span>
          member <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">fnames</span> <span class="entity">fname</span> <span class="keyword1"><span class="keyword">orelse</span></span>
          <span class="entity">input_error</span> <span class="main">(</span><span class="inner_quoted">"Illegal equation head. Expected "</span> ^ commas_quote <span class="entity">fnames</span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">fname</span><span class="main">,</span> <span class="entity">qs</span><span class="main">,</span> <span class="entity">gs</span><span class="main">,</span> <span class="entity">args</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">split_def</span> <span class="entity">ctxt</span> <span class="entity">check_head</span> <span class="entity">geq</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> length <span class="entity">args</span> &gt; <span class="inner_numeral">0</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">input_error</span> <span class="inner_quoted">"Function has no arguments:"</span>

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_bvs</span> <span class="entity">t</span> <span class="entity">is</span> <span class="main">=</span> add_loose_bnos <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">,</span> <span class="entity">is</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rvs</span> <span class="main">=</span> <span class="main">(</span>subtract <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span>fold <span class="entity">add_bvs</span> <span class="entity">args</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="main">(</span><span class="entity">add_bvs</span> <span class="entity">rhs</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
                    |&gt; map <span class="main">(</span>fst o nth <span class="main">(</span>rev <span class="entity">qs</span><span class="main">)</span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> forall <span class="main">(</span>not o Term.exists_subterm
          <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> Free <span class="main">(</span><span class="entity">n</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> member <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">fnames</span> <span class="entity">n</span> <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false<span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">gs</span> @ <span class="entity">args</span><span class="main">)</span>
          <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">input_error</span> <span class="inner_quoted">"Defined function may not occur in premises or arguments"</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">freeargs</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> subst_bounds <span class="main">(</span>rev <span class="main">(</span>map Free <span class="entity">qs</span><span class="main">)</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span> <span class="entity">args</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">funvars</span> <span class="main">=</span> filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">q</span> <span class="main">=&gt;</span>
          exists <span class="main">(</span>exists_subterm <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span>Free <span class="entity">q'</span><span class="main">)</span> $ <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">q</span> <span class="main">=</span> <span class="entity">q'</span> <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false<span class="main">)</span><span class="main">)</span> <span class="entity">freeargs</span><span class="main">)</span> <span class="entity">qs</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> null <span class="entity">funvars</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="main">(</span>warning <span class="main">(</span>cat_lines
          <span class="main">[</span><span class="inner_quoted">"Bound variable"</span> ^ <span class="entity">plural</span> <span class="inner_quoted">" "</span> <span class="inner_quoted">"s "</span> <span class="entity">funvars</span> ^
          commas_quote <span class="main">(</span>map fst <span class="entity">funvars</span><span class="main">)</span> ^ <span class="inner_quoted">" occur"</span> ^ <span class="entity">plural</span> <span class="inner_quoted">"s"</span> <span class="inner_quoted">""</span> <span class="entity">funvars</span> ^
          <span class="inner_quoted">" in function position."</span><span class="main">,</span> <span class="inner_quoted">"Misspelled constructor???"</span><span class="main">]</span><span class="main">)</span><span class="main">;</span> true<span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="entity">fname</span><span class="main">,</span> length <span class="entity">args</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">grouped_args</span> <span class="main">=</span> AList.group <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span>map <span class="entity">check</span> <span class="entity">eqs</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">grouped_args</span>
      |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">fname</span><span class="main">,</span> <span class="entity">ars</span><span class="main">)</span> <span class="main">=&gt;</span>
        length <span class="main">(</span>distinct <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">ars</span><span class="main">)</span> <span class="main">=</span> <span class="inner_numeral">1</span>
        <span class="keyword1"><span class="keyword">orelse</span></span> error <span class="main">(</span><span class="inner_quoted">"Function "</span> ^ quote <span class="entity">fname</span> ^
          <span class="inner_quoted">" has different numbers of arguments in different equations"</span><span class="main">)</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">not_defined</span> <span class="main">=</span> subtract <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span>map fst <span class="entity">grouped_args</span><span class="main">)</span> <span class="entity">fnames</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> null <span class="entity">not_defined</span>
      <span class="keyword1"><span class="keyword">orelse</span></span> error <span class="main">(</span><span class="inner_quoted">"No defining equations for function"</span> ^
        <span class="entity">plural</span> <span class="inner_quoted">" "</span> <span class="inner_quoted">"s "</span> <span class="entity">not_defined</span> ^ commas_quote <span class="entity">not_defined</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">check_sorts</span> <span class="main">(</span><span class="main">(</span><span class="entity">fname</span><span class="main">,</span> <span class="entity">fT</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span>
      Sorts.of_sort <span class="main">(</span>Sign.classes_of <span class="main">(</span>Proof_Context.theory_of <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">fT</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">"pt"</span><span class="antiquote">}</span></span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">orelse</span></span> error <span class="main">(</span>cat_lines
      <span class="main">[</span><span class="inner_quoted">"Type of "</span> ^ quote <span class="entity">fname</span> ^ <span class="inner_quoted">" is not of sort "</span> ^ quote <span class="inner_quoted">"pt"</span> ^ <span class="inner_quoted">":"</span><span class="main">,</span>
       Syntax.string_of_typ <span class="main">(</span>Config.put show_sorts true <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">fT</span><span class="main">]</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> map <span class="entity">check_sorts</span> <span class="entity">fixes</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>



<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">psimp_attribs</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">Attrib.internal</span> o K<span class="main">)</span>
  <span class="main">[</span><span class="entity">Named_Theorems.add</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">named_theorems</span> nitpick_psimp<span class="antiquote">}</span></span><span class="main">]</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_defname</span> <span class="entity">fixes</span> <span class="main">=</span> <span class="entity">fixes</span> |&gt; map <span class="main">(</span>fst o fst<span class="main">)</span> |&gt; space_implode <span class="inner_quoted">"_"</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_simps</span> <span class="entity">fnames</span> <span class="entity">post</span> <span class="entity">sort</span> <span class="entity">extra_qualify</span> <span class="entity">label</span> <span class="entity">mod_binding</span> <span class="entity">moreatts</span>
  <span class="entity">simps</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">spec</span> <span class="main">=</span> <span class="entity">post</span> <span class="entity">simps</span>
      |&gt; map <span class="main">(</span>apfst <span class="main">(</span>apsnd <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ats</span> <span class="main">=&gt;</span> <span class="entity">moreatts</span> @ <span class="entity">ats</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      |&gt; map <span class="main">(</span>apfst <span class="main">(</span>apfst <span class="entity">extra_qualify</span><span class="main">)</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">saved_spec_simps</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span>
      fold_map Local_Theory.note <span class="entity">spec</span> <span class="entity">lthy</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">saved_simps</span> <span class="main">=</span> maps snd <span class="entity">saved_spec_simps</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simps_by_f</span> <span class="main">=</span> <span class="entity">sort</span> <span class="entity">saved_simps</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_for_f</span> <span class="entity">fname</span> <span class="entity">simps</span> <span class="main">=</span>
      Local_Theory.note
        <span class="main">(</span><span class="main">(</span><span class="entity">mod_binding</span> <span class="main">(</span>Binding.qualify true <span class="entity">fname</span> <span class="main">(</span>Binding.name <span class="entity">label</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">simps</span><span class="main">)</span>
      #&gt; snd
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="entity">saved_simps</span><span class="main">,</span> fold2 <span class="entity">add_for_f</span> <span class="entity">fnames</span> <span class="entity">simps_by_f</span> <span class="entity">lthy</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* nominal *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prepare_nominal_function</span> <span class="entity">do_print</span> <span class="entity">prep</span> <span class="entity">default_constraint</span> <span class="entity">fixspec</span> <span class="entity">eqns</span> <span class="entity">config</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">constrn_fxs</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">b</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">mx</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">b</span><span class="main">,</span> SOME <span class="main">(</span>the_default <span class="entity">default_constraint</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> <span class="entity">mx</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">fixes0</span><span class="main">,</span> <span class="entity">spec0</span><span class="main">)</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">prep</span> <span class="main">(</span><span class="entity">constrn_fxs</span> <span class="entity">fixspec</span><span class="main">)</span> <span class="entity">eqns</span> <span class="entity">lthy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fixes</span> <span class="main">=</span> map <span class="main">(</span>apfst <span class="main">(</span>apfst Binding.name_of<span class="main">)</span><span class="main">)</span> <span class="entity">fixes0</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">spec</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">bnd</span><span class="main">,</span> <span class="entity">prop</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">bnd</span><span class="main">,</span> <span class="main">[</span><span class="entity">prop</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="entity">spec0</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">eqs</span><span class="main">,</span> <span class="entity">post</span><span class="main">,</span> <span class="entity">sort_cont</span><span class="main">,</span> <span class="entity">cnames</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">empty_preproc</span> <span class="entity">nominal_check_defs</span> <span class="main">(</span><span class="entity">Function_Common.default_config</span><span class="main">)</span> <span class="entity">ctxt'</span> <span class="entity">fixes</span> <span class="entity">spec</span> <span class="comment1">(* nominal *)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">defname</span> <span class="main">=</span> <span class="entity">mk_defname</span> <span class="entity">fixes</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">NominalFunctionConfig</span> <span class="main">{</span><span class="entity">partials</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">config</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">goal_state</span><span class="main">,</span> <span class="entity">cont</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">Nominal_Function_Mutual.prepare_nominal_function_mutual</span> <span class="entity">config</span> <span class="entity">defname</span> <span class="entity">fixes</span> <span class="entity">eqs</span> <span class="entity">lthy</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">afterqed</span> <span class="main">[</span><span class="main">[</span><span class="entity">proof</span><span class="main">]</span><span class="main">]</span> <span class="entity">lthy</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">NominalFunctionResult</span> <span class="main">{</span><span class="entity">fs</span><span class="main">,</span> <span class="entity">R</span><span class="main">,</span> <span class="entity">psimps</span><span class="main">,</span> <span class="entity">simple_pinducts</span><span class="main">,</span>
          <span class="entity">termination</span><span class="main">,</span> <span class="entity">domintros</span><span class="main">,</span> <span class="entity">cases</span><span class="main">,</span> <span class="entity">eqvts</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span>
          <span class="entity">cont</span> <span class="entity">lthy</span> <span class="main">(</span>Thm.close_derivation <span class="antiquoted"><span class="operator"><span class="entity">⌂</span></span></span> <span class="entity">proof</span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fnames</span> <span class="main">=</span> map <span class="main">(</span>fst o fst<span class="main">)</span> <span class="entity">fixes</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">qualify</span> <span class="entity">n</span> <span class="main">=</span> Binding.name <span class="entity">n</span>
          |&gt; Binding.qualify true <span class="entity">defname</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">concealed_partial</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">partials</span> <span class="keyword2"><span class="keyword">then</span></span> I <span class="keyword2"><span class="keyword">else</span></span> Binding.concealed

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">addsmps</span> <span class="main">=</span> <span class="entity">add_simps</span> <span class="entity">fnames</span> <span class="entity">post</span> <span class="entity">sort_cont</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">psimps'</span><span class="main">,</span> <span class="entity">pinducts'</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">[</span><span class="entity">termination'</span><span class="main">]</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span>
          <span class="entity">lthy</span>
          |&gt; <span class="entity">addsmps</span> <span class="main">(</span><span class="entity">concealed_partial</span> o Binding.qualify false <span class="inner_quoted">"partial"</span><span class="main">)</span>
               <span class="inner_quoted">"psimps"</span> <span class="entity">concealed_partial</span> <span class="entity">psimp_attribs</span> <span class="entity">psimps</span>
          ||&gt;&gt; Local_Theory.note <span class="main">(</span><span class="main">(</span><span class="entity">concealed_partial</span> <span class="main">(</span><span class="entity">qualify</span> <span class="inner_quoted">"pinduct"</span><span class="main">)</span><span class="main">,</span>
                 <span class="main">[</span><span class="entity">Attrib.internal</span> <span class="main">(</span>K <span class="main">(</span>Rule_Cases.case_names <span class="entity">cnames</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
                  <span class="entity">Attrib.internal</span> <span class="main">(</span>K <span class="main">(</span>Rule_Cases.consumes <span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
                  <span class="entity">Attrib.internal</span> <span class="main">(</span>K <span class="main">(</span><span class="entity">Induct.induct_pred</span> <span class="inner_quoted">""</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">simple_pinducts</span><span class="main">)</span>
          ||&gt;&gt; Local_Theory.note <span class="main">(</span><span class="main">(</span>Binding.concealed <span class="main">(</span><span class="entity">qualify</span> <span class="inner_quoted">"termination"</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="entity">termination</span><span class="main">]</span><span class="main">)</span>
          ||&gt; <span class="main">(</span>snd o Local_Theory.note <span class="main">(</span><span class="main">(</span><span class="entity">qualify</span> <span class="inner_quoted">"cases"</span><span class="main">,</span>
                 <span class="main">[</span><span class="entity">Attrib.internal</span> <span class="main">(</span>K <span class="main">(</span>Rule_Cases.case_names <span class="entity">cnames</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="entity">cases</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
          ||&gt; <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">domintros</span> <span class="keyword2"><span class="keyword">of</span></span> NONE <span class="main">=&gt;</span> I <span class="main">|</span> SOME <span class="entity">thms</span> <span class="main">=&gt;</span>
                   Local_Theory.note <span class="main">(</span><span class="main">(</span><span class="entity">qualify</span> <span class="inner_quoted">"domintros"</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">thms</span><span class="main">)</span> #&gt; snd<span class="main">)</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">info</span> <span class="main">=</span> <span class="main">{</span> add_simps<span class="main">=</span><span class="entity">addsmps</span><span class="main">,</span> case_names<span class="main">=</span><span class="entity">cnames</span><span class="main">,</span> psimps<span class="main">=</span><span class="entity">psimps'</span><span class="main">,</span>
          pinducts<span class="main">=</span>snd <span class="entity">pinducts'</span><span class="main">,</span> simps<span class="main">=</span>NONE<span class="main">,</span> inducts<span class="main">=</span>NONE<span class="main">,</span> termination<span class="main">=</span><span class="entity">termination'</span><span class="main">,</span>
          fs<span class="main">=</span><span class="entity">fs</span><span class="main">,</span> R<span class="main">=</span><span class="entity">R</span><span class="main">,</span> defname<span class="main">=</span><span class="entity">defname</span><span class="main">,</span> is_partial<span class="main">=</span>true<span class="main">,</span> eqvts<span class="main">=</span><span class="entity">eqvts</span><span class="main">}</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">Proof_Display.print_consts</span> <span class="entity">do_print</span>
          <span class="main">(</span>Position.thread_data <span class="main">(</span><span class="main">)</span><span class="main">)</span> <span class="entity">lthy</span> <span class="main">(</span>K false<span class="main">)</span> <span class="main">(</span>map fst <span class="entity">fixes</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="entity">info</span><span class="main">,</span>
         <span class="entity">lthy</span> |&gt; Local_Theory.declaration <span class="main">{</span>syntax <span class="main">=</span> false<span class="main">,</span> pervasive <span class="main">=</span> false<span class="main">}</span>
           <span class="main">(</span><span class="entity">add_function_data</span> o <span class="entity">morph_function_data</span> <span class="entity">info</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="main">(</span><span class="entity">goal_state</span><span class="main">,</span> <span class="entity">afterqed</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">gen_add_nominal_function</span> <span class="entity">do_print</span> <span class="entity">prep</span> <span class="entity">default_constraint</span> <span class="entity">fixspec</span> <span class="entity">eqns</span> <span class="entity">config</span> <span class="entity">tac</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">goal_state</span><span class="main">,</span> <span class="entity">afterqed</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">prepare_nominal_function</span> <span class="entity">do_print</span> <span class="entity">prep</span> <span class="entity">default_constraint</span> <span class="entity">fixspec</span> <span class="entity">eqns</span> <span class="entity">config</span> <span class="entity">lthy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pattern_thm</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">case</span></span> SINGLE <span class="main">(</span><span class="entity">tac</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="entity">goal_state</span> <span class="keyword2"><span class="keyword">of</span></span>
        NONE <span class="main">=&gt;</span> error <span class="inner_quoted">"pattern completeness and compatibility proof failed"</span>
      <span class="main">|</span> SOME <span class="entity">st</span> <span class="main">=&gt;</span> Goal.finish <span class="entity">lthy'</span> <span class="entity">st</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">lthy'</span>
    |&gt; <span class="entity">afterqed</span> <span class="main">[</span><span class="main">[</span><span class="entity">pattern_thm</span><span class="main">]</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">add_nominal_function</span> <span class="main">=</span>
  <span class="entity">gen_add_nominal_function</span> false <span class="entity">Specification.check_multi_specs</span> <span class="main">(</span>Type_Infer.anyT <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">type</span><span class="antiquote">}</span></span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_nominal_function_cmd</span> <span class="entity">a</span> <span class="entity">b</span> <span class="entity">c</span> <span class="entity">d</span> <span class="entity">int</span> <span class="main">=</span>
  <span class="entity">gen_add_nominal_function</span> <span class="entity">int</span> <span class="entity">Specification.read_multi_specs</span> <span class="inner_quoted">"_::type"</span> <span class="entity">a</span> <span class="entity">b</span> <span class="entity">c</span> <span class="entity">d</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">gen_nominal_function</span> <span class="entity">do_print</span> <span class="entity">prep</span> <span class="entity">default_constraint</span> <span class="entity">fixspec</span> <span class="entity">eqns</span> <span class="entity">config</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">goal_state</span><span class="main">,</span> <span class="entity">afterqed</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">prepare_nominal_function</span> <span class="entity">do_print</span> <span class="entity">prep</span> <span class="entity">default_constraint</span> <span class="entity">fixspec</span> <span class="entity">eqns</span> <span class="entity">config</span> <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">lthy'</span>
    |&gt; <span class="entity">Proof.theorem</span> NONE <span class="main">(</span>snd oo <span class="entity">afterqed</span><span class="main">)</span> <span class="main">[</span><span class="main">[</span><span class="main">(</span>Logic.unprotect <span class="main">(</span>Thm.concl_of <span class="entity">goal_state</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">]</span><span class="main">]</span>
    |&gt; <span class="entity">Proof.refine_singleton</span> <span class="main">(</span><span class="entity">Method.primitive_text</span> <span class="main">(</span>K <span class="main">(</span>K <span class="entity">goal_state</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nominal_function</span> <span class="main">=</span>
  <span class="entity">gen_nominal_function</span> false <span class="entity">Specification.check_multi_specs</span> <span class="main">(</span>Type_Infer.anyT <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">type</span><span class="antiquote">}</span></span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">nominal_function_cmd</span> <span class="entity">a</span> <span class="entity">b</span> <span class="entity">c</span> <span class="entity">int</span> <span class="main">=</span>
  <span class="entity">gen_nominal_function</span> <span class="entity">int</span> <span class="entity">Specification.read_multi_specs</span> <span class="inner_quoted">"_::type"</span> <span class="entity">a</span> <span class="entity">b</span> <span class="entity">c</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_info</span> <span class="entity">ctxt</span> <span class="entity">t</span> <span class="main">=</span> Item_Net.retrieve <span class="main">(</span><span class="entity">get_function</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">t</span>
  |&gt; the_single |&gt; snd


<span class="comment1">(* outer syntax *)</span>

<span class="keyword2"><span class="keyword">local</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">option_parser</span> <span class="main">=</span> Parse.group <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="inner_quoted">"option"</span><span class="main">)</span>
    <span class="main">(</span><span class="main">(</span>Parse.reserved <span class="inner_quoted">"sequential"</span> &gt;&gt; K <span class="entity">Sequential</span><span class="main">)</span>
     || <span class="main">(</span><span class="main">(</span>Parse.reserved <span class="inner_quoted">"default"</span> |-- Parse.term<span class="main">)</span> &gt;&gt; <span class="entity">Default</span><span class="main">)</span>
     || <span class="main">(</span>Parse.reserved <span class="inner_quoted">"domintros"</span> &gt;&gt; K <span class="entity">DomIntros</span><span class="main">)</span>
     || <span class="main">(</span>Parse.reserved <span class="inner_quoted">"no_partials"</span> &gt;&gt; K <span class="entity">No_Partials</span><span class="main">)</span>
     || <span class="main">(</span><span class="main">(</span>Parse.reserved <span class="inner_quoted">"invariant"</span> |-- Parse.term<span class="main">)</span> &gt;&gt; <span class="entity">Invariant</span><span class="main">)</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">config_parser</span> <span class="entity">default</span> <span class="main">=</span>
    <span class="main">(</span>Scan.optional <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">(</span>"<span class="antiquote">}</span></span></span> |-- Parse.!!! <span class="main">(</span>Parse.list1 <span class="entity">option_parser</span><span class="main">)</span> --| <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">)</span>"<span class="antiquote">}</span></span></span><span class="main">)</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
     &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">opts</span> <span class="main">=&gt;</span> fold <span class="entity">apply_opt</span> <span class="entity">opts</span> <span class="entity">default</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">in</span></span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">nominal_function_parser</span> <span class="entity">default_cfg</span> <span class="main">=</span>
      <span class="entity">config_parser</span> <span class="entity">default_cfg</span> -- <span class="entity">Parse_Spec.specification</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.local_theory_to_proof'</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> <span class="keyword1">nominal_function</span><span class="antiquote">}</span></span></span>
    <span class="inner_quoted">"define general recursive nominal functions"</span>
       <span class="main">(</span><span class="entity">nominal_function_parser</span> <span class="entity">nominal_default_config</span>
          &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">config</span><span class="main">,</span> <span class="main">(</span><span class="entity">fixes</span><span class="main">,</span> <span class="entity">specs</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">nominal_function_cmd</span> <span class="entity">fixes</span> <span class="entity">specs</span> <span class="entity">config</span><span class="main">)</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/nominal_termination.ML">
<div class="head">
<h1>File ‹nominal_termination.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*  Nominal Termination
    Author: Christian Urban

    heavily based on the code of Alexander Krauss
    (code forked on 18 July 2011)

Redefinition of the termination command
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">NOMINAL_FUNCTION_TERMINATION</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">include</span></span> <span class="entity">NOMINAL_FUNCTION_DATA</span>

  <span class="keyword1"><span class="keyword">val</span></span> termination <span class="main">:</span> bool <span class="main">-&gt;</span> term option <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> <span class="entity">Proof.state</span>
  <span class="keyword1"><span class="keyword">val</span></span> termination_cmd <span class="main">:</span> bool <span class="main">-&gt;</span> string option <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> <span class="entity">Proof.state</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Nominal_Function_Termination</span> <span class="main">:</span> <span class="entity">NOMINAL_FUNCTION_TERMINATION</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword3"><span class="keyword">open</span></span> Function_Lib
<span class="keyword3"><span class="keyword">open</span></span> Function_Common
<span class="keyword3"><span class="keyword">open</span></span> Nominal_Function_Common

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simp_attribs</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">Attrib.internal</span> o K<span class="main">)</span>
  <span class="main">[</span><span class="entity">Simplifier.simp_add</span><span class="main">,</span>
   <span class="entity">Named_Theorems.add</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">named_theorems</span> nitpick_simp<span class="antiquote">}</span></span><span class="main">]</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eqvt_attrib</span> <span class="main">=</span>  <span class="entity">Attrib.internal</span> <span class="main">(</span>K <span class="entity">Nominal_ThmDecls.eqvt_add</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prepare_termination_proof</span> <span class="entity">prep_term</span> <span class="entity">is_eqvt</span> <span class="entity">raw_term_opt</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">term_opt</span> <span class="main">=</span> Option.map <span class="main">(</span><span class="entity">prep_term</span> <span class="entity">lthy</span><span class="main">)</span> <span class="entity">raw_term_opt</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">info</span> <span class="main">=</span> the <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">term_opt</span> <span class="keyword2"><span class="keyword">of</span></span>
                      SOME <span class="entity">t</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">import_function_data</span> <span class="entity">t</span> <span class="entity">lthy</span>
                        <span class="keyword3"><span class="keyword">handle</span></span> Option.Option <span class="main">=&gt;</span>
                          error <span class="main">(</span><span class="inner_quoted">"Not a function: "</span> ^ quote <span class="main">(</span>Syntax.string_of_term <span class="entity">lthy</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                    <span class="main">|</span> NONE <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">import_last_function</span> <span class="entity">lthy</span> <span class="keyword3"><span class="keyword">handle</span></span> Option.Option <span class="main">=&gt;</span> error <span class="inner_quoted">"Not a function"</span><span class="main">)</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span> <span class="entity">termination</span><span class="main">,</span> <span class="entity">fs</span><span class="main">,</span> <span class="entity">R</span><span class="main">,</span> <span class="entity">add_simps</span><span class="main">,</span> <span class="entity">case_names</span><span class="main">,</span> <span class="entity">psimps</span><span class="main">,</span>
        <span class="entity">pinducts</span><span class="main">,</span> <span class="entity">defname</span><span class="main">,</span> <span class="entity">eqvts</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">info</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">domT</span> <span class="main">=</span> domain_type <span class="main">(</span>fastype_of <span class="entity">R</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goal</span> <span class="main">=</span> <span class="entity">HOLogic.mk_Trueprop</span>
                   <span class="main">(</span><span class="entity">HOLogic.mk_all</span> <span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> <span class="entity">domT</span><span class="main">,</span> <span class="entity">mk_acc</span> <span class="entity">domT</span> <span class="entity">R</span> $ Free <span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> <span class="entity">domT</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">afterqed</span> <span class="main">[</span><span class="main">[</span><span class="entity">totality</span><span class="main">]</span><span class="main">]</span> <span class="entity">lthy</span> <span class="main">=</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">totality</span> <span class="main">=</span> Thm.close_derivation <span class="antiquoted"><span class="operator"><span class="entity">⌂</span></span></span> <span class="entity">totality</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">remove_domain_condition</span> <span class="main">=</span>
            <span class="entity">full_simplify</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">lthy</span>
              addsimps <span class="main">[</span><span class="entity">totality</span><span class="main">,</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> True_implies_equals<span class="antiquote">}</span></span></span><span class="main">]</span><span class="main">)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tsimps</span> <span class="main">=</span> map <span class="entity">remove_domain_condition</span> <span class="entity">psimps</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tinducts</span> <span class="main">=</span> map <span class="entity">remove_domain_condition</span> <span class="entity">pinducts</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">teqvts</span> <span class="main">=</span> map <span class="entity">remove_domain_condition</span> <span class="entity">eqvts</span>

          <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">qualify</span> <span class="entity">n</span> <span class="main">=</span> Binding.name <span class="entity">n</span>
            |&gt; Binding.qualify true <span class="entity">defname</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="entity">lthy</span>
          |&gt; <span class="entity">add_simps</span> I <span class="inner_quoted">"simps"</span> I <span class="entity">simp_attribs</span> <span class="entity">tsimps</span>
          ||&gt;&gt; Local_Theory.note <span class="main">(</span><span class="main">(</span><span class="entity">qualify</span> <span class="inner_quoted">"eqvt"</span><span class="main">,</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_eqvt</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="entity">eqvt_attrib</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">teqvts</span><span class="main">)</span>
          ||&gt;&gt; Local_Theory.note
             <span class="main">(</span><span class="main">(</span><span class="entity">qualify</span> <span class="inner_quoted">"induct"</span><span class="main">,</span>
               <span class="main">[</span><span class="entity">Attrib.internal</span> <span class="main">(</span>K <span class="main">(</span>Rule_Cases.case_names <span class="entity">case_names</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
              <span class="entity">tinducts</span><span class="main">)</span>
          |-&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">simps</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">eqvts</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">inducts</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">lthy</span> <span class="main">=&gt;</span>
            <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">info'</span> <span class="main">=</span> <span class="main">{</span> is_partial<span class="main">=</span>false<span class="main">,</span> defname<span class="main">=</span><span class="entity">defname</span><span class="main">,</span> add_simps<span class="main">=</span><span class="entity">add_simps</span><span class="main">,</span>
              case_names<span class="main">=</span><span class="entity">case_names</span><span class="main">,</span> fs<span class="main">=</span><span class="entity">fs</span><span class="main">,</span> R<span class="main">=</span><span class="entity">R</span><span class="main">,</span> psimps<span class="main">=</span><span class="entity">psimps</span><span class="main">,</span> pinducts<span class="main">=</span><span class="entity">pinducts</span><span class="main">,</span>
              simps<span class="main">=</span>SOME <span class="entity">simps</span><span class="main">,</span> inducts<span class="main">=</span>SOME <span class="entity">inducts</span><span class="main">,</span> termination<span class="main">=</span><span class="entity">termination</span><span class="main">,</span> eqvts<span class="main">=</span><span class="entity">teqvts</span> <span class="main">}</span>
            <span class="keyword2"><span class="keyword">in</span></span>
              <span class="entity">lthy</span>
              |&gt; Local_Theory.declaration <span class="main">{</span>syntax <span class="main">=</span> false<span class="main">,</span> pervasive <span class="main">=</span> false<span class="main">}</span>
                   <span class="main">(</span><span class="entity">add_function_data</span> o <span class="entity">morph_function_data</span> <span class="entity">info'</span><span class="main">)</span>
              |&gt; <span class="entity">Spec_Rules.add</span> Binding.empty <span class="entity">Spec_Rules.equational_recdef</span> <span class="entity">fs</span> <span class="entity">tsimps</span>
              |&gt; <span class="entity">Code.declare_default_eqns</span> <span class="main">(</span>map <span class="main">(</span>rpair true<span class="main">)</span> <span class="entity">tsimps</span><span class="main">)</span>
              |&gt; pair <span class="entity">info'</span>
            <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="entity">goal</span><span class="main">,</span> <span class="entity">afterqed</span><span class="main">,</span> <span class="entity">termination</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">gen_termination</span> <span class="entity">prep_term</span> <span class="entity">is_eqvt</span> <span class="entity">raw_term_opt</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">goal</span><span class="main">,</span> <span class="entity">afterqed</span><span class="main">,</span> <span class="entity">termination</span><span class="main">)</span> <span class="main">=</span> <span class="entity">prepare_termination_proof</span> <span class="entity">prep_term</span> <span class="entity">is_eqvt</span> <span class="entity">raw_term_opt</span> <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">lthy</span>
    |&gt; Proof_Context.note_thmss <span class="inner_quoted">""</span>
       <span class="main">[</span><span class="main">(</span><span class="main">(</span>Binding.empty<span class="main">,</span> <span class="main">[</span><span class="entity">Context_Rules.rule_del</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="entity">allI</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">]</span> |&gt; snd
    |&gt; Proof_Context.note_thmss <span class="inner_quoted">""</span>
       <span class="main">[</span><span class="main">(</span><span class="main">(</span>Binding.empty<span class="main">,</span> <span class="main">[</span><span class="entity">Context_Rules.intro_bang</span> <span class="main">(</span>SOME <span class="inner_numeral">1</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="entity">allI</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">]</span> |&gt; snd
    |&gt; Proof_Context.note_thmss <span class="inner_quoted">""</span>
       <span class="main">[</span><span class="main">(</span><span class="main">(</span>Binding.name <span class="inner_quoted">"termination"</span><span class="main">,</span> <span class="main">[</span><span class="entity">Context_Rules.intro_bang</span> <span class="main">(</span>SOME <span class="inner_numeral">0</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
         <span class="main">[</span><span class="main">(</span><span class="main">[</span>Goal.norm_result <span class="entity">lthy</span> <span class="entity">termination</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">]</span> |&gt; snd
    |&gt; <span class="entity">Proof.theorem</span> NONE <span class="main">(</span>snd oo <span class="entity">afterqed</span><span class="main">)</span> <span class="main">[</span><span class="main">[</span><span class="main">(</span><span class="entity">goal</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">]</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">termination</span> <span class="main">=</span> <span class="entity">gen_termination</span> Syntax.check_term
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">termination_cmd</span> <span class="main">=</span> <span class="entity">gen_termination</span> Syntax.read_term

<span class="comment1">(* outer syntax *)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">option_parser</span> <span class="main">=</span>
  <span class="main">(</span>Scan.optional <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">(</span>"<span class="antiquote">}</span></span></span> |-- Parse.!!!
    <span class="main">(</span><span class="main">(</span>Parse.reserved <span class="inner_quoted">"eqvt"</span> &gt;&gt; K true<span class="main">)</span> ||
     <span class="main">(</span>Parse.reserved <span class="inner_quoted">"no_eqvt"</span> &gt;&gt; K false<span class="main">)</span><span class="main">)</span> --| <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">)</span>"<span class="antiquote">}</span></span></span><span class="main">)</span> <span class="main">(</span>false<span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.local_theory_to_proof</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> <span class="keyword1">nominal_termination</span><span class="antiquote">}</span></span></span>
    <span class="inner_quoted">"prove termination of a recursive nominal function"</span>
      <span class="main">(</span><span class="entity">option_parser</span> -- Scan.option Parse.term &gt;&gt;
        <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">is_eqvt</span><span class="main">,</span> <span class="entity">opt_trm</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">termination_cmd</span> <span class="entity">is_eqvt</span> <span class="entity">opt_trm</span><span class="main">)</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Atoms">
<div class="head">
<h1>Theory Atoms</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Atoms
    Authors:    Brian Huffman, Christian Urban

    Instantiations of concrete atoms 
*)</span>

<span class="keyword1"><span class="command">theory</span></span> Atoms
<span class="keyword2"><span class="keyword">imports</span></span> <a href="#Nominal2_Base">Nominal2_Base</a>
<span class="keyword2"><span class="keyword">begin</span></span>



<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> nat_of<span class="antiquote"><span class="antiquote">}</span></span></span></span> is an example of a function 
  without finite support›</span></span>


<span class="keyword1" id="Atoms-not_fresh_nat_of"><span class="command">lemma</span></span> not_fresh_nat_of<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">a</span> <span class="main">♯</span> nat_of"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fresh_def supp_def
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">{</span><span class="bound">b</span><span class="main">.</span> <span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∙</span> nat_of <span class="main">≠</span> nat_of<span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="main">{</span><span class="free">a</span><span class="main">}</span> <span class="main">∪</span> <span class="main">{</span><span class="bound">b</span><span class="main">.</span> <span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∙</span> nat_of <span class="main">≠</span> nat_of<span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">b</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    b1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">≠</span> <span class="free">a</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    b2<span class="main">:</span> <span class="quoted"><span class="quoted">"sort_of <span class="skolem">b</span> <span class="main">=</span> sort_of <span class="free">a</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    b3<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∙</span> nat_of <span class="main">=</span> nat_of"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> obtain_atom<span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"nat_of <span class="free">a</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∙</span> <span class="main">(</span>nat_of <span class="free">a</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_nat_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∙</span> nat_of<span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">a</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> permute_fun_app_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> nat_of <span class="main">(</span><span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∙</span> <span class="free">a</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> b3 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> nat_of <span class="skolem">b</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> b2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"nat_of <span class="free">a</span> <span class="main">=</span> nat_of <span class="skolem">b</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">with</span></span> b2 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">=</span> <span class="skolem">b</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> atom_components_eq_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> b1 <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"False"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Atoms-supp_nat_of"><span class="command">lemma</span></span> supp_nat_of<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supp nat_of <span class="main">=</span> UNIV"</span></span>
  <span class="keyword1"><span class="command">using</span></span> not_fresh_nat_of <span class="main">[</span><span class="operator">unfolded</span> fresh_def<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Manual instantiation of class <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>at›</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">typedef</span></span> name <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">a</span><span class="main">.</span> sort_of <span class="bound">a</span> <span class="main">=</span> Sort <span class="inner_quoted">''name''</span> <span class="main">[]</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> exists_eq_simple_sort<span class="main">)</span>

<span class="keyword1"><span class="command">instantiation</span></span> name <span class="main">::</span> <span class="quoted">at</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∙</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">=</span> Abs_name <span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∙</span> Rep_name <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"atom <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">=</span> Rep_name <span class="free"><span class="bound"><span class="entity">a</span></span></span>"</span></span>

<span class="keyword1"><span class="command">instance</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> at_class<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> type_definition_name<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> atom_name_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> permute_name_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Atoms-sort_of_atom_name"><span class="command">lemma</span></span> sort_of_atom_name<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sort_of <span class="main">(</span>atom <span class="main">(</span><span class="free">a</span><span class="main">::</span>name<span class="main">)</span><span class="main">)</span> <span class="main">=</span> Sort <span class="inner_quoted">''name''</span> <span class="main">[]</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> atom_name_def Rep_name<span class="main"><span class="main">[</span></span><span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Custom syntax for concrete atoms of type at›</span></span>

<span class="keyword1"><span class="command">term</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span><span class="main">:::</span>name"</span></span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Automatic instantiation of class <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>at›</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">atom_decl</span></span> name2

<span class="keyword1"><span class="command">lemma</span></span> 
  <span class="quoted"><span class="quoted">"sort_of <span class="main">(</span>atom <span class="main">(</span><span class="free">a</span><span class="main">::</span>name2<span class="main">)</span><span class="main">)</span> <span class="main">≠</span> sort_of <span class="main">(</span>atom <span class="main">(</span><span class="free">b</span><span class="main">::</span>name<span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sort_of_atom_name<span class="main">)</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹example swappings›</span></span>
<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">a</span> <span class="free">b</span><span class="main">::</span><span class="quoted"><span class="quoted">"atom"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"sort_of <span class="free">a</span> <span class="main">=</span> sort_of <span class="free">b</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">⇌</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="free">b</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">b</span><span class="main">,</span> <span class="free">a</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">a</span> <span class="free">b</span><span class="main">::</span><span class="quoted"><span class="quoted">"name2"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">↔</span> <span class="free">b</span><span class="main">)</span> <span class="main">∙</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="free">b</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">b</span><span class="main">,</span> <span class="free">a</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹An example for multiple-sort atoms›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> ty <span class="main">=</span>
  TVar <span class="quoted">string</span>
<span class="main">|</span> Fun <span class="quoted">ty</span> <span class="quoted">ty</span> <span class="main">(</span><span class="quoted">"_ <span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1">→</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> _"</span><span class="main">)</span>

<span class="keyword1"><span class="command">primrec</span></span>
  <span class="entity">sort_of_ty</span><span class="main">::</span><span class="quoted"><span class="quoted">"ty <span class="main">⇒</span> atom_sort"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">sort_of_ty</span> <span class="main">(</span>TVar <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">=</span> Sort <span class="inner_quoted">''TVar''</span> <span class="main">[</span>Sort <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">[]</span><span class="main">]</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">sort_of_ty</span> <span class="main">(</span>Fun <span class="free"><span class="bound"><span class="entity">ty1</span></span></span> <span class="free"><span class="bound"><span class="entity">ty2</span></span></span><span class="main">)</span> <span class="main">=</span> Sort <span class="inner_quoted">''Fun''</span> <span class="main">[</span><span class="free">sort_of_ty</span> <span class="free"><span class="bound"><span class="entity">ty1</span></span></span><span class="main">,</span> <span class="free">sort_of_ty</span> <span class="free"><span class="bound"><span class="entity">ty2</span></span></span><span class="main">]</span>"</span></span>

<span class="keyword1" id="Atoms-sort_of_ty_eq_iff"><span class="command">lemma</span></span> sort_of_ty_eq_iff<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sort_of_ty <span class="free">x</span> <span class="main">=</span> sort_of_ty <span class="free">y</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">x</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">y</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> <span class="quoted"><span class="improper"><span class="quoted"><span class="improper">y</span></span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">declare</span></span> sort_of_ty.simps <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword">del</span></span><span class="main">]</span>

<span class="keyword1"><span class="command">typedef</span></span> var <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">a</span><span class="main">.</span> sort_of <span class="bound">a</span> <span class="main">∈</span> range sort_of_ty<span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"Atom <span class="main">(</span>sort_of_ty <span class="free">x</span><span class="main">)</span> <span class="free">y</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">instantiation</span></span> var <span class="main">::</span> <span class="quoted">at_base</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∙</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">=</span> Abs_var <span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∙</span> Rep_var <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"atom <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">=</span> Rep_var <span class="free"><span class="bound"><span class="entity">a</span></span></span>"</span></span>

<span class="keyword1"><span class="command">instance</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> at_base_class<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> type_definition_var<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> atom_var_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> permute_var_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Constructor for variables.›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">Var</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> ty <span class="main">⇒</span> var"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Var</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">=</span> Abs_var <span class="main">(</span>Atom <span class="main">(</span>sort_of_ty <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Atoms-Var_eq_iff"><span class="command">lemma</span></span> Var_eq_iff <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Var <span class="free">x</span> <span class="free">s</span> <span class="main">=</span> Var <span class="free">y</span> <span class="free">t</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span> <span class="main">∧</span> <span class="free">s</span> <span class="main">=</span> <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Var_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_var_inject sort_of_ty_eq_iff<span class="main">)</span>

<span class="keyword1" id="Atoms-sort_of_atom_var"><span class="command">lemma</span></span> sort_of_atom_var <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"sort_of <span class="main">(</span>atom <span class="main">(</span>Var <span class="free">n</span> <span class="free">ty</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> sort_of_ty <span class="free">ty</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> atom_var_def Var_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_var_inverse<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">α</span> <span class="main">≠</span> <span class="free">β</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Var <span class="free">x</span> <span class="free">α</span> <span class="main">↔</span> Var <span class="free">y</span> <span class="free">α</span><span class="main">)</span> <span class="main">∙</span> <span class="main">(</span>Var <span class="free">x</span> <span class="free">α</span><span class="main">,</span> Var <span class="free">x</span> <span class="free">β</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Var <span class="free">y</span> <span class="free">α</span><span class="main">,</span> Var <span class="free">x</span> <span class="free">β</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Projecting out the type component of a variable.›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">ty_of</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"var <span class="main">⇒</span> ty"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ty_of</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> inv sort_of_ty <span class="main">(</span>sort_of <span class="main">(</span>atom <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Functions <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Var</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>/<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">ty_of</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> satisfy many of the same
  properties as <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Atom</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>/<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">sort_of</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>

<span class="keyword1" id="Atoms-ty_of_Var"><span class="command">lemma</span></span> ty_of_Var <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ty_of <span class="main">(</span>Var <span class="free">x</span> <span class="free">t</span><span class="main">)</span> <span class="main">=</span> <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ty_of_def
  <span class="keyword1"><span class="command">unfolding</span></span> sort_of_atom_var
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> inv_f_f<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inj_on_def sort_of_ty_eq_iff<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Atoms-ty_of_permute"><span class="command">lemma</span></span> ty_of_permute <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ty_of <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> ty_of <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ty_of_def
  <span class="keyword1"><span class="command">unfolding</span></span> atom_eqvt <span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> sort_of_permute<span class="main">)</span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Tests with subtyping and automatic coercions›</span></span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">coercion_enabled</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1"><span class="command">atom_decl</span></span> var1
<span class="keyword1"><span class="command">atom_decl</span></span> var2

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">coercion</span> <span class="quoted"><span class="quoted">"atom<span class="main">::</span>var1<span class="main">⇒</span>atom"</span></span><span class="main">]</span><span class="main">]</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">coercion</span> <span class="quoted"><span class="quoted">"atom<span class="main">::</span>var2<span class="main">⇒</span>atom"</span></span><span class="main">]</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">a</span><span class="main">::</span><span class="quoted"><span class="quoted">"var1"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">b</span><span class="main">::</span><span class="quoted"><span class="quoted">"var2"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">♯</span> <span class="free">t</span> <span class="main">∧</span> <span class="free">b</span> <span class="main">♯</span> <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">oops</span></span>


<span class="comment1">(* does not yet work: it needs image as
   coercion map *)</span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">as</span><span class="main">::</span><span class="quoted"><span class="quoted">"var1 set"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"atom <span class="main">`</span> <span class="free">as</span> <span class="main">♯*</span> <span class="free">t</span>"</span></span>

<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Eqvt">
<div class="head">
<h1>Theory Eqvt</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Nominal2_Eqvt
    Author:     Brian Huffman,
    Author:     Christian Urban

    Test cases for perm_simp
*)</span>
<span class="keyword1"><span class="command">theory</span></span> Eqvt
<span class="keyword2"><span class="keyword">imports</span></span> <a href="#Nominal2_Base">Nominal2_Base</a>
<span class="keyword2"><span class="keyword">begin</span></span>


<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">trace_eqvt</span> <span class="main"><span class="main">=</span></span> <span class="quasi_keyword">false</span><span class="main">]</span><span class="main">]</span>
<span class="comment1">(* declare [[trace_eqvt = true]] *)</span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">B</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>pt"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">B</span> <span class="main">=</span> <span class="free">C</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">perm_simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">B</span><span class="main">::</span><span class="quoted"><span class="quoted">"bool"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">B</span> <span class="main">=</span> <span class="free">C</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">perm_simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">B</span><span class="main">::</span><span class="quoted"><span class="quoted">"bool"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">A</span> <span class="main">⟶</span> <span class="free">B</span> <span class="main">=</span> <span class="free">C</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">perm_simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>pt<span class="main">)</span><span class="main">.</span> <span class="free">A</span> <span class="main">⟶</span> <span class="main">(</span><span class="free">B</span><span class="main">::</span><span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">C</span><span class="main">)</span> <span class="main">=</span> <span class="free">foo</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">perm_simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="main">λ</span><span class="bound">B</span><span class="main">::</span>bool<span class="main">.</span> <span class="free">A</span> <span class="main">⟶</span> <span class="main">(</span><span class="bound">B</span> <span class="main">=</span> <span class="free">C</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">foo</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">perm_simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="main">∃</span><span class="bound">z</span><span class="main">.</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">z</span> <span class="main">∧</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">y</span> <span class="main">⟶</span> <span class="bound">z</span> <span class="main">≠</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">foo</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">perm_simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="main">λ</span><span class="bound">f</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">f</span> <span class="main">(</span><span class="free">g</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">foo</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">perm_simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p</span> <span class="free">q</span><span class="main">::</span><span class="quoted"><span class="quoted">"perm"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="free">x</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>pt"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">q</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">foo</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">perm_simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p</span> <span class="free">q</span> <span class="free">r</span><span class="main">::</span><span class="quoted"><span class="quoted">"perm"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="free">x</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>pt"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">q</span> <span class="main">∙</span> <span class="free">r</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">foo</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">perm_simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p</span> <span class="free">r</span><span class="main">::</span><span class="quoted"><span class="quoted">"perm"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="main">λ</span><span class="bound">q</span><span class="main">::</span>perm<span class="main">.</span> <span class="bound">q</span> <span class="main">∙</span> <span class="main">(</span><span class="free">r</span> <span class="main">∙</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">foo</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">perm_simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">C</span> <span class="free">D</span><span class="main">::</span><span class="quoted"><span class="quoted">"bool"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">C</span> <span class="main">=</span> <span class="free">D</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">perm_simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">trace_eqvt</span> <span class="main"><span class="main">=</span></span> <span class="quasi_keyword">false</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹there is no raw eqvt-rule for The›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="keyword1">THE</span> <span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">foo</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">perm_strict_simp</span> <span class="quasi_keyword">exclude</span><span class="main"><span class="main">:</span></span> The<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">perm_simp</span> <span class="quasi_keyword">exclude</span><span class="main"><span class="main">:</span></span> The<span class="main">)</span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">P</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">::</span>pt<span class="main">)</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>pt<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="free">P</span> The<span class="main">)</span> <span class="main">=</span> <span class="free">foo</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">perm_simp</span> <span class="quasi_keyword">exclude</span><span class="main"><span class="main">:</span></span> The<span class="main">)</span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span>  <span class="free">P</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>pt<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">::</span>pt<span class="main">)</span> <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∙</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">.</span> <span class="free">P</span> <span class="bound">a</span> <span class="bound">b</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">p</span> <span class="main">∙</span> <span class="free">P</span><span class="main">)</span> <span class="bound">a</span> <span class="bound">b</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">perm_simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">thm</span></span> <span class="dynamic"><span class="dynamic">eqvts</span></span>
<span class="keyword1"><span class="command">thm</span></span> <span class="dynamic"><span class="dynamic">eqvts_raw</span></span>

<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹<span class="entity">Nominal_ThmDecls.is_eqvt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"supp"</span><span class="antiquote">}</span></span>›</span>


<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div>