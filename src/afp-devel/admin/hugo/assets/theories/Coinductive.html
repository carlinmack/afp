<div id="Coinductive_Nat">
<div class="head">
<h1>Theory Coinductive_Nat</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Coinductive natural numbers
    Author:      Andreas Lochbihler
    Maintainer:  Andreas Lochbihler
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Extended natural numbers as a codatatype›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Coinductive_Nat <span class="keyword2"><span class="keyword">imports</span></span>
  <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/Extended_Nat.html">HOL-Library.Extended_Nat</a>"</span>
  <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/Complete_Partial_Order2.html">HOL-Library.Complete_Partial_Order2</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Coinductive_Nat-inj_enat"><span class="command">lemma</span></span> inj_enat <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"inj_on enat <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inj_on_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-Sup_range_enat"><span class="command">lemma</span></span> Sup_range_enat <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Sup <span class="main">(</span>range enat<span class="main">)</span> <span class="main">=</span> <span class="main">∞</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> finite_imageD <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Sup_enat_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> eSuc_plus <span class="main">=</span> iadd_Suc

<span class="keyword1"><span class="command">lemmas</span></span> plus_enat_eq_0_conv <span class="main">=</span> iadd_is_0

<span class="keyword1" id="Coinductive_Nat-enat_add_sub_same"><span class="command">lemma</span></span> enat_add_sub_same<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">a</span> <span class="free">b</span> <span class="main">::</span> <span class="quoted">enat</span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">≠</span> <span class="main">∞</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">+</span> <span class="free">b</span> <span class="main">-</span> <span class="free">a</span> <span class="main">=</span> <span class="free">b</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">b</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_Nat-enat_the_enat"><span class="command">lemma</span></span> enat_the_enat<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≠</span> <span class="main">∞</span> <span class="main">⟹</span> enat <span class="main">(</span>the_enat <span class="free">n</span><span class="main">)</span> <span class="main">=</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_Nat-enat_min_eq_0_iff"><span class="command">lemma</span></span> enat_min_eq_0_iff<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">a</span> <span class="free">b</span> <span class="main">::</span> <span class="quoted">enat</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"min <span class="free">a</span> <span class="free">b</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟷</span> <span class="free">a</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∨</span> <span class="free">b</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> min_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-enat_le_plus_same"><span class="command">lemma</span></span> enat_le_plus_same<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≤</span> <span class="main">(</span><span class="free">x</span> <span class="main">::</span> enat<span class="main">)</span> <span class="main">+</span> <span class="free">y</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">+</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_eq_enat_def plus_enat_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> enat.split<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-the_enat_0"><span class="command">lemma</span></span> the_enat_0 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"the_enat <span class="main">0</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-the_enat_eSuc"><span class="command">lemma</span></span> the_enat_eSuc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≠</span> <span class="main">∞</span> <span class="main">⟹</span> the_enat <span class="main">(</span>eSuc <span class="free">n</span><span class="main">)</span> <span class="main">=</span> Suc <span class="main">(</span>the_enat <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eSuc_enat<span class="main">)</span>

<span class="keyword1"><span class="command">coinductive_set</span></span> <span class="entity">enat_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"enat set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">∈</span> <span class="free">enat_set</span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">∈</span> <span class="free">enat_set</span> <span class="main">⟹</span> <span class="main">(</span>eSuc <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">∈</span> <span class="free">enat_set</span>"</span></span>

<span class="keyword1" id="Coinductive_Nat-enat_set_eq_UNIV"><span class="command">lemma</span></span> enat_set_eq_UNIV <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"enat_set <span class="main">=</span> UNIV"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"enat_set <span class="main">⊆</span> UNIV"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"UNIV <span class="main">⊆</span> enat_set"</span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted">enat</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> UNIV"</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> enat_set"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">coinduct</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>enat_set <span class="skolem">x</span><span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> eSuc <span class="skolem">n</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eSuc_def zero_enat_def gr0_conv_Suc
                               <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> enat.splits<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Case operator›</span></span>

<span class="keyword1" id="Coinductive_Nat-enat_coexhaust"><span class="command">lemma</span></span> enat_coexhaust<span class="main">:</span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="main">(</span>0<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
     <span class="main">|</span> <span class="main">(</span>eSuc<span class="main">)</span> <span class="free">n'</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">=</span> eSuc <span class="free">n'</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">∈</span> enat_set"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="free">thesis</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">cases</span> <span class="main">(</span><span class="operator">erule</span> that<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">locale</span></span> co <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">free_constructors</span></span> <span class="main">(</span><span class="quasi_keyword">plugins</span> <span class="quasi_keyword">del</span><span class="main">:</span> code<span class="main">)</span> case_enat <span class="keyword2"><span class="keyword">for</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">0</span><span class="main">::</span>enat"</span></span>
  <span class="main">|</span> <span class="quoted">eSuc</span> <span class="free"><span class="entity">epred</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">epred</span> <span class="main">0</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> enat_coexhaust<span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> eSuc_inject<span class="main">)</span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> zero_ne_eSuc<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Coinductive_Nat-enat_cocase_0"><span class="command">lemma</span></span> enat_cocase_0 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"co.case_enat <span class="free">z</span> <span class="free">s</span> <span class="main">0</span> <span class="main">=</span> <span class="free">z</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> co.enat.case<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-enat_cocase_eSuc"><span class="command">lemma</span></span> enat_cocase_eSuc <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"co.case_enat <span class="free">z</span> <span class="free">s</span> <span class="main">(</span>eSuc <span class="free">n</span><span class="main">)</span> <span class="main">=</span> <span class="free">s</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> co.enat.case<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-neq_zero_conv_eSuc"><span class="command">lemma</span></span> neq_zero_conv_eSuc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">n'</span><span class="main">.</span> <span class="free">n</span> <span class="main">=</span> eSuc <span class="bound">n'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_coexhaust<span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_Nat-enat_cocase_cert"><span class="command">lemma</span></span> enat_cocase_cert<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">CASE</span> <span class="main">≡</span> co.case_enat <span class="free">c</span> <span class="free">d</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">CASE</span> <span class="main">0</span> <span class="main">≡</span> <span class="free">c</span><span class="main">)</span> <span class="main">&amp;&amp;&amp;</span> <span class="main">(</span><span class="free">CASE</span> <span class="main">(</span>eSuc <span class="free">n</span><span class="main">)</span> <span class="main">≡</span> <span class="free">d</span> <span class="free">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_Nat-enat_cosplit_asm"><span class="command">lemma</span></span> enat_cosplit_asm<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span>co.case_enat <span class="free">c</span> <span class="free">d</span> <span class="free">n</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">¬</span> <span class="main">(</span><span class="free">n</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∧</span> <span class="main">¬</span> <span class="free">P</span> <span class="free">c</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">m</span><span class="main">.</span> <span class="free">n</span> <span class="main">=</span> eSuc <span class="bound">m</span> <span class="main">∧</span> <span class="main">¬</span> <span class="free">P</span> <span class="main">(</span><span class="free">d</span> <span class="bound">m</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> co.enat.split_asm<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-enat_cosplit"><span class="command">lemma</span></span> enat_cosplit<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span>co.case_enat <span class="free">c</span> <span class="free">d</span> <span class="free">n</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="free">n</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟶</span> <span class="free">P</span> <span class="free">c</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">m</span><span class="main">.</span> <span class="free">n</span> <span class="main">=</span> eSuc <span class="bound">m</span> <span class="main">⟶</span> <span class="free">P</span> <span class="main">(</span><span class="free">d</span> <span class="bound">m</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> co.enat.split<span class="main">)</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">epred</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"enat <span class="main">=&gt;</span> enat"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">epred</span> <span class="main">≡</span> co.epred"</span></span>

<span class="keyword1" id="Coinductive_Nat-epred_0"><span class="command">lemma</span></span> epred_0 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"epred <span class="main">0</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> co.enat.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1" id="Coinductive_Nat-epred_eSuc"><span class="command">lemma</span></span> epred_eSuc <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"epred <span class="main">(</span>eSuc <span class="free">n</span><span class="main">)</span> <span class="main">=</span> <span class="free">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> co.enat.sel<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">declare</span></span> co.enat.collapse<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
<span class="keyword1" id="Coinductive_Nat-epred_conv_minus"><span class="command">lemma</span></span> epred_conv_minus<span class="main">:</span> <span class="quoted"><span class="quoted">"epred <span class="free">n</span> <span class="main">=</span> <span class="free">n</span> <span class="main">-</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> co.enat.exhaust<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Corecursion for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">enat</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1" id="Coinductive_Nat-case_enat_numeral"><span class="command">lemma</span></span> case_enat_numeral <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"case_enat <span class="free">f</span> <span class="free">i</span> <span class="main">(</span>numeral <span class="free">v</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">n</span> <span class="main">=</span> numeral <span class="free">v</span> <span class="keyword1">in</span> <span class="free">f</span> <span class="bound">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> numeral_eq_enat<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-case_enat_0"><span class="command">lemma</span></span> case_enat_0 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"case_enat <span class="free">f</span> <span class="free">i</span> <span class="main">0</span> <span class="main">=</span> <span class="free">f</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> max_eSuc_eSuc<span class="main">:</span> <span class="quoted"><span class="quoted">"max <span class="main">(</span>eSuc <span class="free">n</span><span class="main">)</span> <span class="main">(</span>eSuc <span class="free">m</span><span class="main">)</span> <span class="main">=</span> eSuc <span class="main">(</span>max <span class="free">n</span> <span class="free">m</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> min_eSuc_eSuc<span class="main">:</span> <span class="quoted"><span class="quoted">"min <span class="main">(</span>eSuc <span class="free">n</span><span class="main">)</span> <span class="main">(</span>eSuc <span class="free">m</span><span class="main">)</span> <span class="main">=</span> eSuc <span class="main">(</span>min <span class="free">n</span> <span class="free">m</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eSuc_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> enat.split<span class="main">)</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">epred_numeral</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"num <span class="main">⇒</span> enat"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">epred_numeral</span> <span class="main">=</span> enat <span class="main">∘</span> pred_numeral"</span></span>

<span class="keyword1" id="Coinductive_Nat-numeral_eq_eSuc"><span class="command">lemma</span></span> numeral_eq_eSuc<span class="main">:</span> <span class="quoted"><span class="quoted">"numeral <span class="free">k</span> <span class="main">=</span> eSuc <span class="main">(</span>epred_numeral <span class="free">k</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> numeral_eq_Suc eSuc_def epred_numeral_def numeral_eq_enat<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-epred_numeral_simps"><span class="command">lemma</span></span> epred_numeral_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"epred_numeral num.One <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="quoted"><span class="quoted">"epred_numeral <span class="main">(</span>num.Bit0 <span class="free">k</span><span class="main">)</span> <span class="main">=</span> numeral <span class="main">(</span>Num.BitM <span class="free">k</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"epred_numeral <span class="main">(</span>num.Bit1 <span class="free">k</span><span class="main">)</span> <span class="main">=</span> numeral <span class="main">(</span>num.Bit0 <span class="free">k</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> epred_numeral_def enat_numeral zero_enat_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> eq_numeral_eSuc<span class="main">:</span> <span class="quoted"><span class="quoted">"numeral <span class="free">k</span> <span class="main">=</span> eSuc <span class="free">n</span> <span class="main">⟷</span> epred_numeral <span class="free">k</span> <span class="main">=</span> <span class="free">n</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> Suc_eq_numeral<span class="main">:</span> <span class="quoted"><span class="quoted">"eSuc <span class="free">n</span> <span class="main">=</span> numeral <span class="free">k</span> <span class="main">⟷</span> <span class="free">n</span> <span class="main">=</span> epred_numeral <span class="free">k</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> less_numeral_Suc<span class="main">:</span> <span class="quoted"><span class="quoted">"numeral <span class="free">k</span> <span class="main">&lt;</span> eSuc <span class="free">n</span> <span class="main">⟷</span> epred_numeral <span class="free">k</span> <span class="main">&lt;</span> <span class="free">n</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> less_eSuc_numeral<span class="main">:</span> <span class="quoted"><span class="quoted">"eSuc <span class="free">n</span> <span class="main">&lt;</span> numeral <span class="free">k</span> <span class="main">⟷</span> <span class="free">n</span> <span class="main">&lt;</span> epred_numeral <span class="free">k</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> le_numeral_eSuc<span class="main">:</span> <span class="quoted"><span class="quoted">"numeral <span class="free">k</span> <span class="main">≤</span> eSuc <span class="free">n</span> <span class="main">⟷</span> epred_numeral <span class="free">k</span> <span class="main">≤</span> <span class="free">n</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> le_eSuc_numeral<span class="main">:</span> <span class="quoted"><span class="quoted">"eSuc <span class="free">n</span> <span class="main">≤</span> numeral <span class="free">k</span> <span class="main">⟷</span> <span class="free">n</span> <span class="main">≤</span> epred_numeral <span class="free">k</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> diff_eSuc_numeral<span class="main">:</span> <span class="quoted"><span class="quoted">"eSuc <span class="free">n</span> <span class="main">-</span> numeral <span class="free">k</span> <span class="main">=</span> <span class="free">n</span> <span class="main">-</span> epred_numeral <span class="free">k</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> diff_numeral_eSuc<span class="main">:</span> <span class="quoted"><span class="quoted">"numeral <span class="free">k</span> <span class="main">-</span> eSuc <span class="free">n</span> <span class="main">=</span> epred_numeral <span class="free">k</span> <span class="main">-</span> <span class="free">n</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> max_eSuc_numeral<span class="main">:</span> <span class="quoted"><span class="quoted">"max <span class="main">(</span>eSuc <span class="free">n</span><span class="main">)</span> <span class="main">(</span>numeral <span class="free">k</span><span class="main">)</span> <span class="main">=</span> eSuc <span class="main">(</span>max <span class="free">n</span> <span class="main">(</span>epred_numeral <span class="free">k</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> max_numeral_eSuc<span class="main">:</span> <span class="quoted"><span class="quoted">"max <span class="main">(</span>numeral <span class="free">k</span><span class="main">)</span> <span class="main">(</span>eSuc <span class="free">n</span><span class="main">)</span> <span class="main">=</span> eSuc <span class="main">(</span>max <span class="main">(</span>epred_numeral <span class="free">k</span><span class="main">)</span> <span class="free">n</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> min_eSuc_numeral<span class="main">:</span> <span class="quoted"><span class="quoted">"min <span class="main">(</span>eSuc <span class="free">n</span><span class="main">)</span> <span class="main">(</span>numeral <span class="free">k</span><span class="main">)</span> <span class="main">=</span> eSuc <span class="main">(</span>min <span class="free">n</span> <span class="main">(</span>epred_numeral <span class="free">k</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> min_numeral_eSuc<span class="main">:</span> <span class="quoted"><span class="quoted">"min <span class="main">(</span>numeral <span class="free">k</span><span class="main">)</span> <span class="main">(</span>eSuc <span class="free">n</span><span class="main">)</span> <span class="main">=</span> eSuc <span class="main">(</span>min <span class="main">(</span>epred_numeral <span class="free">k</span><span class="main">)</span> <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> numeral_eq_eSuc<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-enat_cocase_numeral"><span class="command">lemma</span></span> enat_cocase_numeral <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"co.case_enat <span class="free">a</span> <span class="free">f</span> <span class="main">(</span>numeral <span class="free">v</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">pv</span> <span class="main">=</span> epred_numeral <span class="free">v</span> <span class="keyword1">in</span> <span class="free">f</span> <span class="bound">pv</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> numeral_eq_eSuc<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-enat_cocase_add_eq_if"><span class="command">lemma</span></span> enat_cocase_add_eq_if <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"co.case_enat <span class="free">a</span> <span class="free">f</span> <span class="main">(</span><span class="main">(</span>numeral <span class="free">v</span><span class="main">)</span> <span class="main">+</span> <span class="free">n</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">pv</span> <span class="main">=</span> epred_numeral <span class="free">v</span> <span class="keyword1">in</span> <span class="free">f</span> <span class="main">(</span><span class="bound">pv</span> <span class="main">+</span> <span class="free">n</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> numeral_eq_eSuc iadd_Suc<span class="main">)</span>


<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> epred_1<span class="main">:</span> <span class="quoted"><span class="quoted">"epred <span class="main">1</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> epred_numeral<span class="main">:</span> <span class="quoted"><span class="quoted">"epred <span class="main">(</span>numeral <span class="free">i</span><span class="main">)</span> <span class="main">=</span> epred_numeral <span class="free">i</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> epred_Infty<span class="main">:</span> <span class="quoted"><span class="quoted">"epred <span class="main">∞</span> <span class="main">=</span> <span class="main">∞</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> epred_enat<span class="main">:</span> <span class="quoted"><span class="quoted">"epred <span class="main">(</span>enat <span class="free">m</span><span class="main">)</span> <span class="main">=</span> enat <span class="main">(</span><span class="free">m</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> epred_conv_minus one_enat_def zero_enat_def eSuc_def epred_numeral_def numeral_eq_enat <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> enat.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> epred_simps <span class="main">=</span> epred_0 epred_1 epred_numeral epred_eSuc epred_Infty epred_enat

<span class="keyword1" id="Coinductive_Nat-epred_iadd1"><span class="command">lemma</span></span> epred_iadd1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">⟹</span> epred <span class="main">(</span><span class="free">a</span> <span class="main">+</span> <span class="free">b</span><span class="main">)</span> <span class="main">=</span> epred <span class="free">a</span> <span class="main">+</span> <span class="free">b</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">a</span></span> <span class="quoted"><span class="free">b</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat.exhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> enat.exhaust<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> epred_conv_minus eSuc_def one_enat_def zero_enat_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> enat.splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Coinductive_Nat-epred_min"><span class="command">lemma</span></span> epred_min <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"epred <span class="main">(</span>min <span class="free">a</span> <span class="free">b</span><span class="main">)</span> <span class="main">=</span> min <span class="main">(</span>epred <span class="free">a</span><span class="main">)</span> <span class="main">(</span>epred <span class="free">b</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">a</span></span> <span class="quoted"><span class="free">b</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_coexhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> enat_coexhaust<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_Nat-epred_le_epredI"><span class="command">lemma</span></span> epred_le_epredI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≤</span> <span class="free">m</span> <span class="main">⟹</span> epred <span class="free">n</span> <span class="main">≤</span> epred <span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">m</span></span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_coexhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> enat_coexhaust<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_Nat-epred_minus_epred"><span class="command">lemma</span></span> epred_minus_epred <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">⟹</span> epred <span class="free">n</span> <span class="main">-</span> epred <span class="free">m</span> <span class="main">=</span> <span class="free">n</span> <span class="main">-</span> <span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">m</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_coexhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> enat_coexhaust<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> epred_conv_minus<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-eSuc_epred"><span class="command">lemma</span></span> eSuc_epred<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">⟹</span> eSuc <span class="main">(</span>epred <span class="free">n</span><span class="main">)</span> <span class="main">=</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_coexhaust<span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_Nat-epred_inject"><span class="command">lemma</span></span> epred_inject<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">x</span> <span class="main">≠</span> <span class="main">0</span><span class="main">;</span> <span class="free">y</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">⟧</span> <span class="main">⟹</span> epred <span class="free">x</span> <span class="main">=</span> epred <span class="free">y</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">y</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat.exhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> enat.exhaust<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-monotone_fun_eSuc"><span class="command">lemma</span></span> monotone_fun_eSuc<span class="main">[</span><span class="operator">partial_function_mono</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"monotone <span class="main">(</span>fun_ord <span class="main">(</span><span class="main">λ</span><span class="bound">y</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">y</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> eSuc <span class="main">(</span><span class="bound">f</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> monotone_def fun_ord_def<span class="main">)</span>

<span class="keyword1"><span class="command">partial_function</span></span> <span class="main">(</span>gfp<span class="main">)</span> <span class="entity">enat_unfold</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> enat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  enat_unfold <span class="main">[</span><span class="operator">code</span><span class="main">,</span> <span class="operator">nitpick_simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">enat_unfold</span> <span class="free"><span class="bound"><span class="entity">stop</span></span></span> <span class="free"><span class="bound"><span class="entity">next</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">stop</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> eSuc <span class="main">(</span><span class="free">enat_unfold</span> <span class="free"><span class="bound"><span class="entity">stop</span></span></span> <span class="free"><span class="bound"><span class="entity">next</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">next</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Coinductive_Nat-enat_unfold_stop"><span class="command">lemma</span></span> enat_unfold_stop <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">stop</span> <span class="free">a</span> <span class="main">⟹</span> enat_unfold <span class="free">stop</span> <span class="free">next</span> <span class="free">a</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> enat_unfold<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-enat_unfold_next"><span class="command">lemma</span></span> enat_unfold_next<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">stop</span> <span class="free">a</span> <span class="main">⟹</span> enat_unfold <span class="free">stop</span> <span class="free">next</span> <span class="free">a</span> <span class="main">=</span> eSuc <span class="main">(</span>enat_unfold <span class="free">stop</span> <span class="free">next</span> <span class="main">(</span><span class="free">next</span> <span class="free">a</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> enat_unfold<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-enat_unfold_eq_0"><span class="command">lemma</span></span> enat_unfold_eq_0 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"enat_unfold <span class="free">stop</span> <span class="free">next</span> <span class="free">a</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟷</span> <span class="free">stop</span> <span class="free">a</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> enat_unfold<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-epred_enat_unfold"><span class="command">lemma</span></span> epred_enat_unfold <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"epred <span class="main">(</span>enat_unfold <span class="free">stop</span> <span class="free">next</span> <span class="free">a</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">stop</span> <span class="free">a</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> enat_unfold <span class="free">stop</span> <span class="free">next</span> <span class="main">(</span><span class="free">next</span> <span class="free">a</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> enat_unfold_next<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-epred_max"><span class="command">lemma</span></span> epred_max<span class="main">:</span> <span class="quoted"><span class="quoted">"epred <span class="main">(</span>max <span class="free">x</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> max <span class="main">(</span>epred <span class="free">x</span><span class="main">)</span> <span class="main">(</span>epred <span class="free">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">y</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat.exhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> enat.exhaust<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_Nat-epred_Max"><span class="command">lemma</span></span> epred_Max<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"epred <span class="main">(</span>Max <span class="free">A</span><span class="main">)</span> <span class="main">=</span> Max <span class="main">(</span>epred <span class="main">`</span> <span class="free">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">induction</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>insert <span class="skolem">x</span> <span class="skolem">A</span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">=</span> <span class="main">{}</span>"</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> epred_max<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_Nat-finite_imageD2"><span class="command">lemma</span></span> finite_imageD2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> finite <span class="main">(</span><span class="free">f</span> <span class="main">`</span> <span class="free">A</span><span class="main">)</span><span class="main">;</span> inj_on <span class="free">f</span> <span class="main">(</span><span class="free">A</span> <span class="main">-</span> <span class="free">B</span><span class="main">)</span><span class="main">;</span> finite <span class="free">B</span> <span class="main">⟧</span> <span class="main">⟹</span> finite <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Diff_subset finite_Diff2 image_mono inj_on_finite<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-epred_Sup"><span class="command">lemma</span></span> epred_Sup<span class="main">:</span> <span class="quoted"><span class="quoted">"epred <span class="main">(</span>Sup <span class="free">A</span><span class="main">)</span> <span class="main">=</span> Sup <span class="main">(</span>epred <span class="main">`</span> <span class="free">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 4 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bot_enat_def Sup_enat_def epred_Max inj_on_def neq_zero_conv_eSuc <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> finite_imageD2<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> B<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">0</span><span class="main">}</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Less as greatest fixpoint›</span></span>

<span class="keyword1"><span class="command">coinductive_set</span></span> <span class="entity">Le_enat</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>enat <span class="main">×</span> enat<span class="main">)</span> set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  Le_enat_zero<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">∈</span> <span class="free">Le_enat</span>"</span></span>
<span class="main">|</span> Le_enat_add<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">∈</span> <span class="free">Le_enat</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">≠</span> <span class="main">0</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span>eSuc <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">+</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">)</span> <span class="main">∈</span> <span class="free">Le_enat</span>"</span></span>

<span class="keyword1" id="Coinductive_Nat-ile_into_Le_enat"><span class="command">lemma</span></span> ile_into_Le_enat<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">≤</span> <span class="free">n</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">m</span><span class="main">,</span> <span class="free">n</span><span class="main">)</span> <span class="main">∈</span> Le_enat"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">≤</span> <span class="free">n</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">m</span><span class="main">,</span> <span class="free">n</span><span class="main">)</span> <span class="main">∈</span> <span class="main">{</span><span class="main">(</span><span class="bound">m</span><span class="main">,</span> <span class="bound">n</span><span class="main">)</span><span class="main">|</span><span class="bound">m</span> <span class="bound">n</span><span class="main">.</span> <span class="bound">m</span> <span class="main">≤</span> <span class="bound">n</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">coinduct</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Le_enat <span class="skolem">m</span> <span class="skolem">n</span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">≤</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">hence</span></span> <span class="var"><span class="quoted"><span class="var">?Le_enat_zero</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">m</span> <span class="main">≤</span> <span class="skolem">n</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">m'</span></span> <span class="skolem"><span class="skolem">n'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">=</span> eSuc <span class="skolem">m'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">=</span> <span class="skolem">n'</span> <span class="main">+</span> <span class="main">1</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m'</span> <span class="main">≤</span> <span class="skolem">n'</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">m</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_coexhaust<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
          <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_coexhaust<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eSuc_plus_1<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="var"><span class="quoted"><span class="var">?Le_enat_add</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_Nat-Le_enat_imp_ile_enat_k"><span class="command">lemma</span></span> Le_enat_imp_ile_enat_k<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">m</span><span class="main">,</span> <span class="free">n</span><span class="main">)</span> <span class="main">∈</span> Le_enat <span class="main">⟹</span> <span class="free">n</span> <span class="main">&lt;</span> enat <span class="free">l</span> <span class="main">⟹</span> <span class="free">m</span> <span class="main">&lt;</span> enat <span class="free">l</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">l</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">m</span></span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">l</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">m</span><span class="main">,</span> <span class="skolem">n</span><span class="main">)</span> <span class="main">∈</span> Le_enat›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
    <span class="keyword3"><span class="command">case</span></span> Le_enat_zero
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">n</span> <span class="main">&lt;</span> enat <span class="main">(</span>Suc <span class="skolem">l</span><span class="main">)</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Le_enat_add <span class="skolem">M</span> <span class="skolem">N</span> <span class="skolem">K</span><span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">n</span> <span class="main">=</span> <span class="skolem">N</span> <span class="main">+</span> <span class="skolem">K</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">n</span> <span class="main">&lt;</span> enat <span class="main">(</span>Suc <span class="skolem">l</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">K</span> <span class="main">≠</span> <span class="main">0</span>›</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">N</span> <span class="main">&lt;</span> enat <span class="skolem">l</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">N</span></span><span class="main">)</span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">K</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">M</span><span class="main">,</span> <span class="skolem">N</span><span class="main">)</span> <span class="main">∈</span> Le_enat›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">M</span> <span class="main">&lt;</span> enat <span class="skolem">l</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> Suc<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">m</span> <span class="main">=</span> eSuc <span class="skolem">M</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eSuc_enat<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_Nat-enat_less_imp_le"><span class="command">lemma</span></span> enat_less_imp_le<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> k<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">!!</span><span class="bound">k</span><span class="main">.</span> <span class="free">n</span> <span class="main">&lt;</span> enat <span class="bound">k</span> <span class="main">⟹</span> <span class="free">m</span> <span class="main">&lt;</span> enat <span class="bound">k</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">≤</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>enat <span class="skolem">n'</span><span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> k<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"Suc <span class="skolem">n'</span>"</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">m</span></span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_Nat-Le_enat_imp_ile"><span class="command">lemma</span></span> Le_enat_imp_ile<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">m</span><span class="main">,</span> <span class="free">n</span><span class="main">)</span> <span class="main">∈</span> Le_enat <span class="main">⟹</span> <span class="free">m</span> <span class="main">≤</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> enat_less_imp_le<span class="main">)</span><span class="main">(</span><span class="operator">erule</span> Le_enat_imp_ile_enat_k<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-Le_enat_eq_ile"><span class="command">lemma</span></span> Le_enat_eq_ile<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">m</span><span class="main">,</span> <span class="free">n</span><span class="main">)</span> <span class="main">∈</span> Le_enat <span class="main">⟷</span> <span class="free">m</span> <span class="main">≤</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> Le_enat_imp_ile ile_into_Le_enat<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-enat_leI"><span class="command">lemma</span></span> enat_leI <span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> Leenat<span class="main">,</span> <span class="operator">case_conclusion</span> Leenat zero eSuc<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> major<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">m</span><span class="main">,</span> <span class="free">n</span><span class="main">)</span> <span class="main">∈</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> step<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">m</span> <span class="bound">n</span><span class="main">.</span> <span class="main">(</span><span class="bound">m</span><span class="main">,</span> <span class="bound">n</span><span class="main">)</span> <span class="main">∈</span> <span class="free">X</span> 
     <span class="main">⟹</span> <span class="bound">m</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">m'</span> <span class="bound">n'</span> <span class="bound">k</span><span class="main">.</span> <span class="bound">m</span> <span class="main">=</span> eSuc <span class="bound">m'</span> <span class="main">∧</span> <span class="bound">n</span> <span class="main">=</span> <span class="bound">n'</span> <span class="main">+</span> enat <span class="bound">k</span> <span class="main">∧</span> <span class="bound">k</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">∧</span>
                           <span class="main">(</span><span class="main">(</span><span class="bound">m'</span><span class="main">,</span> <span class="bound">n'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">X</span> <span class="main">∨</span> <span class="bound">m'</span> <span class="main">≤</span> <span class="bound">n'</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">≤</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> Le_enat.coinduct<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> Le_enat_eq_ile<span class="main"><span class="main">,</span></span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> X<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">x</span></span> <span class="bound"><span class="bound">y</span></span><span class="main"><span class="main">.</span></span> <span class="main"><span class="main">(</span></span><span class="bound"><span class="bound">x</span></span><span class="main"><span class="main">,</span></span> <span class="bound"><span class="bound">y</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">∈</span></span> <span class="free"><span class="free">X</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> step <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> major<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Coinductive_Nat-enat_le_coinduct"><span class="command">lemma</span></span> enat_le_coinduct<span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> le<span class="main">,</span> <span class="operator">case_conclusion</span> le 0 eSuc<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> P<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">m</span> <span class="free">n</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> step<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">m</span> <span class="bound">n</span><span class="main">.</span> <span class="free">P</span> <span class="bound">m</span> <span class="bound">n</span> 
     <span class="main">⟹</span> <span class="main">(</span><span class="bound">n</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟶</span> <span class="bound">m</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span> <span class="main">∧</span>
         <span class="main">(</span><span class="bound">m</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">⟶</span> <span class="bound">n</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">k</span> <span class="bound">n'</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span>epred <span class="bound">m</span><span class="main">)</span> <span class="bound">n'</span> <span class="main">∧</span> epred <span class="bound">n</span> <span class="main">=</span> <span class="bound">n'</span> <span class="main">+</span> <span class="bound">k</span><span class="main">)</span> <span class="main">∨</span> epred <span class="bound">m</span> <span class="main">≤</span> epred <span class="bound">n</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">≤</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> P <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">m</span><span class="main">,</span> <span class="free">n</span><span class="main">)</span> <span class="main">∈</span> <span class="main">{</span><span class="main">(</span><span class="bound">m</span><span class="main">,</span> <span class="bound">n</span><span class="main">)</span><span class="main">.</span> <span class="free">P</span> <span class="bound">m</span> <span class="bound">n</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_leI<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Leenat <span class="skolem">m</span> <span class="skolem">n</span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="skolem">m</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">m</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_coexhaust<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> 0 
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>eSuc <span class="skolem">m'</span><span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> step<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="free">P</span> <span class="skolem">m</span> <span class="skolem">n</span>›</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> disj<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">k</span> <span class="bound">n'</span><span class="main">.</span> <span class="free">P</span> <span class="skolem">m'</span> <span class="bound">n'</span> <span class="main">∧</span> epred <span class="skolem">n</span> <span class="main">=</span> <span class="bound">n'</span> <span class="main">+</span> <span class="bound">k</span><span class="main">)</span> <span class="main">∨</span> <span class="skolem">m'</span> <span class="main">≤</span> epred <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">n</span> <span class="main">≠</span> <span class="main">0</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">n'</span></span> <span class="keyword2"><span class="keyword">where</span></span> n'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">=</span> eSuc <span class="skolem">n'</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_coexhaust<span class="main">)</span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> disj <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m'</span> <span class="main">≤</span> epred <span class="skolem">n</span>"</span></span>
        <span class="keyword1"><span class="command">with</span></span> eSuc n' <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
          <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"Suc <span class="main">0</span>"</span></span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eSuc_enat<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> iadd_Suc_right zero_enat_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">k</span> <span class="bound">n'</span><span class="main">.</span> <span class="free">P</span> <span class="skolem">m'</span> <span class="bound">n'</span> <span class="main">∧</span> epred <span class="skolem">n</span> <span class="main">=</span> <span class="bound">n'</span> <span class="main">+</span> <span class="bound">k</span>"</span></span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">k</span></span> <span class="skolem"><span class="skolem">n''</span></span> <span class="keyword2"><span class="keyword">where</span></span> n''<span class="main">:</span> <span class="quoted"><span class="quoted">"epred <span class="skolem">n</span> <span class="main">=</span> <span class="skolem">n''</span> <span class="main">+</span> <span class="skolem">k</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> k<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="skolem">m'</span> <span class="skolem">n''</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> eSuc k n' n''
          <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">k</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> iadd_Suc_right<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> eSuc_enat <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="main">∞</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Equality as greatest fixpoint›</span></span>

<span class="keyword1" id="Coinductive_Nat-enat_equalityI"><span class="command">lemma</span></span> enat_equalityI <span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> Eq_enat<span class="main">,</span>
                                  <span class="operator">case_conclusion</span> Eq_enat zero eSuc<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> major<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">m</span><span class="main">,</span> <span class="free">n</span><span class="main">)</span> <span class="main">∈</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> step<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">m</span> <span class="bound">n</span><span class="main">.</span> <span class="main">(</span><span class="bound">m</span><span class="main">,</span> <span class="bound">n</span><span class="main">)</span> <span class="main">∈</span> <span class="free">X</span>
     <span class="main">⟹</span> <span class="bound">m</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∧</span> <span class="bound">n</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">m'</span> <span class="bound">n'</span><span class="main">.</span> <span class="bound">m</span> <span class="main">=</span> eSuc <span class="bound">m'</span> <span class="main">∧</span> <span class="bound">n</span> <span class="main">=</span> eSuc <span class="bound">n'</span> <span class="main">∧</span> <span class="main">(</span><span class="main">(</span><span class="bound">m'</span><span class="main">,</span> <span class="bound">n'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">X</span> <span class="main">∨</span> <span class="bound">m'</span> <span class="main">=</span> <span class="bound">n'</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">=</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> antisym<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> major <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">≤</span> <span class="free">n</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_leI<span class="main">)</span>
      <span class="main">(</span><span class="operator">drule</span> step<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eSuc_plus_1 enat_1<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

  <span class="keyword1"><span class="command">from</span></span> major <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">n</span><span class="main">,</span> <span class="free">m</span><span class="main">)</span> <span class="main">∈</span> <span class="main">{</span><span class="main">(</span><span class="bound">n</span><span class="main">,</span> <span class="bound">m</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">m</span><span class="main">,</span> <span class="bound">n</span><span class="main">)</span> <span class="main">∈</span> <span class="free">X</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≤</span> <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_leI<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Leenat <span class="skolem">n</span> <span class="skolem">m</span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">m</span><span class="main">,</span> <span class="skolem">n</span><span class="main">)</span> <span class="main">∈</span> <span class="free">X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> step<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eSuc_plus_1 enat_1<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_Nat-enat_coinduct"><span class="command">lemma</span></span> enat_coinduct <span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> Eq_enat<span class="main">,</span> <span class="operator">case_conclusion</span> Eq_enat zero eSuc<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> major<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">m</span> <span class="free">n</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> step<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">m</span> <span class="bound">n</span><span class="main">.</span> <span class="free">P</span> <span class="bound">m</span> <span class="bound">n</span> 
    <span class="main">⟹</span> <span class="main">(</span><span class="bound">m</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟷</span> <span class="bound">n</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span> <span class="main">∧</span>
       <span class="main">(</span><span class="bound">m</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">⟶</span> <span class="bound">n</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">⟶</span> <span class="free">P</span> <span class="main">(</span>epred <span class="bound">m</span><span class="main">)</span> <span class="main">(</span>epred <span class="bound">n</span><span class="main">)</span> <span class="main">∨</span> epred <span class="bound">m</span> <span class="main">=</span> epred <span class="bound">n</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">=</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> major <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">m</span><span class="main">,</span> <span class="free">n</span><span class="main">)</span> <span class="main">∈</span> <span class="main">{</span><span class="main">(</span><span class="bound">m</span><span class="main">,</span> <span class="bound">n</span><span class="main">)</span><span class="main">.</span> <span class="free">P</span> <span class="bound">m</span> <span class="bound">n</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_equalityI<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Eq_enat <span class="skolem">m</span> <span class="skolem">n</span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="skolem">m</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> step<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">m</span></span> <span class="quoted"><span class="skolem">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_coexhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> enat_coexhaust<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_Nat-enat_coinduct2"><span class="command">lemma</span></span> enat_coinduct2 <span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> zero eSuc<span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">P</span> <span class="free">m</span> <span class="free">n</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">m</span> <span class="bound">n</span><span class="main">.</span> <span class="free">P</span> <span class="bound">m</span> <span class="bound">n</span> <span class="main">⟹</span> <span class="bound">m</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟷</span> <span class="bound">n</span> <span class="main">=</span> <span class="main">0</span><span class="main">;</span> 
     <span class="main">⋀</span><span class="bound">m</span> <span class="bound">n</span><span class="main">.</span> <span class="main">⟦</span> <span class="free">P</span> <span class="bound">m</span> <span class="bound">n</span><span class="main">;</span> <span class="bound">m</span> <span class="main">≠</span> <span class="main">0</span><span class="main">;</span> <span class="bound">n</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span>epred <span class="bound">m</span><span class="main">)</span> <span class="main">(</span>epred <span class="bound">n</span><span class="main">)</span> <span class="main">∨</span> epred <span class="bound">m</span> <span class="main">=</span> epred <span class="bound">n</span> <span class="main">⟧</span>
  <span class="main">⟹</span> <span class="free">m</span> <span class="main">=</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">erule</span> enat_coinduct<span class="main">)</span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Uniqueness of corecursion›</span></span>

<span class="keyword1" id="Coinductive_Nat-enat_unfold_unique"><span class="command">lemma</span></span> enat_unfold_unique<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> h<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">!!</span><span class="bound">x</span><span class="main">.</span> <span class="free">h</span> <span class="bound">x</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">stop</span> <span class="bound">x</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> eSuc <span class="main">(</span><span class="free">h</span> <span class="main">(</span><span class="free">next</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="free">x</span> <span class="main">=</span> enat_unfold <span class="free">stop</span> <span class="free">next</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_coinduct<span class="main">)</span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 3<span class="main"><span class="main">)</span></span> h<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Setup for partial\_function›</span></span>

<span class="keyword1" id="Coinductive_Nat-enat_diff_cancel_left"><span class="command">lemma</span></span> enat_diff_cancel_left<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">m</span> <span class="main">≤</span> <span class="free">x</span><span class="main">;</span> <span class="free">m</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">-</span> <span class="free">m</span> <span class="main">=</span> <span class="free">y</span> <span class="main">-</span> <span class="free">m</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">y</span> <span class="main">::</span> enat<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">y</span></span> <span class="quoted"><span class="free">m</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat.exhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> enat.exhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> enat.exhaust<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">arith</span><span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-finite_lessThan_enatI"><span class="command">lemma</span></span> finite_lessThan_enatI<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">≠</span> <span class="main">∞</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">{..&lt;</span><span class="free">m</span> <span class="main">::</span> enat<span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">m'</span></span> <span class="keyword2"><span class="keyword">where</span></span> m<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">=</span> enat <span class="skolem">m'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{..&lt;</span>enat <span class="skolem">m'</span><span class="main">}</span> <span class="main">⊆</span> enat <span class="main">`</span> <span class="main">{..&lt;</span><span class="skolem">m'</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> subsetI<span class="main">)</span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> m <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main">)</span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_Nat-infinite_lessThan_infty"><span class="command">lemma</span></span> infinite_lessThan_infty<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> finite <span class="main">{..&lt;</span><span class="main">∞</span> <span class="main">::</span> enat<span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"range enat <span class="main">⊆</span> <span class="main">{..&lt;</span><span class="main">∞</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">{..&lt;</span><span class="main">∞</span> <span class="main">::</span> enat<span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>range enat<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">::</span> nat set<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> finite_imageD<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inj_on_def<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_Nat-finite_lessThan_enat_iff"><span class="command">lemma</span></span> finite_lessThan_enat_iff<span class="main">:</span>
  <span class="quoted"><span class="quoted">"finite <span class="main">{..&lt;</span><span class="free">m</span> <span class="main">::</span> enat<span class="main">}</span> <span class="main">⟷</span> <span class="free">m</span> <span class="main">≠</span> <span class="main">∞</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">m</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_lessThan_enatI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> infinite_lessThan_infty<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-enat_minus_mono1"><span class="command">lemma</span></span> enat_minus_mono1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">-</span> <span class="free">m</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">-</span> <span class="main">(</span><span class="free">m</span> <span class="main">::</span> enat<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">m</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">y</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat.exhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> enat.exhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> enat.exhaust<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_Nat-max_enat_minus1"><span class="command">lemma</span></span> max_enat_minus1<span class="main">:</span> <span class="quoted"><span class="quoted">"max <span class="free">n</span> <span class="free">m</span> <span class="main">-</span> <span class="free">k</span> <span class="main">=</span> max <span class="main">(</span><span class="free">n</span> <span class="main">-</span> <span class="free">k</span><span class="main">)</span> <span class="main">(</span><span class="free">m</span> <span class="main">-</span> <span class="free">k</span> <span class="main">::</span> enat<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">m</span></span> <span class="quoted"><span class="free">k</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat.exhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> enat.exhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> enat.exhaust<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_Nat-Max_enat_minus1"><span class="command">lemma</span></span> Max_enat_minus1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Max <span class="free">A</span> <span class="main">-</span> <span class="free">m</span> <span class="main">=</span> Max <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">n</span> <span class="main">::</span> enat<span class="main">.</span> <span class="bound">n</span> <span class="main">-</span> <span class="free">m</span><span class="main">)</span> <span class="main">`</span> <span class="free">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">proof</span></span> <span class="operator">induct</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>insert <span class="skolem">x</span> <span class="skolem">A</span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">=</span> <span class="main">{}</span>"</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> max_enat_minus1<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_Nat-Sup_enat_minus1"><span class="command">lemma</span></span> Sup_enat_minus1<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">≠</span> <span class="main">∞</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">⨆</span><span class="free">A</span> <span class="main">-</span> <span class="free">m</span> <span class="main">=</span> <span class="main">⨆</span><span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">n</span> <span class="main">::</span> enat<span class="main">.</span> <span class="bound">n</span> <span class="main">-</span> <span class="free">m</span><span class="main">)</span> <span class="main">`</span> <span class="free">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">m'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">=</span> enat <span class="skolem">m'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Sup_enat_def Max_enat_minus1 finite_lessThan_enat_iff enat_diff_cancel_left inj_on_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> finite_imageD2<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> B<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">{..&lt;</span>enat <span class="skolem">m'</span><span class="main">}</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_Nat-Sup_image_eadd1"><span class="command">lemma</span></span> Sup_image_eadd1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">Y</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Sup <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">y</span> <span class="main">::</span> enat<span class="main">.</span> <span class="bound">y</span><span class="main">+</span><span class="free">x</span><span class="main">)</span> <span class="main">`</span> <span class="free">Y</span><span class="main">)</span> <span class="main">=</span> Sup <span class="free">Y</span> <span class="main">+</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"finite <span class="free">Y</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Sup_enat_def Max_add_commute assms<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>enat <span class="skolem">x'</span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> finite <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="bound">y</span><span class="main">+</span><span class="free">x</span><span class="main">)</span> <span class="main">`</span> <span class="free">Y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> False
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> finite_imageD <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> inj_onI<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> False <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Sup_enat_def assms<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> infinity
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(+)</span> <span class="free">x</span> <span class="main">`</span> <span class="free">Y</span> <span class="main">=</span> <span class="main">{</span><span class="main">∞</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> infinity <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> image_constant_conv assms<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_Nat-Sup_image_eadd2"><span class="command">lemma</span></span> Sup_image_eadd2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">Y</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">⟹</span> Sup <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">y</span> <span class="main">::</span> enat<span class="main">.</span> <span class="free">x</span> <span class="main">+</span> <span class="bound">y</span><span class="main">)</span> <span class="main">`</span> <span class="free">Y</span><span class="main">)</span> <span class="main">=</span> <span class="free">x</span> <span class="main">+</span> Sup <span class="free">Y</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Sup_image_eadd1 add.commute<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-mono2mono_eSuc"><span class="command">lemma</span></span> mono2mono_eSuc <span class="main">[</span><span class="operator">THEN</span> lfp.mono2mono<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> monotone_eSuc<span class="main">:</span> <span class="quoted"><span class="quoted">"monotone <span class="main">(≤)</span> <span class="main">(≤)</span> eSuc"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monotoneI<span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_Nat-mcont2mcont_eSuc"><span class="command">lemma</span></span> mcont2mcont_eSuc <span class="main">[</span><span class="operator">THEN</span> lfp.mcont2mcont<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> mcont_eSuc<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont Sup <span class="main">(≤)</span> Sup <span class="main">(≤)</span> eSuc"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> mcontI contI<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> monotone_eSuc eSuc_Sup<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-mono2mono_epred"><span class="command">lemma</span></span> mono2mono_epred <span class="main">[</span><span class="operator">THEN</span> lfp.mono2mono<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> monotone_epred<span class="main">:</span> <span class="quoted"><span class="quoted">"monotone <span class="main">(≤)</span> <span class="main">(≤)</span> epred"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monotoneI<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> epred_le_epredI<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-mcont2mcont_epred"><span class="command">lemma</span></span> mcont2mcont_epred <span class="main">[</span><span class="operator">THEN</span> lfp.mcont2mcont<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> mcont_epred<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont Sup <span class="main">(≤)</span> Sup <span class="main">(≤)</span> epred"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mcont_def monotone_epred cont_def epred_Sup<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-enat_cocase_mono"><span class="command">lemma</span></span> enat_cocase_mono <span class="main">[</span><span class="operator">partial_function_mono</span><span class="main">,</span> <span class="operator">cont_intro</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> monotone <span class="free">orda</span> <span class="free">ordb</span> <span class="free">zero</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">n</span><span class="main">.</span> monotone <span class="free">orda</span> <span class="free">ordb</span> <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="free">esuc</span> <span class="bound">f</span> <span class="bound">n</span><span class="main">)</span> <span class="main">⟧</span>
  <span class="main">⟹</span> monotone <span class="free">orda</span> <span class="free">ordb</span> <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> co.case_enat <span class="main">(</span><span class="free">zero</span> <span class="bound">f</span><span class="main">)</span> <span class="main">(</span><span class="free">esuc</span> <span class="bound">f</span><span class="main">)</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> co.enat.exhaust<span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_Nat-enat_cocase_mcont"><span class="command">lemma</span></span> enat_cocase_mcont <span class="main">[</span><span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> mcont <span class="free">luba</span> <span class="free">orda</span> <span class="free">lubb</span> <span class="free">ordb</span> <span class="free">zero</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">n</span><span class="main">.</span> mcont <span class="free">luba</span> <span class="free">orda</span> <span class="free">lubb</span> <span class="free">ordb</span> <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="free">esuc</span> <span class="bound">f</span> <span class="bound">n</span><span class="main">)</span> <span class="main">⟧</span>
  <span class="main">⟹</span> mcont <span class="free">luba</span> <span class="free">orda</span> <span class="free">lubb</span> <span class="free">ordb</span> <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> co.case_enat <span class="main">(</span><span class="free">zero</span> <span class="bound">f</span><span class="main">)</span> <span class="main">(</span><span class="free">esuc</span> <span class="bound">f</span><span class="main">)</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> co.enat.exhaust<span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_Nat-eSuc_mono"><span class="command">lemma</span></span> eSuc_mono <span class="main">[</span><span class="operator">partial_function_mono</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monotone <span class="main">(</span>fun_ord <span class="main">(≤)</span><span class="main">)</span> <span class="main">(≤)</span> <span class="free">f</span> <span class="main">⟹</span> monotone <span class="main">(</span>fun_ord <span class="main">(≤)</span><span class="main">)</span> <span class="main">(≤)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> eSuc <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> mono2mono_eSuc<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-mono2mono_enat_minus1"><span class="command">lemma</span></span> mono2mono_enat_minus1 <span class="main">[</span><span class="operator">THEN</span> lfp.mono2mono<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> monotone_enat_minus1<span class="main">:</span> <span class="quoted"><span class="quoted">"monotone <span class="main">(≤)</span> <span class="main">(≤)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="bound">n</span> <span class="main">-</span> <span class="free">m</span> <span class="main">::</span> enat<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monotoneI<span class="main">)</span><span class="main">(</span><span class="operator">rule</span> enat_minus_mono1<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-mcont2mcont_enat_minus"><span class="command">lemma</span></span> mcont2mcont_enat_minus <span class="main">[</span><span class="operator">THEN</span> lfp.mcont2mcont<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> mcont_enat_minus<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">≠</span> <span class="main">∞</span> <span class="main">⟹</span> mcont Sup <span class="main">(≤)</span> Sup <span class="main">(≤)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="bound">n</span> <span class="main">-</span> <span class="free">m</span> <span class="main">::</span> enat<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> mcontI<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> monotone_enat_minus1 contI Sup_enat_minus1<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-monotone_eadd1"><span class="command">lemma</span></span> monotone_eadd1<span class="main">:</span> <span class="quoted"><span class="quoted">"monotone <span class="main">(≤)</span> <span class="main">(≤)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">+</span> <span class="free">y</span> <span class="main">::</span> enat<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> monotoneI<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-monotone_eadd2"><span class="command">lemma</span></span> monotone_eadd2<span class="main">:</span> <span class="quoted"><span class="quoted">"monotone <span class="main">(≤)</span> <span class="main">(≤)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="free">x</span> <span class="main">+</span> <span class="bound">y</span> <span class="main">::</span> enat<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> monotoneI<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-mono2mono_eadd"><span class="command">lemma</span></span> mono2mono_eadd<span class="main">[</span><span class="operator">THEN</span> lfp.mono2mono2<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> monotone_eadd<span class="main">:</span> <span class="quoted"><span class="quoted">"monotone <span class="main">(</span>rel_prod <span class="main">(≤)</span> <span class="main">(≤)</span><span class="main">)</span> <span class="main">(≤)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">+</span> <span class="bound">y</span> <span class="main">::</span> enat<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> monotone_eadd1 monotone_eadd2<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-mcont_eadd2"><span class="command">lemma</span></span> mcont_eadd2<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont Sup <span class="main">(≤)</span> Sup <span class="main">(≤)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="free">x</span> <span class="main">+</span> <span class="bound">y</span> <span class="main">::</span> enat<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> mcontI monotone_eadd2 contI Sup_image_eadd2<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-mcont_eadd1"><span class="command">lemma</span></span> mcont_eadd1<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont Sup <span class="main">(≤)</span> Sup <span class="main">(≤)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">+</span> <span class="free">y</span> <span class="main">::</span> enat<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> mcontI monotone_eadd1 contI Sup_image_eadd1<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-mcont2mcont_eadd"><span class="command">lemma</span></span> mcont2mcont_eadd <span class="main">[</span><span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> mcont <span class="free">lub</span> <span class="free">ord</span> Sup <span class="main">(≤)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">;</span>
    mcont <span class="free">lub</span> <span class="free">ord</span> Sup <span class="main">(≤)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">g</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⟧</span>
  <span class="main">⟹</span> mcont <span class="free">lub</span> <span class="free">ord</span> Sup <span class="main">(≤)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">+</span> <span class="free">g</span> <span class="bound">x</span> <span class="main">::</span> enat<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">best</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> ccpo.mcont2mcont'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> complete_lattice_ccpo<span class="main"><span class="main">]</span></span> mcont_eadd1 mcont_eadd2 ccpo.mcont_const<span class="main"><span class="main">[</span></span><span class="operator">OF</span> complete_lattice_ccpo<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-eadd_partial_function_mono"><span class="command">lemma</span></span> eadd_partial_function_mono <span class="main">[</span><span class="operator">partial_function_mono</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> monotone <span class="main">(</span>fun_ord <span class="main">(≤)</span><span class="main">)</span> <span class="main">(≤)</span> <span class="free">f</span><span class="main">;</span> monotone <span class="main">(</span>fun_ord <span class="main">(≤)</span><span class="main">)</span> <span class="main">(≤)</span> <span class="free">g</span> <span class="main">⟧</span>
  <span class="main">⟹</span> monotone <span class="main">(</span>fun_ord <span class="main">(≤)</span><span class="main">)</span> <span class="main">(≤)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">+</span> <span class="free">g</span> <span class="bound">x</span> <span class="main">::</span> enat<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> mono2mono_eadd<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-monotone_max_enat1"><span class="command">lemma</span></span> monotone_max_enat1<span class="main">:</span> <span class="quoted"><span class="quoted">"monotone <span class="main">(≤)</span> <span class="main">(≤)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> max <span class="bound">x</span> <span class="free">y</span> <span class="main">::</span> enat<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> monotoneI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> max_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-monotone_max_enat2"><span class="command">lemma</span></span> monotone_max_enat2<span class="main">:</span> <span class="quoted"><span class="quoted">"monotone <span class="main">(≤)</span> <span class="main">(≤)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> max <span class="free">x</span> <span class="bound">y</span> <span class="main">::</span> enat<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> monotoneI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> max_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-mono2mono_max_enat"><span class="command">lemma</span></span> mono2mono_max_enat<span class="main">[</span><span class="operator">THEN</span> lfp.mono2mono2<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> monotone_max_enat<span class="main">:</span> <span class="quoted"><span class="quoted">"monotone <span class="main">(</span>rel_prod <span class="main">(≤)</span> <span class="main">(≤)</span><span class="main">)</span> <span class="main">(≤)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> max <span class="bound">x</span> <span class="bound">y</span> <span class="main">::</span> enat<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> monotone_max_enat1 monotone_max_enat2<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-max_Sup_enat2"><span class="command">lemma</span></span> max_Sup_enat2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">Y</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"max <span class="free">x</span> <span class="main">(</span>Sup <span class="free">Y</span><span class="main">)</span> <span class="main">=</span> Sup <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">y</span> <span class="main">::</span> enat<span class="main">.</span> max <span class="free">x</span> <span class="bound">y</span><span class="main">)</span> <span class="main">`</span> <span class="free">Y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"finite <span class="free">Y</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"max <span class="free">x</span> <span class="main">(</span>Max <span class="free">Y</span><span class="main">)</span> <span class="main">=</span> Max <span class="main">(</span>max <span class="free">x</span> <span class="main">`</span> <span class="free">Y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>insert <span class="skolem">y</span> <span class="skolem">Y</span><span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">Y</span> <span class="main">=</span> <span class="main">{}</span>"</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">metis</span> max.assoc max.left_commute max.left_idem<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> True <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Sup_enat_def assms<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> infinity
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"max <span class="free">x</span> <span class="main">`</span> <span class="free">Y</span> <span class="main">=</span> <span class="main">{</span><span class="main">∞</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> False <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Sup_enat_def assms<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>enat <span class="skolem">x'</span><span class="main">)</span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>max <span class="free">x</span> <span class="main">`</span> <span class="free">Y</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>max <span class="free">x</span> <span class="main">`</span> <span class="main">{</span><span class="bound"><span class="bound">y</span></span> <span class="main">∈</span> <span class="free">Y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&gt;</span> <span class="free">x</span><span class="main">}</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">{</span><span class="bound"><span class="bound">y</span></span> <span class="main">∈</span> <span class="free">Y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&gt;</span> <span class="free">x</span><span class="main">}</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> finite_imageD<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> inj_onI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> max_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">{</span><span class="bound"><span class="bound">y</span></span> <span class="main">∈</span> <span class="free">Y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="free">x</span><span class="main">}</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> finite_enat_bounded<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> enat<span class="main">)</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="main">{</span><span class="bound"><span class="bound">y</span></span> <span class="main">∈</span> <span class="free">Y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&gt;</span> <span class="free">x</span><span class="main">}</span> <span class="main">∪</span> <span class="main">{</span><span class="bound"><span class="bound">y</span></span> <span class="main">∈</span> <span class="free">Y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="free">x</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound"><span class="bound">y</span></span> <span class="main">∈</span> <span class="free">Y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&gt;</span> <span class="free">x</span><span class="main">}</span> <span class="main">∪</span> <span class="main">{</span><span class="bound"><span class="bound">y</span></span> <span class="main">∈</span> <span class="free">Y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="free">x</span><span class="main">}</span> <span class="main">=</span> <span class="free">Y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">Y</span>"</span></span> <span class="keyword1"><span class="command">.</span></span> <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> False <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Sup_enat_def assms<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_Nat-max_Sup_enat1"><span class="command">lemma</span></span> max_Sup_enat1<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">Y</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">⟹</span> max <span class="main">(</span>Sup <span class="free">Y</span><span class="main">)</span> <span class="free">x</span> <span class="main">=</span> Sup <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">y</span> <span class="main">::</span> enat<span class="main">.</span> max <span class="bound">y</span> <span class="free">x</span><span class="main">)</span> <span class="main">`</span> <span class="free">Y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2<span class="main"><span class="main">)</span></span> max.commute<span class="main">)</span><span class="main">(</span><span class="operator">rule</span> max_Sup_enat2<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-mcont_max_enat1"><span class="command">lemma</span></span> mcont_max_enat1<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont Sup <span class="main">(≤)</span> Sup <span class="main">(≤)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> max <span class="bound">x</span> <span class="free">y</span> <span class="main">::</span> enat<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> mcontI contI max_Sup_enat1 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> monotone_max_enat1<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-mcont_max_enat2"><span class="command">lemma</span></span> mcont_max_enat2<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont Sup <span class="main">(≤)</span> Sup <span class="main">(≤)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> max <span class="free">x</span> <span class="bound">y</span> <span class="main">::</span> enat<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> mcontI contI max_Sup_enat2 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> monotone_max_enat2<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-mcont2mcont_max_enat"><span class="command">lemma</span></span> mcont2mcont_max_enat <span class="main">[</span><span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> mcont <span class="free">lub</span> <span class="free">ord</span> Sup <span class="main">(≤)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">;</span>
    mcont <span class="free">lub</span> <span class="free">ord</span> Sup <span class="main">(≤)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">g</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⟧</span>
  <span class="main">⟹</span> mcont <span class="free">lub</span> <span class="free">ord</span> Sup <span class="main">(≤)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> max <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">g</span> <span class="bound">x</span><span class="main">)</span> <span class="main">::</span> enat<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">best</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> ccpo.mcont2mcont'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> complete_lattice_ccpo<span class="main"><span class="main">]</span></span> mcont_max_enat1 mcont_max_enat2 ccpo.mcont_const<span class="main"><span class="main">[</span></span><span class="operator">OF</span> complete_lattice_ccpo<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-max_enat_partial_function_mono"><span class="command">lemma</span></span> max_enat_partial_function_mono <span class="main">[</span><span class="operator">partial_function_mono</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> monotone <span class="main">(</span>fun_ord <span class="main">(≤)</span><span class="main">)</span> <span class="main">(≤)</span> <span class="free">f</span><span class="main">;</span> monotone <span class="main">(</span>fun_ord <span class="main">(≤)</span><span class="main">)</span> <span class="main">(≤)</span> <span class="free">g</span> <span class="main">⟧</span>
  <span class="main">⟹</span> monotone <span class="main">(</span>fun_ord <span class="main">(≤)</span><span class="main">)</span> <span class="main">(≤)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> max <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">g</span> <span class="bound">x</span><span class="main">)</span> <span class="main">::</span> enat<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> mono2mono_max_enat<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-chain_epredI"><span class="command">lemma</span></span> chain_epredI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Complete_Partial_Order.chain <span class="main">(≤)</span> <span class="free">Y</span>
  <span class="main">⟹</span> Complete_Partial_Order.chain <span class="main">(≤)</span> <span class="main">(</span>epred <span class="main">`</span> <span class="main">(</span><span class="free">Y</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≠</span> <span class="main">0</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> chainI <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> chainD<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-monotone_enat_le_case"><span class="command">lemma</span></span> monotone_enat_le_case<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">bot</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> mono<span class="main">:</span> <span class="quoted"><span class="quoted">"monotone <span class="main">(≤)</span> <span class="free">ord</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">(</span>eSuc <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> ord<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">ord</span> <span class="free">bot</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span> <span class="main">(</span>eSuc <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> bot<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">ord</span> <span class="free">bot</span> <span class="free">bot</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monotone <span class="main">(≤)</span> <span class="free">ord</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">x</span> <span class="keyword1">of</span> <span class="main">0</span> <span class="main">⇒</span> <span class="free">bot</span> <span class="main">|</span> eSuc <span class="bound">x'</span> <span class="main">⇒</span> <span class="free">f</span> <span class="bound">x'</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"monotone <span class="main">(≤)</span> <span class="free">ord</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">≤</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="free">bot</span> <span class="keyword1">else</span> <span class="free">f</span> <span class="main">(</span>epred <span class="bound">x</span><span class="main">)</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> monotone_if_bot<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">::</span> <span class="quoted">enat</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">y</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="skolem">x</span> <span class="main">≤</span> <span class="main">0</span>"</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">ord</span> <span class="main">(</span><span class="free">f</span> <span class="main">(</span>epred <span class="skolem">x</span><span class="main">)</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="free">f</span> <span class="main">(</span>epred <span class="skolem">y</span><span class="main">)</span> <span class="skolem">y</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span> <span class="quoted"><span class="skolem">y</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> co.enat.exhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> co.enat.exhaust<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> monotoneD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mono<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted">enat</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="skolem">x</span> <span class="main">≤</span> <span class="main">0</span>"</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">ord</span> <span class="free">bot</span> <span class="main">(</span><span class="free">f</span> <span class="main">(</span>epred <span class="skolem">x</span><span class="main">)</span> <span class="skolem">x</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> co.enat.exhaust<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> ord<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">rule</span> bot<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">≤</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="free">bot</span> <span class="keyword1">else</span> <span class="free">f</span> <span class="main">(</span>epred <span class="bound">x</span><span class="main">)</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">x</span> <span class="keyword1">of</span> <span class="main">0</span> <span class="main">⇒</span> <span class="free">bot</span> <span class="main">|</span> eSuc <span class="bound">x'</span> <span class="main">⇒</span> <span class="free">f</span> <span class="bound">x'</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> co.enat.split<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_Nat-mcont_enat_le_case"><span class="command">lemma</span></span> mcont_enat_le_case<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">bot</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ccpo<span class="main">:</span> <span class="quoted"><span class="quoted">"class.ccpo <span class="free">lub</span> <span class="free">ord</span> <span class="main">(</span>mk_less <span class="free">ord</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> mcont<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont Sup <span class="main">(≤)</span> <span class="free">lub</span> <span class="free">ord</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">(</span>eSuc <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> ord<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">ord</span> <span class="free">bot</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span> <span class="main">(</span>eSuc <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mcont Sup <span class="main">(≤)</span> <span class="free">lub</span> <span class="free">ord</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">x</span> <span class="keyword1">of</span> <span class="main">0</span> <span class="main">⇒</span> <span class="free">bot</span> <span class="main">|</span> eSuc <span class="bound">x'</span> <span class="main">⇒</span> <span class="free">f</span> <span class="bound">x'</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> ccpo
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"mcont Sup <span class="main">(≤)</span> <span class="free">lub</span> <span class="free">ord</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">≤</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="free">bot</span> <span class="keyword1">else</span> <span class="free">f</span> <span class="main">(</span>epred <span class="bound">x</span><span class="main">)</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> mcont_if_bot<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">::</span> <span class="quoted">enat</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">y</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="skolem">x</span> <span class="main">≤</span> <span class="main">0</span>"</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">ord</span> <span class="main">(</span><span class="free">f</span> <span class="main">(</span>epred <span class="skolem">x</span><span class="main">)</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="free">f</span> <span class="main">(</span>epred <span class="skolem">y</span><span class="main">)</span> <span class="skolem">y</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span> <span class="quoted"><span class="skolem">y</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> co.enat.exhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> co.enat.exhaust<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> mcont_monoD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mcont<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">Y</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"enat set"</span></span>
    <span class="keyword3"><span class="command">assume</span></span> chain<span class="main">:</span> <span class="quoted"><span class="quoted">"Complete_Partial_Order.chain <span class="main">(≤)</span> <span class="skolem">Y</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> Y<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">Y</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="skolem">Y</span> <span class="main">⟹</span> <span class="main">¬</span> <span class="bound">x</span> <span class="main">≤</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> Y <span class="keyword1"><span class="command">have</span></span> Y'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">Y</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≠</span> <span class="main">0</span><span class="main">}</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> Y<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">Y</span> <span class="main">=</span> eSuc <span class="main">`</span> <span class="main">(</span>epred <span class="main">`</span> <span class="main">(</span><span class="skolem">Y</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≠</span> <span class="main">0</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_image_eqI<span class="main">)</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?Y</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"epred <span class="main">`</span> <span class="main">(</span><span class="skolem">Y</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≠</span> <span class="main">0</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> chain_epredI <span class="main">[</span><span class="operator">OF</span> chain<span class="main">]</span> Y'
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span><span class="main">⨆</span><span class="var">?Y</span><span class="main">)</span> <span class="main">(</span>eSuc <span class="main">(</span><span class="main">⨆</span><span class="var">?Y</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">lub</span> <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">(</span>eSuc <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">`</span> <span class="var">?Y</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> mcont <span class="main">[</span><span class="operator">THEN</span> mcont_contD<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> chain_epredI <span class="main">[</span><span class="operator">OF</span> chain<span class="main">]</span> Y'
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⨆</span><span class="main">(</span>eSuc <span class="main">`</span> <span class="var">?Y</span><span class="main">)</span> <span class="main">=</span> eSuc <span class="main">(</span><span class="main">⨆</span><span class="var">?Y</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> mcont_eSuc <span class="main">[</span><span class="operator">THEN</span> mcont_contD<span class="main">,</span> <span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span>epred <span class="main">(</span>Sup <span class="skolem">Y</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Sup <span class="skolem">Y</span><span class="main">)</span> <span class="main">=</span> <span class="free">lub</span> <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span>epred <span class="bound">x</span><span class="main">)</span> <span class="bound">x</span><span class="main">)</span> <span class="main">`</span> <span class="skolem">Y</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2 3<span class="main"><span class="main">)</span></span> eq<span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> image_image<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted">enat</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="skolem">x</span> <span class="main">≤</span> <span class="main">0</span>"</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">ord</span> <span class="free">bot</span> <span class="main">(</span><span class="free">f</span> <span class="main">(</span>epred <span class="skolem">x</span><span class="main">)</span> <span class="skolem">x</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> co.enat.exhaust<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> ord<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">≤</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="free">bot</span> <span class="keyword1">else</span> <span class="free">f</span> <span class="main">(</span>epred <span class="bound">x</span><span class="main">)</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">x</span> <span class="keyword1">of</span> <span class="main">0</span> <span class="main">⇒</span> <span class="free">bot</span> <span class="main">|</span> eSuc <span class="bound">x'</span> <span class="main">⇒</span> <span class="free">f</span> <span class="bound">x'</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> co.enat.split<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Misc.›</span></span>

<span class="keyword1" id="Coinductive_Nat-enat_add_mono"><span class="command">lemma</span></span> enat_add_mono <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"enat <span class="free">x</span> <span class="main">+</span> <span class="free">y</span> <span class="main">&lt;</span> enat <span class="free">x</span> <span class="main">+</span> <span class="free">z</span> <span class="main">⟷</span> <span class="free">y</span> <span class="main">&lt;</span> <span class="free">z</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">y</span></span><span class="main">)</span><span class="main">(</span><span class="operator">case_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">z</span></span></span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-enat_add1_eq"><span class="command">lemma</span></span> enat_add1_eq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"enat <span class="free">x</span> <span class="main">+</span> <span class="free">y</span> <span class="main">=</span> enat <span class="free">x</span> <span class="main">+</span> <span class="free">z</span> <span class="main">⟷</span> <span class="free">y</span> <span class="main">=</span> <span class="free">z</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> enat_add_mono add.commute neq_iff<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-enat_add2_eq"><span class="command">lemma</span></span> enat_add2_eq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">+</span> enat <span class="free">x</span> <span class="main">=</span> <span class="free">z</span> <span class="main">+</span> enat <span class="free">x</span> <span class="main">⟷</span> <span class="free">y</span> <span class="main">=</span> <span class="free">z</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> enat_add1_eq add.commute<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-enat_less_enat_plusI"><span class="command">lemma</span></span> enat_less_enat_plusI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">&lt;</span> <span class="free">y</span> <span class="main">⟹</span> enat <span class="free">x</span> <span class="main">&lt;</span> enat <span class="free">y</span> <span class="main">+</span> <span class="free">z</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">z</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_Nat-enat_less_enat_plusI2"><span class="command">lemma</span></span> enat_less_enat_plusI2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"enat <span class="free">y</span> <span class="main">&lt;</span> <span class="free">z</span> <span class="main">⟹</span> enat <span class="main">(</span><span class="free">x</span> <span class="main">+</span> <span class="free">y</span><span class="main">)</span> <span class="main">&lt;</span> enat <span class="free">x</span> <span class="main">+</span> <span class="free">z</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> enat_add_mono plus_enat_simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-min_enat1_conv_enat"><span class="command">lemma</span></span> min_enat1_conv_enat<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> min <span class="main">(</span>enat <span class="bound">a</span><span class="main">)</span> <span class="bound">b</span> <span class="main">=</span> enat <span class="main">(</span><span class="keyword1">case</span> <span class="bound">b</span> <span class="keyword1">of</span> enat <span class="bound">b'</span> <span class="main">⇒</span> min <span class="bound">a</span> <span class="bound">b'</span> <span class="main">|</span> <span class="main">∞</span> <span class="main">⇒</span> <span class="bound">a</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> min_enat2_conv_enat<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> min <span class="bound">a</span> <span class="main">(</span>enat <span class="bound">b</span><span class="main">)</span> <span class="main">=</span> enat <span class="main">(</span><span class="keyword1">case</span> <span class="bound">a</span> <span class="keyword1">of</span> enat <span class="bound">a'</span> <span class="main">⇒</span> min <span class="bound">a'</span> <span class="bound">b</span> <span class="main">|</span> <span class="main">∞</span> <span class="main">⇒</span> <span class="bound">b</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> enat.split<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-eSuc_le_iff"><span class="command">lemma</span></span> eSuc_le_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"eSuc <span class="free">x</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y'</span><span class="main">.</span> <span class="free">y</span> <span class="main">=</span> eSuc <span class="bound">y'</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">≤</span> <span class="bound">y'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">y</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> co.enat.exhaust<span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_Nat-eSuc_eq_infinity_iff"><span class="command">lemma</span></span> eSuc_eq_infinity_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"eSuc <span class="free">n</span> <span class="main">=</span> <span class="main">∞</span> <span class="main">⟷</span> <span class="free">n</span> <span class="main">=</span> <span class="main">∞</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def eSuc_enat<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-infinity_eq_eSuc_iff"><span class="command">lemma</span></span> infinity_eq_eSuc_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∞</span> <span class="main">=</span> eSuc <span class="free">n</span> <span class="main">⟷</span> <span class="free">n</span> <span class="main">=</span> <span class="main">∞</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def eSuc_enat<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-enat_cocase_inf"><span class="command">lemma</span></span> enat_cocase_inf<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">case</span> <span class="main">∞</span> <span class="keyword1">of</span> <span class="main">0</span> <span class="main">⇒</span> <span class="free">a</span> <span class="main">|</span> eSuc <span class="bound">b</span> <span class="main">⇒</span> <span class="free">f</span> <span class="bound">b</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">∞</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> co.enat.split <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> infinity_eq_eSuc_iff<span class="main">)</span>

<span class="keyword1" id="Coinductive_Nat-eSuc_Inf"><span class="command">lemma</span></span> eSuc_Inf<span class="main">:</span> <span class="quoted"><span class="quoted">"eSuc <span class="main">(</span>Inf <span class="free">A</span><span class="main">)</span> <span class="main">=</span> Inf <span class="main">(</span>eSuc <span class="main">`</span> <span class="free">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"eSuc <span class="main">(</span><span class="keyword1">LEAST</span> <span class="bound">a</span><span class="main">.</span> <span class="bound">a</span> <span class="main">∈</span> <span class="free">A</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">LEAST</span> <span class="bound">a</span><span class="main">.</span> <span class="bound">a</span> <span class="main">∈</span> eSuc <span class="main">`</span> <span class="free">A</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> LeastI2_wellorder<span class="main">)</span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> b<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b</span><span class="main">.</span> <span class="bound">b</span> <span class="main">∈</span> <span class="free">A</span> <span class="main">⟶</span> <span class="skolem">a</span> <span class="main">≤</span> <span class="bound">b</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"eSuc <span class="skolem">a</span> <span class="main">∈</span> eSuc <span class="main">`</span> <span class="free">A</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"eSuc <span class="skolem">a</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">LEAST</span> <span class="bound">a</span><span class="main">.</span> <span class="bound">a</span> <span class="main">∈</span> eSuc <span class="main">`</span> <span class="free">A</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> LeastI2_wellorder<span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>full_types<span class="main"><span class="main">)</span></span> b a antisym eSuc_le_iff imageE<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Inf_enat_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Coinductive_List">
<div class="head">
<h1>Theory Coinductive_List</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Coinductive_List.thy
    Author:     Andreas Lochbihler
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Coinductive lists and their operations›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Coinductive_List
<span class="keyword2"><span class="keyword">imports</span></span>
  <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/Infinite_Set.html">HOL-Library.Infinite_Set</a>"</span>
  <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/Sublist.html">HOL-Library.Sublist</a>"</span>
  <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/Simps_Case_Conv.html">HOL-Library.Simps_Case_Conv</a>"</span>
  <a href="#Coinductive_Nat">Coinductive_Nat</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Auxiliary lemmata›</span></span>

<span class="keyword1" id="Coinductive_List-funpow_Suc_conv"><span class="command">lemma</span></span> funpow_Suc_conv <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Suc <span class="main">^^</span> <span class="free">n</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span> <span class="free">m</span> <span class="main">+</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">m</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-wlog_linorder_le"><span class="command">lemma</span></span> wlog_linorder_le <span class="main">[</span><span class="operator">consumes</span> 0<span class="main">,</span> <span class="operator">case_names</span> le symmetry<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> le<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">a</span> <span class="bound">b</span> <span class="main">::</span> <span class="tfree">'a</span> <span class="main">::</span> linorder<span class="main">.</span> <span class="bound">a</span> <span class="main">≤</span> <span class="bound">b</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">a</span> <span class="bound">b</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> sym<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">b</span> <span class="free">a</span> <span class="main">⟹</span> <span class="free">P</span> <span class="free">a</span> <span class="free">b</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">a</span> <span class="free">b</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">≤</span> <span class="free">b</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> le<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">≤</span> <span class="free">a</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">b</span> <span class="free">a</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> le<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> sym<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Type definition›</span></span>

<span class="keyword1"><span class="command">codatatype</span></span> <span class="main">(</span>lset<span class="main">:</span> <span class="tfree">'a</span><span class="main">)</span> llist <span class="main">=</span>
    <span class="entity">lnull</span><span class="main">:</span> LNil
  <span class="main">|</span> LCons <span class="main">(</span><span class="free"><span class="free"><span class="entity">lhd</span></span></span><span class="main">:</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="free"><span class="entity">ltl</span></span></span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist"</span></span><span class="main">)</span>
<span class="keyword2"><span class="keyword">for</span></span>
  map<span class="main">:</span> lmap
  rel<span class="main">:</span> llist_all2
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lhd</span> LNil <span class="main">=</span> undefined"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ltl</span> LNil <span class="main">=</span> LNil"</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Coiterator setup.
›</span></span>

<span class="keyword1"><span class="command">primcorec</span></span> <span class="entity">unfold_llist</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> llist"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">⟹</span> <span class="free">unfold_llist</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">g21</span></span></span> <span class="free"><span class="bound"><span class="entity">g22</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">=</span> LNil"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">⟹</span> <span class="free">unfold_llist</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">g21</span></span></span> <span class="free"><span class="bound"><span class="entity">g22</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">=</span> LCons <span class="main">(</span><span class="free"><span class="bound"><span class="entity">g21</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free">unfold_llist</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">g21</span></span></span> <span class="free"><span class="bound"><span class="entity">g22</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">g22</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">declare</span></span>
  unfold_llist.ctr<span class="main">(</span>1<span class="main">)</span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  llist.corec<span class="main">(</span>1<span class="main">)</span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The following setup should be done by the BNF package.
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹congruence rule›</span></span>

<span class="keyword1"><span class="command">declare</span></span> llist.map_cong <span class="main">[</span><span class="operator">cong</span><span class="main">]</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Code generator setup›</span></span>

<span class="keyword1" id="Coinductive_List-corec_llist_never_stop"><span class="command">lemma</span></span> corec_llist_never_stop<span class="main">:</span> <span class="quoted"><span class="quoted">"corec_llist <span class="free">IS_LNIL</span> <span class="free">LHD</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> False<span class="main">)</span> <span class="free">MORE</span> <span class="free">LTL</span> <span class="free">x</span> <span class="main">=</span> unfold_llist <span class="free">IS_LNIL</span> <span class="free">LHD</span> <span class="free">LTL</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹lemmas about generated constants›</span></span>

<span class="keyword1" id="Coinductive_List-eq_LConsD"><span class="command">lemma</span></span> eq_LConsD<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> LCons <span class="free">y</span> <span class="free">ys</span> <span class="main">⟹</span> <span class="free">xs</span> <span class="main">≠</span> LNil <span class="main">∧</span> lhd <span class="free">xs</span> <span class="main">=</span> <span class="free">y</span> <span class="main">∧</span> ltl <span class="free">xs</span> <span class="main">=</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> LNil_eq_lmap<span class="main">:</span> <span class="quoted"><span class="quoted">"LNil <span class="main">=</span> lmap <span class="free">f</span> <span class="free">xs</span> <span class="main">⟷</span> <span class="free">xs</span> <span class="main">=</span> LNil"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> lmap_eq_LNil<span class="main">:</span> <span class="quoted"><span class="quoted">"lmap <span class="free">f</span> <span class="free">xs</span> <span class="main">=</span> LNil <span class="main">⟷</span> <span class="free">xs</span> <span class="main">=</span> LNil"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">simp_all</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">declare</span></span> llist.map_sel<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">simp</span><span class="main">]</span>

<span class="keyword1" id="Coinductive_List-ltl_lmap"><span class="command">lemma</span></span> ltl_lmap<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ltl <span class="main">(</span>lmap <span class="free">f</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lmap <span class="free">f</span> <span class="main">(</span>ltl <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> llist.map_ident<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>

<span class="keyword1" id="Coinductive_List-lmap_eq_LCons_conv"><span class="command">lemma</span></span> lmap_eq_LCons_conv<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lmap <span class="free">f</span> <span class="free">xs</span> <span class="main">=</span> LCons <span class="free">y</span> <span class="free">ys</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="main">∃</span><span class="bound">x</span> <span class="bound">xs'</span><span class="main">.</span> <span class="free">xs</span> <span class="main">=</span> LCons <span class="bound">x</span> <span class="bound">xs'</span> <span class="main">∧</span> <span class="free">y</span> <span class="main">=</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">∧</span> <span class="free">ys</span> <span class="main">=</span> lmap <span class="free">f</span> <span class="bound">xs'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lmap_conv_unfold_llist"><span class="command">lemma</span></span> lmap_conv_unfold_llist<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lmap <span class="free">f</span> <span class="main">=</span> unfold_llist <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="bound">xs</span> <span class="main">=</span> LNil<span class="main">)</span> <span class="main">(</span><span class="free">f</span> <span class="main">∘</span> lhd<span class="main">)</span> ltl"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="skolem">x</span> <span class="main">=</span> <span class="var">?rhs</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lmap_unfold_llist"><span class="command">lemma</span></span> lmap_unfold_llist<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lmap <span class="free">f</span> <span class="main">(</span>unfold_llist <span class="free">IS_LNIL</span> <span class="free">LHD</span> <span class="free">LTL</span> <span class="free">b</span><span class="main">)</span> <span class="main">=</span> unfold_llist <span class="free">IS_LNIL</span> <span class="main">(</span><span class="free">f</span> <span class="main">∘</span> <span class="free">LHD</span><span class="main">)</span> <span class="free">LTL</span> <span class="free">b</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">b</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_List-lmap_corec_llist"><span class="command">lemma</span></span> lmap_corec_llist<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lmap <span class="free">f</span> <span class="main">(</span>corec_llist <span class="free">IS_LNIL</span> <span class="free">LHD</span> <span class="free">endORmore</span> <span class="free">TTL_end</span> <span class="free">TTL_more</span> <span class="free">b</span><span class="main">)</span> <span class="main">=</span>
   corec_llist <span class="free">IS_LNIL</span> <span class="main">(</span><span class="free">f</span> <span class="main">∘</span> <span class="free">LHD</span><span class="main">)</span> <span class="free">endORmore</span> <span class="main">(</span>lmap <span class="free">f</span> <span class="main">∘</span> <span class="free">TTL_end</span><span class="main">)</span> <span class="free">TTL_more</span> <span class="free">b</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">b</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> llist.coinduct_strong<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_List-unfold_llist_ltl_unroll"><span class="command">lemma</span></span> unfold_llist_ltl_unroll<span class="main">:</span>
  <span class="quoted"><span class="quoted">"unfold_llist <span class="free">IS_LNIL</span> <span class="free">LHD</span> <span class="free">LTL</span> <span class="main">(</span><span class="free">LTL</span> <span class="free">b</span><span class="main">)</span> <span class="main">=</span> unfold_llist <span class="main">(</span><span class="free">IS_LNIL</span> <span class="main">∘</span> <span class="free">LTL</span><span class="main">)</span> <span class="main">(</span><span class="free">LHD</span> <span class="main">∘</span> <span class="free">LTL</span><span class="main">)</span> <span class="free">LTL</span> <span class="free">b</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">b</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_List-ltl_unfold_llist"><span class="command">lemma</span></span> ltl_unfold_llist<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ltl <span class="main">(</span>unfold_llist <span class="free">IS_LNIL</span> <span class="free">LHD</span> <span class="free">LTL</span> <span class="free">a</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">IS_LNIL</span> <span class="free">a</span> <span class="keyword1">then</span> LNil <span class="keyword1">else</span> unfold_llist <span class="free">IS_LNIL</span> <span class="free">LHD</span> <span class="free">LTL</span> <span class="main">(</span><span class="free">LTL</span> <span class="free">a</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Coinductive_List-unfold_llist_eq_LCons"><span class="command">lemma</span></span> unfold_llist_eq_LCons <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"unfold_llist <span class="free">IS_LNIL</span> <span class="free">LHD</span> <span class="free">LTL</span> <span class="free">b</span> <span class="main">=</span> LCons <span class="free">x</span> <span class="free">xs</span> <span class="main">⟷</span>
  <span class="main">¬</span> <span class="free">IS_LNIL</span> <span class="free">b</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">=</span> <span class="free">LHD</span> <span class="free">b</span> <span class="main">∧</span> <span class="free">xs</span> <span class="main">=</span> unfold_llist <span class="free">IS_LNIL</span> <span class="free">LHD</span> <span class="free">LTL</span> <span class="main">(</span><span class="free">LTL</span> <span class="free">b</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> unfold_llist.code<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_List-unfold_llist_id"><span class="command">lemma</span></span> unfold_llist_id <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"unfold_llist lnull lhd ltl <span class="free">xs</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-lset_eq_empty"><span class="command">lemma</span></span> lset_eq_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lset <span class="free">xs</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">⟷</span> lnull <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">declare</span></span> llist.set_sel<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">simp</span><span class="main">]</span>

<span class="keyword1" id="Coinductive_List-lset_ltl"><span class="command">lemma</span></span> lset_ltl<span class="main">:</span> <span class="quoted"><span class="quoted">"lset <span class="main">(</span>ltl <span class="free">xs</span><span class="main">)</span> <span class="main">⊆</span> lset <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_List-in_lset_ltlD"><span class="command">lemma</span></span> in_lset_ltlD<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> lset <span class="main">(</span>ltl <span class="free">xs</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">∈</span> lset <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> lset_ltl<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">xs</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹induction rules›</span></span>

<span class="keyword1"><span class="command">theorem</span></span> llist_set_induct<span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> find step<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> lset <span class="free">xs</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span>lhd <span class="bound">xs</span><span class="main">)</span> <span class="bound">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span> <span class="bound">y</span><span class="main">.</span> <span class="main">⟦</span><span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">;</span> <span class="bound">y</span> <span class="main">∈</span> lset <span class="main">(</span>ltl <span class="bound">xs</span><span class="main">)</span><span class="main">;</span> <span class="free">P</span> <span class="bound">y</span> <span class="main">(</span>ltl <span class="bound">xs</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">y</span> <span class="bound">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">x</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span><span class="main">)</span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> llist.disc<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> <span class="quasi_keyword">iff</span><span class="main"><span class="main">:</span></span> llist.disc<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Test quickcheck setup›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span><span class="main">.</span> <span class="bound">xs</span> <span class="main">=</span> LNil"</span></span>
<span class="keyword1"><span class="command">quickcheck</span></span><span class="main">[</span>random<span class="main">,</span> expect<span class="main">=</span>counterexample<span class="main">]</span>
<span class="keyword1"><span class="command">quickcheck</span></span><span class="main">[</span>exhaustive<span class="main">,</span> expect<span class="main">=</span>counterexample<span class="main">]</span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"LCons <span class="free">x</span> <span class="free">xs</span> <span class="main">=</span> LCons <span class="free">x</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">quickcheck</span></span><span class="main">[</span>narrowing<span class="main">,</span> expect<span class="main">=</span>no_counterexample<span class="main">]</span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Properties of predefined functions›</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> lhd_LCons <span class="main">=</span> llist.sel<span class="main">(</span>1<span class="main">)</span>
<span class="keyword1"><span class="command">lemmas</span></span> ltl_simps <span class="main">=</span> llist.sel<span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> lhd_LCons_ltl <span class="main">=</span> llist.collapse<span class="main">(</span>2<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lnull_ltlI"><span class="command">lemma</span></span> lnull_ltlI <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lnull <span class="free">xs</span> <span class="main">⟹</span> lnull <span class="main">(</span>ltl <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> lnull_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-neq_LNil_conv"><span class="command">lemma</span></span> neq_LNil_conv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> LNil <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span> <span class="bound">xs'</span><span class="main">.</span> <span class="free">xs</span> <span class="main">=</span> LCons <span class="bound">x</span> <span class="bound">xs'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_List-not_lnull_conv"><span class="command">lemma</span></span> not_lnull_conv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lnull <span class="free">xs</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span> <span class="bound">xs'</span><span class="main">.</span> <span class="free">xs</span> <span class="main">=</span> LCons <span class="bound">x</span> <span class="bound">xs'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> lnull_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> neq_LNil_conv<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lset_LCons"><span class="command">lemma</span></span> lset_LCons<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lset <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> insert <span class="free">x</span> <span class="main">(</span>lset <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-lset_intros"><span class="command">lemma</span></span> lset_intros<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> lset <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> lset <span class="free">xs</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">∈</span> lset <span class="main">(</span>LCons <span class="free">x'</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-lset_cases"><span class="command">lemma</span></span> lset_cases <span class="main">[</span><span class="operator">elim</span><span class="main"><span class="main"><span class="main"><span class="main">?</span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> lset <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">xs'</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> LCons <span class="free">x</span> <span class="free">xs'</span>"</span></span>
  <span class="main">|</span> <span class="free">x'</span> <span class="free">xs'</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> LCons <span class="free">x'</span> <span class="free">xs'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> lset <span class="free">xs'</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_List-lset_induct'"><span class="command">lemma</span></span> lset_induct' <span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> find step<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> major<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> lset <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span>LCons <span class="free">x</span> <span class="bound">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x'</span> <span class="bound">xs</span><span class="main">.</span> <span class="main">⟦</span> <span class="free">x</span> <span class="main">∈</span> lset <span class="bound">xs</span><span class="main">;</span> <span class="free">P</span> <span class="bound">xs</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span>LCons <span class="bound">x'</span> <span class="bound">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> major <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induct</span> <span class="skolem">y</span><span class="main"><span class="main">≡</span></span><span class="quoted"><span class="quoted">"<span class="free">x</span>"</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> llist_set_induct<span class="main">)</span>
<span class="keyword1"><span class="command">using</span></span> 1 2 <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lnull_conv<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lset_induct"><span class="command">lemma</span></span> lset_induct <span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> find step<span class="main">,</span> <span class="operator">induct</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">set</span></span></span><span class="main"><span class="main"><span class="main"><span class="main">:</span></span></span></span> lset<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> major<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> lset <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> find<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span>LCons <span class="free">x</span> <span class="bound">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> step<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x'</span> <span class="bound">xs</span><span class="main">.</span> <span class="main">⟦</span> <span class="free">x</span> <span class="main">∈</span> lset <span class="bound">xs</span><span class="main">;</span> <span class="free">x</span> <span class="main">≠</span> <span class="bound">x'</span><span class="main">;</span> <span class="free">P</span> <span class="bound">xs</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span>LCons <span class="bound">x'</span> <span class="bound">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> major
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lset_induct'<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> find<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="improper">x'</span><span class="main">=</span><span class="free">x</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> find step<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemmas</span></span> lset_LNil <span class="main">=</span> llist.set<span class="main">(</span>1<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lset_lnull"><span class="command">lemma</span></span> lset_lnull<span class="main">:</span> <span class="quoted"><span class="quoted">"lnull <span class="free">xs</span> <span class="main">⟹</span> lset <span class="free">xs</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> llist.collapse<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Alternative definition of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">lset</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> for nitpick›</span></span>

<span class="keyword1"><span class="command">inductive</span></span> <span class="entity">lsetp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lsetp</span> <span class="main">(</span>LCons <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">lsetp</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">⟹</span> <span class="free">lsetp</span> <span class="main">(</span>LCons <span class="free"><span class="bound"><span class="entity">x'</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>

<span class="keyword1" id="Coinductive_List-lset_into_lsetp"><span class="command">lemma</span></span> lset_into_lsetp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> lset <span class="free">xs</span> <span class="main">⟹</span> lsetp <span class="free">xs</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lset_induct<span class="main">)</span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> lsetp.intros<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Coinductive_List-lsetp_into_lset"><span class="command">lemma</span></span> lsetp_into_lset<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lsetp <span class="free">xs</span> <span class="free">x</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">∈</span> lset <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lsetp.induct<span class="main">)</span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> lset_intros<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Coinductive_List-lset_eq_lsetp"><span class="command">lemma</span></span> lset_eq_lsetp <span class="main">[</span><span class="operator">nitpick_unfold</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lset <span class="free">xs</span> <span class="main">=</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> lsetp <span class="free">xs</span> <span class="bound">x</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> lset_into_lsetp <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lsetp_into_lset<span class="main">)</span>

<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> lsetp
<span class="keyword1"><span class="command">hide_fact</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> lsetp.intros lsetp.cases lsetp.induct lset_into_lsetp lset_eq_lsetp

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹code setup for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">lset</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">gen_lset</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> llist <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">gen_lset</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">∪</span> lset <span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>

<span class="keyword1" id="Coinductive_List-gen_lset_code"><span class="command">lemma</span></span> gen_lset_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"gen_lset <span class="free">A</span> LNil <span class="main">=</span> <span class="free">A</span>"</span></span>
  <span class="quoted"><span class="quoted">"gen_lset <span class="free">A</span> <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> gen_lset <span class="main">(</span>insert <span class="free">x</span> <span class="free">A</span><span class="main">)</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gen_lset_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lset_code"><span class="command">lemma</span></span> lset_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lset <span class="main">=</span> gen_lset <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gen_lset_def fun_eq_iff<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">lmember</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> llist <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">lmember</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">∈</span> lset <span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>

<span class="keyword1" id="Coinductive_List-lmember_code"><span class="command">lemma</span></span> lmember_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lmember <span class="free">x</span> LNil <span class="main">⟷</span> False"</span></span>
  <span class="quoted"><span class="quoted">"lmember <span class="free">x</span> <span class="main">(</span>LCons <span class="free">y</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span> <span class="main">∨</span> lmember <span class="free">x</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lmember_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lset_lmember"><span class="command">lemma</span></span> lset_lmember <span class="main">[</span><span class="operator">code_unfold</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> lset <span class="free">xs</span> <span class="main">⟷</span> lmember <span class="free">x</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lmember_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> lset_lmap <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> llist.set_map

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The subset of finite lazy lists <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">lfinite</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">inductive</span></span> <span class="entity">lfinite</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  lfinite_LNil<span class="main">:</span>  <span class="quoted"><span class="quoted">"<span class="free">lfinite</span> LNil"</span></span>
<span class="main">|</span> lfinite_LConsI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">lfinite</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">⟹</span> <span class="free">lfinite</span> <span class="main">(</span>LCons <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">declare</span></span> lfinite_LNil <span class="main">[</span><span class="operator">iff</span><span class="main">]</span>

<span class="keyword1" id="Coinductive_List-lnull_imp_lfinite"><span class="command">lemma</span></span> lnull_imp_lfinite <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lnull <span class="free">xs</span> <span class="main">⟹</span> lfinite <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> llist.collapse<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lfinite_LCons"><span class="command">lemma</span></span> lfinite_LCons <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lfinite <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> lfinite.cases <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> lfinite_LConsI<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lfinite_ltl"><span class="command">lemma</span></span> lfinite_ltl <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>ltl <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lfinite <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-lfinite_code"><span class="command">lemma</span></span> lfinite_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lfinite LNil <span class="main">=</span> True"</span></span>
  <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lfinite <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-lfinite_induct"><span class="command">lemma</span></span> lfinite_induct <span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> LNil LCons<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> lfinite<span class="main">:</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> LNil<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span><span class="main">.</span> lnull <span class="bound">xs</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> LCons<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span><span class="main">.</span> <span class="main">⟦</span> lfinite <span class="bound">xs</span><span class="main">;</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">;</span> <span class="free">P</span> <span class="main">(</span>ltl <span class="bound">xs</span><span class="main">)</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> lfinite <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> LCons LNil<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lfinite_imp_finite_lset"><span class="command">lemma</span></span> lfinite_imp_finite_lset<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>lset <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Concatenating two lists: <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">lappend</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">primcorec</span></span> <span class="entity">lappend</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">⇒</span> <span class="tfree">'a</span> llist <span class="main">⇒</span> <span class="tfree">'a</span> llist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lappend</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">of</span> LNil <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">|</span> LCons <span class="bound">x</span> <span class="bound">xs'</span> <span class="main">⇒</span> LCons <span class="bound">x</span> <span class="main">(</span><span class="free">lappend</span> <span class="bound">xs'</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">simps_of_case</span></span> lappend_code <span class="main">[</span><span class="operator">code</span><span class="main">,</span> <span class="operator">simp</span><span class="main">,</span> <span class="operator">nitpick_simp</span><span class="main">]</span><span class="main">:</span> lappend.code

<span class="keyword1"><span class="command">lemmas</span></span> lappend_LNil_LNil <span class="main">=</span> lappend_code<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> ys <span class="main"><span class="main">=</span></span> <span class="quoted">LNil</span><span class="main">]</span>

<span class="keyword1" id="Coinductive_List-lappend_simps"><span class="command">lemma</span></span> lappend_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> lhd_lappend<span class="main">:</span> <span class="quoted"><span class="quoted">"lhd <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> lnull <span class="free">xs</span> <span class="keyword1">then</span> lhd <span class="free">ys</span> <span class="keyword1">else</span> lhd <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> ltl_lappend<span class="main">:</span> <span class="quoted"><span class="quoted">"ltl <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> lnull <span class="free">xs</span> <span class="keyword1">then</span> ltl <span class="free">ys</span> <span class="keyword1">else</span> lappend <span class="main">(</span>ltl <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">xs</span></span></span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-lnull_lappend"><span class="command">lemma</span></span> lnull_lappend <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lnull <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟷</span> lnull <span class="free">xs</span> <span class="main">∧</span> lnull <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lappend_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lappend_eq_LNil_iff"><span class="command">lemma</span></span> lappend_eq_LNil_iff<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lappend <span class="free">xs</span> <span class="free">ys</span> <span class="main">=</span> LNil <span class="main">⟷</span> <span class="free">xs</span> <span class="main">=</span> LNil <span class="main">∧</span> <span class="free">ys</span> <span class="main">=</span> LNil"</span></span>
<span class="keyword1"><span class="command">using</span></span> lnull_lappend <span class="keyword1"><span class="command">unfolding</span></span> lnull_def <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1" id="Coinductive_List-LNil_eq_lappend_iff"><span class="command">lemma</span></span> LNil_eq_lappend_iff<span class="main">:</span>
  <span class="quoted"><span class="quoted">"LNil <span class="main">=</span> lappend <span class="free">xs</span> <span class="free">ys</span> <span class="main">⟷</span> <span class="free">xs</span> <span class="main">=</span> LNil <span class="main">∧</span> <span class="free">ys</span> <span class="main">=</span> LNil"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> sym <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lappend_eq_LNil_iff<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lappend_LNil2"><span class="command">lemma</span></span> lappend_LNil2 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lappend <span class="free">xs</span> LNil <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="keyword2"><span class="keyword">shows</span></span> lappend_lnull1<span class="main">:</span> <span class="quoted"><span class="quoted">"lnull <span class="free">xs</span> <span class="main">⟹</span> lappend <span class="free">xs</span> <span class="free">ys</span> <span class="main">=</span> <span class="free">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> lappend_lnull2<span class="main">:</span> <span class="quoted"><span class="quoted">"lnull <span class="free">ys</span> <span class="main">⟹</span> lappend <span class="free">xs</span> <span class="free">ys</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> lnull_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-lappend_assoc"><span class="command">lemma</span></span> lappend_assoc<span class="main">:</span> <span class="quoted"><span class="quoted">"lappend <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="free">zs</span> <span class="main">=</span> lappend <span class="free">xs</span> <span class="main">(</span>lappend <span class="free">ys</span> <span class="free">zs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> llist.coinduct_strong<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_List-lmap_lappend_distrib"><span class="command">lemma</span></span> lmap_lappend_distrib<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lmap <span class="free">f</span> <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> lappend <span class="main">(</span>lmap <span class="free">f</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>lmap <span class="free">f</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> llist.coinduct_strong<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_List-lappend_snocL1_conv_LCons2"><span class="command">lemma</span></span> lappend_snocL1_conv_LCons2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lappend <span class="main">(</span>lappend <span class="free">xs</span> <span class="main">(</span>LCons <span class="free">y</span> LNil<span class="main">)</span><span class="main">)</span> <span class="free">ys</span> <span class="main">=</span> lappend <span class="free">xs</span> <span class="main">(</span>LCons <span class="free">y</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lappend_assoc<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lappend_ltl"><span class="command">lemma</span></span> lappend_ltl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lnull <span class="free">xs</span> <span class="main">⟹</span> lappend <span class="main">(</span>ltl <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span> <span class="main">=</span> ltl <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-lfinite_lappend"><span class="command">lemma</span></span> lfinite_lappend <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟷</span> lfinite <span class="free">xs</span> <span class="main">∧</span> lfinite <span class="free">ys</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="skolem">zs</span><span class="main"><span class="main">≡</span></span><span class="quoted"><span class="quoted">"lappend <span class="free">xs</span> <span class="free">ys</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> lfinite_LNil
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> LNil_eq_lappend_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>lfinite_LConsI <span class="skolem">zs</span> <span class="skolem">z</span><span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?xs</span> <span class="main">∧</span> <span class="var">?ys</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="var"><span class="quoted"><span class="var">?xs</span></span></span> <span class="var"><span class="quoted"><span class="var">?ys</span></span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lappend_inf"><span class="command">lemma</span></span> lappend_inf<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lfinite <span class="free">xs</span> <span class="main">⟹</span> lappend <span class="free">xs</span> <span class="free">ys</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_List-lfinite_lmap"><span class="command">lemma</span></span> lfinite_lmap <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>lmap <span class="free">f</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lfinite <span class="free">xs</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="skolem">zs</span><span class="main"><span class="main">≡</span></span><span class="quoted"><span class="quoted">"lmap <span class="free">f</span> <span class="free">xs</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lfinite_induct<span class="main">)</span> <span class="operator">fastforce</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lset_lappend_lfinite"><span class="command">lemma</span></span> lset_lappend_lfinite <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span> <span class="main">⟹</span> lset <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> lset <span class="free">xs</span> <span class="main">∪</span> lset <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lfinite.induct<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_List-lset_lappend"><span class="command">lemma</span></span> lset_lappend<span class="main">:</span> <span class="quoted"><span class="quoted">"lset <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⊆</span> lset <span class="free">xs</span> <span class="main">∪</span> lset <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lappend_inf<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lset_lappend1"><span class="command">lemma</span></span> lset_lappend1<span class="main">:</span> <span class="quoted"><span class="quoted">"lset <span class="free">xs</span> <span class="main">⊆</span> lset <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> subsetI<span class="main">)</span><span class="main">(</span><span class="operator">erule</span> lset_induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lset_lappend_conv"><span class="command">lemma</span></span> lset_lappend_conv<span class="main">:</span> <span class="quoted"><span class="quoted">"lset <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> lfinite <span class="free">xs</span> <span class="keyword1">then</span> lset <span class="free">xs</span> <span class="main">∪</span> lset <span class="free">ys</span> <span class="keyword1">else</span> lset <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lappend_inf<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-in_lset_lappend_iff"><span class="command">lemma</span></span> in_lset_lappend_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> lset <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">∈</span> lset <span class="free">xs</span> <span class="main">∨</span> lfinite <span class="free">xs</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">∈</span> lset <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lset_lappend_conv<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-split_llist_first"><span class="command">lemma</span></span> split_llist_first<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> lset <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">ys</span> <span class="bound">zs</span><span class="main">.</span> <span class="free">xs</span> <span class="main">=</span> lappend <span class="bound">ys</span> <span class="main">(</span>LCons <span class="free">x</span> <span class="bound">zs</span><span class="main">)</span> <span class="main">∧</span> lfinite <span class="bound">ys</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">∉</span> lset <span class="bound">ys</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> find <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">LNil</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> step <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"LCons <span class="skolem">a</span> <span class="skolem">b</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">for</span></span></span></span> <span class="skolem">a</span> <span class="skolem">b</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-split_llist"><span class="command">lemma</span></span> split_llist<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> lset <span class="free">xs</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">ys</span> <span class="bound">zs</span><span class="main">.</span> <span class="free">xs</span> <span class="main">=</span> lappend <span class="bound">ys</span> <span class="main">(</span>LCons <span class="free">x</span> <span class="bound">zs</span><span class="main">)</span> <span class="main">∧</span> lfinite <span class="bound">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> split_llist_first<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The prefix ordering on lazy lists: <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">lprefix</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">coinductive</span></span> <span class="entity">lprefix</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">⇒</span> <span class="tfree">'a</span> llist <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">⊑</span>"</span> 65<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span>
  LNil_lprefix <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"LNil <span class="main"><span class="free">⊑</span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>
<span class="main">|</span> Le_LCons<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main"><span class="free">⊑</span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">⟹</span> LCons <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main"><span class="free">⊑</span></span> LCons <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span>"</span></span>

<span class="keyword1" id="Coinductive_List-lprefixI"><span class="command">lemma</span></span> lprefixI <span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> lprefix<span class="main">,</span>
                <span class="operator">case_conclusion</span> lprefix LeLNil LeLCons<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> major<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">xs</span><span class="main">,</span> <span class="free">ys</span><span class="main">)</span> <span class="main">∈</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> step<span class="main">:</span>
      <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span> <span class="bound">ys</span><span class="main">.</span> <span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">∈</span> <span class="free">X</span>
       <span class="main">⟹</span> lnull <span class="bound">xs</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span> <span class="bound">xs'</span> <span class="bound">ys'</span><span class="main">.</span> <span class="bound">xs</span> <span class="main">=</span> LCons <span class="bound">x</span> <span class="bound">xs'</span> <span class="main">∧</span> <span class="bound">ys</span> <span class="main">=</span> LCons <span class="bound">x</span> <span class="bound">ys'</span> <span class="main">∧</span>
                                   <span class="main">(</span><span class="main">(</span><span class="bound">xs'</span><span class="main">,</span> <span class="bound">ys'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">X</span> <span class="main">∨</span> <span class="bound">xs'</span> <span class="main">⊑</span> <span class="bound">ys'</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">⊑</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> major <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> lprefix.coinduct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> step<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lprefix_coinduct"><span class="command">lemma</span></span> lprefix_coinduct <span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> lprefix<span class="main">,</span> <span class="operator">case_conclusion</span> lprefix LNil LCons<span class="main">,</span> <span class="operator">coinduct</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">pred</span></span></span><span class="main"><span class="main"><span class="main"><span class="main">:</span></span></span></span> lprefix<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> major<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> step<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span> <span class="bound">ys</span><span class="main">.</span> <span class="free">P</span> <span class="bound">xs</span> <span class="bound">ys</span>
    <span class="main">⟹</span> <span class="main">(</span>lnull <span class="bound">ys</span> <span class="main">⟶</span> lnull <span class="bound">xs</span><span class="main">)</span> <span class="main">∧</span>
       <span class="main">(</span><span class="main">¬</span> lnull <span class="bound">xs</span> <span class="main">⟶</span> <span class="main">¬</span> lnull <span class="bound">ys</span> <span class="main">⟶</span> lhd <span class="bound">xs</span> <span class="main">=</span> lhd <span class="bound">ys</span> <span class="main">∧</span> <span class="main">(</span><span class="free">P</span> <span class="main">(</span>ltl <span class="bound">xs</span><span class="main">)</span> <span class="main">(</span>ltl <span class="bound">ys</span><span class="main">)</span> <span class="main">∨</span> ltl <span class="bound">xs</span> <span class="main">⊑</span> ltl <span class="bound">ys</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">⊑</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> major <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">xs</span><span class="main">,</span> <span class="free">ys</span><span class="main">)</span> <span class="main">∈</span> <span class="main">{</span><span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="bound">ys</span><span class="main">)</span><span class="main">.</span> <span class="free">P</span> <span class="bound">xs</span> <span class="bound">ys</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lprefixI<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>lprefix <span class="skolem">xs</span> <span class="skolem">ys</span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="skolem">xs</span> <span class="skolem">ys</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> step<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lnull_conv<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lprefix_refl"><span class="command">lemma</span></span> lprefix_refl <span class="main">[</span><span class="operator">intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">⊑</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-lprefix_LNil"><span class="command">lemma</span></span> lprefix_LNil <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">⊑</span> LNil <span class="main">⟷</span> lnull <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> lnull_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> lprefix.simps<span class="main">)</span><span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-lprefix_lnull"><span class="command">lemma</span></span> lprefix_lnull<span class="main">:</span> <span class="quoted"><span class="quoted">"lnull <span class="free">ys</span> <span class="main">⟹</span> <span class="free">xs</span> <span class="main">⊑</span> <span class="free">ys</span> <span class="main">⟷</span> lnull <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> lnull_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_List-lnull_lprefix"><span class="command">lemma</span></span> lnull_lprefix<span class="main">:</span> <span class="quoted"><span class="quoted">"lnull <span class="free">xs</span> <span class="main">⟹</span> lprefix <span class="free">xs</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnull_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lprefix_LCons_conv"><span class="command">lemma</span></span> lprefix_LCons_conv<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">⊑</span> LCons <span class="free">y</span> <span class="free">ys</span> <span class="main">⟷</span>
   <span class="free">xs</span> <span class="main">=</span> LNil <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">xs'</span><span class="main">.</span> <span class="free">xs</span> <span class="main">=</span> LCons <span class="free">y</span> <span class="bound">xs'</span> <span class="main">∧</span> <span class="bound">xs'</span> <span class="main">⊑</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> lprefix.simps<span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-LCons_lprefix_LCons"><span class="command">lemma</span></span> LCons_lprefix_LCons <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"LCons <span class="free">x</span> <span class="free">xs</span> <span class="main">⊑</span> LCons <span class="free">y</span> <span class="free">ys</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span> <span class="main">∧</span> <span class="free">xs</span> <span class="main">⊑</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lprefix_LCons_conv<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-LCons_lprefix_conv"><span class="command">lemma</span></span> LCons_lprefix_conv<span class="main">:</span>
  <span class="quoted"><span class="quoted">"LCons <span class="free">x</span> <span class="free">xs</span> <span class="main">⊑</span> <span class="free">ys</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">ys'</span><span class="main">.</span> <span class="free">ys</span> <span class="main">=</span> LCons <span class="free">x</span> <span class="bound">ys'</span> <span class="main">∧</span> <span class="free">xs</span> <span class="main">⊑</span> <span class="bound">ys'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lprefix_ltlI"><span class="command">lemma</span></span> lprefix_ltlI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">⊑</span> <span class="free">ys</span> <span class="main">⟹</span> ltl <span class="free">xs</span> <span class="main">⊑</span> ltl <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lprefix_LCons_conv<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lprefix_code"><span class="command">lemma</span></span> lprefix_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"LNil <span class="main">⊑</span> <span class="free">ys</span> <span class="main">⟷</span> True"</span></span>
  <span class="quoted"><span class="quoted">"LCons <span class="free">x</span> <span class="free">xs</span> <span class="main">⊑</span> LNil <span class="main">⟷</span> False"</span></span>
  <span class="quoted"><span class="quoted">"LCons <span class="free">x</span> <span class="free">xs</span> <span class="main">⊑</span> LCons <span class="free">y</span> <span class="free">ys</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span> <span class="main">∧</span> <span class="free">xs</span> <span class="main">⊑</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-lprefix_lhdD"><span class="command">lemma</span></span> lprefix_lhdD<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">xs</span> <span class="main">⊑</span> <span class="free">ys</span><span class="main">;</span> <span class="main">¬</span> lnull <span class="free">xs</span> <span class="main">⟧</span> <span class="main">⟹</span> lhd <span class="free">xs</span> <span class="main">=</span> lhd <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lnull_conv LCons_lprefix_conv<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lprefix_lnullD"><span class="command">lemma</span></span> lprefix_lnullD<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">xs</span> <span class="main">⊑</span> <span class="free">ys</span><span class="main">;</span> lnull <span class="free">ys</span> <span class="main">⟧</span> <span class="main">⟹</span> lnull <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> lprefix.cases<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lprefix_not_lnullD"><span class="command">lemma</span></span> lprefix_not_lnullD<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">xs</span> <span class="main">⊑</span> <span class="free">ys</span><span class="main">;</span> <span class="main">¬</span> lnull <span class="free">xs</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">¬</span> lnull <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> lprefix.cases<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lprefix_expand"><span class="command">lemma</span></span> lprefix_expand<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">¬</span> lnull <span class="free">xs</span> <span class="main">⟹</span> <span class="main">¬</span> lnull <span class="free">ys</span> <span class="main">∧</span> lhd <span class="free">xs</span> <span class="main">=</span> lhd <span class="free">ys</span> <span class="main">∧</span> ltl <span class="free">xs</span> <span class="main">⊑</span> ltl <span class="free">ys</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">xs</span> <span class="main">⊑</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> llist.exhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> llist.exhaust<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lprefix_antisym"><span class="command">lemma</span></span> lprefix_antisym<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">xs</span> <span class="main">⊑</span> <span class="free">ys</span><span class="main">;</span> <span class="free">ys</span> <span class="main">⊑</span> <span class="free">xs</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">xs</span> <span class="main">=</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lnull_conv lprefix_lnull<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lprefix_trans"><span class="command">lemma</span></span> lprefix_trans <span class="main">[</span><span class="operator">trans</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">xs</span> <span class="main">⊑</span> <span class="free">ys</span><span class="main">;</span> <span class="free">ys</span> <span class="main">⊑</span> <span class="free">zs</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">xs</span> <span class="main">⊑</span> <span class="free">zs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quoted"><span class="free">zs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lprefix_lnullD lprefix_lhdD <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> lprefix_ltlI<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-preorder_lprefix"><span class="command">lemma</span></span> preorder_lprefix <span class="main">[</span><span class="operator">cont_intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"class.preorder <span class="main">(⊑)</span> <span class="main">(</span>mk_less <span class="main">(⊑)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mk_less_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> lprefix_trans<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lprefix_lsetD"><span class="command">lemma</span></span> lprefix_lsetD<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">⊑</span> <span class="free">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lset <span class="free">xs</span> <span class="main">⊆</span> lset <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> lset <span class="free">xs</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> lset <span class="free">ys</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> LCons_lprefix_conv<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lprefix_lappend_sameI"><span class="command">lemma</span></span> lprefix_lappend_sameI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">⊑</span> <span class="free">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lappend <span class="free">zs</span> <span class="free">xs</span> <span class="main">⊑</span> lappend <span class="free">zs</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">zs</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lappend_inf<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-not_lfinite_lprefix_conv_eq"><span class="command">lemma</span></span> not_lfinite_lprefix_conv_eq<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> nfin<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lfinite <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">⊑</span> <span class="free">ys</span> <span class="main">⟷</span> <span class="free">xs</span> <span class="main">=</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">⊑</span> <span class="free">ys</span>"</span></span>
  <span class="keyword1"><span class="command">with</span></span> nfin <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="free">ys</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lprefix_lnullD lprefix_lhdD <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> lprefix_ltlI<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-lprefix_lappend"><span class="command">lemma</span></span> lprefix_lappend<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">⊑</span> lappend <span class="free">xs</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_List-lprefix_down_linear"><span class="command">lemma</span></span> lprefix_down_linear<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">⊑</span> <span class="free">zs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">⊑</span> <span class="free">zs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">⊑</span> <span class="free">ys</span> <span class="main">∨</span> <span class="free">ys</span> <span class="main">⊑</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> disjCI<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">ys</span> <span class="main">⊑</span> <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">⊑</span> <span class="free">ys</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quoted"><span class="free">zs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lnull_conv LCons_lprefix_conv<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnull_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lprefix_lappend_same"><span class="command">lemma</span></span> lprefix_lappend_same <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lappend <span class="free">xs</span> <span class="free">ys</span> <span class="main">⊑</span> lappend <span class="free">xs</span> <span class="free">zs</span> <span class="main">⟷</span> <span class="main">(</span>lfinite <span class="free">xs</span> <span class="main">⟶</span> <span class="free">ys</span> <span class="main">⊑</span> <span class="free">zs</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rhs</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span>"</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">⊑</span> <span class="free">zs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?lhs</span>›</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span><span class="main">)</span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rhs</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">hence</span></span> yszs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">⊑</span> <span class="free">zs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> <span class="quoted"><span class="quoted">‹<span class="var">?rhs</span>›</span></span><span class="main"><span class="main">[</span></span><span class="operator">rule_format</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> True <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> yszs<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lappend_inf<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Setup for partial\_function›</span></span>

<span class="keyword1"><span class="command">primcorec</span></span> <span class="entity">lSup</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist set <span class="main">⇒</span> <span class="tfree">'a</span> llist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lSup</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="main">∀</span><span class="bound">x</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">.</span> lnull <span class="bound">x</span> <span class="keyword1">then</span> LNil
   <span class="keyword1">else</span> LCons <span class="main">(</span><span class="keyword1">THE</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> lhd <span class="main">`</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">∩</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">lSup</span> <span class="main">(</span>ltl <span class="main">`</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">∩</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">}</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">declare</span></span> lSup.simps<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span></span><span class="main">]</span>

<span class="keyword1" id="Coinductive_List-lnull_lSup"><span class="command">lemma</span></span> lnull_lSup <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lnull <span class="main">(</span>lSup <span class="free">A</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> lnull <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lSup_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lhd_lSup"><span class="command">lemma</span></span> lhd_lSup <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">x</span> <span class="main">⟹</span> lhd <span class="main">(</span>lSup <span class="free">A</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">THE</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> lhd <span class="main">`</span> <span class="main">(</span><span class="free">A</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lSup_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ltl_lSup"><span class="command">lemma</span></span> ltl_lSup <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ltl <span class="main">(</span>lSup <span class="free">A</span><span class="main">)</span> <span class="main">=</span> lSup <span class="main">(</span>ltl <span class="main">`</span> <span class="main">(</span><span class="free">A</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">xs</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> lnull <span class="bound">xs</span>"</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lSup_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> llist.expand<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lhd_lSup_eq"><span class="command">lemma</span></span> lhd_lSup_eq<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> chain<span class="main">:</span> <span class="quoted"><span class="quoted">"Complete_Partial_Order.chain <span class="main">(⊑)</span> <span class="free">Y</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">xs</span> <span class="main">∈</span> <span class="free">Y</span><span class="main">;</span> <span class="main">¬</span> lnull <span class="free">xs</span> <span class="main">⟧</span> <span class="main">⟹</span> lhd <span class="main">(</span>lSup <span class="free">Y</span><span class="main">)</span> <span class="main">=</span> lhd <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> lhd_lSup<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> chainD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> chain<span class="main"><span class="main">]</span></span> lprefix_lhdD <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> the_equality<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lSup_empty"><span class="command">lemma</span></span> lSup_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lSup <span class="main">{}</span> <span class="main">=</span> LNil"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lSup_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lSup_singleton"><span class="command">lemma</span></span> lSup_singleton <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lSup <span class="main">{</span><span class="free">xs</span><span class="main">}</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-LCons_image_Int_not_lnull"><span class="command">lemma</span></span> LCons_image_Int_not_lnull<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>LCons <span class="free">x</span> <span class="main">`</span> <span class="free">A</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> LCons <span class="free">x</span> <span class="main">`</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_List-lSup_LCons"><span class="command">lemma</span></span> lSup_LCons<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">⟹</span> lSup <span class="main">(</span>LCons <span class="free">x</span> <span class="main">`</span> <span class="free">A</span><span class="main">)</span> <span class="main">=</span> LCons <span class="free">x</span> <span class="main">(</span>lSup <span class="free">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> llist.expand<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> image_image lhd_lSup exI LCons_image_Int_not_lnull <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> the_equality<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lSup_eq_LCons_iff"><span class="command">lemma</span></span> lSup_eq_LCons_iff<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lSup <span class="free">Y</span> <span class="main">=</span> LCons <span class="free">x</span> <span class="free">xs</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">∈</span><span class="free">Y</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">x</span><span class="main">)</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">THE</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> lhd <span class="main">`</span> <span class="main">(</span><span class="free">Y</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="free">xs</span> <span class="main">=</span> lSup <span class="main">(</span>ltl <span class="main">`</span> <span class="main">(</span><span class="free">Y</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> eq_LConsD <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnull_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> llist.expand<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lSup_insert_LNil"><span class="command">lemma</span></span> lSup_insert_LNil<span class="main">:</span> <span class="quoted"><span class="quoted">"lSup <span class="main">(</span>insert LNil <span class="free">Y</span><span class="main">)</span> <span class="main">=</span> lSup <span class="free">Y</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> llist.expand<span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-lSup_minus_LNil"><span class="command">lemma</span></span> lSup_minus_LNil<span class="main">:</span> <span class="quoted"><span class="quoted">"lSup <span class="main">(</span><span class="free">Y</span> <span class="main">-</span> <span class="main">{</span>LNil<span class="main">}</span><span class="main">)</span> <span class="main">=</span> lSup <span class="free">Y</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> lSup_insert_LNil<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> Y<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">Y</span> <span class="main">-</span> <span class="main">{</span>LNil<span class="main">}</span>"</span></span><span class="main">,</span> <span class="operator">symmetric</span><span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"LNil <span class="main">∈</span> <span class="free">Y</span>"</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> insert_absorb<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-chain_lprefix_ltl"><span class="command">lemma</span></span> chain_lprefix_ltl<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> chain<span class="main">:</span> <span class="quoted"><span class="quoted">"Complete_Partial_Order.chain <span class="main">(⊑)</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Complete_Partial_Order.chain <span class="main">(⊑)</span> <span class="main">(</span>ltl <span class="main">`</span> <span class="main">(</span><span class="free">A</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> chainI <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> chainD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> chain<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> lprefix_ltlI<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lSup_finite_prefixes"><span class="command">lemma</span></span> lSup_finite_prefixes<span class="main">:</span> <span class="quoted"><span class="quoted">"lSup <span class="main">{</span><span class="bound">ys</span><span class="main">.</span> <span class="bound">ys</span> <span class="main">⊑</span> <span class="free">xs</span> <span class="main">∧</span> lfinite <span class="bound">ys</span><span class="main">}</span> <span class="main">=</span> <span class="free">xs</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"lSup <span class="main">(</span><span class="var">?C</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">_</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Eq_llist <span class="skolem">xs</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?lnull</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lprefix_LCons_conv<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lnull <span class="skolem">xs</span> <span class="main">⟹</span> ltl <span class="main">`</span> <span class="main">(</span><span class="main">{</span><span class="bound">ys</span><span class="main">.</span> <span class="bound">ys</span> <span class="main">⊑</span> <span class="skolem">xs</span> <span class="main">∧</span> lfinite <span class="bound">ys</span><span class="main">}</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound">ys</span><span class="main">.</span> <span class="bound">ys</span> <span class="main">⊑</span> ltl <span class="skolem">xs</span> <span class="main">∧</span> lfinite <span class="bound">ys</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 4 <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rev_image_eqI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"LCons <span class="main">(</span>lhd <span class="skolem">xs</span><span class="main">)</span> <span class="skolem">ys</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">for</span></span></span></span> <span class="skolem">ys</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> llist.expand lprefix_ltlI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> LCons_lprefix_conv<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="var"><span class="quoted"><span class="var">?LCons</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> the_equality <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lprefix_lhdD <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_image_eqI<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lSup_finite_gen_prefixes"><span class="command">lemma</span></span> lSup_finite_gen_prefixes<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">zs</span> <span class="main">⊑</span> <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">zs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lSup <span class="main">{</span><span class="bound">ys</span><span class="main">.</span> <span class="bound">ys</span> <span class="main">⊑</span> <span class="free">xs</span> <span class="main">∧</span> <span class="free">zs</span> <span class="main">⊑</span> <span class="bound">ys</span> <span class="main">∧</span> lfinite <span class="bound">ys</span><span class="main">}</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹lfinite <span class="free">zs</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">zs</span> <span class="main">⊑</span> <span class="free">xs</span>›</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> lfinite_LNil
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lSup_finite_prefixes<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>lfinite_LConsI <span class="skolem">zs</span> <span class="skolem">z</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹LCons <span class="skolem">z</span> <span class="skolem">zs</span> <span class="main">⊑</span> <span class="skolem">xs</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xs'</span></span> <span class="keyword2"><span class="keyword">where</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> LCons <span class="skolem">z</span> <span class="skolem">xs'</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">zs</span> <span class="main">⊑</span> <span class="skolem">xs'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> LCons_lprefix_conv<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> llist.expand<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"lnull <span class="var">?lhs</span> <span class="main">=</span> lnull <span class="var">?rhs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> xs lfinite_LConsI
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lprefix_LCons_conv <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> disjCI <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> disjI2<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> lnull<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lnull <span class="var">?lhs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lnull <span class="var">?rhs</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lhd <span class="var">?lhs</span> <span class="main">=</span> lhd <span class="var">?rhs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> lnull xs
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rev_image_eqI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> LCons_lprefix_conv<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ltl <span class="main">`</span> <span class="main">(</span><span class="main">{</span><span class="bound">ys</span><span class="main">.</span> <span class="bound">ys</span> <span class="main">⊑</span> <span class="skolem">xs</span> <span class="main">∧</span> LCons <span class="skolem">z</span> <span class="skolem">zs</span> <span class="main">⊑</span> <span class="bound">ys</span> <span class="main">∧</span> lfinite <span class="bound">ys</span><span class="main">}</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
          <span class="main">{</span><span class="bound">ys</span><span class="main">.</span> <span class="bound">ys</span> <span class="main">⊑</span> <span class="skolem">xs'</span> <span class="main">∧</span> <span class="skolem">zs</span> <span class="main">⊑</span> <span class="bound">ys</span> <span class="main">∧</span> lfinite <span class="bound">ys</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> xs <span class="quoted"><span class="quoted">‹<span class="main">¬</span> lnull <span class="var">?rhs</span>›</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lprefix_LCons_conv <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_image_eqI <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> disjCI <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> disjI2<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"ltl <span class="var">?lhs</span> <span class="main">=</span> ltl <span class="var">?rhs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> lfinite_LConsI.IH<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="skolem">zs</span> <span class="main">⊑</span> <span class="skolem">xs'</span>›</span></span><span class="main">]</span> xs <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"lhd <span class="var">?lhs</span> <span class="main">=</span> lhd <span class="var">?rhs</span> <span class="main">∧</span> ltl <span class="var">?lhs</span> <span class="main">=</span> ltl <span class="var">?rhs</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lSup_strict_prefixes"><span class="command">lemma</span></span> lSup_strict_prefixes<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">¬</span> lfinite <span class="free">xs</span> <span class="main">⟹</span> lSup <span class="main">{</span><span class="bound">ys</span><span class="main">.</span> <span class="bound">ys</span> <span class="main">⊑</span> <span class="free">xs</span> <span class="main">∧</span> <span class="bound">ys</span> <span class="main">≠</span> <span class="free">xs</span><span class="main">}</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">⟹</span> lSup <span class="main">(</span><span class="var">?C</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">_</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Eq_llist <span class="skolem">xs</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="skolem"><span class="skolem">x'</span></span> <span class="skolem"><span class="skolem">xs'</span></span> <span class="keyword2"><span class="keyword">where</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> LCons <span class="skolem">x</span> <span class="main">(</span>LCons <span class="skolem">x'</span> <span class="skolem">xs'</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lfinite <span class="skolem">xs'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rename_tac</span> xs'<span class="main"><span class="keyword3">,</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="improper">xs'</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="var"><span class="quoted"><span class="var">?lnull</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"LCons <span class="skolem">x</span> <span class="main">(</span>LCons <span class="skolem">x'</span> LNil<span class="main">)</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">hence</span></span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lnull <span class="main">(</span>lSup <span class="main">{</span><span class="bound">ys</span><span class="main">.</span> <span class="bound">ys</span> <span class="main">⊑</span> <span class="skolem">xs</span> <span class="main">∧</span> <span class="bound">ys</span> <span class="main">≠</span> <span class="skolem">xs</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> xs <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lhd <span class="main">(</span>lSup <span class="main">{</span><span class="bound">ys</span><span class="main">.</span> <span class="bound">ys</span> <span class="main">⊑</span> <span class="skolem">xs</span> <span class="main">∧</span> <span class="bound">ys</span> <span class="main">≠</span> <span class="skolem">xs</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> lhd <span class="skolem">xs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> xs
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> the_equality <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_image_eqI <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lprefix_lhdD<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> xs
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ltl <span class="main">`</span> <span class="main">(</span><span class="main">{</span><span class="bound">ys</span><span class="main">.</span> <span class="bound">ys</span> <span class="main">⊑</span> <span class="skolem">xs</span> <span class="main">∧</span> <span class="bound">ys</span> <span class="main">≠</span> <span class="skolem">xs</span><span class="main">}</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound">ys</span><span class="main">.</span> <span class="bound">ys</span> <span class="main">⊑</span> ltl <span class="skolem">xs</span> <span class="main">∧</span> <span class="bound">ys</span> <span class="main">≠</span> ltl <span class="skolem">xs</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lprefix_LCons_conv <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> image_eqI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"LCons <span class="skolem">x</span> <span class="main">(</span>LCons <span class="skolem">x'</span> <span class="skolem">ys</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">for</span></span></span></span> <span class="skolem">ys</span><span class="main"><span class="main">]</span></span> image_eqI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"LCons <span class="skolem">x</span> LNil"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> Eq_llist <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-chain_lprefix_lSup"><span class="command">lemma</span></span> chain_lprefix_lSup<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> Complete_Partial_Order.chain <span class="main">(⊑)</span> <span class="free">A</span><span class="main">;</span> <span class="free">xs</span> <span class="main">∈</span> <span class="free">A</span> <span class="main">⟧</span>
  <span class="main">⟹</span> <span class="free">xs</span> <span class="main">⊑</span> lSup <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">A</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>lprefix <span class="skolem">xs</span> <span class="skolem">A</span><span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> chain <span class="main">=</span> <span class="quoted"><span class="quoted">‹Complete_Partial_Order.chain <span class="main">(⊑)</span> <span class="skolem">A</span>›</span></span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">xs</span> <span class="main">∈</span> <span class="skolem">A</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> chainD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> chain<span class="main"><span class="main">]</span></span> lprefix_lhdD <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> chain_lprefix_ltl<span class="main"><span class="main">[</span></span><span class="operator">OF</span> chain<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> the_equality<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-chain_lSup_lprefix"><span class="command">lemma</span></span> chain_lSup_lprefix<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> Complete_Partial_Order.chain <span class="main">(⊑)</span> <span class="free">A</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">xs</span><span class="main">.</span> <span class="bound">xs</span> <span class="main">∈</span> <span class="free">A</span> <span class="main">⟹</span> <span class="bound">xs</span> <span class="main">⊑</span> <span class="free">zs</span> <span class="main">⟧</span>
  <span class="main">⟹</span> lSup <span class="free">A</span> <span class="main">⊑</span> <span class="free">zs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">A</span></span> <span class="quoted"><span class="free">zs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>lprefix <span class="skolem">A</span> <span class="skolem">zs</span><span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> chain <span class="main">=</span> <span class="quoted"><span class="quoted">‹Complete_Partial_Order.chain <span class="main">(⊑)</span> <span class="skolem">A</span>›</span></span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="main">∀</span><span class="bound">xs</span><span class="main">.</span> <span class="bound">xs</span> <span class="main">∈</span> <span class="skolem">A</span> <span class="main">⟶</span> <span class="bound">xs</span> <span class="main">⊑</span> <span class="skolem">zs</span>›</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 4 <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lprefix_lnullD lprefix_lhdD <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> chain_lprefix_ltl<span class="main"><span class="main">[</span></span><span class="operator">OF</span> chain<span class="main"><span class="main">]</span></span> lprefix_ltlI rev_image_eqI <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> the_equality<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-llist_ccpo"><span class="command">lemma</span></span> llist_ccpo <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">cont_intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"class.ccpo lSup <span class="main">(⊑)</span> <span class="main">(</span>mk_less <span class="main">(⊑)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lprefix_antisym <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> lprefix_trans chain_lprefix_lSup chain_lSup_lprefix <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mk_less_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">cont_intro</span><span class="main">]</span> <span class="main">=</span> ccpo.admissible_leI<span class="main">[</span><span class="operator">OF</span> llist_ccpo<span class="main">]</span>

<span class="keyword1" id="Coinductive_List-llist_partial_function_definitions"><span class="command">lemma</span></span> llist_partial_function_definitions<span class="main">:</span>
  <span class="quoted"><span class="quoted">"partial_function_definitions <span class="main">(⊑)</span> lSup"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lprefix_antisym <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> lprefix_trans chain_lprefix_lSup chain_lSup_lprefix<span class="main">)</span>

<span class="keyword1"><span class="command">interpretation</span></span> llist<span class="main">:</span> partial_function_definitions <span class="quoted"><span class="quoted">"<span class="main">(⊑)</span>"</span></span> <span class="quoted">lSup</span>
  <span class="keyword2"><span class="keyword">rewrites</span></span> <span class="quoted"><span class="quoted">"lSup <span class="main">{}</span> <span class="main">≡</span> LNil"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> llist_partial_function_definitions<span class="main">)</span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">mono_llist</span> <span class="main">≡</span> monotone <span class="main">(</span>fun_ord <span class="main">(⊑)</span><span class="main">)</span> <span class="main">(⊑)</span>"</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> llist_lift<span class="main">:</span> partial_function_definitions <span class="quoted"><span class="quoted">"fun_ord lprefix"</span></span> <span class="quoted"><span class="quoted">"fun_lub lSup"</span></span>
  <span class="keyword2"><span class="keyword">rewrites</span></span> <span class="quoted"><span class="quoted">"fun_lub lSup <span class="main">{}</span> <span class="main">≡</span> <span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> LNil"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> llist_partial_function_definitions<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> partial_function_lift<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">mono_llist_lift</span> <span class="main">≡</span> monotone <span class="main">(</span>fun_ord <span class="main">(</span>fun_ord lprefix<span class="main">)</span><span class="main">)</span> <span class="main">(</span>fun_ord lprefix<span class="main">)</span>"</span></span>

<span class="keyword1" id="Coinductive_List-lprefixes_chain"><span class="command">lemma</span></span> lprefixes_chain<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Complete_Partial_Order.chain <span class="main">(⊑)</span> <span class="main">{</span><span class="bound">ys</span><span class="main">.</span> lprefix <span class="bound">ys</span> <span class="free">xs</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> chainI<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lprefix_down_linear<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llist_gen_induct"><span class="command">lemma</span></span> llist_gen_induct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> adm<span class="main">:</span> <span class="quoted"><span class="quoted">"ccpo.admissible lSup <span class="main">(⊑)</span> <span class="free">P</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> step<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">zs</span><span class="main">.</span> <span class="bound">zs</span> <span class="main">⊑</span> <span class="free">xs</span> <span class="main">∧</span> lfinite <span class="bound">zs</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">ys</span><span class="main">.</span> <span class="bound">zs</span> <span class="main">⊑</span> <span class="bound">ys</span> <span class="main">⟶</span> <span class="bound">ys</span> <span class="main">⊑</span> <span class="free">xs</span> <span class="main">⟶</span> lfinite <span class="bound">ys</span> <span class="main">⟶</span> <span class="free">P</span> <span class="bound">ys</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> step <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">zs</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> zs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">zs</span> <span class="main">⊑</span> <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="skolem">zs</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> ys<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">ys</span><span class="main">.</span> <span class="main">⟦</span> <span class="skolem">zs</span> <span class="main">⊑</span> <span class="bound">ys</span><span class="main">;</span> <span class="bound">ys</span> <span class="main">⊑</span> <span class="free">xs</span><span class="main">;</span> lfinite <span class="bound">ys</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">ys</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?C</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">ys</span><span class="main">.</span> <span class="bound">ys</span> <span class="main">⊑</span> <span class="free">xs</span> <span class="main">∧</span> <span class="skolem">zs</span> <span class="main">⊑</span> <span class="bound">ys</span> <span class="main">∧</span> lfinite <span class="bound">ys</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> lprefixes_chain<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">xs</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Complete_Partial_Order.chain <span class="main">(⊑)</span> <span class="var">?C</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> chain_compr<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> adm <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span>lSup <span class="var">?C</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> ccpo.admissibleD<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> ys zs<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lSup <span class="var">?C</span>  <span class="main">=</span> <span class="free">xs</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> lSup_finite_gen_prefixes<span class="main">[</span><span class="operator">OF</span> zs<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-llist_induct"><span class="command">lemma</span></span> llist_induct <span class="main">[</span><span class="operator">case_names</span> adm LNil LCons<span class="main">,</span> <span class="operator">induct</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">type</span></span></span><span class="main"><span class="main"><span class="main"><span class="main">:</span></span></span></span> llist<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> adm<span class="main">:</span> <span class="quoted"><span class="quoted">"ccpo.admissible lSup <span class="main">(⊑)</span> <span class="free">P</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> LNil<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> LNil"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> LCons<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">xs</span><span class="main">.</span> <span class="main">⟦</span> lfinite <span class="bound">xs</span><span class="main">;</span> <span class="free">P</span> <span class="bound">xs</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span>LCons <span class="bound">x</span> <span class="bound">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">ys</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist"</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="skolem">ys</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="skolem">ys</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> LNil LCons<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">intro</span><span class="main">]</span> <span class="main">=</span> this
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> adm
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> llist_gen_induct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">LNil</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-LCons_mono"><span class="command">lemma</span></span> LCons_mono <span class="main">[</span><span class="operator">partial_function_mono</span><span class="main">,</span> <span class="operator">cont_intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"mono_llist <span class="free">A</span> <span class="main">⟹</span> mono_llist <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> LCons <span class="free">x</span> <span class="main">(</span><span class="free">A</span> <span class="bound">f</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monotoneI<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> monotoneD<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-mono2mono_LCons"><span class="command">lemma</span></span> mono2mono_LCons <span class="main">[</span><span class="operator">THEN</span> llist.mono2mono<span class="main">,</span> <span class="operator">simp</span><span class="main">,</span> <span class="operator">cont_intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> monotone_LCons<span class="main">:</span> <span class="quoted"><span class="quoted">"monotone <span class="main">(⊑)</span> <span class="main">(⊑)</span> <span class="main">(</span>LCons <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> monotoneI<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-mcont2mcont_LCons"><span class="command">lemma</span></span> mcont2mcont_LCons <span class="main">[</span><span class="operator">THEN</span> llist.mcont2mcont<span class="main">,</span> <span class="operator">simp</span><span class="main">,</span> <span class="operator">cont_intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> mcont_LCons<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont lSup <span class="main">(⊑)</span> lSup <span class="main">(⊑)</span> <span class="main">(</span>LCons <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mcont_def monotone_LCons lSup_LCons<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> contI<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-mono2mono_ltl"><span class="command">lemma</span></span> mono2mono_ltl<span class="main">[</span><span class="operator">THEN</span> llist.mono2mono<span class="main">,</span> <span class="operator">simp</span><span class="main">,</span> <span class="operator">cont_intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> monotone_ltl<span class="main">:</span> <span class="quoted"><span class="quoted">"monotone <span class="main">(⊑)</span> <span class="main">(⊑)</span> ltl"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> monotoneI lprefix_ltlI<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-cont_ltl"><span class="command">lemma</span></span> cont_ltl<span class="main">:</span> <span class="quoted"><span class="quoted">"cont lSup <span class="main">(⊑)</span> lSup <span class="main">(⊑)</span> ltl"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> contI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">Y</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist set"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">Y</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ltl <span class="main">(</span>lSup <span class="skolem">Y</span><span class="main">)</span> <span class="main">=</span> lSup <span class="main">(</span>insert LNil <span class="main">(</span>ltl <span class="main">`</span> <span class="main">(</span><span class="skolem">Y</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">}</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lSup_insert_LNil<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"insert LNil <span class="main">(</span>ltl <span class="main">`</span> <span class="main">(</span><span class="skolem">Y</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> insert LNil <span class="main">(</span>ltl <span class="main">`</span> <span class="skolem">Y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lSup <span class="main">…</span> <span class="main">=</span> lSup <span class="main">(</span>ltl <span class="main">`</span> <span class="skolem">Y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lSup_insert_LNil<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ltl <span class="main">(</span>lSup <span class="skolem">Y</span><span class="main">)</span> <span class="main">=</span> lSup <span class="main">(</span>ltl <span class="main">`</span> <span class="skolem">Y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-mcont2mcont_ltl"><span class="command">lemma</span></span> mcont2mcont_ltl <span class="main">[</span><span class="operator">THEN</span> llist.mcont2mcont<span class="main">,</span> <span class="operator">simp</span><span class="main">,</span> <span class="operator">cont_intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> mcont_ltl<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont lSup <span class="main">(⊑)</span> lSup <span class="main">(⊑)</span> ltl"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mcont_def monotone_ltl cont_ltl<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llist_case_mono"><span class="command">lemma</span></span> llist_case_mono <span class="main">[</span><span class="operator">partial_function_mono</span><span class="main">,</span> <span class="operator">cont_intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> lnil<span class="main">:</span> <span class="quoted"><span class="quoted">"monotone <span class="free">orda</span> <span class="free">ordb</span> <span class="free">lnil</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> lcons<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">xs</span><span class="main">.</span> monotone <span class="free">orda</span> <span class="free">ordb</span> <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="free">lcons</span> <span class="bound">f</span> <span class="bound">x</span> <span class="bound">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monotone <span class="free">orda</span> <span class="free">ordb</span> <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> case_llist <span class="main">(</span><span class="free">lnil</span> <span class="bound">f</span><span class="main">)</span> <span class="main">(</span><span class="free">lcons</span> <span class="bound">f</span><span class="main">)</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monotoneI<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> monotoneD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lnil<span class="main"><span class="main">]</span></span> monotoneD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lcons<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Coinductive_List-mcont_llist_case"><span class="command">lemma</span></span> mcont_llist_case <span class="main">[</span><span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> mcont <span class="free">luba</span> <span class="free">orda</span> <span class="free">lubb</span> <span class="free">ordb</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">x</span> <span class="bound">xs</span><span class="main">.</span> mcont <span class="free">luba</span> <span class="free">orda</span> <span class="free">lubb</span> <span class="free">ordb</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="free">g</span> <span class="bound">x</span> <span class="bound">xs</span> <span class="bound">y</span><span class="main">)</span> <span class="main">⟧</span>
  <span class="main">⟹</span> mcont <span class="free">luba</span> <span class="free">orda</span> <span class="free">lubb</span> <span class="free">ordb</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="keyword1">case</span> <span class="free">xs</span> <span class="keyword1">of</span> LNil <span class="main">⇒</span> <span class="free">f</span> <span class="bound">y</span> <span class="main">|</span> LCons <span class="bound">x</span> <span class="bound">xs'</span> <span class="main">⇒</span> <span class="free">g</span> <span class="bound">x</span> <span class="bound">xs'</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-monotone_lprefix_case"><span class="command">lemma</span></span> monotone_lprefix_case <span class="main">[</span><span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> monotone <span class="main">(⊑)</span> <span class="main">(⊑)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="bound">xs</span> <span class="main">(</span>LCons <span class="bound">x</span> <span class="bound">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monotone <span class="main">(⊑)</span> <span class="main">(⊑)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">xs</span> <span class="keyword1">of</span> LNil <span class="main">⇒</span> LNil <span class="main">|</span> LCons <span class="bound">x</span> <span class="bound">xs'</span> <span class="main">⇒</span> <span class="free">f</span> <span class="bound">x</span> <span class="bound">xs'</span> <span class="bound">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> llist.monotone_if_bot<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">λ</span></span></span><span class="bound"><span class="bound"><span class="bound">xs</span></span></span><span class="main"><span class="main"><span class="main">.</span></span></span> <span class="free"><span class="free"><span class="free">f</span></span></span> <span class="main"><span class="main"><span class="main">(</span></span></span>lhd <span class="bound"><span class="bound"><span class="bound">xs</span></span></span><span class="main"><span class="main"><span class="main">)</span></span></span> <span class="main"><span class="main"><span class="main">(</span></span></span>ltl <span class="bound"><span class="bound"><span class="bound">xs</span></span></span><span class="main"><span class="main"><span class="main">)</span></span></span> <span class="bound"><span class="bound"><span class="bound">xs</span></span></span>"</span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> bound<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">LNil</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lnull_conv LCons_lprefix_conv <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> monotoneD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mono<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Coinductive_List-mcont_lprefix_case_aux"><span class="command">lemma</span></span> mcont_lprefix_case_aux<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="free">bot</span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span>lhd <span class="bound">xs</span><span class="main">)</span> <span class="main">(</span>ltl <span class="bound">xs</span><span class="main">)</span> <span class="main">(</span>LCons <span class="main">(</span>lhd <span class="bound">xs</span><span class="main">)</span> <span class="main">(</span>ltl <span class="bound">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> mcont<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> mcont lSup <span class="main">(⊑)</span> <span class="free">lub</span> <span class="free">ord</span> <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="bound">xs</span> <span class="main">(</span>LCons <span class="bound">x</span> <span class="bound">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> ccpo<span class="main">:</span> <span class="quoted"><span class="quoted">"class.ccpo <span class="free">lub</span> <span class="free">ord</span> <span class="main">(</span>mk_less <span class="free">ord</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> bot<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">ord</span> <span class="free">bot</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mcont lSup <span class="main">(⊑)</span> <span class="free">lub</span> <span class="free">ord</span> <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">xs</span> <span class="keyword1">of</span> LNil <span class="main">⇒</span> <span class="free">bot</span> <span class="main">|</span> LCons <span class="bound">x</span> <span class="bound">xs'</span> <span class="main">⇒</span> <span class="free">f</span> <span class="bound">x</span> <span class="bound">xs'</span> <span class="bound">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> llist.mcont_if_bot<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">g</span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> bound<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">LNil</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> bot<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">bot</span></span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">OF</span> ccpo bot<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">Y</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist set"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> chain<span class="main">:</span> <span class="quoted"><span class="quoted">"Complete_Partial_Order.chain <span class="main">(⊑)</span> <span class="skolem">Y</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> Y<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">Y</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="skolem">Y</span> <span class="main">⟹</span> <span class="main">¬</span> <span class="bound">x</span> <span class="main">⊑</span> LNil"</span></span>
  <span class="keyword1"><span class="command">from</span></span> Y <span class="keyword1"><span class="command">have</span></span> Y'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">Y</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">}</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> Y <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="skolem"><span class="skolem">xs</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"LCons <span class="skolem">x</span> <span class="skolem">xs</span> <span class="main">∈</span> <span class="skolem">Y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lnull_conv<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> Y<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">Y</span> <span class="main">=</span> LCons <span class="skolem">x</span> <span class="main">`</span> <span class="main">(</span>ltl <span class="main">`</span> <span class="main">(</span><span class="skolem">Y</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> chainD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> chain<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> LCons_lprefix_conv lprefix_LCons_conv <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> imageI rev_image_eqI<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">(</span>lSup <span class="skolem">Y</span><span class="main">)</span> <span class="main">=</span> <span class="free">lub</span> <span class="main">(</span><span class="free">g</span> <span class="main">`</span> <span class="skolem">Y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2<span class="main"><span class="main">)</span></span> eq<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lSup_LCons Y' g_def mcont_contD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mcont<span class="main"><span class="main">]</span></span> chain chain_lprefix_ltl<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> image_image<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lnull_conv LCons_lprefix_conv g_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> mcont_monoD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mcont<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Coinductive_List-mcont_lprefix_case"><span class="command">lemma</span></span> mcont_lprefix_case <span class="main">[</span><span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> mcont lSup <span class="main">(⊑)</span> lSup <span class="main">(⊑)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="bound">xs</span> <span class="main">(</span>LCons <span class="bound">x</span> <span class="bound">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mcont lSup <span class="main">(⊑)</span> lSup <span class="main">(⊑)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">xs</span> <span class="keyword1">of</span> LNil <span class="main">⇒</span> LNil <span class="main">|</span> LCons <span class="bound">x</span> <span class="bound">xs'</span> <span class="main">⇒</span> <span class="free">f</span> <span class="bound">x</span> <span class="bound">xs'</span> <span class="bound">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> mcont_lprefix_case_aux<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_ccpo<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-monotone_lprefix_case_lfp"><span class="command">lemma</span></span> monotone_lprefix_case_lfp <span class="main">[</span><span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">⇒</span> <span class="main">_</span> <span class="main">::</span> order_bot"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> monotone <span class="main">(⊑)</span> <span class="main">(≤)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="bound">xs</span> <span class="main">(</span>LCons <span class="bound">x</span> <span class="bound">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monotone <span class="main">(⊑)</span> <span class="main">(≤)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">xs</span> <span class="keyword1">of</span> LNil <span class="main">⇒</span> <span class="main">⊥</span> <span class="main">|</span> LCons <span class="bound">x</span> <span class="bound">xs</span> <span class="main">⇒</span> <span class="free">f</span> <span class="bound">x</span> <span class="bound">xs</span> <span class="main">(</span>LCons <span class="bound">x</span> <span class="bound">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> llist.monotone_if_bot<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> bound<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">LNil</span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> bot<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="main"><span class="quoted"><span class="main"><span class="quoted"><span class="main">⊥</span></span></span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">λ</span></span></span><span class="bound"><span class="bound"><span class="bound">xs</span></span></span><span class="main"><span class="main"><span class="main">.</span></span></span> <span class="free"><span class="free"><span class="free">f</span></span></span> <span class="main"><span class="main"><span class="main">(</span></span></span>lhd <span class="bound"><span class="bound"><span class="bound">xs</span></span></span><span class="main"><span class="main"><span class="main">)</span></span></span> <span class="main"><span class="main"><span class="main">(</span></span></span>ltl <span class="bound"><span class="bound"><span class="bound">xs</span></span></span><span class="main"><span class="main"><span class="main">)</span></span></span> <span class="bound"><span class="bound"><span class="bound">xs</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lnull_conv LCons_lprefix_conv <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> monotoneD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mono<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-mcont_lprefix_case_lfp"><span class="command">lemma</span></span> mcont_lprefix_case_lfp <span class="main">[</span><span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=&gt;</span> <span class="main">_</span> <span class="main">::</span> complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> mcont lSup <span class="main">(⊑)</span> Sup <span class="main">(≤)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="bound">xs</span> <span class="main">(</span>LCons <span class="bound">x</span> <span class="bound">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mcont lSup <span class="main">(⊑)</span> Sup <span class="main">(≤)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">xs</span> <span class="keyword1">of</span> LNil <span class="main">⇒</span> <span class="main">⊥</span> <span class="main">|</span> LCons <span class="bound">x</span> <span class="bound">xs</span> <span class="main">⇒</span> <span class="free">f</span> <span class="bound">x</span> <span class="bound">xs</span> <span class="main">(</span>LCons <span class="bound">x</span> <span class="bound">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> mcont_lprefix_case_aux<span class="main">)</span><span class="main">(</span><span class="operator">rule</span> complete_lattice_ccpo'<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">declaration</span></span> <span class="quoted">‹<span class="entity">Partial_Function.init</span> <span class="inner_quoted">"llist"</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">llist.fixp_fun</span><span class="antiquote">}</span></span>
  <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">llist.mono_body</span><span class="antiquote">}</span></span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> llist.fixp_rule_uc<span class="antiquote">}</span></span></span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> llist.fixp_strong_induct_uc<span class="antiquote">}</span></span></span> NONE›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Monotonicity and continuity of already defined functions›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="free">F</span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">F</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">lmap</span> <span class="bound">xs</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">xs</span> <span class="keyword1">of</span> LNil <span class="main">⇒</span> LNil <span class="main">|</span> LCons <span class="bound">x</span> <span class="bound">xs</span> <span class="main">⇒</span> LCons <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="bound">lmap</span> <span class="bound">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> lmap_conv_fixp<span class="main">:</span> <span class="quoted"><span class="quoted">"lmap <span class="free">f</span> <span class="main">≡</span> ccpo.fixp <span class="main">(</span>fun_lub lSup<span class="main">)</span> <span class="main">(</span>fun_ord <span class="main">(⊑)</span><span class="main">)</span> <span class="free">F</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">≡</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> lmap_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span><span class="main">.</span> mono_llist <span class="main">(</span><span class="main">λ</span><span class="bound">lmap</span><span class="main">.</span> <span class="free">F</span> <span class="bound">lmap</span> <span class="bound">xs</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">PROP</span> <span class="var">?mono</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">intro</span> eq_reflection ext<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">PROP</span> <span class="var">?mono</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> F_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">tactic</span> <span class="quoted">‹<span class="entity">Partial_Function.mono_tac</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span>›</span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="skolem">xs</span> <span class="main">=</span> <span class="var">?rhs</span> <span class="skolem">xs</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> Eq_llist
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 3 4<span class="main"><span class="main">)</span></span> llist.mono_body_fixp<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mono<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> F_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-mono2mono_lmap"><span class="command">lemma</span></span> mono2mono_lmap<span class="main">[</span><span class="operator">THEN</span> llist.mono2mono<span class="main">,</span> <span class="operator">simp</span><span class="main">,</span> <span class="operator">cont_intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> monotone_lmap<span class="main">:</span> <span class="quoted"><span class="quoted">"monotone <span class="main">(⊑)</span> <span class="main">(⊑)</span> <span class="main">(</span>lmap <span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> llist.fixp_preserves_mono1<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lmap_mono lmap_conv_fixp<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-mcont2mcont_lmap"><span class="command">lemma</span></span> mcont2mcont_lmap<span class="main">[</span><span class="operator">THEN</span> llist.mcont2mcont<span class="main">,</span> <span class="operator">simp</span><span class="main">,</span> <span class="operator">cont_intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> mcont_lmap<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont lSup <span class="main">(⊑)</span> lSup <span class="main">(⊑)</span> <span class="main">(</span>lmap <span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> llist.fixp_preserves_mcont1<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lmap_mono lmap_conv_fixp<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">partial_function_mono</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"mono_llist <span class="free">F</span> <span class="main">⟹</span> mono_llist <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> lmap <span class="free">g</span> <span class="main">(</span><span class="free">F</span> <span class="bound">f</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> mono2mono_lmap<span class="main">)</span>


<span class="keyword1" id="Coinductive_List-mono_llist_lappend2"><span class="command">lemma</span></span> mono_llist_lappend2 <span class="main">[</span><span class="operator">partial_function_mono</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"mono_llist <span class="free">A</span> <span class="main">⟹</span> mono_llist <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> lappend <span class="free">xs</span> <span class="main">(</span><span class="free">A</span> <span class="bound">f</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> monotoneI lprefix_lappend_sameI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_ord_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> monotoneD<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-mono2mono_lappend2"><span class="command">lemma</span></span> mono2mono_lappend2 <span class="main">[</span><span class="operator">THEN</span> llist.mono2mono<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> monotone_lappend2<span class="main">:</span> <span class="quoted"><span class="quoted">"monotone <span class="main">(⊑)</span> <span class="main">(⊑)</span> <span class="main">(</span>lappend <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monotoneI<span class="main">)</span><span class="main">(</span><span class="operator">rule</span> lprefix_lappend_sameI<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-mcont2mcont_lappend2"><span class="command">lemma</span></span> mcont2mcont_lappend2 <span class="main">[</span><span class="operator">THEN</span> llist.mcont2mcont<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> mcont_lappend2<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont lSup <span class="main">(⊑)</span> lSup <span class="main">(⊑)</span> <span class="main">(</span>lappend <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> monotone_lappend2<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lappend <span class="free">xs</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff lappend_inf<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ccpo.cont_const<span class="main"><span class="main">[</span></span><span class="operator">OF</span> llist_ccpo<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="free">F</span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">F</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">lset</span> <span class="bound">xs</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">xs</span> <span class="keyword1">of</span> LNil <span class="main">⇒</span> <span class="main">{}</span> <span class="main">|</span> LCons <span class="bound">x</span> <span class="bound">xs</span> <span class="main">⇒</span> insert <span class="bound">x</span> <span class="main">(</span><span class="bound">lset</span> <span class="bound">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> lset_conv_fixp<span class="main">:</span> <span class="quoted"><span class="quoted">"lset <span class="main">≡</span> ccpo.fixp <span class="main">(</span>fun_lub Union<span class="main">)</span> <span class="main">(</span>fun_ord <span class="main">(⊆)</span><span class="main">)</span> <span class="free">F</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">≡</span> <span class="var">?fixp</span>"</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> lset_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> monotone <span class="main">(</span>fun_ord <span class="main">(⊆)</span><span class="main">)</span> <span class="main">(⊆)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="free">F</span> <span class="bound">f</span> <span class="bound">x</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">PROP</span> <span class="var">?mono</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> eq_reflection ext antisym subsetI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword3"><span class="command">show</span></span> mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">PROP</span> <span class="var">?mono</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> F_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">tactic</span> <span class="quoted">‹<span class="entity">Partial_Function.mono_tac</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span>›</span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">xs</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?fixp</span> <span class="skolem">xs</span> <span class="main">⊆</span> lset <span class="skolem">xs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lfp.fixp_induct_uc<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">λ</span></span></span><span class="bound"><span class="bound"><span class="bound">x</span></span></span><span class="main"><span class="main"><span class="main">.</span></span></span> <span class="bound"><span class="bound"><span class="bound">x</span></span></span>"</span></span></span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">F</span></span></span></span></span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">λ</span></span></span><span class="bound"><span class="bound"><span class="bound">x</span></span></span><span class="main"><span class="main"><span class="main">.</span></span></span> <span class="bound"><span class="bound"><span class="bound">x</span></span></span>"</span></span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">OF</span> mono reflexive refl<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> F_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split<span class="main">)</span>

  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> lset <span class="skolem">xs</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="var">?fixp</span> <span class="skolem">xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span><span class="main">(</span><span class="operator">subst</span> lfp.mono_body_fixp<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mono<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> F_def<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-mono2mono_lset"><span class="command">lemma</span></span> mono2mono_lset <span class="main">[</span><span class="operator">THEN</span> lfp.mono2mono<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> monotone_lset<span class="main">:</span> <span class="quoted"><span class="quoted">"monotone <span class="main">(⊑)</span> <span class="main">(⊆)</span> lset"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> lfp.fixp_preserves_mono1<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lset_mono lset_conv_fixp<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-mcont2mcont_lset"><span class="command">lemma</span></span> mcont2mcont_lset<span class="main">[</span><span class="operator">THEN</span> mcont2mcont<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> mcont_lset<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont lSup <span class="main">(⊑)</span> Union <span class="main">(⊆)</span> lset"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> lfp.fixp_preserves_mcont1<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lset_mono lset_conv_fixp<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-lset_lSup"><span class="command">lemma</span></span> lset_lSup<span class="main">:</span> <span class="quoted"><span class="quoted">"Complete_Partial_Order.chain <span class="main">(⊑)</span> <span class="free">Y</span> <span class="main">⟹</span> lset <span class="main">(</span>lSup <span class="free">Y</span><span class="main">)</span> <span class="main">=</span> <span class="main">⋃</span><span class="main">(</span>lset <span class="main">`</span> <span class="free">Y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">Y</span> <span class="main">=</span> <span class="main">{}</span>"</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mcont_lset<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> mcont_contD<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lfinite_lSupD"><span class="command">lemma</span></span> lfinite_lSupD<span class="main">:</span> <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>lSup <span class="free">A</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">∀</span><span class="bound">xs</span> <span class="main">∈</span> <span class="free">A</span><span class="main">.</span> lfinite <span class="bound">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="skolem">ys</span><span class="main"><span class="main">≡</span></span><span class="quoted"><span class="quoted">"lSup <span class="free">A</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">A</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lfinite_induct<span class="main">)</span> <span class="operator">fastforce</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Coinductive_List-monotone_enat_le_lprefix_case"><span class="command">lemma</span></span> monotone_enat_le_lprefix_case <span class="main">[</span><span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monotone <span class="main">(≤)</span> <span class="main">(⊑)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">(</span>eSuc <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> monotone <span class="main">(≤)</span> <span class="main">(⊑)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">x</span> <span class="keyword1">of</span> <span class="main">0</span> <span class="main">⇒</span> LNil <span class="main">|</span> eSuc <span class="bound">x'</span> <span class="main">⇒</span> <span class="free">f</span> <span class="bound">x'</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">erule</span> monotone_enat_le_case<span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-mcont_enat_le_lprefix_case"><span class="command">lemma</span></span> mcont_enat_le_lprefix_case <span class="main">[</span><span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"mcont Sup <span class="main">(≤)</span> lSup <span class="main">(⊑)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">(</span>eSuc <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mcont Sup <span class="main">(≤)</span> lSup <span class="main">(⊑)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">x</span> <span class="keyword1">of</span> <span class="main">0</span> <span class="main">⇒</span> LNil <span class="main">|</span> eSuc <span class="bound">x'</span> <span class="main">⇒</span> <span class="free">f</span> <span class="bound">x'</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> llist_ccpo assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> mcont_enat_le_case<span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-compact_LConsI"><span class="command">lemma</span></span> compact_LConsI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ccpo.compact lSup <span class="main">(⊑)</span> <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ccpo.compact lSup <span class="main">(⊑)</span> <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> llist_ccpo
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ccpo.compactI<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ccpo.admissible lSup <span class="main">(⊑)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">ys</span><span class="main">.</span> <span class="main">¬</span> <span class="free">xs</span> <span class="main">⊑</span> <span class="bound">ys</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">cases</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">cont_intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ccpo.admissible lSup <span class="main">(⊑)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">ys</span><span class="main">.</span> <span class="main">¬</span> <span class="free">xs</span> <span class="main">⊑</span> ltl <span class="bound">ys</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> mcont_ltl <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> admissible_subst<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">cont_intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ccpo.admissible lSup <span class="main">(⊑)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">ys</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">ys</span> <span class="main">∧</span> lhd <span class="bound">ys</span> <span class="main">≠</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ccpo.admissibleI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">Y</span>
    <span class="keyword3"><span class="command">assume</span></span> chain<span class="main">:</span> <span class="quoted"><span class="quoted">"Complete_Partial_Order.chain <span class="main">(⊑)</span> <span class="skolem">Y</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">Y</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">ys</span><span class="main">∈</span><span class="skolem">Y</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">ys</span> <span class="main">∧</span> lhd <span class="bound">ys</span> <span class="main">≠</span> <span class="free">x</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> * <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lnull <span class="main">(</span>lSup <span class="skolem">Y</span><span class="main">)</span> <span class="main">∧</span> lhd <span class="main">(</span>lSup <span class="skolem">Y</span><span class="main">)</span> <span class="main">≠</span> <span class="free">x</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> lhd_lSup<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 4 <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> chainD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> chain<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> the_equality<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lprefix_lhdD<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">have</span></span> eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">ys</span><span class="main">.</span> <span class="main">¬</span> LCons <span class="free">x</span> <span class="free">xs</span> <span class="main">⊑</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">ys</span><span class="main">.</span> <span class="main">¬</span> <span class="free">xs</span> <span class="main">⊑</span> ltl <span class="bound">ys</span> <span class="main">∨</span> <span class="bound">ys</span> <span class="main">=</span> LNil <span class="main">∨</span> <span class="main">¬</span> lnull <span class="bound">ys</span> <span class="main">∧</span> lhd <span class="bound">ys</span> <span class="main">≠</span> <span class="free">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff LCons_lprefix_conv neq_LNil_conv<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ccpo.admissible lSup <span class="main">(⊑)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">ys</span><span class="main">.</span> <span class="main">¬</span> LCons <span class="free">x</span> <span class="free">xs</span> <span class="main">⊑</span> <span class="bound">ys</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-compact_LConsD"><span class="command">lemma</span></span> compact_LConsD<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ccpo.compact lSup <span class="main">(⊑)</span> <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ccpo.compact lSup <span class="main">(⊑)</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> llist_ccpo
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ccpo.compactI<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ccpo.admissible lSup <span class="main">(⊑)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">ys</span><span class="main">.</span> <span class="main">¬</span> LCons <span class="free">x</span> <span class="free">xs</span> <span class="main">⊑</span> <span class="bound">ys</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">cases</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"ccpo.admissible lSup <span class="main">(⊑)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">ys</span><span class="main">.</span> <span class="main">¬</span> LCons <span class="free">x</span> <span class="free">xs</span> <span class="main">⊑</span> LCons <span class="free">x</span> <span class="bound">ys</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> admissible_subst<span class="main">)</span><span class="main">(</span><span class="operator">rule</span> mcont_LCons<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"ccpo.admissible lSup <span class="main">(⊑)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">ys</span><span class="main">.</span> <span class="main">¬</span> <span class="free">xs</span> <span class="main">⊑</span> <span class="bound">ys</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-compact_LCons_iff"><span class="command">lemma</span></span> compact_LCons_iff <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"ccpo.compact lSup <span class="main">(⊑)</span> <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟷</span> ccpo.compact lSup <span class="main">(⊑)</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> compact_LConsI compact_LConsD<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-compact_lfiniteI"><span class="command">lemma</span></span> compact_lfiniteI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span> <span class="main">⟹</span> ccpo.compact lSup <span class="main">(⊑)</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lfinite.induct<span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-compact_lfiniteD"><span class="command">lemma</span></span> compact_lfiniteD<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ccpo.compact lSup <span class="main">(⊑)</span> <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> inf<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lfinite <span class="free">xs</span>"</span></span>

  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ccpo.admissible lSup <span class="main">(⊑)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">ys</span><span class="main">.</span> <span class="main">¬</span> <span class="free">xs</span> <span class="main">⊑</span> <span class="bound">ys</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">cases</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?C</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">ys</span><span class="main">.</span> <span class="bound">ys</span> <span class="main">⊑</span> <span class="free">xs</span> <span class="main">∧</span> <span class="bound">ys</span> <span class="main">≠</span> <span class="free">xs</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Complete_Partial_Order.chain <span class="main">(⊑)</span> <span class="var">?C</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> lprefixes_chain<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">xs</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> chain_compr<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?C</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> inf <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">xs</span> <span class="main">⊑</span> lSup <span class="var">?C</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> ccpo.admissibleD<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lprefix_antisym<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lSup <span class="var">?C</span> <span class="main">=</span> <span class="free">xs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> inf <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> lSup_strict_prefixes<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-compact_eq_lfinite"><span class="command">lemma</span></span> compact_eq_lfinite <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ccpo.compact lSup <span class="main">(⊑)</span> <span class="main">=</span> lfinite"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> compact_lfiniteI compact_lfiniteD<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹More function definitions›</span></span>

<span class="keyword1"><span class="command">primcorec</span></span> <span class="entity">iterates</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> llist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">iterates</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> LCons <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="free">iterates</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">llist_of</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> llist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">llist_of</span> <span class="main">[]</span> <span class="main">=</span> LNil"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">llist_of</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> LCons <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="free">llist_of</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">list_of</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">list_of</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> lfinite <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">then</span> inv llist_of <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">else</span> undefined<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">llength</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">⇒</span> enat"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">llength</span> <span class="main">=</span> enat_unfold lnull ltl"</span></span>

<span class="keyword1"><span class="command">primcorec</span></span> <span class="entity">ltake</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"enat <span class="main">⇒</span> <span class="tfree">'a</span> llist <span class="main">⇒</span> <span class="tfree">'a</span> llist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="main">∨</span> lnull <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">⟹</span> lnull <span class="main">(</span><span class="free">ltake</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"lhd <span class="main">(</span><span class="free">ltake</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> lhd <span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"ltl <span class="main">(</span><span class="free">ltake</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">ltake</span> <span class="main">(</span>epred <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">(</span>ltl <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ldropn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="tfree">'a</span> llist <span class="main">⇒</span> <span class="tfree">'a</span> llist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ldropn</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="main">(</span>ltl <span class="main">^^</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">function_internals</span><span class="main">]</span><span class="main">]</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">partial_function</span></span> <span class="main">(</span>llist<span class="main">)</span> <span class="entity">ldrop</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"enat <span class="main">⇒</span> <span class="tfree">'a</span> llist <span class="main">⇒</span> <span class="tfree">'a</span> llist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ldrop</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">of</span> <span class="main">0</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">|</span> eSuc <span class="bound">n'</span> <span class="main">⇒</span> <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">of</span> LNil <span class="main">⇒</span> LNil <span class="main">|</span> LCons <span class="bound">x</span> <span class="bound">xs'</span> <span class="main">⇒</span> <span class="free">ldrop</span> <span class="bound">n'</span> <span class="bound">xs'</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">primcorec</span></span> <span class="entity">ltakeWhile</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> llist <span class="main">⇒</span> <span class="tfree">'a</span> llist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"lnull <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">∨</span> <span class="main">¬</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">(</span>lhd <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">⟹</span> lnull <span class="main">(</span><span class="free">ltakeWhile</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"lhd <span class="main">(</span><span class="free">ltakeWhile</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> lhd <span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"ltl <span class="main">(</span><span class="free">ltakeWhile</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">ltakeWhile</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">(</span>ltl <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">P</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">function_internals</span><span class="main">]</span><span class="main">]</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">partial_function</span></span> <span class="main">(</span>llist<span class="main">)</span> <span class="entity">ldropWhile</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">⇒</span> <span class="tfree">'a</span> llist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ldropWhile</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">of</span> LNil <span class="main">⇒</span> LNil <span class="main">|</span> LCons <span class="bound">x</span> <span class="bound">xs'</span> <span class="main">⇒</span> <span class="keyword1">if</span> <span class="free">P</span> <span class="bound">x</span> <span class="keyword1">then</span> <span class="free">ldropWhile</span> <span class="bound">xs'</span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">partial_function</span></span> <span class="main">(</span>llist<span class="main">)</span> <span class="entity">lfilter</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">⇒</span> <span class="tfree">'a</span> llist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">lfilter</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">of</span> LNil <span class="main">⇒</span> LNil <span class="main">|</span> LCons <span class="bound">x</span> <span class="bound">xs'</span> <span class="main">⇒</span> <span class="keyword1">if</span> <span class="free">P</span> <span class="bound">x</span> <span class="keyword1">then</span> LCons <span class="bound">x</span> <span class="main">(</span><span class="free">lfilter</span> <span class="bound">xs'</span><span class="main">)</span> <span class="keyword1">else</span> <span class="free">lfilter</span> <span class="bound">xs'</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">lnth</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">⇒</span> nat <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lnth</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">0</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">of</span> LNil <span class="main">⇒</span> undefined <span class="main">(</span><span class="main">0</span> <span class="main">::</span> nat<span class="main">)</span> <span class="main">|</span> LCons <span class="bound">x</span> <span class="bound">xs'</span> <span class="main">⇒</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">lnth</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">of</span> LNil <span class="main">⇒</span> undefined <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">|</span> LCons <span class="bound">x</span> <span class="bound">xs'</span> <span class="main">⇒</span> <span class="free">lnth</span> <span class="bound">xs'</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">declare</span></span> lnth.simps <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword">del</span></span><span class="main">]</span>

<span class="keyword1"><span class="command">primcorec</span></span> <span class="entity">lzip</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">⇒</span> <span class="tfree">'b</span> llist <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> llist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"lnull <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">∨</span> lnull <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">⟹</span> lnull <span class="main">(</span><span class="free">lzip</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"lhd <span class="main">(</span><span class="free">lzip</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>lhd <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">,</span> lhd <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"ltl <span class="main">(</span><span class="free">lzip</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">lzip</span> <span class="main">(</span>ltl <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">(</span>ltl <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">llast</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">nitpick_simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">llast</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> llength <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">of</span> enat <span class="bound">n</span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> <span class="bound">n</span> <span class="keyword1">of</span> <span class="main">0</span> <span class="main">⇒</span> undefined <span class="main">|</span> Suc <span class="bound">n'</span> <span class="main">⇒</span> lnth <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="bound">n'</span><span class="main">)</span> <span class="main">|</span> <span class="main">∞</span> <span class="main">⇒</span> undefined<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">coinductive</span></span> <span class="entity">ldistinct</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  LNil <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">ldistinct</span> LNil"</span></span>
<span class="main">|</span> LCons<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">∉</span> lset <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">;</span> <span class="free">ldistinct</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">ldistinct</span> <span class="main">(</span>LCons <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">hide_fact</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> LNil LCons

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">inf_llist</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> llist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">inf_llist</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> lmap <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>iterates Suc <span class="main">0</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">repeat</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> llist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">repeat</span> <span class="main">≡</span> iterates <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">lstrict_prefix</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">⇒</span> <span class="tfree">'a</span> llist <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">lstrict_prefix</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">⊑</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≠</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹longest common prefix›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">llcp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">⇒</span> <span class="tfree">'a</span> llist <span class="main">⇒</span> enat"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">llcp</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">=</span>
   enat_unfold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="bound">ys</span><span class="main">)</span><span class="main">.</span> lnull <span class="bound">xs</span> <span class="main">∨</span> lnull <span class="bound">ys</span> <span class="main">∨</span> lhd <span class="bound">xs</span> <span class="main">≠</span> lhd <span class="bound">ys</span><span class="main">)</span> <span class="main">(</span>map_prod ltl ltl<span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">coinductive</span></span> <span class="entity">llexord</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> llist <span class="main">⇒</span> <span class="tfree">'a</span> llist <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">for</span></span> <span class="entity">r</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  llexord_LCons_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">llexord</span> <span class="free">r</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">⟹</span> <span class="free">llexord</span> <span class="free">r</span> <span class="main">(</span>LCons <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">(</span>LCons <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> llexord_LCons_less<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">⟹</span> <span class="free">llexord</span> <span class="free">r</span> <span class="main">(</span>LCons <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">(</span>LCons <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> llexord_LNil <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">llexord</span> <span class="free">r</span> LNil <span class="free"><span class="bound"><span class="entity">ys</span></span></span>"</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">function_internals</span><span class="main">]</span><span class="main">]</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">partial_function</span></span> <span class="main">(</span>llist<span class="main">)</span> <span class="entity">lconcat</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist llist <span class="main">⇒</span> <span class="tfree">'a</span> llist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">lconcat</span> <span class="free"><span class="bound"><span class="entity">xss</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">xss</span></span></span> <span class="keyword1">of</span> LNil <span class="main">⇒</span> LNil <span class="main">|</span> LCons <span class="bound">xs</span> <span class="bound">xss'</span> <span class="main">⇒</span> lappend <span class="bound">xs</span> <span class="main">(</span><span class="free">lconcat</span> <span class="bound">xss'</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">lhd'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">⇒</span> <span class="tfree">'a</span> option"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">lhd'</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> lnull <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">then</span> None <span class="keyword1">else</span> Some <span class="main">(</span>lhd <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Coinductive_List-lhd'_simps"><span class="command">lemma</span></span> lhd'_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lhd' LNil <span class="main">=</span> None"</span></span>
  <span class="quoted"><span class="quoted">"lhd' <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> Some <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> lhd'_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ltl'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">⇒</span> <span class="tfree">'a</span> llist option"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">ltl'</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> lnull <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">then</span> None <span class="keyword1">else</span> Some <span class="main">(</span>ltl <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Coinductive_List-ltl'_simps"><span class="command">lemma</span></span> ltl'_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"ltl' LNil <span class="main">=</span> None"</span></span>
  <span class="quoted"><span class="quoted">"ltl' <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> Some <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> ltl'_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">lnths</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">⇒</span> nat set <span class="main">⇒</span> <span class="tfree">'a</span> llist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">lnths</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">=</span> lmap fst <span class="main">(</span>lfilter <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">)</span> <span class="main">(</span>lzip <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">(</span>iterates Suc <span class="main">0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> monoid_add<span class="main">)</span> <span class="entity">lsum_list</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">lsum_list</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> lfinite <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">then</span> sum_list <span class="main">(</span>list_of <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Converting ordinary lists to lazy lists: <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"llist_of"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1" id="Coinductive_List-lhd_llist_of"><span class="command">lemma</span></span> lhd_llist_of <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lhd <span class="main">(</span>llist_of <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> hd <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hd_def lhd_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ltl_llist_of"><span class="command">lemma</span></span> ltl_llist_of <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ltl <span class="main">(</span>llist_of <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> llist_of <span class="main">(</span>tl <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-lfinite_llist_of"><span class="command">lemma</span></span> lfinite_llist_of <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>llist_of <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_List-lfinite_eq_range_llist_of"><span class="command">lemma</span></span> lfinite_eq_range_llist_of<span class="main">:</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span> <span class="main">⟷</span> <span class="free">xs</span> <span class="main">∈</span> range llist_of"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">∈</span> range llist_of"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lfinite.induct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> llist_of.simps<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">∈</span> range llist_of"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> lfinite_llist_of<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lnull_llist_of"><span class="command">lemma</span></span> lnull_llist_of <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lnull <span class="main">(</span>llist_of <span class="free">xs</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">xs</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-llist_of_eq_LNil_conv"><span class="command">lemma</span></span> llist_of_eq_LNil_conv<span class="main">:</span>
  <span class="quoted"><span class="quoted">"llist_of <span class="free">xs</span> <span class="main">=</span> LNil <span class="main">⟷</span> <span class="free">xs</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-llist_of_eq_LCons_conv"><span class="command">lemma</span></span> llist_of_eq_LCons_conv<span class="main">:</span>
  <span class="quoted"><span class="quoted">"llist_of <span class="free">xs</span> <span class="main">=</span> LCons <span class="free">y</span> <span class="free">ys</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">xs'</span><span class="main">.</span> <span class="free">xs</span> <span class="main">=</span> <span class="free">y</span> <span class="main">#</span> <span class="bound">xs'</span> <span class="main">∧</span> <span class="free">ys</span> <span class="main">=</span> llist_of <span class="bound">xs'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_List-lappend_llist_of_llist_of"><span class="command">lemma</span></span> lappend_llist_of_llist_of<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lappend <span class="main">(</span>llist_of <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>llist_of <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> llist_of <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-lfinite_rev_induct"><span class="command">lemma</span></span> lfinite_rev_induct <span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> Nil snoc<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> fin<span class="main">:</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> Nil<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> LNil"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> snoc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">xs</span><span class="main">.</span> <span class="main">⟦</span> lfinite <span class="bound">xs</span><span class="main">;</span> <span class="free">P</span> <span class="bound">xs</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span>lappend <span class="bound">xs</span> <span class="main">(</span>LCons <span class="bound">x</span> LNil<span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> fin <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xs'</span></span> <span class="keyword2"><span class="keyword">where</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> llist_of <span class="skolem">xs'</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> lfinite_eq_range_llist_of <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> xs
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs'</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_induct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Nil lappend_llist_of_llist_of<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> snoc<span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lappend_llist_of_LCons"><span class="command">lemma</span></span> lappend_llist_of_LCons<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lappend <span class="main">(</span>llist_of <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>LCons <span class="free">y</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> lappend <span class="main">(</span>llist_of <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">y</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-lmap_llist_of"><span class="command">lemma</span></span> lmap_llist_of <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lmap <span class="free">f</span> <span class="main">(</span>llist_of <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> llist_of <span class="main">(</span>map <span class="free">f</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-lset_llist_of"><span class="command">lemma</span></span> lset_llist_of <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lset <span class="main">(</span>llist_of <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> set <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-llist_of_inject"><span class="command">lemma</span></span> llist_of_inject <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"llist_of <span class="free">xs</span> <span class="main">=</span> llist_of <span class="free">ys</span> <span class="main">⟷</span> <span class="free">xs</span> <span class="main">=</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"llist_of <span class="free">xs</span> <span class="main">=</span> llist_of <span class="free">ys</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="free">ys</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> Cons <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-inj_llist_of"><span class="command">lemma</span></span> inj_llist_of <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"inj llist_of"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> inj_onI<span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Converting finite lazy lists to ordinary lists: <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"list_of"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1" id="Coinductive_List-list_of_llist_of"><span class="command">lemma</span></span> list_of_llist_of <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"list_of <span class="main">(</span>llist_of <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list_of_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> inv_f_f inj_onI<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llist_of_list_of"><span class="command">lemma</span></span> llist_of_list_of <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span> <span class="main">⟹</span> llist_of <span class="main">(</span>list_of <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> lfinite_eq_range_llist_of <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_List-list_of_LNil"><span class="command">lemma</span></span> list_of_LNil <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">nitpick_simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"list_of LNil <span class="main">=</span> <span class="main">[]</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> list_of_llist_of<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">[]</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-list_of_LCons"><span class="command">lemma</span></span> list_of_LCons <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span> <span class="main">⟹</span> list_of <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">x</span> <span class="main">#</span> list_of <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lfinite.induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> lfinite_LNil
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> list_of_llist_of<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="skolem">x</span><span class="main">]</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>lfinite_LConsI <span class="skolem">xs'</span> <span class="skolem">x'</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹list_of <span class="main">(</span>LCons <span class="skolem">x'</span> <span class="skolem">xs'</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">x'</span> <span class="main">#</span> list_of <span class="skolem">xs'</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> list_of_llist_of<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">#</span> <span class="skolem">x'</span> <span class="main">#</span> list_of <span class="skolem">xs'</span>"</span></span><span class="main">]</span>
      llist_of_list_of<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹lfinite <span class="skolem">xs'</span>›</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-list_of_LCons_conv"><span class="command">lemma</span></span> list_of_LCons_conv <span class="main">[</span><span class="operator">nitpick_simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"list_of <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> lfinite <span class="free">xs</span> <span class="keyword1">then</span> <span class="free">x</span> <span class="main">#</span> list_of <span class="free">xs</span> <span class="keyword1">else</span> undefined<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list_of_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-list_of_lappend"><span class="command">lemma</span></span> list_of_lappend<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"list_of <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> list_of <span class="free">xs</span> <span class="main">@</span> list_of <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹lfinite <span class="free">xs</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">‹lfinite <span class="free">ys</span>›</span></span><span class="main">)</span>

<span class="keyword1" id="Coinductive_List-list_of_lmap"><span class="command">lemma</span></span> list_of_lmap <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"list_of <span class="main">(</span>lmap <span class="free">f</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> map <span class="free">f</span> <span class="main">(</span>list_of <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-set_list_of"><span class="command">lemma</span></span> set_list_of <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>list_of <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lset <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1" id="Coinductive_List-hd_list_of"><span class="command">lemma</span></span> hd_list_of <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span> <span class="main">⟹</span> hd <span class="main">(</span>list_of <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lhd <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lfinite_eq_range_llist_of<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-tl_list_of"><span class="command">lemma</span></span> tl_list_of<span class="main">:</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span> <span class="main">⟹</span> tl <span class="main">(</span>list_of <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> list_of <span class="main">(</span>ltl <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lfinite_eq_range_llist_of<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Efficient implementation via tail recursion suggested by Brian Huffman›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">list_of_aux</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> llist <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">list_of_aux</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> lfinite <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="keyword1">then</span> rev <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">@</span> list_of <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="keyword1">else</span> undefined<span class="main">)</span>"</span></span>

<span class="keyword1" id="Coinductive_List-list_of_code"><span class="command">lemma</span></span> list_of_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"list_of <span class="main">=</span> list_of_aux <span class="main">[]</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff list_of_def list_of_aux_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-list_of_aux_code"><span class="command">lemma</span></span> list_of_aux_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"list_of_aux <span class="free">xs</span> LNil <span class="main">=</span> rev <span class="free">xs</span>"</span></span>
  <span class="quoted"><span class="quoted">"list_of_aux <span class="free">xs</span> <span class="main">(</span>LCons <span class="free">y</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> list_of_aux <span class="main">(</span><span class="free">y</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list_of_aux_def<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The length of a lazy list: <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"llength"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">nitpick_simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> llength_LNil<span class="main">:</span> <span class="quoted"><span class="quoted">"llength LNil <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> llength_LCons<span class="main">:</span> <span class="quoted"><span class="quoted">"llength <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> eSuc <span class="main">(</span>llength <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llength_def enat_unfold<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llength_eq_0"><span class="command">lemma</span></span> llength_eq_0 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"llength <span class="free">xs</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟷</span> lnull <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-llength_lnull"><span class="command">lemma</span></span> llength_lnull <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lnull <span class="free">xs</span> <span class="main">⟹</span> llength <span class="free">xs</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-epred_llength"><span class="command">lemma</span></span> epred_llength<span class="main">:</span>
  <span class="quoted"><span class="quoted">"epred <span class="main">(</span>llength <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> llength <span class="main">(</span>ltl <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemmas</span></span> llength_ltl <span class="main">=</span> epred_llength<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>

<span class="keyword1" id="Coinductive_List-llength_lmap"><span class="command">lemma</span></span> llength_lmap <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"llength <span class="main">(</span>lmap <span class="free">f</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> llength <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_coinduct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> epred_llength<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llength_lappend"><span class="command">lemma</span></span> llength_lappend <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"llength <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> llength <span class="free">xs</span> <span class="main">+</span> llength <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_coinduct<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> iadd_is_0 epred_iadd1 split_paired_all epred_llength<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llength_llist_of"><span class="command">lemma</span></span> llength_llist_of <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"llength <span class="main">(</span>llist_of <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> enat <span class="main">(</span>length <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def eSuc_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-length_list_of"><span class="command">lemma</span></span> length_list_of<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span> <span class="main">⟹</span> enat <span class="main">(</span>length <span class="main">(</span>list_of <span class="free">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> llength <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> sym<span class="main">)</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lfinite.induct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eSuc_enat zero_enat_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-length_list_of_conv_the_enat"><span class="command">lemma</span></span> length_list_of_conv_the_enat<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span> <span class="main">⟹</span> length <span class="main">(</span>list_of <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> the_enat <span class="main">(</span>llength <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> lfinite_eq_range_llist_of <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_List-llength_eq_enat_lfiniteD"><span class="command">lemma</span></span> llength_eq_enat_lfiniteD<span class="main">:</span> <span class="quoted"><span class="quoted">"llength <span class="free">xs</span> <span class="main">=</span> enat <span class="free">n</span> <span class="main">⟹</span> lfinite <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">[</span><span class="operator">folded</span> zero_enat_def<span class="main">]</span><span class="main">:</span> 0
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> len <span class="main">=</span> <span class="quoted"><span class="quoted">‹llength <span class="skolem">xs</span> <span class="main">=</span> enat <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>›</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="skolem"><span class="skolem">xs'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> LCons <span class="skolem">x</span> <span class="skolem">xs'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">with</span></span></span> len <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"llength <span class="skolem">xs'</span> <span class="main">=</span> enat <span class="skolem">n</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eSuc_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> enat.split_asm<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="skolem">xs'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> Suc<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lfinite_llength_enat"><span class="command">lemma</span></span> lfinite_llength_enat<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">n</span><span class="main">.</span> llength <span class="free">xs</span> <span class="main">=</span> enat <span class="bound">n</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eSuc_def zero_enat_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lfinite_conv_llength_enat"><span class="command">lemma</span></span> lfinite_conv_llength_enat<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">n</span><span class="main">.</span> llength <span class="free">xs</span> <span class="main">=</span> enat <span class="bound">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> llength_eq_enat_lfiniteD lfinite_llength_enat<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-not_lfinite_llength"><span class="command">lemma</span></span> not_lfinite_llength<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">¬</span> lfinite <span class="free">xs</span> <span class="main">⟹</span> llength <span class="free">xs</span> <span class="main">=</span> <span class="main">∞</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lfinite_conv_llength_enat<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llength_eq_infty_conv_lfinite"><span class="command">lemma</span></span> llength_eq_infty_conv_lfinite<span class="main">:</span>
  <span class="quoted"><span class="quoted">"llength <span class="free">xs</span> <span class="main">=</span> <span class="main">∞</span> <span class="main">⟷</span> <span class="main">¬</span> lfinite <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lfinite_conv_llength_enat<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lfinite_finite_index"><span class="command">lemma</span></span> lfinite_finite_index<span class="main">:</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span> <span class="main">⟹</span> finite <span class="main">{</span><span class="bound">n</span><span class="main">.</span> enat <span class="bound">n</span> <span class="main">&lt;</span> llength <span class="free">xs</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lfinite_llength_enat<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹tail-recursive implementation for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">llength</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">gen_llength</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="tfree">'a</span> llist <span class="main">⇒</span> enat"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">gen_llength</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> enat <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">+</span> llength <span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>

<span class="keyword1" id="Coinductive_List-gen_llength_code"><span class="command">lemma</span></span> gen_llength_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"gen_llength <span class="free">n</span> LNil <span class="main">=</span> enat <span class="free">n</span>"</span></span>
  <span class="quoted"><span class="quoted">"gen_llength <span class="free">n</span> <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> gen_llength <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gen_llength_def iadd_Suc eSuc_enat<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> iadd_Suc_right<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llength_code"><span class="command">lemma</span></span> llength_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"llength <span class="main">=</span> gen_llength <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gen_llength_def fun_eq_iff zero_enat_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">F</span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">F</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">llength</span> <span class="bound">xs</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">xs</span> <span class="keyword1">of</span> LNil <span class="main">⇒</span> <span class="main">0</span> <span class="main">|</span> LCons <span class="bound">x</span> <span class="bound">xs</span> <span class="main">⇒</span> eSuc <span class="main">(</span><span class="bound">llength</span> <span class="bound">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> llength_conv_fixp<span class="main">:</span> <span class="quoted"><span class="quoted">"llength <span class="main">≡</span> ccpo.fixp <span class="main">(</span>fun_lub Sup<span class="main">)</span> <span class="main">(</span>fun_ord <span class="main">(≤)</span><span class="main">)</span> <span class="free">F</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">≡</span> <span class="var">?fixp</span>"</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> llength_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span><span class="main">.</span> monotone <span class="main">(</span>fun_ord <span class="main">(≤)</span><span class="main">)</span> <span class="main">(≤)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">llength</span><span class="main">.</span> <span class="free">F</span> <span class="bound">llength</span> <span class="bound">xs</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">PROP</span> <span class="var">?mono</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">intro</span> eq_reflection ext<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">PROP</span> <span class="var">?mono</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> F_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">tactic</span> <span class="quoted">‹<span class="entity">Partial_Function.mono_tac</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span>›</span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"llength <span class="skolem">xs</span> <span class="main">=</span> <span class="var">?fixp</span> <span class="skolem">xs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_coinduct<span class="main">)</span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2 3<span class="main"><span class="main">)</span></span> lfp.mono_body_fixp<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mono<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> F_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> iffI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-mono2mono_llength"><span class="command">lemma</span></span> mono2mono_llength<span class="main">[</span><span class="operator">THEN</span> lfp.mono2mono<span class="main">,</span> <span class="operator">simp</span><span class="main">,</span> <span class="operator">cont_intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> monotone_llength<span class="main">:</span> <span class="quoted"><span class="quoted">"monotone <span class="main">(⊑)</span> <span class="main">(≤)</span> llength"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> lfp.fixp_preserves_mono1<span class="main"><span class="main">[</span></span><span class="operator">OF</span> llength_mono llength_conv_fixp<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">fold</span> bot_enat_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Coinductive_List-mcont2mcont_llength"><span class="command">lemma</span></span> mcont2mcont_llength<span class="main">[</span><span class="operator">THEN</span> lfp.mcont2mcont<span class="main">,</span> <span class="operator">simp</span><span class="main">,</span> <span class="operator">cont_intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> mcont_llength<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont lSup <span class="main">(⊑)</span> Sup <span class="main">(≤)</span> llength"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> lfp.fixp_preserves_mcont1<span class="main"><span class="main">[</span></span><span class="operator">OF</span> llength_mono llength_conv_fixp<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">fold</span> bot_enat_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Taking and dropping from lazy lists: <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"ltake"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"ldropn"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"ldrop"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1" id="Coinductive_List-ltake_LNil"><span class="command">lemma</span></span> ltake_LNil <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span><span class="main">,</span> <span class="operator">nitpick_simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ltake <span class="free">n</span> LNil <span class="main">=</span> LNil"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-ltake_0"><span class="command">lemma</span></span> ltake_0 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ltake <span class="main">0</span> <span class="free">xs</span> <span class="main">=</span> LNil"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltake_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ltake_eSuc_LCons"><span class="command">lemma</span></span> ltake_eSuc_LCons <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"ltake <span class="main">(</span>eSuc <span class="free">n</span><span class="main">)</span> <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> LCons <span class="free">x</span> <span class="main">(</span>ltake <span class="free">n</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> llist.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ltake_eSuc"><span class="command">lemma</span></span> ltake_eSuc<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ltake <span class="main">(</span>eSuc <span class="free">n</span><span class="main">)</span> <span class="free">xs</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> <span class="free">xs</span> <span class="keyword1">of</span> LNil <span class="main">⇒</span> LNil <span class="main">|</span> LCons <span class="bound">x</span> <span class="bound">xs'</span> <span class="main">⇒</span> LCons <span class="bound">x</span> <span class="main">(</span>ltake <span class="free">n</span> <span class="bound">xs'</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-lnull_ltake"><span class="command">lemma</span></span> lnull_ltake <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lnull <span class="main">(</span>ltake <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟷</span> lnull <span class="free">xs</span> <span class="main">∨</span> <span class="free">n</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_coexhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> llist.exhaust<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-ltake_eq_LNil_iff"><span class="command">lemma</span></span> ltake_eq_LNil_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"ltake <span class="free">n</span> <span class="free">xs</span> <span class="main">=</span> LNil <span class="main">⟷</span> <span class="free">xs</span> <span class="main">=</span> LNil <span class="main">∨</span> <span class="free">n</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_coexhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> llist.exhaust<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-LNil_eq_ltake_iff"><span class="command">lemma</span></span> LNil_eq_ltake_iff <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"LNil <span class="main">=</span> ltake <span class="free">n</span> <span class="free">xs</span> <span class="main">⟷</span> <span class="free">xs</span> <span class="main">=</span> LNil <span class="main">∨</span> <span class="free">n</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_coexhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> llist.exhaust<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-ltake_LCons"><span class="command">lemma</span></span> ltake_LCons <span class="main">[</span><span class="operator">code</span><span class="main">,</span> <span class="operator">nitpick_simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"ltake <span class="free">n</span> <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> <span class="free">n</span> <span class="keyword1">of</span> <span class="main">0</span> <span class="main">⇒</span> LNil <span class="main">|</span> eSuc <span class="bound">n'</span> <span class="main">⇒</span> LCons <span class="free">x</span> <span class="main">(</span>ltake <span class="bound">n'</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> llist.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> co.enat.split<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lhd_ltake"><span class="command">lemma</span></span> lhd_ltake <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">⟹</span> lhd <span class="main">(</span>ltake <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lhd <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_coexhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> llist.exhaust<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-ltl_ltake"><span class="command">lemma</span></span> ltl_ltake<span class="main">:</span> <span class="quoted"><span class="quoted">"ltl <span class="main">(</span>ltake <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> ltake <span class="main">(</span>epred <span class="free">n</span><span class="main">)</span> <span class="main">(</span>ltl <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_coexhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> llist.exhaust<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemmas</span></span> ltake_epred_ltl <span class="main">=</span> ltl_ltake <span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>

<span class="keyword1"><span class="command">declare</span></span> ltake.sel<span class="main">(</span>2<span class="main">)</span> <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>

<span class="keyword1" id="Coinductive_List-ltake_ltl"><span class="command">lemma</span></span> ltake_ltl<span class="main">:</span> <span class="quoted"><span class="quoted">"ltake <span class="free">n</span> <span class="main">(</span>ltl <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> ltl <span class="main">(</span>ltake <span class="main">(</span>eSuc <span class="free">n</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-llength_ltake"><span class="command">lemma</span></span> llength_ltake <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"llength <span class="main">(</span>ltake <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> min <span class="free">n</span> <span class="main">(</span>llength <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_coinduct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> enat_min_eq_0_iff epred_llength ltl_ltake<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ltake_lmap"><span class="command">lemma</span></span> ltake_lmap <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ltake <span class="free">n</span> <span class="main">(</span>lmap <span class="free">f</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lmap <span class="free">f</span> <span class="main">(</span>ltake <span class="free">n</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltl_ltake<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ltake_ltake"><span class="command">lemma</span></span> ltake_ltake <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ltake <span class="free">n</span> <span class="main">(</span>ltake <span class="free">m</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> ltake <span class="main">(</span>min <span class="free">n</span> <span class="free">m</span><span class="main">)</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">m</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 4 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> enat_min_eq_0_iff ltl_ltake<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lset_ltake"><span class="command">lemma</span></span> lset_ltake<span class="main">:</span> <span class="quoted"><span class="quoted">"lset <span class="main">(</span>ltake <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⊆</span> lset <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> subsetI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> lset <span class="main">(</span>ltake <span class="free">n</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> lset <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"ltake <span class="free">n</span> <span class="free">xs</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lset_induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> find <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_coexhaust<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> step <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_coexhaust<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-ltake_all"><span class="command">lemma</span></span> ltake_all<span class="main">:</span> <span class="quoted"><span class="quoted">"llength <span class="free">xs</span> <span class="main">≤</span> <span class="free">m</span> <span class="main">⟹</span> ltake <span class="free">m</span> <span class="free">xs</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">m</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> epred_llength<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> ltl_ltake <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> epred_le_epredI<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ltake_llist_of"><span class="command">lemma</span></span> ltake_llist_of <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"ltake <span class="main">(</span>enat <span class="free">n</span><span class="main">)</span> <span class="main">(</span>llist_of <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> llist_of <span class="main">(</span>take <span class="free">n</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> zero_enat_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> eSuc_enat<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lfinite_ltake"><span class="command">lemma</span></span> lfinite_ltake <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>ltake <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟷</span> lfinite <span class="free">xs</span> <span class="main">∨</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="main">∞</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="skolem">ys</span><span class="main"><span class="main">≡</span></span><span class="quoted"><span class="quoted">"ltake <span class="free">n</span> <span class="free">xs</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lfinite_induct<span class="main">)</span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def ltl_ltake<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?xs</span> <span class="main">∨</span> <span class="var">?n</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?xs</span></span></span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltake_LCons <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> enat_cosplit<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?n</span></span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">n'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">=</span> enat <span class="skolem">n'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>ltake <span class="main">(</span>enat <span class="skolem">n'</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">n'</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
        <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> eSuc_enat<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> ltake_eSuc
              <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-ltake_lappend1"><span class="command">lemma</span></span> ltake_lappend1<span class="main">:</span>  <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≤</span> llength <span class="free">xs</span> <span class="main">⟹</span> ltake <span class="free">n</span> <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> ltake <span class="free">n</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> exI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llength_ltl epred_le_epredI ltl_ltake<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ltake_lappend2"><span class="command">lemma</span></span> ltake_lappend2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"llength <span class="free">xs</span> <span class="main">≤</span> <span class="free">n</span> <span class="main">⟹</span> ltake <span class="free">n</span> <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> lappend <span class="free">xs</span> <span class="main">(</span>ltake <span class="main">(</span><span class="free">n</span> <span class="main">-</span> llength <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> llist.coinduct_strong<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> exI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llength_ltl epred_le_epredI ltl_ltake<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ltake_lappend"><span class="command">lemma</span></span> ltake_lappend<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ltake <span class="free">n</span> <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> lappend <span class="main">(</span>ltake <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>ltake <span class="main">(</span><span class="free">n</span> <span class="main">-</span> llength <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> llist.coinduct_strong<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> exI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llength_ltl ltl_ltake<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-take_list_of"><span class="command">lemma</span></span> take_list_of<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"take <span class="free">n</span> <span class="main">(</span>list_of <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> list_of <span class="main">(</span>ltake <span class="main">(</span>enat <span class="free">n</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span>
  <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> take_Cons zero_enat_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> eSuc_enat<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> nat.split<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ltake_eq_ltake_antimono"><span class="command">lemma</span></span> ltake_eq_ltake_antimono<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> ltake <span class="free">n</span> <span class="free">xs</span> <span class="main">=</span> ltake <span class="free">n</span> <span class="free">ys</span><span class="main">;</span> <span class="free">m</span> <span class="main">≤</span> <span class="free">n</span> <span class="main">⟧</span> <span class="main">⟹</span> ltake <span class="free">m</span> <span class="free">xs</span> <span class="main">=</span> ltake <span class="free">m</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> ltake_ltake min_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ltake_is_lprefix"><span class="command">lemma</span></span> ltake_is_lprefix <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ltake <span class="free">n</span> <span class="free">xs</span> <span class="main">⊑</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltl_ltake<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lprefix_ltake_same"><span class="command">lemma</span></span> lprefix_ltake_same <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"ltake <span class="free">n</span> <span class="free">xs</span> <span class="main">⊑</span> ltake <span class="free">m</span> <span class="free">xs</span> <span class="main">⟷</span> <span class="free">n</span> <span class="main">≤</span> <span class="free">m</span> <span class="main">∨</span> llength <span class="free">xs</span> <span class="main">≤</span> <span class="free">m</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> iffI disjCI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> llength <span class="free">xs</span> <span class="main">≤</span> <span class="free">m</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≤</span> <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">m</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_le_coinduct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>le <span class="skolem">n</span> <span class="skolem">m</span> <span class="skolem">xs</span><span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltake_LCons <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> co.enat.splits<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≤</span> <span class="free">m</span>"</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">m</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 4 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltl_ltake epred_le_epredI<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltake_all<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="free">F</span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">F</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">ltake</span> <span class="bound">n</span> <span class="bound">xs</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">xs</span> <span class="keyword1">of</span> LNil <span class="main">⇒</span> LNil <span class="main">|</span> LCons <span class="bound">x</span> <span class="bound">xs</span> <span class="main">⇒</span> <span class="keyword1">case</span> <span class="bound">n</span> <span class="keyword1">of</span> <span class="main">0</span> <span class="main">⇒</span> LNil <span class="main">|</span> eSuc <span class="bound">n</span> <span class="main">⇒</span> LCons <span class="bound">x</span> <span class="main">(</span><span class="bound">ltake</span> <span class="bound">n</span> <span class="bound">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> ltake_conv_fixp<span class="main">:</span> <span class="quoted"><span class="quoted">"ltake <span class="main">≡</span> curry <span class="main">(</span>ccpo.fixp <span class="main">(</span>fun_lub lSup<span class="main">)</span> <span class="main">(</span>fun_ord <span class="main">(⊑)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">ltake</span><span class="main">.</span> case_prod <span class="main">(</span><span class="free">F</span> <span class="main">(</span>curry <span class="bound">ltake</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">≡</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> ltake_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">nxs</span><span class="main">.</span> mono_llist <span class="main">(</span><span class="main">λ</span><span class="bound">ltake</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">nxs</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">n</span><span class="main">,</span> <span class="bound">xs</span><span class="main">)</span> <span class="main">⇒</span> <span class="free">F</span> <span class="main">(</span>curry <span class="bound">ltake</span><span class="main">)</span> <span class="bound">n</span> <span class="bound">xs</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">PROP</span> <span class="var">?mono</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">intro</span> eq_reflection ext<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">PROP</span> <span class="var">?mono</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> F_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">tactic</span> <span class="quoted">‹<span class="entity">Partial_Function.mono_tac</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span>›</span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">n</span> <span class="skolem">xs</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="skolem">n</span> <span class="skolem">xs</span> <span class="main">=</span> <span class="var">?rhs</span> <span class="skolem">n</span> <span class="skolem">xs</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">n</span></span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> Eq_llist
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 3 4<span class="main"><span class="main">)</span></span> llist.mono_body_fixp<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mono<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> F_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split prod.split co.enat.split<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-monotone_ltake"><span class="command">lemma</span></span> monotone_ltake<span class="main">:</span> <span class="quoted"><span class="quoted">"monotone <span class="main">(</span>rel_prod <span class="main">(≤)</span> <span class="main">(⊑)</span><span class="main">)</span> <span class="main">(⊑)</span> <span class="main">(</span>case_prod ltake<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> llist.fixp_preserves_mono2<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ltake_mono ltake_conv_fixp<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-mono2mono_ltake1"><span class="command">lemma</span></span> mono2mono_ltake1<span class="main">[</span><span class="operator">THEN</span> llist.mono2mono<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> monotone_ltake1<span class="main">:</span> <span class="quoted"><span class="quoted">"monotone <span class="main">(≤)</span> <span class="main">(⊑)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> ltake <span class="bound">n</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> monotone_ltake <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_List-mono2mono_ltake2"><span class="command">lemma</span></span> mono2mono_ltake2<span class="main">[</span><span class="operator">THEN</span> llist.mono2mono<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> monotone_ltake2<span class="main">:</span> <span class="quoted"><span class="quoted">"monotone <span class="main">(⊑)</span> <span class="main">(⊑)</span> <span class="main">(</span>ltake <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> monotone_ltake <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_List-mcont_ltake"><span class="command">lemma</span></span> mcont_ltake<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont <span class="main">(</span>prod_lub Sup lSup<span class="main">)</span> <span class="main">(</span>rel_prod <span class="main">(≤)</span> <span class="main">(⊑)</span><span class="main">)</span> lSup <span class="main">(⊑)</span> <span class="main">(</span>case_prod ltake<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> llist.fixp_preserves_mcont2<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ltake_mono ltake_conv_fixp<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-mcont2mcont_ltake1"><span class="command">lemma</span></span> mcont2mcont_ltake1 <span class="main">[</span><span class="operator">THEN</span> llist.mcont2mcont<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> mcont_ltake1<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont Sup <span class="main">(≤)</span> lSup <span class="main">(⊑)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> ltake <span class="bound">n</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> mcont_ltake <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_List-mcont2mcont_ltake2"><span class="command">lemma</span></span> mcont2mcont_ltake2 <span class="main">[</span><span class="operator">THEN</span> llist.mcont2mcont<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> mcont_ltake2<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont lSup <span class="main">(⊑)</span> lSup <span class="main">(⊑)</span> <span class="main">(</span>ltake <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> mcont_ltake <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">partial_function_mono</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"mono_llist <span class="free">F</span> <span class="main">⟹</span> mono_llist <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> ltake <span class="free">n</span> <span class="main">(</span><span class="free">F</span> <span class="bound">f</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> mono2mono_ltake2<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llist_induct2"><span class="command">lemma</span></span> llist_induct2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> adm<span class="main">:</span> <span class="quoted"><span class="quoted">"ccpo.admissible <span class="main">(</span>prod_lub lSup lSup<span class="main">)</span> <span class="main">(</span>rel_prod <span class="main">(⊑)</span> <span class="main">(⊑)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span>fst <span class="bound">x</span><span class="main">)</span> <span class="main">(</span>snd <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> LNil<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> LNil LNil"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> LCons1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">xs</span><span class="main">.</span> <span class="main">⟦</span> lfinite <span class="bound">xs</span><span class="main">;</span> <span class="free">P</span> <span class="bound">xs</span> LNil <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span>LCons <span class="bound">x</span> <span class="bound">xs</span><span class="main">)</span> LNil"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> LCons2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">y</span> <span class="bound">ys</span><span class="main">.</span> <span class="main">⟦</span> lfinite <span class="bound">ys</span><span class="main">;</span> <span class="free">P</span> LNil <span class="bound">ys</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> LNil <span class="main">(</span>LCons <span class="bound">y</span> <span class="bound">ys</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> LCons<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">xs</span> <span class="bound">y</span> <span class="bound">ys</span><span class="main">.</span> <span class="main">⟦</span> lfinite <span class="bound">xs</span><span class="main">;</span> lfinite <span class="bound">ys</span><span class="main">;</span> <span class="free">P</span> <span class="bound">xs</span> <span class="bound">ys</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span>LCons <span class="bound">x</span> <span class="bound">xs</span><span class="main">)</span> <span class="main">(</span>LCons <span class="bound">y</span> <span class="bound">ys</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?C</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="main">(</span>ltake <span class="bound">n</span> <span class="free">xs</span><span class="main">,</span> ltake <span class="bound">n</span> <span class="free">ys</span><span class="main">)</span><span class="main">)</span> <span class="main">`</span> range enat"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Complete_Partial_Order.chain <span class="main">(</span>rel_prod <span class="main">(⊑)</span> <span class="main">(⊑)</span><span class="main">)</span> <span class="var">?C</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> chainI<span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> adm <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span>fst <span class="main">(</span>prod_lub lSup lSup <span class="var">?C</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>snd <span class="main">(</span>prod_lub lSup lSup <span class="var">?C</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ccpo.admissibleD<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xsys</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xsys</span> <span class="main">∈</span> <span class="var">?C</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xsys</span> <span class="main">=</span> <span class="main">(</span>ltake <span class="main">(</span>enat <span class="skolem">n</span><span class="main">)</span> <span class="free">xs</span><span class="main">,</span> ltake <span class="main">(</span>enat <span class="skolem">n</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist"</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="skolem">xs</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="skolem">xs</span> LNil"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> LNil LCons1<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">note</span></span> 1 <span class="main">=</span> this
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">ys</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> llist"</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="skolem">ys</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> LNil <span class="skolem">ys</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> LNil LCons2<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">note</span></span> 2 <span class="main">=</span> this
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span>ltake <span class="main">(</span>enat <span class="skolem">n</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>ltake <span class="main">(</span>enat <span class="skolem">n</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> LNil eSuc_enat<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> ltake_eSuc <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> LNil LCons 1 2<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span>fst <span class="skolem">xsys</span><span class="main">)</span> <span class="main">(</span>snd <span class="skolem">xsys</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"fst <span class="main">(</span>prod_lub lSup lSup <span class="var">?C</span><span class="main">)</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> prod_lub_def fst_conv
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> image_image<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mcont_contD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mcont_ltake1<span class="main"><span class="main">,</span></span> <span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> ltake_all<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"snd <span class="main">(</span>prod_lub lSup lSup <span class="var">?C</span><span class="main">)</span> <span class="main">=</span> <span class="free">ys</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> prod_lub_def snd_conv
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> image_image<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mcont_contD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mcont_ltake1<span class="main"><span class="main">,</span></span> <span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> ltake_all<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-ldropn_0"><span class="command">lemma</span></span> ldropn_0 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ldropn <span class="main">0</span> <span class="free">xs</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldropn_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ldropn_LNil"><span class="command">lemma</span></span> ldropn_LNil <span class="main">[</span><span class="operator">code</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ldropn <span class="free">n</span> LNil <span class="main">=</span> LNil"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldropn_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ldropn_lnull"><span class="command">lemma</span></span> ldropn_lnull<span class="main">:</span> <span class="quoted"><span class="quoted">"lnull <span class="free">xs</span> <span class="main">⟹</span> ldropn <span class="free">n</span> <span class="free">xs</span> <span class="main">=</span> LNil"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnull_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ldropn_LCons"><span class="command">lemma</span></span> ldropn_LCons <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"ldropn <span class="free">n</span> <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">n</span> <span class="keyword1">of</span> <span class="main">0</span> <span class="main">⇒</span> LCons <span class="free">x</span> <span class="free">xs</span> <span class="main">|</span> Suc <span class="bound">n'</span> <span class="main">⇒</span> ldropn <span class="bound">n'</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldropn_def funpow_swap1<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ldropn_Suc"><span class="command">lemma</span></span> ldropn_Suc<span class="main">:</span> <span class="quoted"><span class="quoted">"ldropn <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="free">xs</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">xs</span> <span class="keyword1">of</span> LNil <span class="main">⇒</span> LNil <span class="main">|</span> LCons <span class="bound">x</span> <span class="bound">xs'</span> <span class="main">⇒</span> ldropn <span class="free">n</span> <span class="bound">xs'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldropn_def funpow_swap1<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ldropn_Suc_LCons"><span class="command">lemma</span></span> ldropn_Suc_LCons <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ldropn <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> ldropn <span class="free">n</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldropn_LCons<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ltl_ldropn"><span class="command">lemma</span></span> ltl_ldropn<span class="main">:</span> <span class="quoted"><span class="quoted">"ltl <span class="main">(</span>ldropn <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> ldropn <span class="free">n</span> <span class="main">(</span>ltl <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldropn_Suc <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-ldrop_simps"><span class="command">lemma</span></span> ldrop_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> ldrop_LNil<span class="main">:</span> <span class="quoted"><span class="quoted">"ldrop <span class="free">n</span> LNil <span class="main">=</span> LNil"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> ldrop_0<span class="main">:</span> <span class="quoted"><span class="quoted">"ldrop <span class="main">0</span> <span class="free">xs</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> ldrop_eSuc_LCons<span class="main">:</span> <span class="quoted"><span class="quoted">"ldrop <span class="main">(</span>eSuc <span class="free">n</span><span class="main">)</span> <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> ldrop <span class="free">n</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldrop.simps <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> co.enat.split<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ldrop_lnull"><span class="command">lemma</span></span> ldrop_lnull<span class="main">:</span> <span class="quoted"><span class="quoted">"lnull <span class="free">xs</span> <span class="main">⟹</span> ldrop <span class="free">n</span> <span class="free">xs</span> <span class="main">=</span> LNil"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnull_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="free">F</span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">F</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">ldropn</span> <span class="bound">xs</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">xs</span> <span class="keyword1">of</span> LNil <span class="main">⇒</span> <span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> LNil <span class="main">|</span> LCons <span class="bound">x</span> <span class="bound">xs</span> <span class="main">⇒</span> <span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">n</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> LCons <span class="bound">x</span> <span class="bound">xs</span> <span class="keyword1">else</span> <span class="bound">ldropn</span> <span class="bound">xs</span> <span class="main">(</span><span class="bound">n</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> ldrop_conv_fixp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">xs</span> <span class="bound">n</span><span class="main">.</span> ldropn <span class="bound">n</span> <span class="bound">xs</span><span class="main">)</span> <span class="main">≡</span> ccpo.fixp <span class="main">(</span>fun_lub <span class="main">(</span>fun_lub lSup<span class="main">)</span><span class="main">)</span> <span class="main">(</span>fun_ord <span class="main">(</span>fun_ord lprefix<span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">ldrop</span><span class="main">.</span> <span class="free">F</span> <span class="bound">ldrop</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">≡</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> ldrop_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span><span class="main">.</span> mono_llist_lift <span class="main">(</span><span class="main">λ</span><span class="bound">ldrop</span><span class="main">.</span> <span class="free">F</span> <span class="bound">ldrop</span> <span class="bound">xs</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">PROP</span> <span class="var">?mono</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">intro</span> eq_reflection ext<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">PROP</span> <span class="var">?mono</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> F_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">tactic</span> <span class="quoted">‹<span class="entity">Partial_Function.mono_tac</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span>›</span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">n</span> <span class="skolem">xs</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="skolem">xs</span> <span class="skolem">n</span> <span class="main">=</span> <span class="var">?rhs</span> <span class="skolem">xs</span> <span class="skolem">n</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span>
      <span class="main">(</span><span class="operator">subst</span> llist_lift.mono_body_fixp<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mono<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> F_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-ldropn_fixp_case_conv"><span class="command">lemma</span></span> ldropn_fixp_case_conv<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">xs</span> <span class="keyword1">of</span> LNil <span class="main">⇒</span> <span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> LNil <span class="main">|</span> LCons <span class="bound">x</span> <span class="bound">xs</span> <span class="main">⇒</span> <span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">n</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> LCons <span class="bound">x</span> <span class="bound">xs</span> <span class="keyword1">else</span> <span class="free">f</span> <span class="bound">xs</span> <span class="main">(</span><span class="bound">n</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
   <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span> <span class="bound">n</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">xs</span> <span class="keyword1">of</span> LNil <span class="main">⇒</span> LNil <span class="main">|</span> LCons <span class="bound">x</span> <span class="bound">xs</span> <span class="main">⇒</span> <span class="keyword1">if</span> <span class="bound">n</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> LCons <span class="bound">x</span> <span class="bound">xs</span> <span class="keyword1">else</span> <span class="free">f</span> <span class="bound">xs</span> <span class="main">(</span><span class="bound">n</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-monotone_ldropn_aux"><span class="command">lemma</span></span> monotone_ldropn_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"monotone lprefix <span class="main">(</span>fun_ord lprefix<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span> <span class="bound">n</span><span class="main">.</span> ldropn <span class="bound">n</span> <span class="bound">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> llist_lift.fixp_preserves_mono1<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ldrop_mono ldrop_conv_fixp<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldropn_fixp_case_conv monotone_fun_ord_apply<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-mono2mono_ldropn"><span class="command">lemma</span></span> mono2mono_ldropn<span class="main">[</span><span class="operator">THEN</span> llist.mono2mono<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> monotone_ldropn'<span class="main">:</span> <span class="quoted"><span class="quoted">"monotone lprefix lprefix <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> ldropn <span class="free">n</span> <span class="bound">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> monotone_ldropn_aux <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> monotone_def fun_ord_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-mcont_ldropn_aux"><span class="command">lemma</span></span> mcont_ldropn_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont lSup lprefix <span class="main">(</span>fun_lub lSup<span class="main">)</span> <span class="main">(</span>fun_ord lprefix<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span> <span class="bound">n</span><span class="main">.</span> ldropn <span class="bound">n</span> <span class="bound">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> llist_lift.fixp_preserves_mcont1<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ldrop_mono ldrop_conv_fixp<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldropn_fixp_case_conv mcont_fun_lub_apply<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-mcont2mcont_ldropn"><span class="command">lemma</span></span> mcont2mcont_ldropn <span class="main">[</span><span class="operator">THEN</span> llist.mcont2mcont<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> mcont_ldropn<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont lSup lprefix lSup lprefix <span class="main">(</span>ldropn <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> mcont_ldropn_aux <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mcont_fun_lub_apply<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-monotone_enat_cocase"><span class="command">lemma</span></span> monotone_enat_cocase <span class="main">[</span><span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">⋀</span><span class="bound">n</span><span class="main">.</span> monotone <span class="main">(≤)</span> <span class="free">ord</span> <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="free">f</span> <span class="bound">n</span> <span class="main">(</span>eSuc <span class="bound">n</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="main">⋀</span><span class="bound">n</span><span class="main">.</span> <span class="free">ord</span> <span class="free">a</span> <span class="main">(</span><span class="free">f</span> <span class="bound">n</span> <span class="main">(</span>eSuc <span class="bound">n</span><span class="main">)</span><span class="main">)</span><span class="main">;</span> <span class="free">ord</span> <span class="free">a</span> <span class="free">a</span> <span class="main">⟧</span>
  <span class="main">⟹</span> monotone <span class="main">(≤)</span> <span class="free">ord</span> <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">n</span> <span class="keyword1">of</span> <span class="main">0</span> <span class="main">⇒</span> <span class="free">a</span> <span class="main">|</span> eSuc <span class="bound">n'</span> <span class="main">⇒</span> <span class="free">f</span> <span class="bound">n'</span> <span class="bound">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monotone_enat_le_case<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-monotone_ldrop"><span class="command">lemma</span></span> monotone_ldrop<span class="main">:</span> <span class="quoted"><span class="quoted">"monotone <span class="main">(</span>rel_prod <span class="main">(=)</span> <span class="main">(⊑)</span><span class="main">)</span> <span class="main">(⊑)</span> <span class="main">(</span>case_prod ldrop<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> llist.fixp_preserves_mono2<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ldrop.mono ldrop_def<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-mono2mono_ldrop2"><span class="command">lemma</span></span> mono2mono_ldrop2 <span class="main">[</span><span class="operator">THEN</span> llist.mono2mono<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> monotone_ldrop2<span class="main">:</span> <span class="quoted"><span class="quoted">"monotone <span class="main">(⊑)</span> <span class="main">(⊑)</span> <span class="main">(</span>ldrop <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> monotone_ldrop<span class="main"><span class="main">[</span></span><span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Coinductive_List-mcont_ldrop"><span class="command">lemma</span></span> mcont_ldrop<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont <span class="main">(</span>prod_lub the_Sup lSup<span class="main">)</span> <span class="main">(</span>rel_prod <span class="main">(=)</span> <span class="main">(⊑)</span><span class="main">)</span> lSup <span class="main">(⊑)</span> <span class="main">(</span>case_prod ldrop<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> llist.fixp_preserves_mcont2<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ldrop.mono ldrop_def<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-mcont2monct_ldrop2"><span class="command">lemma</span></span> mcont2monct_ldrop2 <span class="main">[</span><span class="operator">THEN</span> llist.mcont2mcont<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> mcont_ldrop2<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont lSup <span class="main">(⊑)</span> lSup <span class="main">(⊑)</span> <span class="main">(</span>ldrop <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mcont_ldrop<span class="main"><span class="main">[</span></span><span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ldrop_eSuc_conv_ltl"><span class="command">lemma</span></span> ldrop_eSuc_conv_ltl<span class="main">:</span> <span class="quoted"><span class="quoted">"ldrop <span class="main">(</span>eSuc <span class="free">n</span><span class="main">)</span> <span class="free">xs</span> <span class="main">=</span> ltl <span class="main">(</span>ldrop <span class="free">n</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> LCons <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> co.enat.exhaust<span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-ldrop_ltl"><span class="command">lemma</span></span> ldrop_ltl<span class="main">:</span> <span class="quoted"><span class="quoted">"ldrop <span class="free">n</span> <span class="main">(</span>ltl <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> ldrop <span class="main">(</span>eSuc <span class="free">n</span><span class="main">)</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> LCons <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> co.enat.exhaust<span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-lnull_ldropn"><span class="command">lemma</span></span> lnull_ldropn <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lnull <span class="main">(</span>ldropn <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟷</span> llength <span class="free">xs</span> <span class="main">≤</span> enat <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> Suc.IH<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"ltl <span class="skolem">xs</span>"</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eSuc_enat<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ldrop_eq_LNil"><span class="command">lemma</span></span> ldrop_eq_LNil <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ldrop <span class="free">n</span> <span class="free">xs</span> <span class="main">=</span> LNil <span class="main">⟷</span> llength <span class="free">xs</span> <span class="main">≤</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>LCons <span class="skolem">x</span> <span class="skolem">xs</span> <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> co.enat.exhaust<span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-lnull_ldrop"><span class="command">lemma</span></span> lnull_ldrop <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lnull <span class="main">(</span>ldrop <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟷</span> llength <span class="free">xs</span> <span class="main">≤</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> lnull_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> ldrop_eq_LNil<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ldropn_eq_LNil"><span class="command">lemma</span></span> ldropn_eq_LNil<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>ldropn <span class="free">n</span> <span class="free">xs</span> <span class="main">=</span> LNil<span class="main">)</span> <span class="main">=</span> <span class="main">(</span>llength <span class="free">xs</span> <span class="main">≤</span> enat <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> lnull_ldropn <span class="keyword1"><span class="command">unfolding</span></span> lnull_def <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1" id="Coinductive_List-ldropn_all"><span class="command">lemma</span></span> ldropn_all<span class="main">:</span> <span class="quoted"><span class="quoted">"llength <span class="free">xs</span> <span class="main">≤</span> enat <span class="free">m</span> <span class="main">⟹</span> ldropn <span class="free">m</span> <span class="free">xs</span> <span class="main">=</span> LNil"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldropn_eq_LNil<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ldrop_all"><span class="command">lemma</span></span> ldrop_all<span class="main">:</span> <span class="quoted"><span class="quoted">"llength <span class="free">xs</span> <span class="main">≤</span> <span class="free">m</span> <span class="main">⟹</span> ldrop <span class="free">m</span> <span class="free">xs</span> <span class="main">=</span> LNil"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ltl_ldrop"><span class="command">lemma</span></span> ltl_ldrop<span class="main">:</span> <span class="quoted"><span class="quoted">"ltl <span class="main">(</span>ldrop <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> ldrop <span class="free">n</span> <span class="main">(</span>ltl <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldrop_eSuc_conv_ltl ldrop_ltl<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ldrop_eSuc"><span class="command">lemma</span></span> ldrop_eSuc<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ldrop <span class="main">(</span>eSuc <span class="free">n</span><span class="main">)</span> <span class="free">xs</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">xs</span> <span class="keyword1">of</span> LNil <span class="main">⇒</span> LNil <span class="main">|</span> LCons <span class="bound">x</span> <span class="bound">xs'</span> <span class="main">⇒</span> ldrop <span class="free">n</span> <span class="bound">xs'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-ldrop_LCons"><span class="command">lemma</span></span> ldrop_LCons<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ldrop <span class="free">n</span> <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">n</span> <span class="keyword1">of</span> <span class="main">0</span> <span class="main">⇒</span> LCons <span class="free">x</span> <span class="free">xs</span> <span class="main">|</span> eSuc <span class="bound">n'</span> <span class="main">⇒</span> ldrop <span class="bound">n'</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_coexhaust<span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-ldrop_inf"><span class="command">lemma</span></span> ldrop_inf <span class="main">[</span><span class="operator">code</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ldrop <span class="main">∞</span> <span class="free">xs</span> <span class="main">=</span> LNil"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldrop_LCons enat_cocase_inf<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ldrop_enat"><span class="command">lemma</span></span> ldrop_enat <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ldrop <span class="main">(</span>enat <span class="free">n</span><span class="main">)</span> <span class="free">xs</span> <span class="main">=</span> ldropn <span class="free">n</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Suc <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eSuc_enat<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lfinite_ldropn"><span class="command">lemma</span></span> lfinite_ldropn <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>ldropn <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lfinite <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldropn_Suc <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lfinite_ldrop"><span class="command">lemma</span></span> lfinite_ldrop <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>ldrop <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟷</span> lfinite <span class="free">xs</span> <span class="main">∨</span> <span class="free">n</span> <span class="main">=</span> <span class="main">∞</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldrop_enat<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ldropn_ltl"><span class="command">lemma</span></span> ldropn_ltl<span class="main">:</span> <span class="quoted"><span class="quoted">"ldropn <span class="free">n</span> <span class="main">(</span>ltl <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> ldropn <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldropn_def funpow_swap1<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> ldrop_eSuc_ltl <span class="main">=</span> ldropn_ltl<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>

<span class="keyword1" id="Coinductive_List-lset_ldropn_subset"><span class="command">lemma</span></span> lset_ldropn_subset<span class="main">:</span> <span class="quoted"><span class="quoted">"lset <span class="main">(</span>ldropn <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⊆</span> lset <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldropn_Suc <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split_asm<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Coinductive_List-in_lset_ldropnD"><span class="command">lemma</span></span> in_lset_ldropnD<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> lset <span class="main">(</span>ldropn <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">∈</span> lset <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> lset_ldropn_subset<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_List-lset_ldrop_subset"><span class="command">lemma</span></span> lset_ldrop_subset<span class="main">:</span> <span class="quoted"><span class="quoted">"lset <span class="main">(</span>ldrop <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⊆</span> lset <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> LCons <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> co.enat.exhaust<span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-in_lset_ldropD"><span class="command">lemma</span></span> in_lset_ldropD<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> lset <span class="main">(</span>ldrop <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">∈</span> lset <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> lset_ldrop_subset<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lappend_ltake_ldrop"><span class="command">lemma</span></span> lappend_ltake_ldrop<span class="main">:</span> <span class="quoted"><span class="quoted">"lappend <span class="main">(</span>ltake <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>ldrop <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> llist.coinduct_strong<span class="main">)</span>
  <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldrop_ltl ltl_ltake <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> arg_cong2<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">lappend</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ldropn_lappend"><span class="command">lemma</span></span> ldropn_lappend<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ldropn <span class="free">n</span> <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> enat <span class="free">n</span> <span class="main">&lt;</span> llength <span class="free">xs</span> <span class="keyword1">then</span> lappend <span class="main">(</span>ldropn <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span>
   <span class="keyword1">else</span> ldropn <span class="main">(</span><span class="free">n</span> <span class="main">-</span> the_enat <span class="main">(</span>llength <span class="free">xs</span><span class="main">)</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> lappend_lnull1<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">zs</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"llength <span class="skolem">zs</span> <span class="main">≤</span> enat <span class="skolem">n</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"the_enat <span class="main">(</span>eSuc <span class="main">(</span>llength <span class="skolem">zs</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Suc <span class="main">(</span>the_enat <span class="main">(</span>llength <span class="skolem">zs</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> the_enat_eSuc <span class="quasi_keyword">iff</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> not_infinity_eq<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">note</span></span> eq <span class="main">=</span> this
  <span class="keyword1"><span class="command">from</span></span> Suc <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_less not_le eSuc_enat<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> eq<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-ldropn_lappend2"><span class="command">lemma</span></span> ldropn_lappend2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"llength <span class="free">xs</span> <span class="main">≤</span> enat <span class="free">n</span> <span class="main">⟹</span> ldropn <span class="free">n</span> <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> ldropn <span class="main">(</span><span class="free">n</span> <span class="main">-</span> the_enat <span class="main">(</span>llength <span class="free">xs</span><span class="main">)</span><span class="main">)</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldropn_lappend<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lappend_ltake_enat_ldropn"><span class="command">lemma</span></span> lappend_ltake_enat_ldropn <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lappend <span class="main">(</span>ltake <span class="main">(</span>enat <span class="free">n</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>ldropn <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fold</span> ldrop_enat<span class="main">)</span><span class="main">(</span><span class="operator">rule</span> lappend_ltake_ldrop<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ldrop_lappend"><span class="command">lemma</span></span> ldrop_lappend<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ldrop <span class="free">n</span> <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> llength <span class="free">xs</span> <span class="keyword1">then</span> lappend <span class="main">(</span>ldrop <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span>
   <span class="keyword1">else</span> ldrop <span class="main">(</span><span class="free">n</span> <span class="main">-</span> llength <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
  <span class="comment1">― ‹cannot prove this directly using fixpoint induction,
     because <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="main">(-)</span> <span class="main">::</span> enat <span class="main">⇒</span> enat <span class="main">⇒</span> enat"</span><span class="antiquote">}</span></span> is not a least fixpoint›</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"llength <span class="free">xs</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldropn_lappend not_less ldrop_enat<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ltake_plus_conv_lappend"><span class="command">lemma</span></span> ltake_plus_conv_lappend<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ltake <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="free">m</span><span class="main">)</span> <span class="free">xs</span> <span class="main">=</span> lappend <span class="main">(</span>ltake <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>ltake <span class="free">m</span> <span class="main">(</span>ldrop <span class="free">n</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">m</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> llist.coinduct_strong<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> exI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> iadd_is_0 ltl_ltake epred_iadd1 ldrop_ltl<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ldropn_eq_LConsD"><span class="command">lemma</span></span> ldropn_eq_LConsD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ldropn <span class="free">n</span> <span class="free">xs</span> <span class="main">=</span> LCons <span class="free">y</span> <span class="free">ys</span> <span class="main">⟹</span> enat <span class="free">n</span> <span class="main">&lt;</span> llength <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Suc_ile_eq<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-ldrop_eq_LConsD"><span class="command">lemma</span></span> ldrop_eq_LConsD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ldrop <span class="free">n</span> <span class="free">xs</span> <span class="main">=</span> LCons <span class="free">y</span> <span class="free">ys</span> <span class="main">⟹</span> <span class="free">n</span> <span class="main">&lt;</span> llength <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_less ldrop_all<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ldropn_lmap"><span class="command">lemma</span></span> ldropn_lmap <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ldropn <span class="free">n</span> <span class="main">(</span>lmap <span class="free">f</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lmap <span class="free">f</span> <span class="main">(</span>ldropn <span class="free">n</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldropn_Suc <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ldrop_lmap"><span class="command">lemma</span></span> ldrop_lmap <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ldrop <span class="free">n</span> <span class="main">(</span>lmap <span class="free">f</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lmap <span class="free">f</span> <span class="main">(</span>ldrop <span class="free">n</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> LCons <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> co.enat.exhaust<span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-ldropn_ldropn"><span class="command">lemma</span></span> ldropn_ldropn <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"ldropn <span class="free">n</span> <span class="main">(</span>ldropn <span class="free">m</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> ldropn <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="free">m</span><span class="main">)</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">m</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldropn_Suc <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ldrop_ldrop"><span class="command">lemma</span></span> ldrop_ldrop <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"ldrop <span class="free">n</span> <span class="main">(</span>ldrop <span class="free">m</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> ldrop <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="free">m</span><span class="main">)</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">m</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> LCons <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">m</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> co.enat.exhaust<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> iadd_Suc_right<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-llength_ldropn"><span class="command">lemma</span></span> llength_ldropn <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"llength <span class="main">(</span>ldropn <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> llength <span class="free">xs</span> <span class="main">-</span> enat <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eSuc_enat<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-enat_llength_ldropn"><span class="command">lemma</span></span> enat_llength_ldropn<span class="main">:</span>
  <span class="quoted"><span class="quoted">"enat <span class="free">n</span> <span class="main">≤</span> llength <span class="free">xs</span> <span class="main">⟹</span> enat <span class="main">(</span><span class="free">n</span> <span class="main">-</span> <span class="free">m</span><span class="main">)</span> <span class="main">≤</span> llength <span class="main">(</span>ldropn <span class="free">m</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"llength <span class="free">xs</span>"</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-ldropn_llist_of"><span class="command">lemma</span></span> ldropn_llist_of <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ldropn <span class="free">n</span> <span class="main">(</span>llist_of <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> llist_of <span class="main">(</span>drop <span class="free">n</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Suc <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-ldrop_llist_of"><span class="command">lemma</span></span> ldrop_llist_of<span class="main">:</span> <span class="quoted"><span class="quoted">"ldrop <span class="main">(</span>enat <span class="free">n</span><span class="main">)</span> <span class="main">(</span>llist_of <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> llist_of <span class="main">(</span>drop <span class="free">n</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Cons <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> eSuc_enat<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-drop_list_of"><span class="command">lemma</span></span> drop_list_of<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span> <span class="main">⟹</span> drop <span class="free">n</span> <span class="main">(</span>list_of <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> list_of <span class="main">(</span>ldropn <span class="free">n</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> ldropn_llist_of list_of_llist_of llist_of_list_of<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llength_ldrop"><span class="command">lemma</span></span> llength_ldrop<span class="main">:</span> <span class="quoted"><span class="quoted">"llength <span class="main">(</span>ldrop <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">=</span> <span class="main">∞</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> llength <span class="free">xs</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>LCons <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> co.enat.exhaust<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-ltake_ldropn"><span class="command">lemma</span></span> ltake_ldropn<span class="main">:</span> <span class="quoted"><span class="quoted">"ltake <span class="free">n</span> <span class="main">(</span>ldropn <span class="free">m</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> ldropn <span class="free">m</span> <span class="main">(</span>ltake <span class="main">(</span><span class="free">n</span> <span class="main">+</span> enat <span class="free">m</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">m</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> ldropn_Suc eSuc_enat<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> iadd_Suc_right <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ldropn_ltake"><span class="command">lemma</span></span> ldropn_ltake<span class="main">:</span> <span class="quoted"><span class="quoted">"ldropn <span class="free">n</span> <span class="main">(</span>ltake <span class="free">m</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> ltake <span class="main">(</span><span class="free">m</span> <span class="main">-</span> enat <span class="free">n</span><span class="main">)</span> <span class="main">(</span>ldropn <span class="free">n</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">m</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> ltake_LCons ldropn_Suc eSuc_enat<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> iadd_Suc_right <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split co.enat.split_asm<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ltake_ldrop"><span class="command">lemma</span></span> ltake_ldrop<span class="main">:</span> <span class="quoted"><span class="quoted">"ltake <span class="free">n</span> <span class="main">(</span>ldrop <span class="free">m</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> ldrop <span class="free">m</span> <span class="main">(</span>ltake <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="free">m</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">m</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldrop_LCons iadd_Suc_right <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> co.enat.split<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ldrop_ltake"><span class="command">lemma</span></span> ldrop_ltake<span class="main">:</span> <span class="quoted"><span class="quoted">"ldrop <span class="free">n</span> <span class="main">(</span>ltake <span class="free">m</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> ltake <span class="main">(</span><span class="free">m</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span> <span class="main">(</span>ldrop <span class="free">n</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">m</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltake_LCons ldrop_LCons <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> co.enat.split<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Taking the $n$-th element of a lazy list: <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"lnth"</span></span> <span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1" id="Coinductive_List-lnth_LNil"><span class="command">lemma</span></span> lnth_LNil<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lnth LNil <span class="free">n</span> <span class="main">=</span> undefined <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnth.simps<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lnth_0"><span class="command">lemma</span></span> lnth_0 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lnth <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">0</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnth.simps<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lnth_Suc_LCons"><span class="command">lemma</span></span> lnth_Suc_LCons <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lnth <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="main">=</span> lnth <span class="free">xs</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnth.simps<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lnth_LCons"><span class="command">lemma</span></span> lnth_LCons<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lnth <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="free">n</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">n</span> <span class="keyword1">of</span> <span class="main">0</span> <span class="main">⇒</span> <span class="free">x</span> <span class="main">|</span> Suc <span class="bound">n'</span> <span class="main">⇒</span> lnth <span class="free">xs</span> <span class="bound">n'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-lnth_LCons'"><span class="command">lemma</span></span> lnth_LCons'<span class="main">:</span> <span class="quoted"><span class="quoted">"lnth <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="free">n</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="free">x</span> <span class="keyword1">else</span> lnth <span class="free">xs</span> <span class="main">(</span><span class="free">n</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnth_LCons <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> nat.split<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lhd_conv_lnth"><span class="command">lemma</span></span> lhd_conv_lnth<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">¬</span> lnull <span class="free">xs</span> <span class="main">⟹</span> lhd <span class="free">xs</span> <span class="main">=</span> lnth <span class="free">xs</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lhd_def not_lnull_conv<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> lnth_0_conv_lhd <span class="main">=</span> lhd_conv_lnth<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>

<span class="keyword1" id="Coinductive_List-lnth_ltl"><span class="command">lemma</span></span> lnth_ltl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lnull <span class="free">xs</span> <span class="main">⟹</span> lnth <span class="main">(</span>ltl <span class="free">xs</span><span class="main">)</span> <span class="free">n</span> <span class="main">=</span> lnth <span class="free">xs</span> <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lnull_conv<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lhd_ldropn"><span class="command">lemma</span></span> lhd_ldropn<span class="main">:</span>
  <span class="quoted"><span class="quoted">"enat <span class="free">n</span> <span class="main">&lt;</span> llength <span class="free">xs</span> <span class="main">⟹</span> lhd <span class="main">(</span>ldropn <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lnth <span class="free">xs</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹enat <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span> <span class="main">&lt;</span> llength <span class="skolem">xs</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="skolem"><span class="skolem">xs'</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> LCons <span class="skolem">x</span> <span class="skolem">xs'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹enat <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span> <span class="main">&lt;</span> llength <span class="skolem">xs</span>›</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"enat <span class="skolem">n</span> <span class="main">&lt;</span> llength <span class="skolem">xs'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Suc_ile_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lhd <span class="main">(</span>ldropn <span class="skolem">n</span> <span class="skolem">xs'</span><span class="main">)</span> <span class="main">=</span> lnth <span class="skolem">xs'</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> Suc<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lhd_ldrop"><span class="command">lemma</span></span> lhd_ldrop<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">&lt;</span> llength <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lhd <span class="main">(</span>ldrop <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lnth <span class="free">xs</span> <span class="main">(</span>the_enat <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">n'</span></span> <span class="keyword2"><span class="keyword">where</span></span> n<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">=</span> enat <span class="skolem">n'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> n
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">n'</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> lhd_conv_lnth<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n'</span><span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eSuc_enat<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eSuc_enat<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lnth_beyond"><span class="command">lemma</span></span> lnth_beyond<span class="main">:</span>
  <span class="quoted"><span class="quoted">"llength <span class="free">xs</span> <span class="main">≤</span> enat <span class="free">n</span> <span class="main">⟹</span> lnth <span class="free">xs</span> <span class="free">n</span> <span class="main">=</span> undefined <span class="main">(</span><span class="free">n</span> <span class="main">-</span> <span class="main">(</span><span class="keyword1">case</span> llength <span class="free">xs</span> <span class="keyword1">of</span> enat <span class="bound">m</span> <span class="main">⇒</span> <span class="bound">m</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> lnth_def lnull_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> Suc <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def lnth_def eSuc_enat<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> enat.split<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eSuc_enat<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lnth_lmap"><span class="command">lemma</span></span> lnth_lmap <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"enat <span class="free">n</span> <span class="main">&lt;</span> llength <span class="free">xs</span> <span class="main">⟹</span> lnth <span class="main">(</span>lmap <span class="free">f</span> <span class="free">xs</span><span class="main">)</span> <span class="free">n</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span>lnth <span class="free">xs</span> <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹enat <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span> <span class="main">&lt;</span> llength <span class="skolem">xs</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="skolem"><span class="skolem">xs'</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> LCons <span class="skolem">x</span> <span class="skolem">xs'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> len<span class="main">:</span> <span class="quoted"><span class="quoted">"enat <span class="skolem">n</span> <span class="main">&lt;</span> llength <span class="skolem">xs'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Suc_ile_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> len <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lnth <span class="main">(</span>lmap <span class="free">f</span> <span class="skolem">xs'</span><span class="main">)</span> <span class="skolem">n</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span>lnth <span class="skolem">xs'</span> <span class="skolem">n</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> Suc<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> xs <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lnth_ldropn"><span class="command">lemma</span></span> lnth_ldropn <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"enat <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="free">m</span><span class="main">)</span> <span class="main">&lt;</span> llength <span class="free">xs</span> <span class="main">⟹</span> lnth <span class="main">(</span>ldropn <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span> lnth <span class="free">xs</span> <span class="main">(</span><span class="free">m</span> <span class="main">+</span> <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹enat <span class="main">(</span>Suc <span class="skolem">n</span> <span class="main">+</span> <span class="free">m</span><span class="main">)</span> <span class="main">&lt;</span> llength <span class="skolem">xs</span>›</span></span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="skolem"><span class="skolem">xs'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> LCons <span class="skolem">x</span> <span class="skolem">xs'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">with</span></span></span> <span class="quoted"><span class="quoted">‹enat <span class="main">(</span>Suc <span class="skolem">n</span> <span class="main">+</span> <span class="free">m</span><span class="main">)</span> <span class="main">&lt;</span> llength <span class="skolem">xs</span>›</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"enat <span class="main">(</span><span class="skolem">n</span> <span class="main">+</span> <span class="free">m</span><span class="main">)</span> <span class="main">&lt;</span> llength <span class="skolem">xs'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Suc_ile_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lnth <span class="main">(</span>ldropn <span class="skolem">n</span> <span class="skolem">xs'</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span> lnth <span class="skolem">xs'</span> <span class="main">(</span><span class="free">m</span> <span class="main">+</span> <span class="skolem">n</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> Suc<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-lnth_ldrop"><span class="command">lemma</span></span> lnth_ldrop <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">+</span> enat <span class="free">m</span> <span class="main">&lt;</span> llength <span class="free">xs</span> <span class="main">⟹</span> lnth <span class="main">(</span>ldrop <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span> lnth <span class="free">xs</span> <span class="main">(</span><span class="free">m</span> <span class="main">+</span> the_enat <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldrop_enat<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-in_lset_conv_lnth"><span class="command">lemma</span></span> in_lset_conv_lnth<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> lset <span class="free">xs</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">n</span><span class="main">.</span> enat <span class="bound">n</span> <span class="main">&lt;</span> llength <span class="free">xs</span> <span class="main">∧</span> lnth <span class="free">xs</span> <span class="bound">n</span> <span class="main">=</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"enat <span class="skolem">n</span> <span class="main">&lt;</span> llength <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"lnth <span class="free">xs</span> <span class="skolem">n</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> 0
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> not_lnull_conv<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eSuc_enat<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>find <span class="skolem">xs</span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="main">0</span></span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">x'</span> <span class="skolem">xs</span><span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 4 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"Suc <span class="skolem">n</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">for</span></span></span></span> <span class="skolem">n</span><span class="main"><span class="main">]</span></span> ileI1 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eSuc_enat<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lset_conv_lnth"><span class="command">lemma</span></span> lset_conv_lnth<span class="main">:</span> <span class="quoted"><span class="quoted">"lset <span class="free">xs</span> <span class="main">=</span> <span class="main">{</span>lnth <span class="free">xs</span> <span class="bound">n</span><span class="main">|</span><span class="bound">n</span><span class="main">.</span> enat <span class="bound">n</span> <span class="main">&lt;</span> llength <span class="free">xs</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> in_lset_conv_lnth<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lnth_llist_of"><span class="command">lemma</span></span> lnth_llist_of <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lnth <span class="main">(</span>llist_of <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> nth <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">n</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"lnth <span class="main">(</span>llist_of <span class="free">xs</span><span class="main">)</span> <span class="skolem">n</span> <span class="main">=</span> <span class="free">xs</span> <span class="main">!</span> <span class="skolem">n</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">n</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nth_def lnth_def<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> Cons <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnth_LCons <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> nat.split<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-nth_list_of"><span class="command">lemma</span></span> nth_list_of <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"nth <span class="main">(</span>list_of <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lnth <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nth_def lnth_LNil nth_Cons <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> nat.split<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lnth_lappend1"><span class="command">lemma</span></span> lnth_lappend1<span class="main">:</span>
  <span class="quoted"><span class="quoted">"enat <span class="free">n</span> <span class="main">&lt;</span> llength <span class="free">xs</span> <span class="main">⟹</span> lnth <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="free">n</span> <span class="main">=</span> lnth <span class="free">xs</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> not_lnull_conv<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹enat <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span> <span class="main">&lt;</span> llength <span class="skolem">xs</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="skolem"><span class="skolem">xs'</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> LCons <span class="skolem">x</span> <span class="skolem">xs'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> len<span class="main">:</span> <span class="quoted"><span class="quoted">"enat <span class="skolem">n</span> <span class="main">&lt;</span> llength <span class="skolem">xs'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Suc_ile_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> len <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lnth <span class="main">(</span>lappend <span class="skolem">xs'</span> <span class="free">ys</span><span class="main">)</span> <span class="skolem">n</span> <span class="main">=</span> lnth <span class="skolem">xs'</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> Suc<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lnth_lappend_llist_of"><span class="command">lemma</span></span> lnth_lappend_llist_of<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lnth <span class="main">(</span>lappend <span class="main">(</span>llist_of <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span> <span class="free">n</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> length <span class="free">xs</span> <span class="keyword1">then</span> <span class="free">xs</span> <span class="main">!</span> <span class="free">n</span> <span class="keyword1">else</span> lnth <span class="free">ys</span> <span class="main">(</span><span class="free">n</span> <span class="main">-</span> length <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">n</span></span><span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-lnth_lappend2"><span class="command">lemma</span></span> lnth_lappend2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> llength <span class="free">xs</span> <span class="main">=</span> enat <span class="free">k</span><span class="main">;</span> <span class="free">k</span> <span class="main">≤</span> <span class="free">n</span> <span class="main">⟧</span> <span class="main">⟹</span> lnth <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="free">n</span> <span class="main">=</span> lnth <span class="free">ys</span> <span class="main">(</span><span class="free">n</span> <span class="main">-</span> <span class="free">k</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">k</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> lappend_lnull1<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eSuc_def zero_enat_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> enat.split_asm<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lnth_lappend"><span class="command">lemma</span></span> lnth_lappend<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lnth <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="free">n</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> enat <span class="free">n</span> <span class="main">&lt;</span> llength <span class="free">xs</span> <span class="keyword1">then</span> lnth <span class="free">xs</span> <span class="free">n</span> <span class="keyword1">else</span> lnth <span class="free">ys</span> <span class="main">(</span><span class="free">n</span> <span class="main">-</span> the_enat <span class="main">(</span>llength <span class="free">xs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"llength <span class="free">xs</span>"</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnth_lappend1 lnth_lappend2<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lnth_ltake"><span class="command">lemma</span></span> lnth_ltake<span class="main">:</span>
  <span class="quoted"><span class="quoted">"enat <span class="free">m</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="main">⟹</span> lnth <span class="main">(</span>ltake <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span> lnth <span class="free">xs</span> <span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">m</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_coexhaust<span class="main">)</span><span class="main">(</span><span class="operator">auto</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">m</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹enat <span class="main">(</span>Suc <span class="skolem">m</span><span class="main">)</span> <span class="main">&lt;</span> <span class="skolem">n</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">n'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">=</span> eSuc <span class="skolem">n'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_coexhaust<span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹enat <span class="main">(</span>Suc <span class="skolem">m</span><span class="main">)</span> <span class="main">&lt;</span> <span class="skolem">n</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"enat <span class="skolem">m</span> <span class="main">&lt;</span> <span class="skolem">n'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eSuc_enat<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> Suc <span class="quoted"><span class="quoted">‹<span class="skolem">n</span> <span class="main">=</span> eSuc <span class="skolem">n'</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-ldropn_Suc_conv_ldropn"><span class="command">lemma</span></span> ldropn_Suc_conv_ldropn<span class="main">:</span>
  <span class="quoted"><span class="quoted">"enat <span class="free">n</span> <span class="main">&lt;</span> llength <span class="free">xs</span> <span class="main">⟹</span> LCons <span class="main">(</span>lnth <span class="free">xs</span> <span class="free">n</span><span class="main">)</span> <span class="main">(</span>ldropn <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> ldropn <span class="free">n</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹enat <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span> <span class="main">&lt;</span> llength <span class="skolem">xs</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="skolem"><span class="skolem">xs'</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> LCons <span class="skolem">x</span> <span class="skolem">xs'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹enat <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span> <span class="main">&lt;</span> llength <span class="skolem">xs</span>›</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"enat <span class="skolem">n</span> <span class="main">&lt;</span> llength <span class="skolem">xs'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Suc_ile_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"LCons <span class="main">(</span>lnth <span class="skolem">xs'</span> <span class="skolem">n</span><span class="main">)</span> <span class="main">(</span>ldropn <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span> <span class="skolem">xs'</span><span class="main">)</span> <span class="main">=</span> ldropn <span class="skolem">n</span> <span class="skolem">xs'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> Suc<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-ltake_Suc_conv_snoc_lnth"><span class="command">lemma</span></span> ltake_Suc_conv_snoc_lnth<span class="main">:</span>
  <span class="quoted"><span class="quoted">"enat <span class="free">m</span> <span class="main">&lt;</span> llength <span class="free">xs</span> <span class="main">⟹</span> ltake <span class="main">(</span>enat <span class="main">(</span>Suc <span class="free">m</span><span class="main">)</span><span class="main">)</span> <span class="free">xs</span> <span class="main">=</span> lappend <span class="main">(</span>ltake <span class="main">(</span>enat <span class="free">m</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>LCons <span class="main">(</span>lnth <span class="free">xs</span> <span class="free">m</span><span class="main">)</span> LNil<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">metis</span> eSuc_enat eSuc_plus_1 ltake_plus_conv_lappend ldrop_enat ldropn_Suc_conv_ldropn ltake_0 ltake_eSuc_LCons one_eSuc<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lappend_eq_lappend_conv"><span class="command">lemma</span></span> lappend_eq_lappend_conv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> len<span class="main">:</span> <span class="quoted"><span class="quoted">"llength <span class="free">xs</span> <span class="main">=</span> llength <span class="free">us</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lappend <span class="free">xs</span> <span class="free">ys</span> <span class="main">=</span> lappend <span class="free">us</span> <span class="free">vs</span> <span class="main">⟷</span>
         <span class="free">xs</span> <span class="main">=</span> <span class="free">us</span> <span class="main">∧</span> <span class="main">(</span>lfinite <span class="free">xs</span> <span class="main">⟶</span> <span class="free">ys</span> <span class="main">=</span> <span class="free">vs</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lappend_inf<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> eq<span class="main">:</span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">intro</span> conjI impI<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="free">us</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> len eq
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">us</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Eq_llist <span class="skolem">xs</span> <span class="skolem">us</span><span class="main">)</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quoted"><span class="skolem">us</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> llist.exhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> llist.exhaust<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xs'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> llist_of <span class="skolem">xs'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lfinite_eq_range_llist_of<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lappend <span class="main">(</span>llist_of <span class="skolem">xs'</span><span class="main">)</span> <span class="free">ys</span> <span class="main">=</span> lappend <span class="main">(</span>llist_of <span class="skolem">xs'</span><span class="main">)</span> <span class="free">vs</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> eq <span class="quoted"><span class="quoted">‹<span class="free">xs</span> <span class="main">=</span> <span class="free">us</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">=</span> <span class="free">vs</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs'</span></span><span class="main">)</span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹iterates›</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> iterates <span class="main">[</span><span class="operator">code</span><span class="main">,</span> <span class="operator">nitpick_simp</span><span class="main">]</span> <span class="main">=</span> iterates.ctr
  <span class="keyword2"><span class="keyword">and</span></span> lnull_iterates <span class="main">=</span> iterates.simps<span class="main">(</span>1<span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> lhd_iterates <span class="main">=</span> iterates.simps<span class="main">(</span>2<span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> ltl_iterates <span class="main">=</span> iterates.simps<span class="main">(</span>3<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lfinite_iterates"><span class="command">lemma</span></span> lfinite_iterates <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lfinite <span class="main">(</span>iterates <span class="free">f</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>iterates <span class="free">f</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted">False</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="skolem">zs</span><span class="main"><span class="main">≡</span></span><span class="quoted"><span class="quoted">"iterates <span class="free">f</span> <span class="free">x</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lfinite_induct<span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lmap_iterates"><span class="command">lemma</span></span> lmap_iterates<span class="main">:</span> <span class="quoted"><span class="quoted">"lmap <span class="free">f</span> <span class="main">(</span>iterates <span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> iterates <span class="free">f</span> <span class="main">(</span><span class="free">f</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_List-iterates_lmap"><span class="command">lemma</span></span> iterates_lmap<span class="main">:</span> <span class="quoted"><span class="quoted">"iterates <span class="free">f</span> <span class="free">x</span> <span class="main">=</span> LCons <span class="free">x</span> <span class="main">(</span>lmap <span class="free">f</span> <span class="main">(</span>iterates <span class="free">f</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lmap_iterates<span class="main">)</span><span class="main">(</span><span class="operator">rule</span> iterates<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lappend_iterates"><span class="command">lemma</span></span> lappend_iterates<span class="main">:</span> <span class="quoted"><span class="quoted">"lappend <span class="main">(</span>iterates <span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="free">xs</span> <span class="main">=</span> iterates <span class="free">f</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> lnull_funpow_lmap<span class="main">:</span> <span class="quoted"><span class="quoted">"lnull <span class="main">(</span><span class="main">(</span>lmap <span class="free">f</span> <span class="main">^^</span> <span class="free">n</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟷</span> lnull <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> lhd_funpow_lmap<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lnull <span class="free">xs</span> <span class="main">⟹</span> lhd <span class="main">(</span><span class="main">(</span>lmap <span class="free">f</span> <span class="main">^^</span> <span class="free">n</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">f</span> <span class="main">^^</span> <span class="free">n</span><span class="main">)</span> <span class="main">(</span>lhd <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> ltl_funpow_lmap<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lnull <span class="free">xs</span> <span class="main">⟹</span> ltl <span class="main">(</span><span class="main">(</span>lmap <span class="free">f</span> <span class="main">^^</span> <span class="free">n</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>lmap <span class="free">f</span> <span class="main">^^</span> <span class="free">n</span><span class="main">)</span> <span class="main">(</span>ltl <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-iterates_equality"><span class="command">lemma</span></span> iterates_equality<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> h<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">h</span> <span class="bound">x</span> <span class="main">=</span> LCons <span class="bound">x</span> <span class="main">(</span>lmap <span class="free">f</span> <span class="main">(</span><span class="free">h</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">=</span> iterates <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lnull <span class="main">(</span><span class="free">h</span> <span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"lhd <span class="main">(</span><span class="free">h</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="quoted"><span class="quoted">"ltl <span class="main">(</span><span class="free">h</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">=</span> lmap <span class="free">f</span> <span class="main">(</span><span class="free">h</span> <span class="skolem">x</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> h<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> this

  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="main">::</span> <span class="quoted">nat</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>lmap <span class="free">f</span> <span class="main">^^</span> <span class="skolem">n</span><span class="main">)</span> <span class="main">(</span><span class="free">h</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>lmap <span class="free">f</span> <span class="main">^^</span> <span class="skolem">n</span><span class="main">)</span> <span class="main">(</span>iterates <span class="free">f</span> <span class="skolem">x</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> funpow_swap1 lmap_iterates <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"Suc <span class="skolem">n</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">for</span></span></span></span> <span class="skolem">n</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-llength_iterates"><span class="command">lemma</span></span> llength_iterates <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"llength <span class="main">(</span>iterates <span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">∞</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_coinduct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> epred_llength<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ldropn_iterates"><span class="command">lemma</span></span> ldropn_iterates<span class="main">:</span> <span class="quoted"><span class="quoted">"ldropn <span class="free">n</span> <span class="main">(</span>iterates <span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> iterates <span class="free">f</span> <span class="main">(</span><span class="main">(</span><span class="free">f</span> <span class="main">^^</span> <span class="free">n</span><span class="main">)</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ldropn <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span> <span class="main">(</span>iterates <span class="free">f</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">=</span> ldropn <span class="skolem">n</span> <span class="main">(</span>iterates <span class="free">f</span> <span class="main">(</span><span class="free">f</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> iterates<span class="main">)</span><span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> iterates <span class="free">f</span> <span class="main">(</span><span class="main">(</span><span class="free">f</span> <span class="main">^^</span> <span class="skolem">n</span><span class="main">)</span> <span class="main">(</span><span class="free">f</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> Suc<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> funpow_swap1<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-ldrop_iterates"><span class="command">lemma</span></span> ldrop_iterates<span class="main">:</span> <span class="quoted"><span class="quoted">"ldrop <span class="main">(</span>enat <span class="free">n</span><span class="main">)</span> <span class="main">(</span>iterates <span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> iterates <span class="free">f</span> <span class="main">(</span><span class="main">(</span><span class="free">f</span> <span class="main">^^</span> <span class="free">n</span><span class="main">)</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Suc <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> iterates<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eSuc_enat<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> funpow_swap1<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lnth_iterates"><span class="command">lemma</span></span> lnth_iterates <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lnth <span class="main">(</span>iterates <span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="free">n</span> <span class="main">=</span> <span class="main">(</span><span class="free">f</span> <span class="main">^^</span> <span class="free">n</span><span class="main">)</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> iterates<span class="main">)</span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lnth <span class="main">(</span>iterates <span class="free">f</span> <span class="main">(</span><span class="free">f</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span> <span class="skolem">n</span> <span class="main">=</span> <span class="main">(</span><span class="free">f</span> <span class="main">^^</span> <span class="skolem">n</span><span class="main">)</span> <span class="main">(</span><span class="free">f</span> <span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> iterates<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> funpow_swap1<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lset_iterates"><span class="command">lemma</span></span> lset_iterates<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lset <span class="main">(</span>iterates <span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="free">f</span> <span class="main">^^</span> <span class="bound">n</span><span class="main">)</span> <span class="free">x</span><span class="main">|</span><span class="bound">n</span><span class="main">.</span> True<span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lset_conv_lnth<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lset_repeat"><span class="command">lemma</span></span> lset_repeat <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lset <span class="main">(</span>repeat <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lset_iterates id_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹
  More on the prefix ordering on lazy lists: <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"lprefix"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"lstrict_prefix"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
›</span></span>

<span class="keyword1" id="Coinductive_List-lstrict_prefix_code"><span class="command">lemma</span></span> lstrict_prefix_code <span class="main">[</span><span class="operator">code</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lstrict_prefix LNil LNil <span class="main">⟷</span> False"</span></span>
  <span class="quoted"><span class="quoted">"lstrict_prefix LNil <span class="main">(</span>LCons <span class="free">y</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟷</span> True"</span></span>
  <span class="quoted"><span class="quoted">"lstrict_prefix <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> LNil <span class="main">⟷</span> False"</span></span>
  <span class="quoted"><span class="quoted">"lstrict_prefix <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>LCons <span class="free">y</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span> <span class="main">∧</span> lstrict_prefix <span class="free">xs</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lstrict_prefix_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lmap_lprefix"><span class="command">lemma</span></span> lmap_lprefix<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">⊑</span> <span class="free">ys</span> <span class="main">⟹</span> lmap <span class="free">f</span> <span class="free">xs</span> <span class="main">⊑</span> lmap <span class="free">f</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monotoneD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> monotone_lmap<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lprefix_llength_eq_imp_eq"><span class="command">lemma</span></span> lprefix_llength_eq_imp_eq<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">xs</span> <span class="main">⊑</span> <span class="free">ys</span><span class="main">;</span> llength <span class="free">xs</span> <span class="main">=</span> llength <span class="free">ys</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">xs</span> <span class="main">=</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lnull_conv<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lprefix_llength_le"><span class="command">lemma</span></span> lprefix_llength_le<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">⊑</span> <span class="free">ys</span> <span class="main">⟹</span> llength <span class="free">xs</span> <span class="main">≤</span> llength <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> monotone_llength <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monotoneD<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lstrict_prefix_llength_less"><span class="command">lemma</span></span> lstrict_prefix_llength_less<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"lstrict_prefix <span class="free">xs</span> <span class="free">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"llength <span class="free">xs</span> <span class="main">&lt;</span> llength <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> llength <span class="free">xs</span> <span class="main">&lt;</span> llength <span class="free">ys</span>"</span></span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹lstrict_prefix <span class="free">xs</span> <span class="free">ys</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">⊑</span> <span class="free">ys</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="free">ys</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> lstrict_prefix_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="free">xs</span> <span class="main">⊑</span> <span class="free">ys</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"llength <span class="free">xs</span> <span class="main">≤</span> llength <span class="free">ys</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> lprefix_llength_le<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"llength <span class="free">xs</span> <span class="main">=</span> llength <span class="free">ys</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="free">xs</span> <span class="main">⊑</span> <span class="free">ys</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="free">ys</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> lprefix_llength_eq_imp_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="free">xs</span> <span class="main">≠</span> <span class="free">ys</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">contradiction</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lstrict_prefix_lfinite1"><span class="command">lemma</span></span> lstrict_prefix_lfinite1<span class="main">:</span> <span class="quoted"><span class="quoted">"lstrict_prefix <span class="free">xs</span> <span class="free">ys</span> <span class="main">⟹</span> lfinite <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> lstrict_prefix_def not_lfinite_lprefix_conv_eq<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-wfP_lstrict_prefix"><span class="command">lemma</span></span> wfP_lstrict_prefix<span class="main">:</span> <span class="quoted"><span class="quoted">"wfP lstrict_prefix"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">unfold</span> wfP_def<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"wf <span class="main">{</span><span class="main">(</span><span class="bound">x</span> <span class="main">::</span> enat<span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="bound">y</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> wf_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> less_induct<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"wf <span class="main">(</span>inv_image <span class="main">{</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="bound">y</span><span class="main">}</span> llength<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> wf_inv_image<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="bound">ys</span><span class="main">)</span><span class="main">.</span> lstrict_prefix <span class="bound">xs</span> <span class="bound">ys</span><span class="main">}</span> <span class="main">⊆</span> inv_image <span class="main">{</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="bound">y</span><span class="main">}</span> llength"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> lstrict_prefix_llength_less<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"wf <span class="main">{</span><span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="bound">ys</span><span class="main">)</span><span class="main">.</span> lstrict_prefix <span class="bound">xs</span> <span class="bound">ys</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> wf_subset<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-llist_less_induct"><span class="command">lemma</span></span> llist_less_induct<span class="main">[</span><span class="operator">case_names</span> less<span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">xs</span><span class="main">.</span> <span class="main">(</span><span class="main">⋀</span><span class="bound">ys</span><span class="main">.</span> lstrict_prefix <span class="bound">ys</span> <span class="bound">xs</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">xs</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">P</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> wfP_induct<span class="main"><span class="main">[</span></span><span class="operator">OF</span> wfP_lstrict_prefix<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">blast</span>

<span class="keyword1" id="Coinductive_List-ltake_enat_eq_imp_eq"><span class="command">lemma</span></span> ltake_enat_eq_imp_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">n</span><span class="main">.</span> ltake <span class="main">(</span>enat <span class="bound">n</span><span class="main">)</span> <span class="free">xs</span> <span class="main">=</span> ltake <span class="main">(</span>enat <span class="bound">n</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">xs</span> <span class="main">=</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def lnull_def neq_LNil_conv ltake_eq_LNil_iff eSuc_enat<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> allE<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"Suc <span class="skolem">n</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">for</span></span></span></span> <span class="skolem">n</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ltake_enat_lprefix_imp_lprefix"><span class="command">lemma</span></span> ltake_enat_lprefix_imp_lprefix<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">n</span><span class="main">.</span> lprefix <span class="main">(</span>ltake <span class="main">(</span>enat <span class="bound">n</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>ltake <span class="main">(</span>enat <span class="bound">n</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lprefix <span class="free">xs</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ccpo.admissible Sup <span class="main">(≤)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> ltake <span class="bound">n</span> <span class="free">xs</span> <span class="main">⊑</span> ltake <span class="bound">n</span> <span class="free">ys</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"ltake <span class="main">(</span>Sup <span class="main">(</span>range enat<span class="main">)</span><span class="main">)</span> <span class="free">xs</span> <span class="main">⊑</span> ltake <span class="main">(</span>Sup <span class="main">(</span>range enat<span class="main">)</span><span class="main">)</span> <span class="free">ys</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> ccpo.admissibleD<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> assms<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltake_all<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lprefix_conv_lappend"><span class="command">lemma</span></span> lprefix_conv_lappend<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">⊑</span> <span class="free">ys</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">zs</span><span class="main">.</span> <span class="free">ys</span> <span class="main">=</span> lappend <span class="free">xs</span> <span class="bound">zs</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> iffI<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">=</span> lappend <span class="free">xs</span> <span class="main">(</span>ldrop <span class="main">(</span>llength <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lprefix_lnullD lprefix_lhdD <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> lprefix_ltlI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lnull_conv lprefix_LCons_conv <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">LNil</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lprefix_coinduct<span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lappend_lprefixE"><span class="command">lemma</span></span> lappend_lprefixE<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"lappend <span class="free">xs</span> <span class="free">ys</span> <span class="main">⊑</span> <span class="free">zs</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">zs'</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">zs</span> <span class="main">=</span> lappend <span class="free">xs</span> <span class="free">zs'</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> lprefix_conv_lappend <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lappend_assoc<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lprefix_lfiniteD"><span class="command">lemma</span></span> lprefix_lfiniteD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">xs</span> <span class="main">⊑</span> <span class="free">ys</span><span class="main">;</span> lfinite <span class="free">ys</span> <span class="main">⟧</span> <span class="main">⟹</span> lfinite <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> lprefix_conv_lappend <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_List-lprefix_lappendD"><span class="command">lemma</span></span> lprefix_lappendD<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">⊑</span> lappend <span class="free">ys</span> <span class="free">zs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">⊑</span> <span class="free">ys</span> <span class="main">∨</span> <span class="free">ys</span> <span class="main">⊑</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="main">(</span><span class="free">xs</span> <span class="main">⊑</span> <span class="free">ys</span> <span class="main">∨</span> <span class="free">ys</span> <span class="main">⊑</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">xs</span> <span class="main">⊑</span> <span class="free">ys</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">ys</span> <span class="main">⊑</span> <span class="free">xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="free">xs</span> <span class="main">⊑</span> lappend <span class="free">ys</span> <span class="free">zs</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xs'</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"lappend <span class="free">xs</span> <span class="skolem">xs'</span> <span class="main">=</span> lappend <span class="free">ys</span> <span class="free">zs</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> lprefix_conv_lappend <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> eq<span class="main">:</span> <span class="quoted"><span class="quoted">"lappend <span class="main">(</span>ltake <span class="main">(</span>llength <span class="free">ys</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>lappend <span class="main">(</span>ldrop <span class="main">(</span>llength <span class="free">ys</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span> <span class="skolem">xs'</span><span class="main">)</span> <span class="main">=</span>
             lappend <span class="free">ys</span> <span class="free">zs</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> lappend_assoc<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> lappend_ltake_ldrop<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"llength <span class="free">xs</span> <span class="main">≥</span> llength <span class="free">ys</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="var">?thesis</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"llength <span class="free">xs</span> <span class="main">&lt;</span> llength <span class="free">ys</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"ltake <span class="main">(</span>llength <span class="free">ys</span><span class="main">)</span> <span class="free">xs</span> <span class="main">=</span> <span class="free">xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltake_all<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lappend <span class="free">xs</span> <span class="main">(</span>lappend <span class="main">(</span>ldrop <span class="main">(</span>llength <span class="free">ys</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span> <span class="skolem">xs'</span><span class="main">)</span> <span class="main">=</span>
           lappend <span class="main">(</span>ltake <span class="main">(</span>llength <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span> <span class="main">(</span>lappend <span class="main">(</span>ldrop <span class="main">(</span>llength <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span> <span class="free">zs</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> lappend_assoc<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> lappend_ltake_ldrop
      <span class="keyword1"><span class="command">using</span></span> eq <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lappend_assoc<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> ltake <span class="main">(</span>llength <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹llength <span class="free">xs</span> <span class="main">&lt;</span> llength <span class="free">ys</span>›</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> lappend_eq_lappend_conv<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> min_def<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">⊑</span> <span class="free">ys</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> xs<span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> <span class="free">xs</span> <span class="main">⊑</span> <span class="free">ys</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">contradiction</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> ys<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">=</span> ltake <span class="main">(</span>llength <span class="free">ys</span><span class="main">)</span> <span class="free">xs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> lappend_eq_lappend_conv<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> min_def<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">⊑</span> <span class="free">xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> ys<span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> <span class="free">ys</span> <span class="main">⊑</span> <span class="free">xs</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">contradiction</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lstrict_prefix_lappend_conv"><span class="command">lemma</span></span> lstrict_prefix_lappend_conv<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lstrict_prefix <span class="free">xs</span> <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟷</span> lfinite <span class="free">xs</span> <span class="main">∧</span> <span class="main">¬</span> lnull <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> lappend <span class="free">xs</span> <span class="free">ys</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lnull <span class="free">ys</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span> <span class="operator">auto</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lstrict_prefix_def lprefix_lappend lappend_inf lappend_lnull2
            <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> contrapos_np<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lprefix_llist_ofI"><span class="command">lemma</span></span> lprefix_llist_ofI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">zs</span><span class="main">.</span> <span class="free">ys</span> <span class="main">=</span> <span class="free">xs</span> <span class="main">@</span> <span class="bound">zs</span> <span class="main">⟹</span> llist_of <span class="free">xs</span> <span class="main">⊑</span> llist_of <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lappend_llist_of_llist_of<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> lprefix_lappend<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lprefix_llist_of"><span class="command">lemma</span></span> lprefix_llist_of <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"llist_of <span class="free">xs</span> <span class="main">⊑</span> llist_of <span class="free">ys</span> <span class="main">⟷</span> prefix <span class="free">xs</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> prefix_def lprefix_conv_lappend<span class="main">)</span><span class="main">(</span><span class="operator">metis</span> lfinite_lappend lfinite_llist_of list_of_lappend list_of_llist_of lappend_llist_of_llist_of<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Coinductive_List-llimit_induct"><span class="command">lemma</span></span> llimit_induct <span class="main">[</span><span class="operator">case_names</span> LNil LCons limit<span class="main">]</span><span class="main">:</span>
  <span class="comment1">― ‹The limit case is just an instance of admissibility›</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> LNil<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> LNil"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> LCons<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">xs</span><span class="main">.</span> <span class="main">⟦</span> lfinite <span class="bound">xs</span><span class="main">;</span> <span class="free">P</span> <span class="bound">xs</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span>LCons <span class="bound">x</span> <span class="bound">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> limit<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">ys</span><span class="main">.</span> lstrict_prefix <span class="bound">ys</span> <span class="free">xs</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">P</span> <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> limit<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">ys</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"lstrict_prefix <span class="skolem">ys</span> <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="skolem">ys</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> lstrict_prefix_lfinite1<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="skolem">ys</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span><span class="main">)</span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> LNil LCons<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lmap_lstrict_prefix"><span class="command">lemma</span></span> lmap_lstrict_prefix<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lstrict_prefix <span class="free">xs</span> <span class="free">ys</span> <span class="main">⟹</span> lstrict_prefix <span class="main">(</span>lmap <span class="free">f</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>lmap <span class="free">f</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> llength_lmap lmap_lprefix lprefix_llength_eq_imp_eq lstrict_prefix_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lprefix_lnthD"><span class="command">lemma</span></span> lprefix_lnthD<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">⊑</span> <span class="free">ys</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"enat <span class="free">n</span> <span class="main">&lt;</span> llength <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lnth <span class="free">xs</span> <span class="free">n</span> <span class="main">=</span> lnth <span class="free">ys</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> lnth_lappend1 lprefix_conv_lappend<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lfinite_lSup_chain"><span class="command">lemma</span></span> lfinite_lSup_chain<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> chain<span class="main">:</span> <span class="quoted"><span class="quoted">"Complete_Partial_Order.chain <span class="main">(⊑)</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>lSup <span class="free">A</span><span class="main">)</span> <span class="main">⟷</span> finite <span class="free">A</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">xs</span> <span class="main">∈</span> <span class="free">A</span><span class="main">.</span> lfinite <span class="bound">xs</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">intro</span> iffI conjI<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="keyword2"><span class="keyword">where</span></span> n<span class="main">:</span> <span class="quoted"><span class="quoted">"llength <span class="main">(</span>lSup <span class="free">A</span><span class="main">)</span> <span class="main">=</span> enat <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> lfinite_conv_llength_enat <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"llength <span class="main">`</span> <span class="free">A</span> <span class="main">⊆</span> <span class="main">{..&lt;</span>enat <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> chain_lprefix_lSup<span class="main"><span class="main">[</span></span><span class="operator">OF</span> chain<span class="main"><span class="main">]</span></span> lprefix_llength_le <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> n <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> le_less_trans<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>llength <span class="main">`</span> <span class="free">A</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finite_lessThan_enat_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"inj_on llength <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> inj_onI<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> chainD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> chain<span class="main"><span class="main">]</span></span> lprefix_llength_eq_imp_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> finite_imageD<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">xs</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> lfinite <span class="bound">xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">=</span> <span class="main">{}</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">with</span></span> chain <span class="quoted"><span class="quoted">‹finite <span class="free">A</span>›</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lSup <span class="free">A</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> ccpo.in_chain_finite<span class="main"><span class="main">[</span></span><span class="operator">OF</span> llist_ccpo<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">∀</span><span class="bound">xs</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> lfinite <span class="bound">xs</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">rule</span> lfinite_lSupD<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Setup for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"lprefix"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> for Nitpick›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">finite_lprefix</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">⇒</span> <span class="tfree">'a</span> llist <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">finite_lprefix</span> <span class="main">=</span> <span class="main">(⊑)</span>"</span></span>

<span class="keyword1" id="Coinductive_List-finite_lprefix_nitpick_simps"><span class="command">lemma</span></span> finite_lprefix_nitpick_simps <span class="main">[</span><span class="operator">nitpick_simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"finite_lprefix <span class="free">xs</span> LNil <span class="main">⟷</span> <span class="free">xs</span> <span class="main">=</span> LNil"</span></span>
  <span class="quoted"><span class="quoted">"finite_lprefix LNil <span class="free">xs</span> <span class="main">⟷</span> True"</span></span>
  <span class="quoted"><span class="quoted">"finite_lprefix <span class="free">xs</span> <span class="main">(</span>LCons <span class="free">y</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟷</span>
   <span class="free">xs</span> <span class="main">=</span> LNil <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">xs'</span><span class="main">.</span> <span class="free">xs</span> <span class="main">=</span> LCons <span class="free">y</span> <span class="bound">xs'</span> <span class="main">∧</span> finite_lprefix <span class="bound">xs'</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lprefix_LCons_conv finite_lprefix_def lnull_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lprefix_nitpick_simps"><span class="command">lemma</span></span> lprefix_nitpick_simps <span class="main">[</span><span class="operator">nitpick_simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">⊑</span> <span class="free">ys</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> lfinite <span class="free">xs</span> <span class="keyword1">then</span> finite_lprefix <span class="free">xs</span> <span class="free">ys</span> <span class="keyword1">else</span> <span class="free">xs</span> <span class="main">=</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finite_lprefix_def not_lfinite_lprefix_conv_eq<span class="main">)</span>

<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> finite_lprefix
<span class="keyword1"><span class="command">hide_fact</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> finite_lprefix_def finite_lprefix_nitpick_simps lprefix_nitpick_simps

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Length of the longest common prefix›</span></span>

<span class="keyword1" id="Coinductive_List-llcp_simps"><span class="command">lemma</span></span> llcp_simps <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span><span class="main">,</span> <span class="operator">nitpick_simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> llcp_LNil1<span class="main">:</span> <span class="quoted"><span class="quoted">"llcp LNil <span class="free">ys</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> llcp_LNil2<span class="main">:</span> <span class="quoted"><span class="quoted">"llcp <span class="free">xs</span> LNil <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> llcp_LCons<span class="main">:</span> <span class="quoted"><span class="quoted">"llcp <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>LCons <span class="free">y</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span> <span class="keyword1">then</span> eSuc <span class="main">(</span>llcp <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llcp_def enat_unfold <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llcp_eq_0_iff"><span class="command">lemma</span></span> llcp_eq_0_iff<span class="main">:</span>
  <span class="quoted"><span class="quoted">"llcp <span class="free">xs</span> <span class="free">ys</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟷</span> lnull <span class="free">xs</span> <span class="main">∨</span> lnull <span class="free">ys</span> <span class="main">∨</span> lhd <span class="free">xs</span> <span class="main">≠</span> lhd <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llcp_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-epred_llcp"><span class="command">lemma</span></span> epred_llcp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">¬</span> lnull <span class="free">xs</span><span class="main">;</span> <span class="main">¬</span> lnull <span class="free">ys</span><span class="main">;</span> lhd <span class="free">xs</span> <span class="main">=</span> lhd <span class="free">ys</span> <span class="main">⟧</span>
  <span class="main">⟹</span>  epred <span class="main">(</span>llcp <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> llcp <span class="main">(</span>ltl <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>ltl <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llcp_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llcp_commute"><span class="command">lemma</span></span> llcp_commute<span class="main">:</span> <span class="quoted"><span class="quoted">"llcp <span class="free">xs</span> <span class="free">ys</span> <span class="main">=</span> llcp <span class="free">ys</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_coinduct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llcp_eq_0_iff epred_llcp<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llcp_same_conv_length"><span class="command">lemma</span></span> llcp_same_conv_length <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"llcp <span class="free">xs</span> <span class="free">xs</span> <span class="main">=</span> llength <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_coinduct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llcp_eq_0_iff epred_llcp epred_llength<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llcp_lappend_same"><span class="command">lemma</span></span> llcp_lappend_same <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"llcp <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">zs</span><span class="main">)</span> <span class="main">=</span> llength <span class="free">xs</span> <span class="main">+</span> llcp <span class="free">ys</span> <span class="free">zs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_coinduct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> iadd_is_0 llcp_eq_0_iff epred_iadd1 epred_llcp epred_llength<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llcp_lprefix1"><span class="command">lemma</span></span> llcp_lprefix1 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">⊑</span> <span class="free">ys</span> <span class="main">⟹</span> llcp <span class="free">xs</span> <span class="free">ys</span> <span class="main">=</span> llength <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> add_0_right lappend_LNil2 llcp_LNil1 llcp_lappend_same lprefix_conv_lappend<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llcp_lprefix2"><span class="command">lemma</span></span> llcp_lprefix2 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">⊑</span> <span class="free">xs</span> <span class="main">⟹</span> llcp <span class="free">xs</span> <span class="free">ys</span> <span class="main">=</span> llength <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> llcp_commute llcp_lprefix1<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llcp_le_length"><span class="command">lemma</span></span> llcp_le_length<span class="main">:</span> <span class="quoted"><span class="quoted">"llcp <span class="free">xs</span> <span class="free">ys</span> <span class="main">≤</span> min <span class="main">(</span>llength <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>llength <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">m</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">=</span> llcp <span class="free">xs</span> <span class="free">ys</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">=</span> min <span class="main">(</span>llength <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>llength <span class="free">ys</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">m</span><span class="main">,</span> <span class="skolem">n</span><span class="main">)</span> <span class="main">∈</span> <span class="main">{</span><span class="main">(</span>llcp <span class="bound">xs</span> <span class="bound">ys</span><span class="main">,</span> min <span class="main">(</span>llength <span class="bound">xs</span><span class="main">)</span> <span class="main">(</span>llength <span class="bound">ys</span><span class="main">)</span><span class="main">)</span> <span class="main">|</span><span class="bound">xs</span> <span class="bound">ys</span> <span class="main">::</span> <span class="tfree">'a</span> llist<span class="main">.</span> True<span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">≤</span> <span class="skolem">n</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_leI<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Leenat <span class="skolem">m</span> <span class="skolem">n</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xs</span></span> <span class="skolem"><span class="skolem">ys</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">=</span> llcp <span class="skolem">xs</span> <span class="skolem">ys</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">=</span> min <span class="main">(</span>llength <span class="skolem">xs</span><span class="main">)</span> <span class="main">(</span>llength <span class="skolem">ys</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quoted"><span class="skolem">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> llist.exhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> llist.exhaust<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"Suc <span class="main">0</span>"</span></span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eSuc_enat<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> iadd_Suc_right zero_enat_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-llcp_ltake1"><span class="command">lemma</span></span> llcp_ltake1<span class="main">:</span> <span class="quoted"><span class="quoted">"llcp <span class="main">(</span>ltake <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span> <span class="main">=</span> min <span class="free">n</span> <span class="main">(</span>llcp <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_coinduct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llcp_eq_0_iff enat_min_eq_0_iff epred_llcp ltl_ltake<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llcp_ltake2"><span class="command">lemma</span></span> llcp_ltake2<span class="main">:</span> <span class="quoted"><span class="quoted">"llcp <span class="free">xs</span> <span class="main">(</span>ltake <span class="free">n</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> min <span class="free">n</span> <span class="main">(</span>llcp <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">metis</span> llcp_commute llcp_ltake1<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llcp_ltake"><span class="command">lemma</span></span> llcp_ltake <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"llcp <span class="main">(</span>ltake <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>ltake <span class="free">m</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> min <span class="main">(</span>min <span class="free">n</span> <span class="free">m</span><span class="main">)</span> <span class="main">(</span>llcp <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">metis</span> llcp_ltake1 llcp_ltake2 min.assoc<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Zipping two lazy lists to a lazy list of pairs <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"lzip"</span></span> <span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1" id="Coinductive_List-lzip_simps"><span class="command">lemma</span></span> lzip_simps <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span><span class="main">,</span> <span class="operator">nitpick_simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lzip LNil <span class="free">ys</span> <span class="main">=</span> LNil"</span></span>
  <span class="quoted"><span class="quoted">"lzip <span class="free">xs</span> LNil <span class="main">=</span> LNil"</span></span>
  <span class="quoted"><span class="quoted">"lzip <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>LCons <span class="free">y</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> LCons <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">(</span>lzip <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> llist.expand<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lnull_lzip"><span class="command">lemma</span></span> lnull_lzip <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lnull <span class="main">(</span>lzip <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟷</span> lnull <span class="free">xs</span> <span class="main">∨</span> lnull <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lzip_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lzip_eq_LNil_conv"><span class="command">lemma</span></span> lzip_eq_LNil_conv<span class="main">:</span> <span class="quoted"><span class="quoted">"lzip <span class="free">xs</span> <span class="free">ys</span> <span class="main">=</span> LNil <span class="main">⟷</span> <span class="free">xs</span> <span class="main">=</span> LNil <span class="main">∨</span> <span class="free">ys</span> <span class="main">=</span> LNil"</span></span>
<span class="keyword1"><span class="command">using</span></span> lnull_lzip <span class="keyword1"><span class="command">unfolding</span></span> lnull_def <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> lhd_lzip <span class="main">=</span> lzip.sel<span class="main">(</span>1<span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> ltl_lzip <span class="main">=</span> lzip.sel<span class="main">(</span>2<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lzip_eq_LCons_conv"><span class="command">lemma</span></span> lzip_eq_LCons_conv<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lzip <span class="free">xs</span> <span class="free">ys</span> <span class="main">=</span> LCons <span class="free">z</span> <span class="free">zs</span> <span class="main">⟷</span>
   <span class="main">(</span><span class="main">∃</span><span class="bound">x</span> <span class="bound">xs'</span> <span class="bound">y</span> <span class="bound">ys'</span><span class="main">.</span> <span class="free">xs</span> <span class="main">=</span> LCons <span class="bound">x</span> <span class="bound">xs'</span> <span class="main">∧</span> <span class="free">ys</span> <span class="main">=</span> LCons <span class="bound">y</span> <span class="bound">ys'</span> <span class="main">∧</span> <span class="free">z</span> <span class="main">=</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∧</span> <span class="free">zs</span> <span class="main">=</span> lzip <span class="bound">xs'</span> <span class="bound">ys'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> llist.exhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> llist.exhaust<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_List-lzip_lappend"><span class="command">lemma</span></span> lzip_lappend<span class="main">:</span>
  <span class="quoted"><span class="quoted">"llength <span class="free">xs</span> <span class="main">=</span> llength <span class="free">us</span>
  <span class="main">⟹</span> lzip <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">(</span>lappend <span class="free">us</span> <span class="free">vs</span><span class="main">)</span> <span class="main">=</span> lappend <span class="main">(</span>lzip <span class="free">xs</span> <span class="free">us</span><span class="main">)</span> <span class="main">(</span>lzip <span class="free">ys</span> <span class="free">vs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quoted"><span class="free">us</span></span> <span class="quoted"><span class="free">vs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> llist.coinduct_strong<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 6 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llength_ltl<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llength_lzip"><span class="command">lemma</span></span> llength_lzip <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"llength <span class="main">(</span>lzip <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> min <span class="main">(</span>llength <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>llength <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_coinduct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> enat_min_eq_0_iff epred_llength<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ltake_lzip"><span class="command">lemma</span></span> ltake_lzip<span class="main">:</span> <span class="quoted"><span class="quoted">"ltake <span class="free">n</span> <span class="main">(</span>lzip <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> lzip <span class="main">(</span>ltake <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>ltake <span class="free">n</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltl_ltake<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ldropn_lzip"><span class="command">lemma</span></span> ldropn_lzip <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"ldropn <span class="free">n</span> <span class="main">(</span>lzip <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> lzip <span class="main">(</span>ldropn <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>ldropn <span class="free">n</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldropn_Suc <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">F</span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">F</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">lzip</span> <span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="bound">ys</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">xs</span> <span class="keyword1">of</span> LNil <span class="main">⇒</span> LNil <span class="main">|</span> LCons <span class="bound">x</span> <span class="bound">xs'</span> <span class="main">⇒</span> <span class="keyword1">case</span> <span class="bound">ys</span> <span class="keyword1">of</span> LNil <span class="main">⇒</span> LNil <span class="main">|</span> LCons <span class="bound">y</span> <span class="bound">ys'</span> <span class="main">⇒</span> LCons <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">(</span>curry <span class="bound">lzip</span> <span class="bound">xs'</span> <span class="bound">ys'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> lzip_conv_fixp<span class="main">:</span> <span class="quoted"><span class="quoted">"lzip <span class="main">≡</span> curry <span class="main">(</span>ccpo.fixp <span class="main">(</span>fun_lub lSup<span class="main">)</span> <span class="main">(</span>fun_ord <span class="main">(⊑)</span><span class="main">)</span> <span class="free">F</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">≡</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> lzip_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"mono_llist <span class="main">(</span><span class="main">λ</span><span class="bound">lzip</span><span class="main">.</span> <span class="free">F</span> <span class="bound">lzip</span> <span class="free">xs</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?mono</span> <span class="free">xs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">intro</span> eq_reflection ext<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span><span class="main">.</span> <span class="var">?mono</span> <span class="bound">xs</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> F_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">tactic</span> <span class="quoted">‹<span class="entity">Partial_Function.mono_tac</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span>›</span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="skolem">ys</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"lzip <span class="skolem">xs</span> <span class="skolem">ys</span> <span class="main">=</span> <span class="var">?rhs</span> <span class="skolem">xs</span> <span class="skolem">ys</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quoted"><span class="skolem">ys</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> Eq_llist <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 3 4<span class="main"><span class="main">)</span></span> llist.mono_body_fixp<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mono<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> F_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-monotone_lzip"><span class="command">lemma</span></span> monotone_lzip<span class="main">:</span> <span class="quoted"><span class="quoted">"monotone <span class="main">(</span>rel_prod <span class="main">(⊑)</span> <span class="main">(⊑)</span><span class="main">)</span> <span class="main">(⊑)</span> <span class="main">(</span>case_prod lzip<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> llist.fixp_preserves_mono2<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lzip_mono lzip_conv_fixp<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-mono2mono_lzip1"><span class="command">lemma</span></span> mono2mono_lzip1 <span class="main">[</span><span class="operator">THEN</span> llist.mono2mono<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> monotone_lzip1<span class="main">:</span> <span class="quoted"><span class="quoted">"monotone <span class="main">(⊑)</span> <span class="main">(⊑)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> lzip <span class="bound">xs</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> monotone_lzip<span class="main"><span class="main">[</span></span><span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Coinductive_List-mono2mono_lzip2"><span class="command">lemma</span></span> mono2mono_lzip2 <span class="main">[</span><span class="operator">THEN</span> llist.mono2mono<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> monotone_lzip2<span class="main">:</span> <span class="quoted"><span class="quoted">"monotone <span class="main">(⊑)</span> <span class="main">(⊑)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">ys</span><span class="main">.</span> lzip <span class="free">xs</span> <span class="bound">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> monotone_lzip<span class="main"><span class="main">[</span></span><span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Coinductive_List-mcont_lzip"><span class="command">lemma</span></span> mcont_lzip<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont <span class="main">(</span>prod_lub lSup lSup<span class="main">)</span> <span class="main">(</span>rel_prod <span class="main">(⊑)</span> <span class="main">(⊑)</span><span class="main">)</span> lSup <span class="main">(⊑)</span> <span class="main">(</span>case_prod lzip<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> llist.fixp_preserves_mcont2<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lzip_mono lzip_conv_fixp<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-mcont2mcont_lzip1"><span class="command">lemma</span></span> mcont2mcont_lzip1 <span class="main">[</span><span class="operator">THEN</span> llist.mcont2mcont<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> mcont_lzip1<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont lSup <span class="main">(⊑)</span> lSup <span class="main">(⊑)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> lzip <span class="bound">xs</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mcont_lzip<span class="main"><span class="main">[</span></span><span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Coinductive_List-mcont2mcont_lzip2"><span class="command">lemma</span></span> mcont2mcont_lzip2 <span class="main">[</span><span class="operator">THEN</span> llist.mcont2mcont<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> mcont_lzip2<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont lSup <span class="main">(⊑)</span> lSup <span class="main">(⊑)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">ys</span><span class="main">.</span> lzip <span class="free">xs</span> <span class="bound">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mcont_lzip<span class="main"><span class="main">[</span></span><span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ldrop_lzip"><span class="command">lemma</span></span> ldrop_lzip <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ldrop <span class="free">n</span> <span class="main">(</span>lzip <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> lzip <span class="main">(</span>ldrop <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>ldrop <span class="free">n</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> LCons
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ys</span></span> <span class="quoted"><span class="skolem">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> llist.exhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> co.enat.exhaust<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-lzip_iterates"><span class="command">lemma</span></span> lzip_iterates<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lzip <span class="main">(</span>iterates <span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span>iterates <span class="free">g</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> iterates <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">,</span> <span class="free">g</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">y</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_List-lzip_llist_of"><span class="command">lemma</span></span> lzip_llist_of <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lzip <span class="main">(</span>llist_of <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>llist_of <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> llist_of <span class="main">(</span>zip <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x</span> <span class="skolem">xs'</span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-lnth_lzip"><span class="command">lemma</span></span> lnth_lzip<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> enat <span class="free">n</span> <span class="main">&lt;</span> llength <span class="free">xs</span><span class="main">;</span> enat <span class="free">n</span> <span class="main">&lt;</span> llength <span class="free">ys</span> <span class="main">⟧</span>
  <span class="main">⟹</span> lnth <span class="main">(</span>lzip <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="free">n</span> <span class="main">=</span> <span class="main">(</span>lnth <span class="free">xs</span> <span class="free">n</span><span class="main">,</span> lnth <span class="free">ys</span> <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> lnth_0_conv_lhd<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quoted"><span class="skolem">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> llist.exhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> llist.exhaust<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eSuc_enat<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lset_lzip"><span class="command">lemma</span></span> lset_lzip<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lset <span class="main">(</span>lzip <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span>
   <span class="main">{</span><span class="main">(</span>lnth <span class="free">xs</span> <span class="bound">n</span><span class="main">,</span> lnth <span class="free">ys</span> <span class="bound">n</span><span class="main">)</span><span class="main">|</span><span class="bound">n</span><span class="main">.</span> enat <span class="bound">n</span> <span class="main">&lt;</span> min <span class="main">(</span>llength <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>llength <span class="free">ys</span><span class="main">)</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lset_conv_lnth lnth_lzip<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> exI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnth_lzip<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lset_lzipD1"><span class="command">lemma</span></span> lset_lzipD1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> lset <span class="main">(</span>lzip <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">∈</span> lset <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"lzip <span class="free">xs</span> <span class="free">ys</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lset_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span><span class="main">:</span> find
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lzip_eq_LCons_conv<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">z</span> <span class="skolem">zs</span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span><span class="main">(</span><span class="operator">drule</span> sym<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lzip_eq_LCons_conv<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lset_lzipD2"><span class="command">lemma</span></span> lset_lzipD2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> lset <span class="main">(</span>lzip <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">y</span> <span class="main">∈</span> lset <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"lzip <span class="free">xs</span> <span class="free">ys</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lset_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span><span class="main">:</span> find
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lzip_eq_LCons_conv<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">z</span> <span class="skolem">zs</span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span><span class="main">(</span><span class="operator">drule</span> sym<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lzip_eq_LCons_conv<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lset_lzip_same"><span class="command">lemma</span></span> lset_lzip_same <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lset <span class="main">(</span>lzip <span class="free">xs</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">`</span> lset <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lset_lzip in_lset_conv_lnth<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lfinite_lzip"><span class="command">lemma</span></span> lfinite_lzip <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>lzip <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟷</span> lfinite <span class="free">xs</span> <span class="main">∨</span> lfinite <span class="free">ys</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="skolem">zs</span><span class="main"><span class="main">≡</span></span><span class="quoted"><span class="quoted">"lzip <span class="free">xs</span> <span class="free">ys</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lfinite_induct<span class="main">)</span> <span class="operator">fastforce</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?xs</span> <span class="main">∨</span> <span class="var">?ys</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?xs</span></span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>lfinite_LConsI <span class="skolem">xs</span> <span class="skolem">x</span><span class="main">)</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main">)</span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?ys</span></span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>lfinite_LConsI <span class="skolem">ys</span> <span class="skolem">y</span><span class="main">)</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lzip_eq_lappend_conv"><span class="command">lemma</span></span> lzip_eq_lappend_conv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> eq<span class="main">:</span> <span class="quoted"><span class="quoted">"lzip <span class="free">xs</span> <span class="free">ys</span> <span class="main">=</span> lappend <span class="free">us</span> <span class="free">vs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">xs'</span> <span class="bound">xs''</span> <span class="bound">ys'</span> <span class="bound">ys''</span><span class="main">.</span> <span class="free">xs</span> <span class="main">=</span> lappend <span class="bound">xs'</span> <span class="bound">xs''</span> <span class="main">∧</span> <span class="free">ys</span> <span class="main">=</span> lappend <span class="bound">ys'</span> <span class="bound">ys''</span> <span class="main">∧</span>
                             llength <span class="bound">xs'</span> <span class="main">=</span> llength <span class="bound">ys'</span> <span class="main">∧</span> <span class="free">us</span> <span class="main">=</span> lzip <span class="bound">xs'</span> <span class="bound">ys'</span> <span class="main">∧</span>
                             <span class="free">vs</span> <span class="main">=</span> lzip <span class="bound">xs''</span> <span class="bound">ys''</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?xs'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"ltake <span class="main">(</span>llength <span class="free">us</span><span class="main">)</span> <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?xs''</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"ldrop <span class="main">(</span>llength <span class="free">us</span><span class="main">)</span> <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?ys'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"ltake <span class="main">(</span>llength <span class="free">us</span><span class="main">)</span> <span class="free">ys</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?ys''</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"ldrop <span class="main">(</span>llength <span class="free">us</span><span class="main">)</span> <span class="free">ys</span>"</span></span>

  <span class="keyword1"><span class="command">from</span></span> eq <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"llength <span class="main">(</span>lzip <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> llength <span class="main">(</span>lappend <span class="free">us</span> <span class="free">vs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"min <span class="main">(</span>llength <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>llength <span class="free">ys</span><span class="main">)</span> <span class="main">≥</span> llength <span class="free">us</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> enat_le_plus_same<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> len<span class="main">:</span> <span class="quoted"><span class="quoted">"llength <span class="free">xs</span> <span class="main">≥</span> llength <span class="free">us</span>"</span></span> <span class="quoted"><span class="quoted">"llength <span class="free">ys</span> <span class="main">≥</span> llength <span class="free">us</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

  <span class="keyword1"><span class="command">hence</span></span> leneq<span class="main">:</span> <span class="quoted"><span class="quoted">"llength <span class="var">?xs'</span> <span class="main">=</span> llength <span class="var">?ys'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> min_def<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> lappend <span class="var">?xs'</span> <span class="var">?xs''</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> ys<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">=</span> lappend <span class="var">?ys'</span> <span class="var">?ys''</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lappend_ltake_ldrop<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lappend <span class="free">us</span> <span class="free">vs</span> <span class="main">=</span> lzip <span class="main">(</span>lappend <span class="var">?xs'</span> <span class="var">?xs''</span><span class="main">)</span> <span class="main">(</span>lappend <span class="var">?ys'</span> <span class="var">?ys''</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">with</span></span> len <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lappend <span class="free">us</span> <span class="free">vs</span> <span class="main">=</span> lappend <span class="main">(</span>lzip <span class="var">?xs'</span> <span class="var">?ys'</span><span class="main">)</span> <span class="main">(</span>lzip <span class="var">?xs''</span> <span class="var">?ys''</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lzip_lappend min_def<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> us<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">us</span> <span class="main">=</span> lzip <span class="var">?xs'</span> <span class="var">?ys'</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> vs<span class="main">:</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">us</span> <span class="main">⟶</span> <span class="free">vs</span> <span class="main">=</span> lzip <span class="var">?xs''</span> <span class="var">?ys''</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> len
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> min_def lappend_eq_lappend_conv<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">us</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">with</span></span> leneq xs ys us vs len <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?xs''</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"lmap fst <span class="free">vs</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?ys''</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"lmap snd <span class="free">vs</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> False <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lappend <span class="free">us</span> <span class="free">vs</span> <span class="main">=</span> <span class="free">us</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lappend_inf<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> False <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"llength <span class="free">us</span> <span class="main">=</span> <span class="main">∞</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> not_lfinite_llength<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">with</span></span></span> len
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"llength <span class="free">xs</span> <span class="main">=</span> <span class="main">∞</span>"</span></span> <span class="quoted"><span class="quoted">"llength <span class="free">ys</span> <span class="main">=</span> <span class="main">∞</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">with</span></span></span> <span class="quoted"><span class="quoted">‹llength <span class="free">us</span> <span class="main">=</span> <span class="main">∞</span>›</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="var">?xs'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">=</span> <span class="var">?ys'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltake_all<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹llength <span class="free">us</span> <span class="main">=</span> <span class="main">∞</span>›</span></span> len
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lfinite <span class="var">?xs'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lfinite <span class="var">?ys'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> llength_ltake lfinite_ltake
             <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltake_all <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lfinite_llength_enat<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="free">xs</span> <span class="main">=</span> <span class="var">?xs'</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">ys</span> <span class="main">=</span> <span class="var">?ys'</span>›</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> lappend <span class="var">?xs'</span> <span class="var">?xs''</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">=</span> lappend <span class="var">?ys'</span> <span class="var">?ys''</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lappend_inf<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">vs</span> <span class="main">=</span> lzip <span class="var">?xs''</span> <span class="var">?ys''</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">vs</span></span><span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> eq <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltake_all<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lzip_lmap"><span class="command">lemma</span></span> lzip_lmap <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lzip <span class="main">(</span>lmap <span class="free">f</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>lmap <span class="free">g</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> lmap <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">,</span> <span class="free">g</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>lzip <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_List-lzip_lmap1"><span class="command">lemma</span></span> lzip_lmap1<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lzip <span class="main">(</span>lmap <span class="free">f</span> <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span> <span class="main">=</span> lmap <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>lzip <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span> llist.map_ident<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> lzip_lmap<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lzip_lmap2"><span class="command">lemma</span></span> lzip_lmap2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lzip <span class="free">xs</span> <span class="main">(</span>lmap <span class="free">f</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> lmap <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="free">f</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>lzip <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> llist.map_ident<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> lzip_lmap<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lmap_fst_lzip_conv_ltake"><span class="command">lemma</span></span> lmap_fst_lzip_conv_ltake<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lmap fst <span class="main">(</span>lzip <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> ltake <span class="main">(</span>min <span class="main">(</span>llength <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>llength <span class="free">ys</span><span class="main">)</span><span class="main">)</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> enat_min_eq_0_iff ltl_ltake epred_llength<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lmap_snd_lzip_conv_ltake"><span class="command">lemma</span></span> lmap_snd_lzip_conv_ltake<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lmap snd <span class="main">(</span>lzip <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> ltake <span class="main">(</span>min <span class="main">(</span>llength <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>llength <span class="free">ys</span><span class="main">)</span><span class="main">)</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> enat_min_eq_0_iff ltl_ltake epred_llength<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lzip_conv_lzip_ltake_min_llength"><span class="command">lemma</span></span> lzip_conv_lzip_ltake_min_llength<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lzip <span class="free">xs</span> <span class="free">ys</span> <span class="main">=</span>
  lzip <span class="main">(</span>ltake <span class="main">(</span>min <span class="main">(</span>llength <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>llength <span class="free">ys</span><span class="main">)</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span>
       <span class="main">(</span>ltake <span class="main">(</span>min <span class="main">(</span>llength <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>llength <span class="free">ys</span><span class="main">)</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> enat_min_eq_0_iff ltl_ltake epred_llength<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Taking and dropping from a lazy list: <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"ltakeWhile"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"ldropWhile"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1" id="Coinductive_List-ltakeWhile_simps"><span class="command">lemma</span></span> ltakeWhile_simps <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span><span class="main">,</span> <span class="operator">nitpick_simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> ltakeWhile_LNil<span class="main">:</span> <span class="quoted"><span class="quoted">"ltakeWhile <span class="free">P</span> LNil <span class="main">=</span> LNil"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> ltakeWhile_LCons<span class="main">:</span> <span class="quoted"><span class="quoted">"ltakeWhile <span class="free">P</span> <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">P</span> <span class="free">x</span> <span class="keyword1">then</span> LCons <span class="free">x</span> <span class="main">(</span>ltakeWhile <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="keyword1">else</span> LNil<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltakeWhile_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> llist.expand<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ldropWhile_simps"><span class="command">lemma</span></span> ldropWhile_simps <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> ldropWhile_LNil<span class="main">:</span> <span class="quoted"><span class="quoted">"ldropWhile <span class="free">P</span> LNil <span class="main">=</span> LNil"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> ldropWhile_LCons<span class="main">:</span> <span class="quoted"><span class="quoted">"ldropWhile <span class="free">P</span> <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">P</span> <span class="free">x</span> <span class="keyword1">then</span> ldropWhile <span class="free">P</span> <span class="free">xs</span> <span class="keyword1">else</span> LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldropWhile.simps<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="free">F</span> <span class="free">P</span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">F</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">ltakeWhile</span> <span class="bound">xs</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">xs</span> <span class="keyword1">of</span> LNil <span class="main">⇒</span> LNil <span class="main">|</span> LCons <span class="bound">x</span> <span class="bound">xs</span> <span class="main">⇒</span> <span class="keyword1">if</span> <span class="free">P</span> <span class="bound">x</span> <span class="keyword1">then</span> LCons <span class="bound">x</span> <span class="main">(</span><span class="bound">ltakeWhile</span> <span class="bound">xs</span><span class="main">)</span> <span class="keyword1">else</span> LNil"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> ltakeWhile_conv_fixp<span class="main">:</span> <span class="quoted"><span class="quoted">"ltakeWhile <span class="free">P</span> <span class="main">≡</span> ccpo.fixp <span class="main">(</span>fun_lub lSup<span class="main">)</span> <span class="main">(</span>fun_ord lprefix<span class="main">)</span> <span class="free">F</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">≡</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> ltakeWhile_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span><span class="main">.</span> mono_llist <span class="main">(</span><span class="main">λ</span><span class="bound">ltakeWhile</span><span class="main">.</span> <span class="free">F</span> <span class="bound">ltakeWhile</span> <span class="bound">xs</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">PROP</span> <span class="var">?mono</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">intro</span> eq_reflection ext<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">PROP</span> <span class="var">?mono</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> F_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">tactic</span> <span class="quoted">‹<span class="entity">Partial_Function.mono_tac</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span>›</span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="skolem">xs</span> <span class="main">=</span> <span class="var">?rhs</span> <span class="skolem">xs</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> Eq_llist
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 3 4<span class="main"><span class="main">)</span></span> llist.mono_body_fixp<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mono<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> F_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split prod.split co.enat.split<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-mono2mono_ltakeWhile"><span class="command">lemma</span></span> mono2mono_ltakeWhile<span class="main">[</span><span class="operator">THEN</span> llist.mono2mono<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> monotone_ltakeWhile<span class="main">:</span> <span class="quoted"><span class="quoted">"monotone lprefix lprefix <span class="main">(</span>ltakeWhile <span class="free">P</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> llist.fixp_preserves_mono1<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ltakeWhile_mono ltakeWhile_conv_fixp<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-mcont2mcont_ltakeWhile"><span class="command">lemma</span></span> mcont2mcont_ltakeWhile <span class="main">[</span><span class="operator">THEN</span> llist.mcont2mcont<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> mcont_ltakeWhile<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont lSup lprefix lSup lprefix <span class="main">(</span>ltakeWhile <span class="free">P</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> llist.fixp_preserves_mcont1<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ltakeWhile_mono ltakeWhile_conv_fixp<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-mono_llist_ltakeWhile"><span class="command">lemma</span></span> mono_llist_ltakeWhile <span class="main">[</span><span class="operator">partial_function_mono</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"mono_llist <span class="free">F</span> <span class="main">⟹</span> mono_llist <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> ltakeWhile <span class="free">P</span> <span class="main">(</span><span class="free">F</span> <span class="bound">f</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> mono2mono_ltakeWhile<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-mono2mono_ldropWhile"><span class="command">lemma</span></span> mono2mono_ldropWhile <span class="main">[</span><span class="operator">THEN</span> llist.mono2mono<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> monotone_ldropWhile<span class="main">:</span> <span class="quoted"><span class="quoted">"monotone <span class="main">(⊑)</span> <span class="main">(⊑)</span> <span class="main">(</span>ldropWhile <span class="free">P</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> llist.fixp_preserves_mono1<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ldropWhile.mono ldropWhile_def<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-mcont2mcont_ldropWhile"><span class="command">lemma</span></span> mcont2mcont_ldropWhile <span class="main">[</span><span class="operator">THEN</span> llist.mcont2mcont<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> mcont_ldropWhile<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont lSup <span class="main">(⊑)</span> lSup <span class="main">(⊑)</span> <span class="main">(</span>ldropWhile <span class="free">P</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> llist.fixp_preserves_mcont1<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ldropWhile.mono ldropWhile_def<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-lnull_ltakeWhile"><span class="command">lemma</span></span> lnull_ltakeWhile <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lnull <span class="main">(</span>ltakeWhile <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">¬</span> lnull <span class="free">xs</span> <span class="main">⟶</span> <span class="main">¬</span> <span class="free">P</span> <span class="main">(</span>lhd <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-ltakeWhile_eq_LNil_iff"><span class="command">lemma</span></span> ltakeWhile_eq_LNil_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"ltakeWhile <span class="free">P</span> <span class="free">xs</span> <span class="main">=</span> LNil <span class="main">⟷</span> <span class="main">(</span><span class="free">xs</span> <span class="main">≠</span> LNil <span class="main">⟶</span> <span class="main">¬</span> <span class="free">P</span> <span class="main">(</span>lhd <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> lnull_ltakeWhile <span class="keyword1"><span class="command">unfolding</span></span> lnull_def <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> lhd_ltakeWhile <span class="main">=</span> ltakeWhile.sel<span class="main">(</span>1<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ltl_ltakeWhile"><span class="command">lemma</span></span> ltl_ltakeWhile<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ltl <span class="main">(</span>ltakeWhile <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">P</span> <span class="main">(</span>lhd <span class="free">xs</span><span class="main">)</span> <span class="keyword1">then</span> ltakeWhile <span class="free">P</span> <span class="main">(</span>ltl <span class="free">xs</span><span class="main">)</span> <span class="keyword1">else</span> LNil<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-lprefix_ltakeWhile"><span class="command">lemma</span></span> lprefix_ltakeWhile<span class="main">:</span> <span class="quoted"><span class="quoted">"ltakeWhile <span class="free">P</span> <span class="free">xs</span> <span class="main">⊑</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltl_ltakeWhile<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llength_ltakeWhile_le"><span class="command">lemma</span></span> llength_ltakeWhile_le<span class="main">:</span> <span class="quoted"><span class="quoted">"llength <span class="main">(</span>ltakeWhile <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">≤</span> llength <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> lprefix_llength_le<span class="main">)</span><span class="main">(</span><span class="operator">rule</span> lprefix_ltakeWhile<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ltakeWhile_nth"><span class="command">lemma</span></span> ltakeWhile_nth<span class="main">:</span> <span class="quoted"><span class="quoted">"enat <span class="free">i</span> <span class="main">&lt;</span> llength <span class="main">(</span>ltakeWhile <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟹</span> lnth <span class="main">(</span>ltakeWhile <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="free">i</span> <span class="main">=</span> lnth <span class="free">xs</span> <span class="free">i</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> lprefix_lnthD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lprefix_ltakeWhile<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ltakeWhile_all"><span class="command">lemma</span></span> ltakeWhile_all<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">∈</span>lset <span class="free">xs</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="main">⟹</span> ltakeWhile <span class="free">P</span> <span class="free">xs</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltl_ltakeWhile <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> ltakeWhile.disc_iff <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> in_lset_ltlD<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lset_ltakeWhileD"><span class="command">lemma</span></span> lset_ltakeWhileD<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> lset <span class="main">(</span>ltakeWhile <span class="free">P</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> lset <span class="free">xs</span> <span class="main">∧</span> <span class="free">P</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="skolem">ys</span><span class="main"><span class="main">≡</span></span><span class="quoted"><span class="quoted">"ltakeWhile <span class="free">P</span> <span class="free">xs</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> llist_set_induct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltl_ltakeWhile <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> in_lset_ltlD<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lset_ltakeWhile_subset"><span class="command">lemma</span></span> lset_ltakeWhile_subset<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lset <span class="main">(</span>ltakeWhile <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⊆</span> lset <span class="free">xs</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lset_ltakeWhileD<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ltakeWhile_all_conv"><span class="command">lemma</span></span> ltakeWhile_all_conv<span class="main">:</span> <span class="quoted"><span class="quoted">"ltakeWhile <span class="free">P</span> <span class="free">xs</span> <span class="main">=</span> <span class="free">xs</span> <span class="main">⟷</span> lset <span class="free">xs</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Int_Collect Int_absorb2 le_infE lset_ltakeWhile_subset ltakeWhile_all<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llength_ltakeWhile_all"><span class="command">lemma</span></span> llength_ltakeWhile_all<span class="main">:</span> <span class="quoted"><span class="quoted">"llength <span class="main">(</span>ltakeWhile <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> llength <span class="free">xs</span> <span class="main">⟷</span> ltakeWhile <span class="free">P</span> <span class="free">xs</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> lprefix_llength_eq_imp_eq lprefix_ltakeWhile<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ldropWhile_eq_LNil_iff"><span class="command">lemma</span></span> ldropWhile_eq_LNil_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"ldropWhile <span class="free">P</span> <span class="free">xs</span> <span class="main">=</span> LNil <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> lset <span class="free">xs</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-lnull_ldropWhile"><span class="command">lemma</span></span> lnull_ldropWhile <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lnull <span class="main">(</span>ldropWhile <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> lset <span class="free">xs</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">unfolding</span></span> lnull_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldropWhile_eq_LNil_iff<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lset_ldropWhile_subset"><span class="command">lemma</span></span> lset_ldropWhile_subset<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lset <span class="main">(</span>ldropWhile <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⊆</span> lset <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_List-in_lset_ldropWhileD"><span class="command">lemma</span></span> in_lset_ldropWhileD<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> lset <span class="main">(</span>ldropWhile <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">∈</span> lset <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> lset_ldropWhile_subset<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">P</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_List-ltakeWhile_lmap"><span class="command">lemma</span></span> ltakeWhile_lmap<span class="main">:</span> <span class="quoted"><span class="quoted">"ltakeWhile <span class="free">P</span> <span class="main">(</span>lmap <span class="free">f</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lmap <span class="free">f</span> <span class="main">(</span>ltakeWhile <span class="main">(</span><span class="free">P</span> <span class="main">∘</span> <span class="free">f</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltl_ltakeWhile<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ldropWhile_lmap"><span class="command">lemma</span></span> ldropWhile_lmap<span class="main">:</span> <span class="quoted"><span class="quoted">"ldropWhile <span class="free">P</span> <span class="main">(</span>lmap <span class="free">f</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lmap <span class="free">f</span> <span class="main">(</span>ldropWhile <span class="main">(</span><span class="free">P</span> <span class="main">∘</span> <span class="free">f</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-llength_ltakeWhile_lt_iff"><span class="command">lemma</span></span> llength_ltakeWhile_lt_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"llength <span class="main">(</span>ltakeWhile <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">&lt;</span> llength <span class="free">xs</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">∈</span>lset <span class="free">xs</span><span class="main">.</span> <span class="main">¬</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"ltakeWhile <span class="free">P</span> <span class="free">xs</span> <span class="main">≠</span> <span class="free">xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltakeWhile_all_conv<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"ltakeWhile <span class="free">P</span> <span class="free">xs</span> <span class="main">≠</span> <span class="free">xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltakeWhile_all_conv<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> llength_ltakeWhile_all<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
    <span class="keyword1"><span class="command">using</span></span> llength_ltakeWhile_le<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">P</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-ltakeWhile_K_False"><span class="command">lemma</span></span> ltakeWhile_K_False <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ltakeWhile <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> False<span class="main">)</span> <span class="free">xs</span> <span class="main">=</span> LNil"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltakeWhile_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ltakeWhile_K_True"><span class="command">lemma</span></span> ltakeWhile_K_True <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ltakeWhile <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> <span class="free">xs</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-ldropWhile_K_False"><span class="command">lemma</span></span> ldropWhile_K_False <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ldropWhile <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> False<span class="main">)</span> <span class="main">=</span> id"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ldropWhile <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> False<span class="main">)</span> <span class="skolem">xs</span> <span class="main">=</span> id <span class="skolem">xs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-ldropWhile_K_True"><span class="command">lemma</span></span> ldropWhile_K_True <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ldropWhile <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> <span class="free">xs</span> <span class="main">=</span> LNil"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lappend_ltakeWhile_ldropWhile"><span class="command">lemma</span></span> lappend_ltakeWhile_ldropWhile <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lappend <span class="main">(</span>ltakeWhile <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>ldropWhile <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> llist.coinduct_strong<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 4 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lnull_conv lset_lnull <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> ccontr<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ltakeWhile_lappend"><span class="command">lemma</span></span> ltakeWhile_lappend<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ltakeWhile <span class="free">P</span> <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="main">∃</span><span class="bound">x</span><span class="main">∈</span>lset <span class="free">xs</span><span class="main">.</span> <span class="main">¬</span> <span class="free">P</span> <span class="bound">x</span> <span class="keyword1">then</span> ltakeWhile <span class="free">P</span> <span class="free">xs</span>
   <span class="keyword1">else</span> lappend <span class="free">xs</span> <span class="main">(</span>ltakeWhile <span class="free">P</span> <span class="free">ys</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> llist.coinduct_strong<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Eq_llist <span class="skolem">xs</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?lnull</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lset_lnull<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?LCons</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm <span class="quasi_keyword">split</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> if_split <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltl_ltakeWhile<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lnull_conv<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-ldropWhile_lappend"><span class="command">lemma</span></span> ldropWhile_lappend<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ldropWhile <span class="free">P</span> <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="main">∃</span><span class="bound">x</span><span class="main">∈</span>lset <span class="free">xs</span><span class="main">.</span> <span class="main">¬</span> <span class="free">P</span> <span class="bound">x</span> <span class="keyword1">then</span> lappend <span class="main">(</span>ldropWhile <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span>
   <span class="keyword1">else</span> <span class="keyword1">if</span> lfinite <span class="free">xs</span> <span class="keyword1">then</span> ldropWhile <span class="free">P</span> <span class="free">ys</span> <span class="keyword1">else</span> LNil<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span><span class="main">∈</span>lset <span class="free">xs</span><span class="main">.</span> <span class="main">¬</span> <span class="free">P</span> <span class="bound">x</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> lset <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">P</span> <span class="skolem">x</span>"</span></span>  <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">note</span></span> xs <span class="main">=</span> this
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> xs <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lappend_inf<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> xs <span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lfinite_ltakeWhile"><span class="command">lemma</span></span> lfinite_ltakeWhile<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>ltakeWhile <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟷</span> lfinite <span class="free">xs</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span> <span class="main">∈</span> lset <span class="free">xs</span><span class="main">.</span> <span class="main">¬</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltakeWhile_all<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rhs</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> lprefix_ltakeWhile <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> lprefix_lfiniteD<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span><span class="main">∈</span>lset <span class="free">xs</span><span class="main">.</span> <span class="main">¬</span> <span class="free">P</span> <span class="bound">x</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> lset <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">P</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lset_induct<span class="main">)</span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-llength_ltakeWhile_eq_infinity"><span class="command">lemma</span></span> llength_ltakeWhile_eq_infinity<span class="main">:</span>
  <span class="quoted"><span class="quoted">"llength <span class="main">(</span>ltakeWhile <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">∞</span> <span class="main">⟷</span> <span class="main">¬</span> lfinite <span class="free">xs</span> <span class="main">∧</span> ltakeWhile <span class="free">P</span> <span class="free">xs</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> llength_ltakeWhile_all<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> llength_eq_infty_conv_lfinite<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llength_eq_infty_conv_lfinite lfinite_ltakeWhile <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> sym<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llength_ltakeWhile_eq_infinity'"><span class="command">lemma</span></span> llength_ltakeWhile_eq_infinity'<span class="main">:</span>
  <span class="quoted"><span class="quoted">"llength <span class="main">(</span>ltakeWhile <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">∞</span> <span class="main">⟷</span> <span class="main">¬</span> lfinite <span class="free">xs</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">∈</span>lset <span class="free">xs</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> lfinite_ltakeWhile llength_eq_infty_conv_lfinite<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lzip_ltakeWhile_fst"><span class="command">lemma</span></span> lzip_ltakeWhile_fst<span class="main">:</span> <span class="quoted"><span class="quoted">"lzip <span class="main">(</span>ltakeWhile <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span> <span class="main">=</span> ltakeWhile <span class="main">(</span><span class="free">P</span> <span class="main">∘</span> fst<span class="main">)</span> <span class="main">(</span>lzip <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltl_ltakeWhile <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> ltakeWhile.disc_iff<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lzip_ltakeWhile_snd"><span class="command">lemma</span></span> lzip_ltakeWhile_snd<span class="main">:</span> <span class="quoted"><span class="quoted">"lzip <span class="free">xs</span> <span class="main">(</span>ltakeWhile <span class="free">P</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> ltakeWhile <span class="main">(</span><span class="free">P</span> <span class="main">∘</span> snd<span class="main">)</span> <span class="main">(</span>lzip <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltl_ltakeWhile<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ltakeWhile_lappend1"><span class="command">lemma</span></span> ltakeWhile_lappend1<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">x</span> <span class="main">∈</span> lset <span class="free">xs</span><span class="main">;</span> <span class="main">¬</span> <span class="free">P</span> <span class="free">x</span> <span class="main">⟧</span> <span class="main">⟹</span> ltakeWhile <span class="free">P</span> <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> ltakeWhile <span class="free">P</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lset_induct<span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-ltakeWhile_lappend2"><span class="command">lemma</span></span> ltakeWhile_lappend2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lset <span class="free">xs</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">}</span>
  <span class="main">⟹</span> ltakeWhile <span class="free">P</span> <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> lappend <span class="free">xs</span> <span class="main">(</span>ltakeWhile <span class="free">P</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> llist.coinduct_strong<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 4 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lnull_conv lappend_lnull1<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ltakeWhile_cong"><span class="command">lemma</span></span> ltakeWhile_cong <span class="main">[</span><span class="operator">cong</span><span class="main">,</span> <span class="operator">fundef_cong</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="free">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> PQ<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> lset <span class="free">ys</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">Q</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ltakeWhile <span class="free">P</span> <span class="free">xs</span> <span class="main">=</span> ltakeWhile <span class="free">Q</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> PQ <span class="keyword1"><span class="command">unfolding</span></span> xs
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltl_ltakeWhile not_lnull_conv<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lnth_llength_ltakeWhile"><span class="command">lemma</span></span> lnth_llength_ltakeWhile<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> len<span class="main">:</span> <span class="quoted"><span class="quoted">"llength <span class="main">(</span>ltakeWhile <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">&lt;</span> llength <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">P</span> <span class="main">(</span>lnth <span class="free">xs</span> <span class="main">(</span>the_enat <span class="main">(</span>llength <span class="main">(</span>ltakeWhile <span class="free">P</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> P<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span>lnth <span class="free">xs</span> <span class="main">(</span>the_enat <span class="main">(</span>llength <span class="main">(</span>ltakeWhile <span class="free">P</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> len <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">len</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"llength <span class="main">(</span>ltakeWhile <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> enat <span class="skolem">len</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"llength <span class="main">(</span>ltakeWhile <span class="free">P</span> <span class="free">xs</span><span class="main">)</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> P len <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">len</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> lnth_0_conv_lhd<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">len</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eSuc_enat<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span><span class="main">∈</span>lset <span class="free">xs</span><span class="main">.</span> <span class="main">¬</span> <span class="free">P</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> lhd_ldropWhile<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">P</span> <span class="main">(</span>lhd <span class="main">(</span>ldropWhile <span class="free">P</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?thesis1</span></span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> lhd_ldropWhile_in_lset<span class="main">:</span> <span class="quoted"><span class="quoted">"lhd <span class="main">(</span>ldropWhile <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">∈</span> lset <span class="free">xs</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?thesis2</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> lset <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">P</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis1</span></span></span> <span class="var"><span class="quoted"><span class="var">?thesis2</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-ldropWhile_eq_ldrop"><span class="command">lemma</span></span> ldropWhile_eq_ldrop<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ldropWhile <span class="free">P</span> <span class="free">xs</span> <span class="main">=</span> ldrop <span class="main">(</span>llength <span class="main">(</span>ltakeWhile <span class="free">P</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span> <span class="free">xs</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> lprefix_antisym<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⊑</span> <span class="var">?rhs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> ldropWhile.fixp_induct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rhs</span> <span class="main">⊑</span> <span class="var">?lhs</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> ldrop.fixp_induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>3 <span class="skolem">ldrop</span> <span class="skolem">xs</span><span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-ldropWhile_cong"><span class="command">lemma</span></span> ldropWhile_cong <span class="main">[</span><span class="operator">cong</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">xs</span> <span class="main">=</span> <span class="free">ys</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> lset <span class="free">ys</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">Q</span> <span class="bound">x</span> <span class="main">⟧</span> <span class="main">⟹</span> ldropWhile <span class="free">P</span> <span class="free">xs</span> <span class="main">=</span> ldropWhile <span class="free">Q</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldropWhile_eq_ldrop<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ltakeWhile_repeat"><span class="command">lemma</span></span> ltakeWhile_repeat<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ltakeWhile <span class="free">P</span> <span class="main">(</span>repeat <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">P</span> <span class="free">x</span> <span class="keyword1">then</span> repeat <span class="free">x</span> <span class="keyword1">else</span> LNil<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltl_ltakeWhile<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ldropWhile_repeat"><span class="command">lemma</span></span> ldropWhile_repeat<span class="main">:</span> <span class="quoted"><span class="quoted">"ldropWhile <span class="free">P</span> <span class="main">(</span>repeat <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">P</span> <span class="free">x</span> <span class="keyword1">then</span> LNil <span class="keyword1">else</span> repeat <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldropWhile_eq_ldrop ltakeWhile_repeat<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lfinite_ldropWhile"><span class="command">lemma</span></span> lfinite_ldropWhile<span class="main">:</span> <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>ldropWhile <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span> <span class="main">∈</span> lset <span class="free">xs</span><span class="main">.</span> <span class="main">¬</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> lfinite <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldropWhile_eq_ldrop llength_eq_infty_conv_lfinite lfinite_ltakeWhile<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llength_ldropWhile"><span class="command">lemma</span></span> llength_ldropWhile<span class="main">:</span>
  <span class="quoted"><span class="quoted">"llength <span class="main">(</span>ldropWhile <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="main">∃</span><span class="bound">x</span><span class="main">∈</span>lset <span class="free">xs</span><span class="main">.</span> <span class="main">¬</span> <span class="free">P</span> <span class="bound">x</span> <span class="keyword1">then</span> llength <span class="free">xs</span> <span class="main">-</span> llength <span class="main">(</span>ltakeWhile <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldropWhile_eq_ldrop llength_ldrop llength_ltakeWhile_all ltakeWhile_all_conv llength_ltakeWhile_eq_infinity zero_enat_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> lfinite_llength_enat<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lhd_ldropWhile_conv_lnth"><span class="command">lemma</span></span> lhd_ldropWhile_conv_lnth<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span><span class="main">∈</span>lset <span class="free">xs</span><span class="main">.</span> <span class="main">¬</span> <span class="free">P</span> <span class="bound">x</span> <span class="main">⟹</span> lhd <span class="main">(</span>ldropWhile <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lnth <span class="free">xs</span> <span class="main">(</span>the_enat <span class="main">(</span>llength <span class="main">(</span>ltakeWhile <span class="free">P</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldropWhile_eq_ldrop lhd_ldrop llength_ltakeWhile_lt_iff<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"llist_all2"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> llist_all2_LNil_LNil <span class="main">=</span> llist.rel_inject<span class="main">(</span>1<span class="main">)</span>
<span class="keyword1"><span class="command">lemmas</span></span> llist_all2_LNil_LCons <span class="main">=</span> llist.rel_distinct<span class="main">(</span>1<span class="main">)</span>
<span class="keyword1"><span class="command">lemmas</span></span> llist_all2_LCons_LNil <span class="main">=</span> llist.rel_distinct<span class="main">(</span>2<span class="main">)</span>
<span class="keyword1"><span class="command">lemmas</span></span> llist_all2_LCons_LCons <span class="main">=</span> llist.rel_inject<span class="main">(</span>2<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llist_all2_LNil1"><span class="command">lemma</span></span> llist_all2_LNil1 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"llist_all2 <span class="free">P</span> LNil <span class="free">xs</span> <span class="main">⟷</span> <span class="free">xs</span> <span class="main">=</span> LNil"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-llist_all2_LNil2"><span class="command">lemma</span></span> llist_all2_LNil2 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"llist_all2 <span class="free">P</span> <span class="free">xs</span> LNil <span class="main">⟷</span> <span class="free">xs</span> <span class="main">=</span> LNil"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-llist_all2_LCons1"><span class="command">lemma</span></span> llist_all2_LCons1<span class="main">:</span>
  <span class="quoted"><span class="quoted">"llist_all2 <span class="free">P</span> <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y</span> <span class="bound">ys'</span><span class="main">.</span> <span class="free">ys</span> <span class="main">=</span> LCons <span class="bound">y</span> <span class="bound">ys'</span> <span class="main">∧</span> <span class="free">P</span> <span class="free">x</span> <span class="bound">y</span> <span class="main">∧</span> llist_all2 <span class="free">P</span> <span class="free">xs</span> <span class="bound">ys'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-llist_all2_LCons2"><span class="command">lemma</span></span> llist_all2_LCons2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"llist_all2 <span class="free">P</span> <span class="free">xs</span> <span class="main">(</span>LCons <span class="free">y</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span> <span class="bound">xs'</span><span class="main">.</span> <span class="free">xs</span> <span class="main">=</span> LCons <span class="bound">x</span> <span class="bound">xs'</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">x</span> <span class="free">y</span> <span class="main">∧</span> llist_all2 <span class="free">P</span> <span class="bound">xs'</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-llist_all2_llist_of"><span class="command">lemma</span></span> llist_all2_llist_of <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"llist_all2 <span class="free">P</span> <span class="main">(</span>llist_of <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>llist_of <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> list_all2 <span class="free">P</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> list_induct2'<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llist_all2_conv_lzip"><span class="command">lemma</span></span> llist_all2_conv_lzip<span class="main">:</span>
  <span class="quoted"><span class="quoted">"llist_all2 <span class="free">P</span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">⟷</span> llength <span class="free">xs</span> <span class="main">=</span> llength <span class="free">ys</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> lset <span class="main">(</span>lzip <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 4 <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> GrpE <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>
  llist_all2_def lmap_fst_lzip_conv_ltake lmap_snd_lzip_conv_ltake ltake_all
  <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> GrpI relcomppI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llist_all2_llengthD"><span class="command">lemma</span></span> llist_all2_llengthD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"llist_all2 <span class="free">P</span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">⟹</span> llength <span class="free">xs</span> <span class="main">=</span> llength <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_all2_conv_lzip<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llist_all2_lnullD"><span class="command">lemma</span></span> llist_all2_lnullD<span class="main">:</span> <span class="quoted"><span class="quoted">"llist_all2 <span class="free">P</span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">⟹</span> lnull <span class="free">xs</span> <span class="main">⟷</span> lnull <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> lnull_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_List-llist_all2_all_lnthI"><span class="command">lemma</span></span> llist_all2_all_lnthI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> llength <span class="free">xs</span> <span class="main">=</span> llength <span class="free">ys</span><span class="main">;</span>
     <span class="main">⋀</span><span class="bound">n</span><span class="main">.</span> enat <span class="bound">n</span> <span class="main">&lt;</span> llength <span class="free">xs</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span>lnth <span class="free">xs</span> <span class="bound">n</span><span class="main">)</span> <span class="main">(</span>lnth <span class="free">ys</span> <span class="bound">n</span><span class="main">)</span> <span class="main">⟧</span>
  <span class="main">⟹</span> llist_all2 <span class="free">P</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_all2_conv_lzip lset_lzip<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llist_all2_lnthD"><span class="command">lemma</span></span> llist_all2_lnthD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> llist_all2 <span class="free">P</span> <span class="free">xs</span> <span class="free">ys</span><span class="main">;</span> enat <span class="free">n</span> <span class="main">&lt;</span> llength <span class="free">xs</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span>lnth <span class="free">xs</span> <span class="free">n</span><span class="main">)</span> <span class="main">(</span>lnth <span class="free">ys</span> <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_all2_conv_lzip lset_lzip<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llist_all2_lnthD2"><span class="command">lemma</span></span> llist_all2_lnthD2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> llist_all2 <span class="free">P</span> <span class="free">xs</span> <span class="free">ys</span><span class="main">;</span> enat <span class="free">n</span> <span class="main">&lt;</span> llength <span class="free">ys</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span>lnth <span class="free">xs</span> <span class="free">n</span><span class="main">)</span> <span class="main">(</span>lnth <span class="free">ys</span> <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_all2_conv_lzip lset_lzip<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llist_all2_conv_all_lnth"><span class="command">lemma</span></span> llist_all2_conv_all_lnth<span class="main">:</span>
  <span class="quoted"><span class="quoted">"llist_all2 <span class="free">P</span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">⟷</span>
   llength <span class="free">xs</span> <span class="main">=</span> llength <span class="free">ys</span> <span class="main">∧</span>
   <span class="main">(</span><span class="main">∀</span><span class="bound">n</span><span class="main">.</span> enat <span class="bound">n</span> <span class="main">&lt;</span> llength <span class="free">ys</span> <span class="main">⟶</span> <span class="free">P</span> <span class="main">(</span>lnth <span class="free">xs</span> <span class="bound">n</span><span class="main">)</span> <span class="main">(</span>lnth <span class="free">ys</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> llist_all2_llengthD llist_all2_lnthD2 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> llist_all2_all_lnthI<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llist_all2_True"><span class="command">lemma</span></span> llist_all2_True <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"llist_all2 <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">⟷</span> llength <span class="free">xs</span> <span class="main">=</span> llength <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_all2_conv_all_lnth<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llist_all2_reflI"><span class="command">lemma</span></span> llist_all2_reflI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> lset <span class="free">xs</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">x</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⟹</span> llist_all2 <span class="free">P</span> <span class="free">xs</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_all2_conv_all_lnth lset_conv_lnth<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llist_all2_lmap1"><span class="command">lemma</span></span> llist_all2_lmap1<span class="main">:</span>
  <span class="quoted"><span class="quoted">"llist_all2 <span class="free">P</span> <span class="main">(</span>lmap <span class="free">f</span> <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span> <span class="main">⟷</span> llist_all2 <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_all2_conv_all_lnth<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llist_all2_lmap2"><span class="command">lemma</span></span> llist_all2_lmap2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"llist_all2 <span class="free">P</span> <span class="free">xs</span> <span class="main">(</span>lmap <span class="free">g</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟷</span> llist_all2 <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="main">(</span><span class="free">g</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_all2_conv_all_lnth<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llist_all2_lfiniteD"><span class="command">lemma</span></span> llist_all2_lfiniteD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"llist_all2 <span class="free">P</span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">⟹</span> lfinite <span class="free">xs</span> <span class="main">⟷</span> lfinite <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">drule</span> llist_all2_llengthD<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lfinite_conv_llength_enat<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llist_all2_coinduct"><span class="command">lemma</span></span> llist_all2_coinduct<span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> LNil LCons<span class="main">,</span> <span class="operator">case_conclusion</span> LCons lhd ltl<span class="main">,</span> <span class="operator">coinduct</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">pred</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> major<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> step<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span> <span class="bound">ys</span><span class="main">.</span> <span class="free">X</span> <span class="bound">xs</span> <span class="bound">ys</span> <span class="main">⟹</span> lnull <span class="bound">xs</span> <span class="main">⟷</span> lnull <span class="bound">ys</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span> <span class="bound">ys</span><span class="main">.</span> <span class="main">⟦</span> <span class="free">X</span> <span class="bound">xs</span> <span class="bound">ys</span><span class="main">;</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">;</span> <span class="main">¬</span> lnull <span class="bound">ys</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span>lhd <span class="bound">xs</span><span class="main">)</span> <span class="main">(</span>lhd <span class="bound">ys</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="free">X</span> <span class="main">(</span>ltl <span class="bound">xs</span><span class="main">)</span> <span class="main">(</span>ltl <span class="bound">ys</span><span class="main">)</span> <span class="main">∨</span> llist_all2 <span class="free">P</span> <span class="main">(</span>ltl <span class="bound">xs</span><span class="main">)</span> <span class="main">(</span>ltl <span class="bound">ys</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"llist_all2 <span class="free">P</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> llist_all2_all_lnthI<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> major <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"llength <span class="free">xs</span> <span class="main">=</span> llength <span class="free">ys</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_coinduct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> step llist_all2_llengthD <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> epred_llength<span class="main">)</span>

  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">n</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"enat <span class="skolem">n</span> <span class="main">&lt;</span> llength <span class="free">xs</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span>lnth <span class="free">xs</span> <span class="skolem">n</span><span class="main">)</span> <span class="main">(</span>lnth <span class="free">ys</span> <span class="skolem">n</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> major <span class="quoted"><span class="quoted">‹llength <span class="free">xs</span> <span class="main">=</span> llength <span class="free">ys</span>›</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"lnull <span class="skolem">xs</span>"</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> step <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> lnth_0_conv_lhd<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> step<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">X</span></span> <span class="skolem"><span class="skolem">xs</span></span> <span class="skolem"><span class="skolem">ys</span></span>›</span></span></span><span class="main">]</span> <span class="quoted"><span class="quoted">‹enat <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span> <span class="main">&lt;</span> llength <span class="skolem">xs</span>›</span></span> Suc <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lnull_conv Suc_ile_eq <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> Suc.hyps llist_all2_lnthD <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> llist_all2_llengthD<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-llist_all2_cases"><span class="command">lemma</span></span> llist_all2_cases<span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> LNil LCons<span class="main">,</span> <span class="operator">cases</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">pred</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"llist_all2 <span class="free">P</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="main">(</span>LNil<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> LNil"</span></span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">=</span> LNil"</span></span>
  <span class="main">|</span> <span class="main">(</span>LCons<span class="main">)</span> <span class="free">x</span> <span class="free">xs'</span> <span class="free">y</span> <span class="free">ys'</span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> LCons <span class="free">x</span> <span class="free">xs'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">=</span> LCons <span class="free">y</span> <span class="free">ys'</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">x</span> <span class="free">y</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"llist_all2 <span class="free">P</span> <span class="free">xs'</span> <span class="free">ys'</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_all2_LCons1<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llist_all2_mono"><span class="command">lemma</span></span> llist_all2_mono<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> llist_all2 <span class="free">P</span> <span class="free">xs</span> <span class="free">ys</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">⟹</span> <span class="free">P'</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">⟧</span> <span class="main">⟹</span> llist_all2 <span class="free">P'</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_all2_conv_all_lnth<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llist_all2_left"><span class="command">lemma</span></span> llist_all2_left<span class="main">:</span> <span class="quoted"><span class="quoted">"llist_all2 <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">⟷</span> llength <span class="free">xs</span> <span class="main">=</span> llength <span class="free">ys</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">∈</span>lset <span class="free">xs</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_all2_conv_all_lnth lset_conv_lnth<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llist_all2_right"><span class="command">lemma</span></span> llist_all2_right<span class="main">:</span> <span class="quoted"><span class="quoted">"llist_all2 <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">P</span><span class="main">)</span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">⟷</span> llength <span class="free">xs</span> <span class="main">=</span> llength <span class="free">ys</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">∈</span>lset <span class="free">ys</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_all2_conv_all_lnth lset_conv_lnth<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llist_all2_lsetD1"><span class="command">lemma</span></span> llist_all2_lsetD1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> llist_all2 <span class="free">P</span> <span class="free">xs</span> <span class="free">ys</span><span class="main">;</span> <span class="free">x</span> <span class="main">∈</span> lset <span class="free">xs</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">y</span><span class="main">∈</span>lset <span class="free">ys</span><span class="main">.</span> <span class="free">P</span> <span class="free">x</span> <span class="bound">y</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 4 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_all2_conv_lzip lset_lzip lset_conv_lnth split_beta lnth_lzip <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> split_paired_All<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llist_all2_lsetD2"><span class="command">lemma</span></span> llist_all2_lsetD2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> llist_all2 <span class="free">P</span> <span class="free">xs</span> <span class="free">ys</span><span class="main">;</span> <span class="free">y</span> <span class="main">∈</span> lset <span class="free">ys</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">x</span><span class="main">∈</span>lset <span class="free">xs</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 4 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_all2_conv_lzip lset_lzip lset_conv_lnth split_beta lnth_lzip <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> split_paired_All<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llist_all2_conj"><span class="command">lemma</span></span> llist_all2_conj<span class="main">:</span>
  <span class="quoted"><span class="quoted">"llist_all2 <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">∧</span> <span class="free">Q</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">⟷</span> llist_all2 <span class="free">P</span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">∧</span> llist_all2 <span class="free">Q</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_all2_conv_all_lnth<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llist_all2_lhdD"><span class="command">lemma</span></span> llist_all2_lhdD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> llist_all2 <span class="free">P</span> <span class="free">xs</span> <span class="free">ys</span><span class="main">;</span> <span class="main">¬</span> lnull <span class="free">xs</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span>lhd <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>lhd <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lnull_conv llist_all2_LCons1<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llist_all2_lhdD2"><span class="command">lemma</span></span> llist_all2_lhdD2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> llist_all2 <span class="free">P</span> <span class="free">xs</span> <span class="free">ys</span><span class="main">;</span> <span class="main">¬</span> lnull <span class="free">ys</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span>lhd <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>lhd <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lnull_conv llist_all2_LCons2<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llist_all2_ltlI"><span class="command">lemma</span></span> llist_all2_ltlI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"llist_all2 <span class="free">P</span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">⟹</span> llist_all2 <span class="free">P</span> <span class="main">(</span>ltl <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>ltl <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_all2_LCons1<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llist_all2_lappendI"><span class="command">lemma</span></span> llist_all2_lappendI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"llist_all2 <span class="free">P</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> lfinite <span class="free">xs</span><span class="main">;</span> lfinite <span class="free">ys</span> <span class="main">⟧</span> <span class="main">⟹</span> llist_all2 <span class="free">P</span> <span class="free">xs'</span> <span class="free">ys'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"llist_all2 <span class="free">P</span> <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">xs'</span><span class="main">)</span> <span class="main">(</span>lappend <span class="free">ys</span> <span class="free">ys'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">with</span></span> 1 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">ys</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> llist_all2_lfiniteD<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> 1 2<span class="main">[</span><span class="operator">OF</span> True this<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> llist_all2_lnullD llist_all2_lhdD <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> llist_all2_ltlI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lappend_eq_LNil_iff<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">with</span></span> 1 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lfinite <span class="free">ys</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> llist_all2_lfiniteD<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> False 1 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lappend_inf<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-llist_all2_lappend1D"><span class="command">lemma</span></span> llist_all2_lappend1D<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"llist_all2 <span class="free">P</span> <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">xs'</span><span class="main">)</span> <span class="free">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"llist_all2 <span class="free">P</span> <span class="free">xs</span> <span class="main">(</span>ltake <span class="main">(</span>llength <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span> <span class="main">⟹</span> llist_all2 <span class="free">P</span> <span class="free">xs'</span> <span class="main">(</span>ldrop <span class="main">(</span>llength <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> len<span class="main">:</span> <span class="quoted"><span class="quoted">"llength <span class="free">xs</span> <span class="main">+</span> llength <span class="free">xs'</span> <span class="main">=</span> llength <span class="free">ys</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> llist_all2_llengthD<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> len_xs<span class="main">:</span> <span class="quoted"><span class="quoted">"llength <span class="free">xs</span> <span class="main">≤</span> llength <span class="free">ys</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> len_xs'<span class="main">:</span> <span class="quoted"><span class="quoted">"llength <span class="free">xs'</span> <span class="main">≤</span> llength <span class="free">ys</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> enat_le_plus_same llength_lappend<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"llist_all2 <span class="free">P</span> <span class="free">xs</span> <span class="main">(</span>ltake <span class="main">(</span>llength <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> llist_all2_all_lnthI<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"llength <span class="free">xs</span> <span class="main">=</span> llength <span class="main">(</span>ltake <span class="main">(</span>llength <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> len_xs <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> min_def<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">n</span>
    <span class="keyword3"><span class="command">assume</span></span> n<span class="main">:</span> <span class="quoted"><span class="quoted">"enat <span class="skolem">n</span> <span class="main">&lt;</span> llength <span class="free">xs</span>"</span></span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> llength <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">xs'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> enat_le_plus_same<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span>lnth <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">xs'</span><span class="main">)</span> <span class="skolem">n</span><span class="main">)</span> <span class="main">(</span>lnth <span class="free">ys</span> <span class="skolem">n</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span><span class="main">(</span><span class="operator">rule</span> llist_all2_lnthD<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> n <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lnth <span class="free">ys</span> <span class="skolem">n</span> <span class="main">=</span> lnth <span class="main">(</span>ltake <span class="main">(</span>llength <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> lnth_ltake<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> n <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lnth <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">xs'</span><span class="main">)</span> <span class="skolem">n</span> <span class="main">=</span> lnth <span class="free">xs</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnth_lappend1<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span>lnth <span class="free">xs</span> <span class="skolem">n</span><span class="main">)</span> <span class="main">(</span>lnth <span class="main">(</span>ltake <span class="main">(</span>llength <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span> <span class="skolem">n</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"llist_all2 <span class="free">P</span> <span class="free">xs'</span> <span class="main">(</span>ldrop <span class="main">(</span>llength <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_all2_LCons1<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lmap_eq_lmap_conv_llist_all2"><span class="command">lemma</span></span> lmap_eq_lmap_conv_llist_all2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lmap <span class="free">f</span> <span class="free">xs</span> <span class="main">=</span> lmap <span class="free">g</span> <span class="free">ys</span> <span class="main">⟷</span> llist_all2 <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">g</span> <span class="bound">y</span><span class="main">)</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> neq_LNil_conv lnull_def LNil_eq_lmap lmap_eq_LNil<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> llist_all2_lnullD llist_all2_lhdD llist_all2_ltlI<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-llist_all2_expand"><span class="command">lemma</span></span> llist_all2_expand<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> lnull <span class="free">xs</span> <span class="main">⟷</span> lnull <span class="free">ys</span><span class="main">;</span>
     <span class="main">⟦</span> <span class="main">¬</span> lnull <span class="free">xs</span><span class="main">;</span> <span class="main">¬</span> lnull <span class="free">ys</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span>lhd <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>lhd <span class="free">ys</span><span class="main">)</span> <span class="main">∧</span> llist_all2 <span class="free">P</span> <span class="main">(</span>ltl <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>ltl <span class="free">ys</span><span class="main">)</span> <span class="main">⟧</span>
   <span class="main">⟹</span> llist_all2 <span class="free">P</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lnull_conv<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llist_all2_llength_ltakeWhileD"><span class="command">lemma</span></span> llist_all2_llength_ltakeWhileD<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> major<span class="main">:</span> <span class="quoted"><span class="quoted">"llist_all2 <span class="free">P</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> Q<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">⟹</span> <span class="free">Q1</span> <span class="bound">x</span> <span class="main">⟷</span> <span class="free">Q2</span> <span class="bound">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"llength <span class="main">(</span>ltakeWhile <span class="free">Q1</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> llength <span class="main">(</span>ltakeWhile <span class="free">Q2</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> major
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_coinduct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lnull_conv llist_all2_LCons1 llist_all2_LCons2 <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Q<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llist_all2_lzipI"><span class="command">lemma</span></span> llist_all2_lzipI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> llist_all2 <span class="free">P</span> <span class="free">xs</span> <span class="free">ys</span><span class="main">;</span> llist_all2 <span class="free">P'</span> <span class="free">xs'</span> <span class="free">ys'</span> <span class="main">⟧</span>
  <span class="main">⟹</span> llist_all2 <span class="main">(</span>rel_prod <span class="free">P</span> <span class="free">P'</span><span class="main">)</span> <span class="main">(</span>lzip <span class="free">xs</span> <span class="free">xs'</span><span class="main">)</span> <span class="main">(</span>lzip <span class="free">ys</span> <span class="free">ys'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">xs'</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quoted"><span class="free">ys'</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 6 6 <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> llist_all2_lhdD llist_all2_lnullD <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> llist_all2_ltlI<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llist_all2_ltakeI"><span class="command">lemma</span></span> llist_all2_ltakeI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"llist_all2 <span class="free">P</span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">⟹</span> llist_all2 <span class="free">P</span> <span class="main">(</span>ltake <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>ltake <span class="free">n</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_all2_conv_all_lnth lnth_ltake<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llist_all2_ldropnI"><span class="command">lemma</span></span> llist_all2_ldropnI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"llist_all2 <span class="free">P</span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">⟹</span> llist_all2 <span class="free">P</span> <span class="main">(</span>ldropn <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>ldropn <span class="free">n</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"llength <span class="free">ys</span>"</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_all2_conv_all_lnth<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llist_all2_ldropI"><span class="command">lemma</span></span> llist_all2_ldropI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"llist_all2 <span class="free">P</span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">⟹</span> llist_all2 <span class="free">P</span> <span class="main">(</span>ldrop <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>ldrop <span class="free">n</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"llength <span class="free">ys</span>"</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_all2_conv_all_lnth llength_ldrop<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llist_all2_lSupI"><span class="command">lemma</span></span> llist_all2_lSupI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Complete_Partial_Order.chain <span class="main">(</span>rel_prod <span class="main">(⊑)</span> <span class="main">(⊑)</span><span class="main">)</span> <span class="free">Y</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="bound">ys</span><span class="main">)</span><span class="main">∈</span><span class="free">Y</span><span class="main">.</span> llist_all2 <span class="free">P</span> <span class="bound">xs</span> <span class="bound">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"llist_all2 <span class="free">P</span> <span class="main">(</span>lSup <span class="main">(</span>fst <span class="main">`</span> <span class="free">Y</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>lSup <span class="main">(</span>snd <span class="main">`</span> <span class="free">Y</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">Y</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> LNil
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> llist_all2_lnullD <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>LCons <span class="skolem">Y</span><span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> chain <span class="main">=</span> <span class="quoted"><span class="quoted">‹Complete_Partial_Order.chain <span class="main">_</span> <span class="skolem">Y</span>›</span></span>
  <span class="keyword1"><span class="command">from</span></span> LCons <span class="keyword1"><span class="command">have</span></span> Y<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span> <span class="bound">ys</span><span class="main">.</span> <span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">Y</span> <span class="main">⟹</span> llist_all2 <span class="free">P</span> <span class="bound">xs</span> <span class="bound">ys</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">from</span></span> LCons <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xs</span></span> <span class="skolem"><span class="skolem">ys</span></span> <span class="keyword2"><span class="keyword">where</span></span> xsysY<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">xs</span><span class="main">,</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">Y</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lnull <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lnull <span class="skolem">ys</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> llist_all2_lnullD <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> xsysY <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lhd <span class="skolem">xs</span> <span class="main">∈</span> lhd <span class="main">`</span> <span class="main">(</span>fst <span class="main">`</span> <span class="skolem">Y</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_image_eqI<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">THE</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> lhd <span class="main">`</span> <span class="main">(</span>fst <span class="main">`</span> <span class="skolem">Y</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> lhd <span class="skolem">xs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> the_equality<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> lprefix_lhdD chainD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> chain xsysY<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> xsysY <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lhd <span class="skolem">ys</span> <span class="main">∈</span> lhd <span class="main">`</span> <span class="main">(</span>snd <span class="main">`</span> <span class="skolem">Y</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_image_eqI<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">THE</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> lhd <span class="main">`</span> <span class="main">(</span>snd <span class="main">`</span> <span class="skolem">Y</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> lhd <span class="skolem">ys</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> the_equality<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> lprefix_lhdD chainD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> chain xsysY<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> xsysY <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"llist_all2 <span class="free">P</span> <span class="skolem">xs</span> <span class="skolem">ys</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> Y<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span>lhd <span class="skolem">xs</span><span class="main">)</span> <span class="main">(</span>lhd <span class="skolem">ys</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> llist_all2_lhdD<span class="main">)</span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?lhd</span></span></span> <span class="keyword1"><span class="command">using</span></span> LCons <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?Y</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"map_prod ltl ltl <span class="main">`</span> <span class="main">(</span><span class="skolem">Y</span> <span class="main">∩</span> <span class="main">{</span><span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="bound">ys</span><span class="main">)</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span> <span class="main">∧</span> <span class="main">¬</span> lnull <span class="bound">ys</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Complete_Partial_Order.chain <span class="main">(</span>rel_prod <span class="main">(⊑)</span> <span class="main">(⊑)</span><span class="main">)</span> <span class="var">?Y</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> chainI<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Y chainD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> chain<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> lprefix_ltlI<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ltl <span class="main">`</span> <span class="main">(</span>fst <span class="main">`</span> <span class="skolem">Y</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> fst <span class="main">`</span> <span class="var">?Y</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"ltl <span class="main">`</span> <span class="main">(</span>snd <span class="main">`</span> <span class="skolem">Y</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> snd <span class="main">`</span> <span class="var">?Y</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> image_image <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Y llist_all2_lnullD <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_image_eqI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?ltl</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> llist_all2_ltlI <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Y<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-admissible_llist_all2"><span class="command">lemma</span></span> admissible_llist_all2 <span class="main">[</span><span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> f<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont <span class="free">lub</span> <span class="free">ord</span> lSup <span class="main">(⊑)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> g<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont <span class="free">lub</span> <span class="free">ord</span> lSup <span class="main">(⊑)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">g</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ccpo.admissible <span class="free">lub</span> <span class="free">ord</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> llist_all2 <span class="free">P</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">g</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ccpo.admissibleI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">Y</span>
  <span class="keyword3"><span class="command">assume</span></span> chain<span class="main">:</span> <span class="quoted"><span class="quoted">"Complete_Partial_Order.chain <span class="free">ord</span> <span class="skolem">Y</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> Y<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">∈</span><span class="skolem">Y</span><span class="main">.</span> llist_all2 <span class="free">P</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">g</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">Y</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> chain <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Complete_Partial_Order.chain <span class="main">(</span>rel_prod <span class="main">(⊑)</span> <span class="main">(⊑)</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">,</span> <span class="free">g</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">`</span> <span class="skolem">Y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> chain_imageI<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> mcont_monoD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> f<span class="main"><span class="main">]</span></span> mcont_monoD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> g<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> llist_all2_lSupI<span class="main">[</span><span class="operator">OF</span> this<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">P</span></span><span class="main">]</span> chain Y
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"llist_all2 <span class="free">P</span> <span class="main">(</span><span class="free">f</span> <span class="main">(</span><span class="free">lub</span> <span class="skolem">Y</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">g</span> <span class="main">(</span><span class="free">lub</span> <span class="skolem">Y</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">Y</span> <span class="main">≠</span> <span class="main">{}</span>›</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mcont_contD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> f chain<span class="main"><span class="main">]</span></span> mcont_contD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> g chain<span class="main"><span class="main">]</span></span> image_image<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">cont_intro</span><span class="main">]</span> <span class="main">=</span>
  ccpo.mcont2mcont<span class="main">[</span><span class="operator">OF</span> llist_ccpo _ mcont_fst<span class="main">]</span>
  ccpo.mcont2mcont<span class="main">[</span><span class="operator">OF</span> llist_ccpo _ mcont_snd<span class="main">]</span>

<span class="keyword1"><span class="command">lemmas</span></span> ldropWhile_fixp_parallel_induct <span class="main">=</span>
  parallel_fixp_induct_1_1<span class="main">[</span><span class="operator">OF</span> llist_partial_function_definitions llist_partial_function_definitions
    ldropWhile.mono ldropWhile.mono ldropWhile_def ldropWhile_def<span class="main">,</span> <span class="operator">case_names</span> adm LNil step<span class="main">]</span>

<span class="keyword1" id="Coinductive_List-llist_all2_ldropWhileI"><span class="command">lemma</span></span> llist_all2_ldropWhileI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"llist_all2 <span class="free">P</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> Q<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">⟹</span> <span class="free">Q1</span> <span class="bound">x</span> <span class="main">⟷</span> <span class="free">Q2</span> <span class="bound">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"llist_all2 <span class="free">P</span> <span class="main">(</span>ldropWhile <span class="free">Q1</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>ldropWhile <span class="free">Q2</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="comment1">― ‹cannot prove this with parallel induction over <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted"><span class="free">xs</span></span><span class="antiquote">}</span></span> and <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted"><span class="free">ys</span></span><span class="antiquote">}</span></span>
  because <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">¬</span> llist_all2 <span class="free">P</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">g</span> <span class="bound">x</span><span class="main">)</span>"</span><span class="antiquote">}</span></span> is not admissible.›</span>
<span class="keyword1"><span class="command">using</span></span> * <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> ldropWhile_fixp_parallel_induct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Q<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llist_all2_same"><span class="command">lemma</span></span> llist_all2_same <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"llist_all2 <span class="free">P</span> <span class="free">xs</span> <span class="free">xs</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">∈</span>lset <span class="free">xs</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_all2_conv_all_lnth in_lset_conv_lnth Ball_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llist_all2_trans"><span class="command">lemma</span></span> llist_all2_trans<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> llist_all2 <span class="free">P</span> <span class="free">xs</span> <span class="free">ys</span><span class="main">;</span> llist_all2 <span class="free">P</span> <span class="free">ys</span> <span class="free">zs</span><span class="main">;</span> transp <span class="free">P</span> <span class="main">⟧</span>
  <span class="main">⟹</span> llist_all2 <span class="free">P</span> <span class="free">xs</span> <span class="free">zs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> llist_all2_all_lnthI<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_all2_llengthD<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">frule</span> llist_all2_llengthD<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> llist_all2_lnthD<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule</span> llist_all2_lnthD<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> transpD<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The last element <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"llast"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1" id="Coinductive_List-llast_LNil"><span class="command">lemma</span></span> llast_LNil<span class="main">:</span> <span class="quoted"><span class="quoted">"llast LNil <span class="main">=</span> undefined"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llast_def zero_enat_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llast_LCons"><span class="command">lemma</span></span> llast_LCons<span class="main">:</span> <span class="quoted"><span class="quoted">"llast <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> lnull <span class="free">xs</span> <span class="keyword1">then</span> <span class="free">x</span> <span class="keyword1">else</span> llast <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"llength <span class="free">xs</span>"</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llast_def eSuc_def zero_enat_def not_lnull_conv <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> enat.splits<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llast_linfinite"><span class="command">lemma</span></span> llast_linfinite<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lfinite <span class="free">xs</span> <span class="main">⟹</span> llast <span class="free">xs</span> <span class="main">=</span> undefined"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llast_def lfinite_conv_llength_enat<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> llast_singleton<span class="main">:</span> <span class="quoted"><span class="quoted">"llast <span class="main">(</span>LCons <span class="free">x</span> LNil<span class="main">)</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> llast_LCons2<span class="main">:</span> <span class="quoted"><span class="quoted">"llast <span class="main">(</span>LCons <span class="free">x</span> <span class="main">(</span>LCons <span class="free">y</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> llast <span class="main">(</span>LCons <span class="free">y</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llast_LCons<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llast_lappend"><span class="command">lemma</span></span> llast_lappend<span class="main">:</span>
  <span class="quoted"><span class="quoted">"llast <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> lnull <span class="free">ys</span> <span class="keyword1">then</span> llast <span class="free">xs</span> <span class="keyword1">else</span> <span class="keyword1">if</span> lfinite <span class="free">xs</span> <span class="keyword1">then</span> llast <span class="free">ys</span> <span class="keyword1">else</span> undefined<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lnull <span class="free">ys</span> <span class="main">⟹</span> llast <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> llast <span class="free">ys</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lfinite.induct<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llast_LCons<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> True <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lappend_lnull2<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llast_linfinite<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-llast_lappend_LCons"><span class="command">lemma</span></span> llast_lappend_LCons <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span> <span class="main">⟹</span> llast <span class="main">(</span>lappend <span class="free">xs</span> <span class="main">(</span>LCons <span class="free">y</span> <span class="free">ys</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> llast <span class="main">(</span>LCons <span class="free">y</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llast_lappend<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llast_ldropn"><span class="command">lemma</span></span> llast_ldropn<span class="main">:</span> <span class="quoted"><span class="quoted">"enat <span class="free">n</span> <span class="main">&lt;</span> llength <span class="free">xs</span> <span class="main">⟹</span> llast <span class="main">(</span>ldropn <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> llast <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Suc_ile_eq llast_LCons<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-llast_ldrop"><span class="command">lemma</span></span> llast_ldrop<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">&lt;</span> llength <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"llast <span class="main">(</span>ldrop <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> llast <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">n'</span></span> <span class="keyword2"><span class="keyword">where</span></span> n<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">=</span> enat <span class="skolem">n'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> n
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">n'</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> Suc <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eSuc_enat<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> llast_LCons<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-llast_llist_of"><span class="command">lemma</span></span> llast_llist_of <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"llast <span class="main">(</span>llist_of <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> last <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> last_def zero_enat_def llast_LCons llast_LNil<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llast_conv_lnth"><span class="command">lemma</span></span> llast_conv_lnth<span class="main">:</span> <span class="quoted"><span class="quoted">"llength <span class="free">xs</span> <span class="main">=</span> eSuc <span class="main">(</span>enat <span class="free">n</span><span class="main">)</span> <span class="main">⟹</span> llast <span class="free">xs</span> <span class="main">=</span> lnth <span class="free">xs</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llast_def zero_enat_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> eSuc_enat <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> nat.split<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llast_lmap"><span class="command">lemma</span></span> llast_lmap<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lnull <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"llast <span class="main">(</span>lmap <span class="free">f</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span>llast <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">induct</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>lfinite_LConsI <span class="skolem">xs</span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Distinct lazy lists <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"ldistinct"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">inductive_simps</span></span> ldistinct_LCons <span class="main">[</span><span class="operator">code</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"ldistinct <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Coinductive_List-ldistinct_LNil_code"><span class="command">lemma</span></span> ldistinct_LNil_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"ldistinct LNil <span class="main">=</span> True"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-ldistinct_llist_of"><span class="command">lemma</span></span> ldistinct_llist_of <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"ldistinct <span class="main">(</span>llist_of <span class="free">xs</span><span class="main">)</span> <span class="main">⟷</span> distinct <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_List-ldistinct_coinduct"><span class="command">lemma</span></span> ldistinct_coinduct <span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> ldistinct<span class="main">,</span> <span class="operator">case_conclusion</span> ldistinct lhd ltl<span class="main">,</span> <span class="operator">coinduct</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">pred</span></span></span><span class="main"><span class="main"><span class="main"><span class="main">:</span></span></span></span> ldistinct<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> step<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span><span class="main">.</span> <span class="main">⟦</span> <span class="free">X</span> <span class="bound">xs</span><span class="main">;</span> <span class="main">¬</span> lnull <span class="bound">xs</span> <span class="main">⟧</span>
    <span class="main">⟹</span> lhd <span class="bound">xs</span> <span class="main">∉</span> lset <span class="main">(</span>ltl <span class="bound">xs</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="free">X</span> <span class="main">(</span>ltl <span class="bound">xs</span><span class="main">)</span> <span class="main">∨</span> ldistinct <span class="main">(</span>ltl <span class="bound">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ldistinct <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">X</span> <span class="free">xs</span>›</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduct</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>ldistinct <span class="skolem">xs</span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> step<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-ldistinct_lhdD"><span class="command">lemma</span></span> ldistinct_lhdD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> ldistinct <span class="free">xs</span><span class="main">;</span> <span class="main">¬</span> lnull <span class="free">xs</span> <span class="main">⟧</span> <span class="main">⟹</span> lhd <span class="free">xs</span> <span class="main">∉</span> lset <span class="main">(</span>ltl <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lnull_conv<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ldistinct_ltlI"><span class="command">lemma</span></span> ldistinct_ltlI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ldistinct <span class="free">xs</span> <span class="main">⟹</span> ldistinct <span class="main">(</span>ltl <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-ldistinct_lSup"><span class="command">lemma</span></span> ldistinct_lSup<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> Complete_Partial_Order.chain <span class="main">(⊑)</span> <span class="free">Y</span><span class="main">;</span> <span class="main">∀</span><span class="bound">xs</span><span class="main">∈</span><span class="free">Y</span><span class="main">.</span> ldistinct <span class="bound">xs</span> <span class="main">⟧</span>
  <span class="main">⟹</span> ldistinct <span class="main">(</span>lSup <span class="free">Y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">Y</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>ldistinct <span class="skolem">Y</span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> chain<span class="main">:</span> <span class="quoted"><span class="quoted">"Complete_Partial_Order.chain <span class="main">(⊑)</span> <span class="skolem">Y</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> distinct<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span><span class="main">.</span> <span class="bound">xs</span> <span class="main">∈</span> <span class="skolem">Y</span> <span class="main">⟹</span> ldistinct <span class="bound">xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?lhd</span></span></span> <span class="keyword1"><span class="command">using</span></span> chain <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 4 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lset_lSup chain_lprefix_ltl <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> distinct lhd_lSup_eq ldistinct_lhdD<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?ltl</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> chain_lprefix_ltl chain <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> ldistinct_ltlI distinct<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-admissible_ldistinct"><span class="command">lemma</span></span> admissible_ldistinct <span class="main">[</span><span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> mcont<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont <span class="free">lub</span> <span class="free">ord</span> lSup <span class="main">(⊑)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ccpo.admissible <span class="free">lub</span> <span class="free">ord</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> ldistinct <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ccpo.admissibleI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">Y</span>
  <span class="keyword3"><span class="command">assume</span></span> chain<span class="main">:</span> <span class="quoted"><span class="quoted">"Complete_Partial_Order.chain <span class="free">ord</span> <span class="skolem">Y</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> distinct<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">∈</span><span class="skolem">Y</span><span class="main">.</span> ldistinct <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">Y</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"ldistinct <span class="main">(</span><span class="free">f</span> <span class="main">(</span><span class="free">lub</span> <span class="skolem">Y</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mcont_contD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mcont<span class="main"><span class="main">]</span></span> ldistinct_lSup chain_imageI mcont_monoD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mcont<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-ldistinct_lappend"><span class="command">lemma</span></span> ldistinct_lappend<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ldistinct <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟷</span> ldistinct <span class="free">xs</span> <span class="main">∧</span> <span class="main">(</span>lfinite <span class="free">xs</span> <span class="main">⟶</span> ldistinct <span class="free">ys</span> <span class="main">∧</span> lset <span class="free">xs</span> <span class="main">∩</span> lset <span class="free">ys</span> <span class="main">=</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">intro</span> iffI conjI strip<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"ldistinct <span class="free">xs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduct</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lnull_conv in_lset_lappend_iff<span class="main">)</span>

  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"ldistinct <span class="free">ys</span>"</span></span> <span class="quoted"><span class="quoted">"lset <span class="free">xs</span> <span class="main">∩</span> lset <span class="free">ys</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?lhs</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rhs</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lnull_conv in_lset_lappend_iff<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-ldistinct_lprefix"><span class="command">lemma</span></span> ldistinct_lprefix<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> ldistinct <span class="free">xs</span><span class="main">;</span> <span class="free">ys</span> <span class="main">⊑</span> <span class="free">xs</span> <span class="main">⟧</span> <span class="main">⟹</span> ldistinct <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lprefix_conv_lappend ldistinct_lappend<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-admissible_not_ldistinct"><span class="command">lemma</span></span> admissible_not_ldistinct<span class="main">[</span><span class="operator">THEN</span> admissible_subst<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"ccpo.admissible lSup <span class="main">(⊑)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">¬</span> ldistinct <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> ccpo.admissibleI<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> ldistinct_lprefix <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> chain_lprefix_lSup<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ldistinct_ltake"><span class="command">lemma</span></span> ldistinct_ltake<span class="main">:</span> <span class="quoted"><span class="quoted">"ldistinct <span class="free">xs</span> <span class="main">⟹</span> ldistinct <span class="main">(</span>ltake <span class="free">n</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> ldistinct_lprefix ltake_is_lprefix<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ldistinct_ldropn"><span class="command">lemma</span></span> ldistinct_ldropn<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ldistinct <span class="free">xs</span> <span class="main">⟹</span> ldistinct <span class="main">(</span>ldropn <span class="free">n</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="improper">xs</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ldistinct_ldrop"><span class="command">lemma</span></span> ldistinct_ldrop<span class="main">:</span> <span class="quoted"><span class="quoted">"ldistinct <span class="free">xs</span> <span class="main">⟹</span> ldistinct <span class="main">(</span>ldrop <span class="free">n</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>LCons <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> co.enat.exhaust<span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-ldistinct_conv_lnth"><span class="command">lemma</span></span> ldistinct_conv_lnth<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ldistinct <span class="free">xs</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">i</span> <span class="bound">j</span><span class="main">.</span> enat <span class="bound">i</span> <span class="main">&lt;</span> llength <span class="free">xs</span> <span class="main">⟶</span> enat <span class="bound">j</span> <span class="main">&lt;</span> llength <span class="free">xs</span> <span class="main">⟶</span> <span class="bound">i</span> <span class="main">≠</span> <span class="bound">j</span> <span class="main">⟶</span> lnth <span class="free">xs</span> <span class="bound">i</span> <span class="main">≠</span> lnth <span class="free">xs</span> <span class="bound">j</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">intro</span> iffI strip<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rhs</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>ldistinct <span class="skolem">xs</span><span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> lnull <span class="skolem">xs</span>›</span></span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="skolem"><span class="skolem">xs'</span></span> <span class="keyword2"><span class="keyword">where</span></span> LCons<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> LCons <span class="skolem">x</span> <span class="skolem">xs'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lnull_conv<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∉</span> lset <span class="skolem">xs'</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> lset <span class="skolem">xs'</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">j</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"enat <span class="skolem">j</span> <span class="main">&lt;</span> llength <span class="skolem">xs'</span>"</span></span> <span class="quoted"><span class="quoted">"lnth <span class="skolem">xs'</span> <span class="skolem">j</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> lset_conv_lnth <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"enat <span class="main">0</span> <span class="main">&lt;</span> llength <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="quoted">"enat <span class="main">(</span>Suc <span class="skolem">j</span><span class="main">)</span> <span class="main">&lt;</span> llength <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="quoted">"lnth <span class="skolem">xs</span> <span class="main">(</span>Suc <span class="skolem">j</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="quoted"><span class="quoted">"lnth <span class="skolem">xs</span> <span class="main">0</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> LCons Suc_ile_eq zero_enat_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> ldistinct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">rule_format</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span> <span class="skolem">j</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"enat <span class="skolem">i</span> <span class="main">&lt;</span> llength <span class="skolem">xs'</span>"</span></span> <span class="quoted"><span class="quoted">"enat <span class="skolem">j</span> <span class="main">&lt;</span> llength <span class="skolem">xs'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">≠</span> <span class="skolem">j</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"enat <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span> <span class="main">&lt;</span> llength <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="quoted">"enat <span class="main">(</span>Suc <span class="skolem">j</span><span class="main">)</span> <span class="main">&lt;</span> llength <span class="skolem">xs</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> LCons Suc_ile_eq<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">i</span> <span class="main">≠</span> <span class="skolem">j</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lnth <span class="skolem">xs</span> <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span> <span class="main">≠</span> lnth <span class="skolem">xs</span> <span class="main">(</span>Suc <span class="skolem">j</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> ldistinct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">rule_format</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lnth <span class="skolem">xs'</span> <span class="skolem">i</span> <span class="main">≠</span> lnth <span class="skolem">xs'</span> <span class="skolem">j</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> LCons <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> LCons <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span>"</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span> <span class="skolem">j</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"enat <span class="skolem">i</span> <span class="main">&lt;</span> llength <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"enat <span class="skolem">j</span> <span class="main">&lt;</span> llength <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">≠</span> <span class="skolem">j</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"lnth <span class="free">xs</span> <span class="skolem">i</span> <span class="main">≠</span> lnth <span class="free">xs</span> <span class="skolem">j</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">i</span></span> <span class="quoted"><span class="skolem">j</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> wlog_linorder_le<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> symmetry <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>le <span class="skolem">i</span> <span class="skolem">j</span><span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?lhs</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ldistinct <span class="main">(</span>ldropn <span class="skolem">i</span> <span class="free">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> ldistinct_ldropn<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> ldropn_Suc_conv_ldropn<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> le <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> <span class="skolem">j</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lnth <span class="free">xs</span> <span class="skolem">j</span> <span class="main">∈</span> lset <span class="main">(</span>ldropn <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> le <span class="keyword1"><span class="command">unfolding</span></span> in_lset_conv_lnth
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"llength <span class="free">xs</span>"</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">-</span> Suc <span class="skolem">i</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹enat <span class="skolem">i</span> <span class="main">&lt;</span> llength <span class="free">xs</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-ldistinct_lmap"><span class="command">lemma</span></span> ldistinct_lmap <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"ldistinct <span class="main">(</span>lmap <span class="free">f</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟷</span> ldistinct <span class="free">xs</span> <span class="main">∧</span> inj_on <span class="free">f</span> <span class="main">(</span>lset <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">intro</span> iffI conjI<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> dist<span class="main">:</span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"ldistinct <span class="free">xs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduct</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lnull_conv<span class="main">)</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"inj_on <span class="free">f</span> <span class="main">(</span>lset <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> inj_onI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> lset <span class="free">xs</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> lset <span class="free">xs</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="skolem">x</span> <span class="main">=</span> <span class="free">f</span> <span class="skolem">y</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">i</span></span> <span class="skolem"><span class="skolem">j</span></span>
      <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"enat <span class="skolem">i</span> <span class="main">&lt;</span> llength <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> lnth <span class="free">xs</span> <span class="skolem">i</span>"</span></span> <span class="quoted"><span class="quoted">"enat <span class="skolem">j</span> <span class="main">&lt;</span> llength <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">=</span> lnth <span class="free">xs</span> <span class="skolem">j</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> lset_conv_lnth <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">with</span></span> dist <span class="quoted"><span class="quoted">‹<span class="free">f</span> <span class="skolem">x</span> <span class="main">=</span> <span class="free">f</span> <span class="skolem">y</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> ldistinct_conv_lnth <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lnull_conv<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-ldistinct_lzipI1"><span class="command">lemma</span></span> ldistinct_lzipI1<span class="main">:</span> <span class="quoted"><span class="quoted">"ldistinct <span class="free">xs</span> <span class="main">⟹</span> ldistinct <span class="main">(</span>lzip <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lnull_conv <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lset_lzipD1<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ldistinct_lzipI2"><span class="command">lemma</span></span> ldistinct_lzipI2<span class="main">:</span> <span class="quoted"><span class="quoted">"ldistinct <span class="free">ys</span> <span class="main">⟹</span> ldistinct <span class="main">(</span>lzip <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lnull_conv <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lset_lzipD2<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Sortedness <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">lsorted</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">context</span></span> ord <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">coinductive</span></span> <span class="entity">lsorted</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  LNil <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">lsorted</span> LNil"</span></span>
<span class="main">|</span> Singleton <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">lsorted</span> <span class="main">(</span>LCons <span class="free"><span class="bound"><span class="entity">x</span></span></span> LNil<span class="main">)</span>"</span></span>
<span class="main">|</span> LCons_LCons<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">;</span> <span class="free">lsorted</span> <span class="main">(</span>LCons <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">lsorted</span> <span class="main">(</span>LCons <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>LCons <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">inductive_simps</span></span> lsorted_LCons_LCons <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lsorted <span class="main">(</span>LCons <span class="free">x</span> <span class="main">(</span>LCons <span class="free">y</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">inductive_simps</span></span> lsorted_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lsorted LNil"</span></span>
  <span class="quoted"><span class="quoted">"lsorted <span class="main">(</span>LCons <span class="free">x</span> LNil<span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"lsorted <span class="main">(</span>LCons <span class="free">x</span> <span class="main">(</span>LCons <span class="free">y</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Coinductive_List-lsorted_coinduct'"><span class="command">lemma</span></span> lsorted_coinduct' <span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> lsorted<span class="main">,</span> <span class="operator">case_conclusion</span> lsorted lhd ltl<span class="main">,</span> <span class="operator">coinduct</span> <span class="quasi_keyword"><span class="quasi_keyword">pred</span></span><span class="main"><span class="main"><span class="main">:</span></span></span> lsorted<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> major<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> step<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span><span class="main">.</span> <span class="main">⟦</span> <span class="free">X</span> <span class="bound">xs</span><span class="main">;</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">;</span> <span class="main">¬</span> lnull <span class="main">(</span>ltl <span class="bound">xs</span><span class="main">)</span> <span class="main">⟧</span> <span class="main">⟹</span> lhd <span class="bound">xs</span> <span class="main">≤</span> lhd <span class="main">(</span>ltl <span class="bound">xs</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="free">X</span> <span class="main">(</span>ltl <span class="bound">xs</span><span class="main">)</span> <span class="main">∨</span> lsorted <span class="main">(</span>ltl <span class="bound">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lsorted <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> major <span class="keyword1"><span class="command">by</span></span> <span class="operator">coinduct</span><span class="main">(</span><span class="operator">subst</span> disj_commute<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> 4 4 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> neq_LNil_conv <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> step<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lsorted_ltlI"><span class="command">lemma</span></span> lsorted_ltlI<span class="main">:</span> <span class="quoted"><span class="quoted">"lsorted <span class="free">xs</span> <span class="main">⟹</span> lsorted <span class="main">(</span>ltl <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">erule</span> lsorted.cases<span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-lsorted_lhdD"><span class="command">lemma</span></span> lsorted_lhdD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> lsorted <span class="free">xs</span><span class="main">;</span> <span class="main">¬</span> lnull <span class="free">xs</span><span class="main">;</span> <span class="main">¬</span> lnull <span class="main">(</span>ltl <span class="free">xs</span><span class="main">)</span> <span class="main">⟧</span> <span class="main">⟹</span> lhd <span class="free">xs</span> <span class="main">≤</span> lhd <span class="main">(</span>ltl <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> lsorted.cases<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lsorted_LCons'"><span class="command">lemma</span></span> lsorted_LCons'<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lsorted <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">¬</span> lnull <span class="free">xs</span> <span class="main">⟶</span> <span class="free">x</span> <span class="main">≤</span> lhd <span class="free">xs</span> <span class="main">∧</span> lsorted <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_List-lsorted_lSup"><span class="command">lemma</span></span> lsorted_lSup<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> Complete_Partial_Order.chain <span class="main">(⊑)</span> <span class="free">Y</span><span class="main">;</span> <span class="main">∀</span><span class="bound">xs</span> <span class="main">∈</span> <span class="free">Y</span><span class="main">.</span> lsorted <span class="bound">xs</span> <span class="main">⟧</span>
  <span class="main">⟹</span> lsorted <span class="main">(</span>lSup <span class="free">Y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">Y</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>lsorted <span class="skolem">Y</span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> sorted<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span><span class="main">.</span> <span class="bound">xs</span> <span class="main">∈</span> <span class="skolem">Y</span> <span class="main">⟹</span> lsorted <span class="bound">xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">note</span></span> chain <span class="main">=</span> <span class="quoted"><span class="quoted">‹Complete_Partial_Order.chain <span class="main">(⊑)</span> <span class="skolem">Y</span>›</span></span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> lnull <span class="main">(</span>lSup <span class="skolem">Y</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> lnull <span class="main">(</span>ltl <span class="main">(</span>lSup <span class="skolem">Y</span><span class="main">)</span><span class="main">)</span>›</span></span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xs</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">∈</span> <span class="skolem">Y</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lnull <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lnull <span class="main">(</span>ltl <span class="skolem">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lhd <span class="main">(</span>lSup <span class="skolem">Y</span><span class="main">)</span> <span class="main">=</span> lhd <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="quoted">"lhd <span class="main">(</span>ltl <span class="main">(</span>lSup <span class="skolem">Y</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> lhd <span class="main">(</span>ltl <span class="skolem">xs</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"lhd <span class="skolem">xs</span> <span class="main">≤</span> lhd <span class="main">(</span>ltl <span class="skolem">xs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> chain sorted <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> lhd_lSup_eq chain_lprefix_ltl lsorted_lhdD<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="var"><span class="quoted"><span class="var">?lhd</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?ltl</span></span></span> <span class="keyword1"><span class="command">using</span></span> chain sorted <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> chain_lprefix_ltl lsorted_ltlI<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lsorted_lprefixD"><span class="command">lemma</span></span> lsorted_lprefixD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">xs</span> <span class="main">⊑</span> <span class="free">ys</span><span class="main">;</span> lsorted <span class="free">ys</span> <span class="main">⟧</span> <span class="main">⟹</span> lsorted <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>lsorted <span class="skolem">xs</span> <span class="skolem">ys</span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lhd <span class="skolem">xs</span> <span class="main">=</span> lhd <span class="skolem">ys</span>"</span></span> <span class="quoted"><span class="quoted">"lhd <span class="main">(</span>ltl <span class="skolem">xs</span><span class="main">)</span> <span class="main">=</span> lhd <span class="main">(</span>ltl <span class="skolem">ys</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lprefix_lhdD lprefix_ltlI<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lhd <span class="skolem">ys</span> <span class="main">≤</span> lhd <span class="main">(</span>ltl <span class="skolem">ys</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> lsorted
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> lsorted_lhdD <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lprefix_lnullD lprefix_ltlI<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?lhd</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?ltl</span></span></span> <span class="keyword1"><span class="command">using</span></span> lsorted <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> lsorted_ltlI lprefix_ltlI<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-admissible_lsorted"><span class="command">lemma</span></span> admissible_lsorted <span class="main">[</span><span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> mcont<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont <span class="free">lub</span> <span class="free">ord</span> lSup <span class="main">(⊑)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> ccpo<span class="main">:</span> <span class="quoted"><span class="quoted">"class.ccpo <span class="free">lub</span> <span class="free">ord</span> <span class="main">(</span>mk_less <span class="free">ord</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ccpo.admissible <span class="free">lub</span> <span class="free">ord</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> lsorted <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ccpo.admissibleI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">Y</span>
  <span class="keyword3"><span class="command">assume</span></span> chain<span class="main">:</span> <span class="quoted"><span class="quoted">"Complete_Partial_Order.chain <span class="free">ord</span> <span class="skolem">Y</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> sorted<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">∈</span><span class="skolem">Y</span><span class="main">.</span> lsorted <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">Y</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"lsorted <span class="main">(</span><span class="free">f</span> <span class="main">(</span><span class="free">lub</span> <span class="skolem">Y</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mcont_contD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mcont<span class="main"><span class="main">]</span></span> lsorted_lSup chain_imageI mcont_monoD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mcont<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-admissible_not_lsorted"><span class="command">lemma</span></span> admissible_not_lsorted<span class="main">[</span><span class="operator">THEN</span> admissible_subst<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"ccpo.admissible lSup <span class="main">(⊑)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lsorted <span class="bound">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> ccpo.admissibleI<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lsorted_lprefixD<span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> chain_lprefix_lSup<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lsorted_ltake"><span class="command">lemma</span></span> lsorted_ltake <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lsorted <span class="free">xs</span> <span class="main">⟹</span> lsorted <span class="main">(</span>ltake <span class="free">n</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> lsorted_lprefixD<span class="main">)</span><span class="main">(</span><span class="operator">rule</span> ltake_is_lprefix<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lsorted_ldropn"><span class="command">lemma</span></span> lsorted_ldropn <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lsorted <span class="free">xs</span> <span class="main">⟹</span> lsorted <span class="main">(</span>ldropn <span class="free">n</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldropn_Suc lsorted_LCons' ldropn_lnull <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Coinductive_List-lsorted_ldrop"><span class="command">lemma</span></span> lsorted_ldrop <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lsorted <span class="free">xs</span> <span class="main">⟹</span> lsorted <span class="main">(</span>ldrop <span class="free">n</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldrop_LCons lsorted_LCons' ldrop_lnull <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> co.enat.split<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">declare</span></span>
  ord.lsorted_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span>
  ord.admissible_lsorted <span class="main">[</span><span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span>
  ord.admissible_not_lsorted <span class="main">[</span><span class="operator">THEN</span> admissible_subst<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span>

<span class="keyword1"><span class="command">context</span></span> preorder <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Coinductive_List-lsorted_LCons"><span class="command">lemma</span></span> lsorted_LCons<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lsorted <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟷</span> lsorted <span class="free">xs</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">y</span><span class="main">∈</span>lset <span class="free">xs</span><span class="main">.</span> <span class="free">x</span> <span class="main">≤</span> <span class="bound">y</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">y</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> lset <span class="free">xs</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≤</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?lhs</span>›</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> order_trans<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?lhs</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">cases</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lsorted_coinduct"><span class="command">lemma</span></span> lsorted_coinduct <span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> lsorted<span class="main">,</span> <span class="operator">case_conclusion</span> lsorted lhd ltl<span class="main">,</span> <span class="operator">coinduct</span> <span class="quasi_keyword"><span class="quasi_keyword">pred</span></span><span class="main"><span class="main"><span class="main">:</span></span></span> lsorted<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> major<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> step<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span><span class="main">.</span> <span class="main">⟦</span> <span class="free">X</span> <span class="bound">xs</span><span class="main">;</span> <span class="main">¬</span> lnull <span class="bound">xs</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> lset <span class="main">(</span>ltl <span class="bound">xs</span><span class="main">)</span><span class="main">.</span> lhd <span class="bound">xs</span> <span class="main">≤</span> <span class="bound">x</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="free">X</span> <span class="main">(</span>ltl <span class="bound">xs</span><span class="main">)</span> <span class="main">∨</span> lsorted <span class="main">(</span>ltl <span class="bound">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lsorted <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> major <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lsorted_coinduct'<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> step<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lsortedD"><span class="command">lemma</span></span> lsortedD<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> lsorted <span class="free">xs</span><span class="main">;</span> <span class="main">¬</span> lnull <span class="free">xs</span><span class="main">;</span> <span class="free">y</span> <span class="main">∈</span> lset <span class="main">(</span>ltl <span class="free">xs</span><span class="main">)</span> <span class="main">⟧</span> <span class="main">⟹</span> lhd <span class="free">xs</span> <span class="main">≤</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lnull_conv lsorted_LCons<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Coinductive_List-lsorted_lmap'"><span class="command">lemma</span></span> lsorted_lmap'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ord.lsorted <span class="free">orda</span> <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"monotone <span class="free">orda</span> <span class="free">ordb</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ord.lsorted <span class="free">ordb</span> <span class="main">(</span>lmap <span class="free">f</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹ord.lsorted <span class="free">orda</span> <span class="free">xs</span>›</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> ord.lsorted_coinduct'<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> monotoneD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹monotone <span class="free">orda</span> <span class="free">ordb</span> <span class="free">f</span>›</span></span><span class="main"><span class="main">]</span></span> ord.lsorted_lhdD ord.lsorted_ltlI<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lsorted_lmap"><span class="command">lemma</span></span> lsorted_lmap<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"lsorted <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"monotone <span class="main">(≤)</span> <span class="main">(≤)</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lsorted <span class="main">(</span>lmap <span class="free">f</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹lsorted <span class="free">xs</span>›</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lsorted_coinduct'<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> monotoneD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹monotone <span class="main">(≤)</span> <span class="main">(≤)</span> <span class="free">f</span>›</span></span><span class="main"><span class="main">]</span></span> lsorted_lhdD lsorted_ltlI<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> linorder <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Coinductive_List-lsorted_ldistinct_lset_unique"><span class="command">lemma</span></span> lsorted_ldistinct_lset_unique<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> lsorted <span class="free">xs</span><span class="main">;</span> ldistinct <span class="free">xs</span><span class="main">;</span> lsorted <span class="free">ys</span><span class="main">;</span> ldistinct <span class="free">ys</span><span class="main">;</span> lset <span class="free">xs</span> <span class="main">=</span> lset <span class="free">ys</span> <span class="main">⟧</span>
  <span class="main">⟹</span> <span class="free">xs</span> <span class="main">=</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Eq_llist <span class="skolem">xs</span> <span class="skolem">ys</span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="var"><span class="quoted"><span class="var">?lnull</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lset_lnull<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> Eq_llist <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?LCons</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> lsorted_ltlI ldistinct_ltlI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lnull_conv insert_eq_iff lsorted_LCons <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Coinductive_List-lsorted_llist_of"><span class="command">lemma</span></span> lsorted_llist_of<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lsorted <span class="main">(</span>llist_of <span class="free">xs</span><span class="main">)</span> <span class="main">⟷</span> sorted <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> lsorted_LCons<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Lexicographic order on lazy lists: <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"llexord"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1" id="Coinductive_List-llexord_coinduct"><span class="command">lemma</span></span> llexord_coinduct <span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> llexord<span class="main">,</span> <span class="operator">coinduct</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">pred</span></span></span><span class="main"><span class="main"><span class="main"><span class="main">:</span></span></span></span> llexord<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> X<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> step<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span> <span class="bound">ys</span><span class="main">.</span> <span class="main">⟦</span> <span class="free">X</span> <span class="bound">xs</span> <span class="bound">ys</span><span class="main">;</span> <span class="main">¬</span> lnull <span class="bound">xs</span> <span class="main">⟧</span>
    <span class="main">⟹</span> <span class="main">¬</span> lnull <span class="bound">ys</span> <span class="main">∧</span>
       <span class="main">(</span><span class="main">¬</span> lnull <span class="bound">ys</span> <span class="main">⟶</span> <span class="free">r</span> <span class="main">(</span>lhd <span class="bound">xs</span><span class="main">)</span> <span class="main">(</span>lhd <span class="bound">ys</span><span class="main">)</span> <span class="main">∨</span>
                     lhd <span class="bound">xs</span> <span class="main">=</span> lhd <span class="bound">ys</span> <span class="main">∧</span> <span class="main">(</span><span class="free">X</span> <span class="main">(</span>ltl <span class="bound">xs</span><span class="main">)</span> <span class="main">(</span>ltl <span class="bound">ys</span><span class="main">)</span> <span class="main">∨</span> llexord <span class="free">r</span> <span class="main">(</span>ltl <span class="bound">xs</span><span class="main">)</span> <span class="main">(</span>ltl <span class="bound">ys</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"llexord <span class="free">r</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> X
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduct</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>llexord <span class="skolem">xs</span> <span class="skolem">ys</span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quoted"><span class="skolem">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> llist.exhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> llist.exhaust<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> step<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-llexord_refl"><span class="command">lemma</span></span> llexord_refl <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"llexord <span class="free">r</span> <span class="free">xs</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">ys</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ys</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="skolem">ys</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"llexord <span class="free">r</span> <span class="free">xs</span> <span class="skolem">ys</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="skolem">ys</span></span><span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-llexord_LCons_LCons"><span class="command">lemma</span></span> llexord_LCons_LCons <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"llexord <span class="free">r</span> <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>LCons <span class="free">y</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">x</span> <span class="main">=</span> <span class="free">y</span> <span class="main">∧</span> llexord <span class="free">r</span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">∨</span> <span class="free">r</span> <span class="free">x</span> <span class="free">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> llexord.intros<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>2<span class="main"><span class="main">)</span></span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> llexord.cases<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lnull_llexord"><span class="command">lemma</span></span> lnull_llexord <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lnull <span class="free">xs</span> <span class="main">⟹</span> llexord <span class="free">r</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> lnull_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-llexord_LNil_right"><span class="command">lemma</span></span> llexord_LNil_right <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lnull <span class="free">ys</span> <span class="main">⟹</span> llexord <span class="free">r</span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">⟷</span> lnull <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> llexord.cases<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llexord_LCons_left"><span class="command">lemma</span></span> llexord_LCons_left<span class="main">:</span>
  <span class="quoted"><span class="quoted">"llexord <span class="free">r</span> <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span> <span class="main">⟷</span>
   <span class="main">(</span><span class="main">∃</span><span class="bound">y</span> <span class="bound">ys'</span><span class="main">.</span> <span class="free">ys</span> <span class="main">=</span> LCons <span class="bound">y</span> <span class="bound">ys'</span> <span class="main">∧</span> <span class="main">(</span><span class="free">x</span> <span class="main">=</span> <span class="bound">y</span> <span class="main">∧</span> llexord <span class="free">r</span> <span class="free">xs</span> <span class="bound">ys'</span> <span class="main">∨</span> <span class="free">r</span> <span class="free">x</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> llexord.cases<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lprefix_imp_llexord"><span class="command">lemma</span></span> lprefix_imp_llexord<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">⊑</span> <span class="free">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"llexord <span class="free">r</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduct</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lnull_conv LCons_lprefix_conv<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llexord_empty"><span class="command">lemma</span></span> llexord_empty<span class="main">:</span>
  <span class="quoted"><span class="quoted">"llexord <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> False<span class="main">)</span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">=</span> <span class="free">xs</span> <span class="main">⊑</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"llexord <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> False<span class="main">)</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">⊑</span> <span class="free">ys</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduct</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> llexord.cases<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">rule</span> lprefix_imp_llexord<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llexord_append_right"><span class="command">lemma</span></span> llexord_append_right<span class="main">:</span>
  <span class="quoted"><span class="quoted">"llexord <span class="free">r</span> <span class="free">xs</span> <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> lprefix_imp_llexord<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lprefix_conv_lappend<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llexord_lappend_leftI"><span class="command">lemma</span></span> llexord_lappend_leftI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"llexord <span class="free">r</span> <span class="free">ys</span> <span class="free">zs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"llexord <span class="free">r</span> <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">zs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lappend_inf<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-llexord_lappend_leftD"><span class="command">lemma</span></span> llexord_lappend_leftD<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> lex<span class="main">:</span> <span class="quoted"><span class="quoted">"llexord <span class="free">r</span> <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">zs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> fin<span class="main">:</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> irrefl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">!!</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> lset <span class="free">xs</span> <span class="main">⟹</span> <span class="main">¬</span> <span class="free">r</span> <span class="bound">x</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"llexord <span class="free">r</span> <span class="free">ys</span> <span class="free">zs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> fin lex irrefl <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-llexord_lappend_left"><span class="command">lemma</span></span> llexord_lappend_left<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> lfinite <span class="free">xs</span><span class="main">;</span> <span class="main">!!</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> lset <span class="free">xs</span> <span class="main">⟹</span> <span class="main">¬</span> <span class="free">r</span> <span class="bound">x</span> <span class="bound">x</span> <span class="main">⟧</span>
  <span class="main">⟹</span> llexord <span class="free">r</span> <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">zs</span><span class="main">)</span> <span class="main">⟷</span> llexord <span class="free">r</span> <span class="free">ys</span> <span class="free">zs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> llexord_lappend_leftI llexord_lappend_leftD<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-antisym_llexord"><span class="command">lemma</span></span> antisym_llexord<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> r<span class="main">:</span> <span class="quoted"><span class="quoted">"antisymp <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> irrefl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="main">¬</span> <span class="free">r</span> <span class="bound">x</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"antisymp <span class="main">(</span>llexord <span class="free">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> antisympI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="skolem">ys</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"llexord <span class="free">r</span> <span class="skolem">xs</span> <span class="skolem">ys</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"llexord <span class="free">r</span> <span class="skolem">ys</span> <span class="skolem">xs</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"llexord <span class="free">r</span> <span class="skolem">xs</span> <span class="skolem">ys</span> <span class="main">∧</span> llexord <span class="free">r</span> <span class="skolem">ys</span> <span class="skolem">xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> <span class="skolem">ys</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">coinduct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> llist.coinduct<span class="main">)</span>
      <span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lnull_conv irrefl <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> antisympD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> r<span class="main"><span class="main">,</span></span> <span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-llexord_antisym"><span class="command">lemma</span></span> llexord_antisym<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> llexord <span class="free">r</span> <span class="free">xs</span> <span class="free">ys</span><span class="main">;</span> llexord <span class="free">r</span> <span class="free">ys</span> <span class="free">xs</span><span class="main">;</span>
    <span class="main">!!</span><span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> <span class="main">⟦</span> <span class="free">r</span> <span class="bound">a</span> <span class="bound">b</span><span class="main">;</span> <span class="free">r</span> <span class="bound">b</span> <span class="bound">a</span> <span class="main">⟧</span> <span class="main">⟹</span> False <span class="main">⟧</span>
  <span class="main">⟹</span> <span class="free">xs</span> <span class="main">=</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> antisympD<span class="main">[</span><span class="operator">OF</span> antisym_llexord<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">r</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> antisympI<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llexord_trans"><span class="command">lemma</span></span> llexord_trans<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"llexord <span class="free">r</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"llexord <span class="free">r</span> <span class="free">ys</span> <span class="free">zs</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> trans<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">!!</span><span class="bound">a</span> <span class="bound">b</span> <span class="bound">c</span><span class="main">.</span> <span class="main">⟦</span> <span class="free">r</span> <span class="bound">a</span> <span class="bound">b</span><span class="main">;</span> <span class="free">r</span> <span class="bound">b</span> <span class="bound">c</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">r</span> <span class="bound">a</span> <span class="bound">c</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"llexord <span class="free">r</span> <span class="free">xs</span> <span class="free">zs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> 1 2 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">ys</span><span class="main">.</span> llexord <span class="free">r</span> <span class="free">xs</span> <span class="bound">ys</span> <span class="main">∧</span> llexord <span class="free">r</span> <span class="bound">ys</span> <span class="free">zs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduct</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lnull_conv llexord_LCons_left <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> trans<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-trans_llexord"><span class="command">lemma</span></span> trans_llexord<span class="main">:</span>
  <span class="quoted"><span class="quoted">"transp <span class="free">r</span> <span class="main">⟹</span> transp <span class="main">(</span>llexord <span class="free">r</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> transpI <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> llexord_trans <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> transpD<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llexord_linear"><span class="command">lemma</span></span> llexord_linear<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> linear<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">!!</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">r</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">∨</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">y</span> <span class="main">∨</span> <span class="free">r</span> <span class="bound">y</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"llexord <span class="free">r</span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">∨</span> llexord <span class="free">r</span> <span class="free">ys</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> disjCI<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> llexord <span class="free">r</span> <span class="free">ys</span> <span class="free">xs</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"llexord <span class="free">r</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> llexord_coinduct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>llexord <span class="skolem">xs</span> <span class="skolem">ys</span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> LNil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> llexord <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>LCons <span class="skolem">x</span> <span class="skolem">xs'</span><span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> llexord <span class="free">r</span> <span class="skolem">ys</span> <span class="skolem">xs</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="skolem"><span class="skolem">ys'</span></span>
        <span class="keyword2"><span class="keyword">where</span></span> ys<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">ys</span> <span class="main">=</span> LCons <span class="skolem">y</span> <span class="skolem">ys'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">r</span> <span class="skolem">y</span> <span class="skolem">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">≠</span> <span class="skolem">x</span> <span class="main">∨</span> <span class="main">¬</span> llexord <span class="free">r</span> <span class="skolem">ys'</span> <span class="skolem">xs'</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main">)</span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> <span class="free">r</span> <span class="skolem">y</span> <span class="skolem">x</span>›</span></span> linear<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">x</span></span> <span class="quoted"><span class="skolem">y</span></span><span class="main">]</span> ys LCons <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-llexord_code"><span class="command">lemma</span></span> llexord_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"llexord <span class="free">r</span> LNil <span class="free">ys</span> <span class="main">=</span> True"</span></span>
  <span class="quoted"><span class="quoted">"llexord <span class="free">r</span> <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> LNil <span class="main">=</span> False"</span></span>
  <span class="quoted"><span class="quoted">"llexord <span class="free">r</span> <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>LCons <span class="free">y</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">r</span> <span class="free">x</span> <span class="free">y</span> <span class="main">∨</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span> <span class="main">∧</span> llexord <span class="free">r</span> <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_List-llexord_conv"><span class="command">lemma</span></span> llexord_conv<span class="main">:</span>
 <span class="quoted"><span class="quoted">"llexord <span class="free">r</span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">⟷</span>
  <span class="free">xs</span> <span class="main">=</span> <span class="free">ys</span> <span class="main">∨</span>
  <span class="main">(</span><span class="main">∃</span><span class="bound">zs</span> <span class="bound">xs'</span> <span class="bound">y</span> <span class="bound">ys'</span><span class="main">.</span> lfinite <span class="bound">zs</span> <span class="main">∧</span> <span class="free">xs</span> <span class="main">=</span> lappend <span class="bound">zs</span> <span class="bound">xs'</span> <span class="main">∧</span> <span class="free">ys</span> <span class="main">=</span> lappend <span class="bound">zs</span> <span class="main">(</span>LCons <span class="bound">y</span> <span class="bound">ys'</span><span class="main">)</span> <span class="main">∧</span>
                  <span class="main">(</span><span class="bound">xs'</span> <span class="main">=</span> LNil <span class="main">∨</span> <span class="free">r</span> <span class="main">(</span>lhd <span class="bound">xs'</span><span class="main">)</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">∨</span> <span class="var">?prefix</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> disjCI<span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="var">?prefix</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?lhs</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="free">ys</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Eq_llist <span class="skolem">xs</span> <span class="skolem">ys</span><span class="main">)</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"llexord <span class="free">r</span> <span class="skolem">xs</span> <span class="skolem">ys</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> prefix<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">zs</span> <span class="bound">xs'</span> <span class="bound">y</span> <span class="bound">ys'</span><span class="main">.</span> <span class="main">⟦</span> lfinite <span class="bound">zs</span><span class="main">;</span> <span class="skolem">xs</span> <span class="main">=</span> lappend <span class="bound">zs</span> <span class="bound">xs'</span><span class="main">;</span>
                                      <span class="skolem">ys</span> <span class="main">=</span> lappend <span class="bound">zs</span> <span class="main">(</span>LCons <span class="bound">y</span> <span class="bound">ys'</span><span class="main">)</span> <span class="main">⟧</span>
                                     <span class="main">⟹</span> <span class="bound">xs'</span> <span class="main">≠</span> LNil <span class="main">∧</span> <span class="main">¬</span> <span class="free">r</span> <span class="main">(</span>lhd <span class="bound">xs'</span><span class="main">)</span> <span class="bound">y</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹llexord <span class="free">r</span> <span class="skolem">xs</span> <span class="skolem">ys</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>llexord_LCons_eq <span class="skolem">xs'</span> <span class="skolem">ys'</span> <span class="skolem">x</span><span class="main">)</span>
        <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">zs</span> <span class="skolem">xs''</span> <span class="skolem">y</span> <span class="skolem">ys''</span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="skolem">zs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs'</span> <span class="main">=</span> lappend <span class="skolem">zs</span> <span class="skolem">xs''</span>"</span></span>
            <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ys'</span> <span class="main">=</span> lappend <span class="skolem">zs</span> <span class="main">(</span>LCons <span class="skolem">y</span> <span class="skolem">ys''</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>LCons <span class="skolem">x</span> <span class="skolem">zs</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> lappend <span class="main">(</span>LCons <span class="skolem">x</span> <span class="skolem">zs</span><span class="main">)</span> <span class="skolem">xs''</span>"</span></span>
            <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ys</span> <span class="main">=</span> lappend <span class="main">(</span>LCons <span class="skolem">x</span> <span class="skolem">zs</span><span class="main">)</span> <span class="main">(</span>LCons <span class="skolem">y</span> <span class="skolem">ys''</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> llexord_LCons_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs''</span> <span class="main">≠</span> LNil <span class="main">∧</span> <span class="main">¬</span> <span class="free">r</span> <span class="main">(</span>lhd <span class="skolem">xs''</span><span class="main">)</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> prefix<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
        <span class="keyword1"><span class="command">with</span></span> llexord_LCons_eq <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>llexord_LCons_less <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">xs'</span> <span class="skolem">ys'</span><span class="main">)</span>
        <span class="keyword1"><span class="command">with</span></span> prefix<span class="main">[</span><span class="operator">of</span> <span class="quoted">LNil</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quoted"><span class="skolem">y</span></span> <span class="quoted"><span class="skolem">ys'</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> llexord_LNil
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> prefix<span class="main">[</span><span class="operator">of</span> <span class="quoted">LNil</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quoted"><span class="quoted">"lhd <span class="skolem">ys</span>"</span></span> <span class="quoted"><span class="quoted">"ltl <span class="skolem">ys</span>"</span></span><span class="main">]</span>
          <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main">)</span> <span class="operator">simp_all</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>llexord <span class="skolem">xs</span> <span class="skolem">ys</span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> LNil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> llexord <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>LCons <span class="skolem">x</span> <span class="skolem">xs'</span><span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> llexord <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="skolem"><span class="skolem">ys'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ys</span> <span class="main">=</span> LCons <span class="skolem">y</span> <span class="skolem">ys'</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> sym <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> LNil_eq_lappend_iff<span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True
        <span class="keyword1"><span class="command">from</span></span> llexord<span class="main">(</span>1<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">proof</span></span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> <span class="skolem">ys</span>"</span></span>
          <span class="keyword1"><span class="command">with</span></span> True LCons <span class="quoted"><span class="quoted">‹<span class="skolem">ys</span> <span class="main">=</span> LCons <span class="skolem">y</span> <span class="skolem">ys'</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">zs</span> <span class="bound">xs'</span> <span class="bound">y</span> <span class="bound">ys'</span><span class="main">.</span> lfinite <span class="bound">zs</span> <span class="main">∧</span> <span class="skolem">xs</span> <span class="main">=</span> lappend <span class="bound">zs</span> <span class="bound">xs'</span> <span class="main">∧</span>
                                 <span class="skolem">ys</span> <span class="main">=</span> lappend <span class="bound">zs</span> <span class="main">(</span>LCons <span class="bound">y</span> <span class="bound">ys'</span><span class="main">)</span> <span class="main">∧</span>
                                 <span class="main">(</span><span class="bound">xs'</span> <span class="main">=</span> LNil <span class="main">∨</span> <span class="free">r</span> <span class="main">(</span>lhd <span class="bound">xs'</span><span class="main">)</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">zs</span></span> <span class="skolem"><span class="skolem">xs'</span></span> <span class="skolem"><span class="skolem">y'</span></span> <span class="skolem"><span class="skolem">ys''</span></span>
            <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="skolem">zs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> lappend <span class="skolem">zs</span> <span class="skolem">xs'</span>"</span></span>
            <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ys</span> <span class="main">=</span> lappend <span class="skolem">zs</span> <span class="main">(</span>LCons <span class="skolem">y'</span> <span class="skolem">ys''</span><span class="main">)</span>"</span></span>
            <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs'</span> <span class="main">=</span> LNil <span class="main">∨</span> <span class="free">r</span> <span class="main">(</span>lhd <span class="skolem">xs'</span><span class="main">)</span> <span class="skolem">y'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
          <span class="keyword1"><span class="command">with</span></span> True LCons <span class="quoted"><span class="quoted">‹<span class="skolem">ys</span> <span class="main">=</span> LCons <span class="skolem">y</span> <span class="skolem">ys'</span>›</span></span>
          <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">zs</span></span><span class="main">)</span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False
        <span class="keyword1"><span class="command">with</span></span> LCons llexord <span class="quoted"><span class="quoted">‹<span class="skolem">ys</span> <span class="main">=</span> LCons <span class="skolem">y</span> <span class="skolem">ys'</span>›</span></span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="skolem">x</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> lfinite.cases<span class="main">)</span>
        <span class="keyword1"><span class="command">with</span></span> LCons <span class="quoted"><span class="quoted">‹<span class="skolem">ys</span> <span class="main">=</span> LCons <span class="skolem">y</span> <span class="skolem">ys'</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-llexord_conv_ltake_index"><span class="command">lemma</span></span> llexord_conv_ltake_index<span class="main">:</span>
  <span class="quoted"><span class="quoted">"llexord <span class="free">r</span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">⟷</span>
   <span class="main">(</span>llength <span class="free">xs</span> <span class="main">≤</span> llength <span class="free">ys</span> <span class="main">∧</span> ltake <span class="main">(</span>llength <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span> <span class="main">=</span> <span class="free">xs</span><span class="main">)</span> <span class="main">∨</span>
   <span class="main">(</span><span class="main">∃</span><span class="bound">n</span><span class="main">.</span> enat <span class="bound">n</span> <span class="main">&lt;</span> min <span class="main">(</span>llength <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>llength <span class="free">ys</span><span class="main">)</span> <span class="main">∧</span>
        ltake <span class="main">(</span>enat <span class="bound">n</span><span class="main">)</span> <span class="free">xs</span> <span class="main">=</span> ltake <span class="main">(</span>enat <span class="bound">n</span><span class="main">)</span> <span class="free">ys</span> <span class="main">∧</span> <span class="free">r</span> <span class="main">(</span>lnth <span class="free">xs</span> <span class="bound">n</span><span class="main">)</span> <span class="main">(</span>lnth <span class="free">ys</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> iffI<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?A</span> <span class="main">∨</span> <span class="var">?B</span>"</span></span><span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> llexord_conv
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="free">ys</span>"</span></span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltake_all<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">zs</span> <span class="bound">xs'</span> <span class="bound">y</span> <span class="bound">ys'</span><span class="main">.</span> lfinite <span class="bound">zs</span> <span class="main">∧</span> <span class="free">xs</span> <span class="main">=</span> lappend <span class="bound">zs</span> <span class="bound">xs'</span> <span class="main">∧</span>
                           <span class="free">ys</span> <span class="main">=</span> lappend <span class="bound">zs</span> <span class="main">(</span>LCons <span class="bound">y</span> <span class="bound">ys'</span><span class="main">)</span> <span class="main">∧</span>
                           <span class="main">(</span><span class="bound">xs'</span> <span class="main">=</span> LNil <span class="main">∨</span> <span class="free">r</span> <span class="main">(</span>lhd <span class="bound">xs'</span><span class="main">)</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">zs</span></span> <span class="skolem"><span class="skolem">xs'</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="skolem"><span class="skolem">ys'</span></span>
      <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="skolem">zs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs'</span> <span class="main">=</span> LNil <span class="main">∨</span> <span class="free">r</span> <span class="main">(</span>lhd <span class="skolem">xs'</span><span class="main">)</span> <span class="skolem">y</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> lappend <span class="skolem">zs</span> <span class="skolem">xs'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">=</span> lappend <span class="skolem">zs</span> <span class="main">(</span>LCons <span class="skolem">y</span> <span class="skolem">ys'</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs'</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> LNil
      <span class="keyword1"><span class="command">hence</span></span> <span class="var"><span class="quoted"><span class="var">?A</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> enat_le_plus_same <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltake_lappend1 ltake_all<span class="main">)</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> LCons
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">xs'</span> <span class="main">=</span> LNil <span class="main">∨</span> <span class="free">r</span> <span class="main">(</span>lhd <span class="skolem">xs'</span><span class="main">)</span> <span class="skolem">y</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">(</span>lhd <span class="skolem">xs'</span><span class="main">)</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹lfinite <span class="skolem">zs</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">zs'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">zs</span> <span class="main">=</span> llist_of <span class="skolem">zs'</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> lfinite_eq_range_llist_of <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">with</span></span> LCons <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"enat <span class="main">(</span>length <span class="skolem">zs'</span><span class="main">)</span> <span class="main">&lt;</span> min <span class="main">(</span>llength <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>llength <span class="free">ys</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_enat_def eSuc_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> enat.split<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ltake <span class="main">(</span>enat <span class="main">(</span>length <span class="skolem">zs'</span><span class="main">)</span><span class="main">)</span> <span class="free">xs</span> <span class="main">=</span> ltake <span class="main">(</span>enat <span class="main">(</span>length <span class="skolem">zs'</span><span class="main">)</span><span class="main">)</span> <span class="free">ys</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltake_lappend1<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">(</span>lnth <span class="free">xs</span> <span class="main">(</span>length <span class="skolem">zs'</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>lnth <span class="free">ys</span> <span class="main">(</span>length <span class="skolem">zs'</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> LCons <span class="quoted"><span class="quoted">‹<span class="free">r</span> <span class="main">(</span>lhd <span class="skolem">xs'</span><span class="main">)</span> <span class="skolem">y</span>›</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lappend_llist_of_LCons lnth_lappend1<span class="main">)</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?B</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?A</span> <span class="main">∨</span> <span class="var">?B</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?A</span></span></span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduct</span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>llexord <span class="skolem">xs</span> <span class="skolem">ys</span><span class="main">)</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="var">?B</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="keyword2"><span class="keyword">where</span></span> len<span class="main">:</span> <span class="quoted"><span class="quoted">"enat <span class="skolem">n</span> <span class="main">&lt;</span> min <span class="main">(</span>llength <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>llength <span class="free">ys</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> takexs<span class="main">:</span> <span class="quoted"><span class="quoted">"ltake <span class="main">(</span>enat <span class="skolem">n</span><span class="main">)</span> <span class="free">xs</span> <span class="main">=</span> ltake <span class="main">(</span>enat <span class="skolem">n</span><span class="main">)</span> <span class="free">ys</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> r<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">(</span>lnth <span class="free">xs</span> <span class="skolem">n</span><span class="main">)</span> <span class="main">(</span>lnth <span class="free">ys</span> <span class="skolem">n</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> lappend <span class="main">(</span>ltake <span class="main">(</span>enat <span class="skolem">n</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>ldrop <span class="main">(</span>enat <span class="skolem">n</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> lappend_ltake_ldrop<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> takexs len
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">=</span> lappend <span class="main">(</span>ltake <span class="main">(</span>enat <span class="skolem">n</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>LCons <span class="main">(</span>lnth <span class="free">ys</span> <span class="skolem">n</span><span class="main">)</span> <span class="main">(</span>ldrop <span class="main">(</span>enat <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldropn_Suc_conv_ldropn ldrop_enat<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> r len
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">(</span>lhd <span class="main">(</span>ldrop <span class="main">(</span>enat <span class="skolem">n</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>lnth <span class="free">ys</span> <span class="skolem">n</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lhd_ldrop<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>ltake <span class="main">(</span>enat <span class="skolem">n</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> llexord_conv <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-llexord_llist_of"><span class="command">lemma</span></span> llexord_llist_of<span class="main">:</span>
  <span class="quoted"><span class="quoted">"llexord <span class="free">r</span> <span class="main">(</span>llist_of <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>llist_of <span class="free">ys</span><span class="main">)</span> <span class="main">⟷</span>
   <span class="free">xs</span> <span class="main">=</span> <span class="free">ys</span> <span class="main">∨</span> <span class="main">(</span><span class="free">xs</span><span class="main">,</span> <span class="free">ys</span><span class="main">)</span> <span class="main">∈</span> lexord <span class="main">{</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="free">r</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">}</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">zs</span> <span class="skolem">xs'</span> <span class="skolem">y</span> <span class="skolem">ys'</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="skolem">zs</span>"</span></span> <span class="quoted"><span class="quoted">"llist_of <span class="free">xs</span> <span class="main">=</span> lappend <span class="skolem">zs</span> <span class="skolem">xs'</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"llist_of <span class="free">ys</span> <span class="main">=</span> lappend <span class="skolem">zs</span> <span class="main">(</span>LCons <span class="skolem">y</span> <span class="skolem">ys'</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs'</span> <span class="main">=</span> LNil <span class="main">∨</span> <span class="free">r</span> <span class="main">(</span>lhd <span class="skolem">xs'</span><span class="main">)</span> <span class="skolem">y</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹lfinite <span class="skolem">zs</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">zs'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">zs</span> <span class="main">=</span> llist_of <span class="skolem">zs'</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> lfinite_eq_range_llist_of <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>llist_of <span class="free">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="skolem">xs'</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> <span class="quoted"><span class="quoted">‹llist_of <span class="free">xs</span> <span class="main">=</span> lappend <span class="skolem">zs</span> <span class="skolem">xs'</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">XS'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xs'</span> <span class="main">=</span> llist_of <span class="skolem">XS'</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> lfinite_eq_range_llist_of <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹llist_of <span class="free">xs</span> <span class="main">=</span> lappend <span class="skolem">zs</span> <span class="skolem">xs'</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="skolem">zs'</span> <span class="main">@</span> <span class="skolem">XS'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lappend_llist_of_llist_of<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>llist_of <span class="free">ys</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="skolem">ys'</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> <span class="quoted"><span class="quoted">‹llist_of <span class="free">ys</span> <span class="main">=</span> lappend <span class="skolem">zs</span> <span class="main">(</span>LCons <span class="skolem">y</span> <span class="skolem">ys'</span><span class="main">)</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">YS'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">ys'</span> <span class="main">=</span> llist_of <span class="skolem">YS'</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> lfinite_eq_range_llist_of <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹llist_of <span class="free">ys</span> <span class="main">=</span> lappend <span class="skolem">zs</span> <span class="main">(</span>LCons <span class="skolem">y</span> <span class="skolem">ys'</span><span class="main">)</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">=</span> <span class="skolem">zs'</span> <span class="main">@</span> <span class="skolem">y</span> <span class="main">#</span> <span class="skolem">YS'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_of.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> lappend_llist_of_llist_of <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> llist_of.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">a</span> <span class="bound">ys'</span><span class="main">.</span> <span class="free">ys</span> <span class="main">=</span> <span class="free">xs</span> <span class="main">@</span> <span class="bound">a</span> <span class="main">#</span> <span class="bound">ys'</span><span class="main">)</span> <span class="main">∨</span>
          <span class="main">(</span><span class="main">∃</span><span class="bound">zs</span> <span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> <span class="free">r</span> <span class="bound">a</span> <span class="bound">b</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span><span class="bound">xs'</span><span class="main">.</span> <span class="free">xs</span> <span class="main">=</span> <span class="bound">zs</span> <span class="main">@</span> <span class="bound">a</span> <span class="main">#</span> <span class="bound">xs'</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span><span class="bound">ys'</span><span class="main">.</span> <span class="free">ys</span> <span class="main">=</span> <span class="bound">zs</span> <span class="main">@</span> <span class="bound">b</span> <span class="main">#</span> <span class="bound">ys'</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?A</span> <span class="main">∨</span> <span class="var">?B</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs'</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> LNil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_of_eq_LNil_conv<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>LCons <span class="skolem">x</span> <span class="skolem">xs''</span><span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">xs'</span> <span class="main">=</span> LNil <span class="main">∨</span> <span class="free">r</span> <span class="main">(</span>lhd <span class="skolem">xs'</span><span class="main">)</span> <span class="skolem">y</span>›</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">(</span>lhd <span class="skolem">xs'</span><span class="main">)</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_of_eq_LCons_conv<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> LCons <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?B</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_of_eq_LCons_conv<span class="main">)</span> <span class="operator">fastforce</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">xs</span><span class="main">,</span> <span class="free">ys</span><span class="main">)</span> <span class="main">∈</span> <span class="main">{</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="main">∃</span><span class="bound">a</span> <span class="bound">v</span><span class="main">.</span> <span class="bound">y</span> <span class="main">=</span> <span class="bound">x</span> <span class="main">@</span> <span class="bound">a</span> <span class="main">#</span> <span class="bound">v</span> <span class="main">∨</span>
                                    <span class="main">(</span><span class="main">∃</span><span class="bound">u</span> <span class="bound">a</span> <span class="bound">b</span> <span class="bound">v</span> <span class="bound">w</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∈</span> <span class="main">{</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="free">r</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">}</span> <span class="main">∧</span>
                                                 <span class="bound">x</span> <span class="main">=</span> <span class="bound">u</span> <span class="main">@</span> <span class="bound">a</span> <span class="main">#</span> <span class="bound">v</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">=</span> <span class="bound">u</span> <span class="main">@</span> <span class="bound">b</span> <span class="main">#</span> <span class="bound">w</span><span class="main">)</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?lhs</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> lexord_def llexord_conv llist_of_inject <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rhs</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="free">ys</span>"</span></span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">xs</span><span class="main">,</span> <span class="free">ys</span><span class="main">)</span> <span class="main">∈</span> lexord <span class="main">{</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="free">r</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">}</span>"</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> neq_Nil_conv<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The filter functional on lazy lists: <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"lfilter"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1" id="Coinductive_List-lfilter_code"><span class="command">lemma</span></span> lfilter_code <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> lfilter_LNil<span class="main">:</span> <span class="quoted"><span class="quoted">"lfilter <span class="free">P</span> LNil <span class="main">=</span> LNil"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> lfilter_LCons<span class="main">:</span> <span class="quoted"><span class="quoted">"lfilter <span class="free">P</span> <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">P</span> <span class="free">x</span> <span class="keyword1">then</span> LCons <span class="free">x</span> <span class="main">(</span>lfilter <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="keyword1">else</span> lfilter <span class="free">P</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lfilter.simps<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> lfilter.mono<span class="main">[</span><span class="operator">cont_intro</span><span class="main">]</span>

<span class="keyword1" id="Coinductive_List-mono2mono_lfilter"><span class="command">lemma</span></span> mono2mono_lfilter<span class="main">[</span><span class="operator">THEN</span> llist.mono2mono<span class="main">,</span> <span class="operator">simp</span><span class="main">,</span> <span class="operator">cont_intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> monotone_lfilter<span class="main">:</span> <span class="quoted"><span class="quoted">"monotone <span class="main">(⊑)</span> <span class="main">(⊑)</span> <span class="main">(</span>lfilter <span class="free">P</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> llist.fixp_preserves_mono1<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lfilter.mono lfilter_def<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-mcont2mcont_lfilter"><span class="command">lemma</span></span> mcont2mcont_lfilter<span class="main">[</span><span class="operator">THEN</span> llist.mcont2mcont<span class="main">,</span> <span class="operator">simp</span><span class="main">,</span> <span class="operator">cont_intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> mcont_lfilter<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont lSup <span class="main">(⊑)</span> lSup <span class="main">(⊑)</span> <span class="main">(</span>lfilter <span class="free">P</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> llist.fixp_preserves_mcont1<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lfilter.mono lfilter_def<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-lfilter_mono"><span class="command">lemma</span></span> lfilter_mono <span class="main">[</span><span class="operator">partial_function_mono</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"mono_llist <span class="free">A</span> <span class="main">⟹</span> mono_llist <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> lfilter <span class="free">P</span> <span class="main">(</span><span class="free">A</span> <span class="bound">f</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> mono2mono_lfilter<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lfilter_LCons_seek"><span class="command">lemma</span></span> lfilter_LCons_seek<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">~</span> <span class="main">(</span><span class="free">p</span> <span class="free">x</span><span class="main">)</span> <span class="main">==&gt;</span> lfilter <span class="free">p</span> <span class="main">(</span>LCons <span class="free">x</span> <span class="free">l</span><span class="main">)</span> <span class="main">=</span> lfilter <span class="free">p</span> <span class="free">l</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-lfilter_LCons_found"><span class="command">lemma</span></span> lfilter_LCons_found<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">x</span> <span class="main">⟹</span> lfilter <span class="free">P</span> <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> LCons <span class="free">x</span> <span class="main">(</span>lfilter <span class="free">P</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-lfilter_eq_LNil"><span class="command">lemma</span></span> lfilter_eq_LNil<span class="main">:</span> <span class="quoted"><span class="quoted">"lfilter <span class="free">P</span> <span class="free">xs</span> <span class="main">=</span> LNil <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> lset <span class="free">xs</span><span class="main">.</span> <span class="main">¬</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">notepad</span></span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword3"><span class="command">fix</span></span> <span class="skolem">P</span> <span class="skolem">xs</span>
<span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>lfilter <span class="skolem">P</span> <span class="skolem">xs</span> <span class="main">=</span> LNil<span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> lset <span class="skolem">xs</span><span class="main">.</span> <span class="main">¬</span> <span class="skolem">P</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">intro</span> iffI strip<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> lset <span class="skolem">xs</span><span class="main">.</span> <span class="main">¬</span> <span class="skolem">P</span> <span class="bound">x</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lfilter <span class="skolem">P</span> <span class="skolem">xs</span> <span class="main">⊑</span> LNil"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lfilter.fixp_induct<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> lprefix_LNil<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"lfilter <span class="skolem">P</span> <span class="skolem">xs</span> <span class="main">=</span> LNil"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> lset <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="quoted">"lfilter <span class="skolem">P</span> <span class="skolem">xs</span> <span class="main">=</span> LNil"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="skolem">P</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">induction</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Coinductive_List-diverge_lfilter_LNil"><span class="command">lemma</span></span> diverge_lfilter_LNil <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">∈</span>lset <span class="free">xs</span><span class="main">.</span> <span class="main">¬</span> <span class="free">P</span> <span class="bound">x</span> <span class="main">⟹</span> lfilter <span class="free">P</span> <span class="free">xs</span> <span class="main">=</span> LNil"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lfilter_eq_LNil<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> lfilter_False <span class="main">=</span> diverge_lfilter_LNil

<span class="keyword1" id="Coinductive_List-lnull_lfilter"><span class="command">lemma</span></span> lnull_lfilter <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lnull <span class="main">(</span>lfilter <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">∈</span>lset <span class="free">xs</span><span class="main">.</span> <span class="main">¬</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> lnull_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lfilter_eq_LNil<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> lfilter_empty_conv <span class="main">=</span> lfilter_eq_LNil

<span class="keyword1" id="Coinductive_List-lhd_lfilter"><span class="command">lemma</span></span> lhd_lfilter <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lhd <span class="main">(</span>lfilter <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lhd <span class="main">(</span>ldropWhile <span class="main">(</span>Not <span class="main">∘</span> <span class="free">P</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span><span class="main">∈</span>lset <span class="free">xs</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> lset <span class="free">xs</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> lset <span class="free">xs</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">‹<span class="free">P</span> <span class="skolem">x</span>›</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ltl_lfilter"><span class="command">lemma</span></span> ltl_lfilter<span class="main">:</span> <span class="quoted"><span class="quoted">"ltl <span class="main">(</span>lfilter <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lfilter <span class="free">P</span> <span class="main">(</span>ltl <span class="main">(</span>ldropWhile <span class="main">(</span>Not <span class="main">∘</span> <span class="free">P</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-lfilter_eq_LCons"><span class="command">lemma</span></span> lfilter_eq_LCons<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lfilter <span class="free">P</span> <span class="free">xs</span> <span class="main">=</span> LCons <span class="free">x</span> <span class="free">xs'</span> <span class="main">⟹</span>
   <span class="main">∃</span><span class="bound">xs''</span><span class="main">.</span> <span class="free">xs'</span> <span class="main">=</span> lfilter <span class="free">P</span> <span class="bound">xs''</span> <span class="main">∧</span> ldropWhile <span class="main">(</span>Not <span class="main">∘</span> <span class="free">P</span><span class="main">)</span> <span class="free">xs</span> <span class="main">=</span> LCons <span class="free">x</span> <span class="bound">xs''</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">drule</span> eq_LConsD<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> exI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltl_lfilter o_def ldropWhile_eq_LNil_iff <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> llist.expand<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lfilter_K_True"><span class="command">lemma</span></span> lfilter_K_True <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lfilter <span class="main">(</span><span class="main">%</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> <span class="free">xs</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-lfitler_K_False"><span class="command">lemma</span></span> lfitler_K_False <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lfilter <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> False<span class="main">)</span> <span class="free">xs</span> <span class="main">=</span> LNil"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-lfilter_lappend_lfinite"><span class="command">lemma</span></span> lfilter_lappend_lfinite <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span> <span class="main">⟹</span> lfilter <span class="free">P</span> <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> lappend <span class="main">(</span>lfilter <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>lfilter <span class="free">P</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lfinite.induct<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_List-lfinite_lfilterI"><span class="command">lemma</span></span> lfinite_lfilterI <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span> <span class="main">⟹</span> lfinite <span class="main">(</span>lfilter <span class="free">P</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lfinite.induct<span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-lset_lfilter"><span class="command">lemma</span></span> lset_lfilter <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lset <span class="main">(</span>lfilter <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">x</span></span> <span class="main">∈</span> lset <span class="free">xs</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Collect_conj_eq<span class="main">)</span>

<span class="keyword1"><span class="command">notepad</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="comment1">― ‹show <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">thm</span> [source] lset_lfilter<span class="antiquote">}</span></span> by fixpoint induction›</span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span> <span class="main">=</span> lset_lfilter
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">P</span> <span class="skolem">xs</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lset <span class="main">(</span>lfilter <span class="skolem">P</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">=</span> lset <span class="skolem">xs</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">P</span> <span class="bound">x</span><span class="main">}</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⊆</span> <span class="var">?rhs</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lfilter.fixp_induct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rhs</span> <span class="main">⊆</span> <span class="var">?lhs</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="var">?rhs</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> lset <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">P</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="var">?lhs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">induction</span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Coinductive_List-lfilter_lfilter"><span class="command">lemma</span></span> lfilter_lfilter<span class="main">:</span> <span class="quoted"><span class="quoted">"lfilter <span class="free">P</span> <span class="main">(</span>lfilter <span class="free">Q</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lfilter <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="main">∧</span> <span class="free">Q</span> <span class="bound">x</span><span class="main">)</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">notepad</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="comment1">― ‹show <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">thm</span> [source] lfilter_lfilter<span class="antiquote">}</span></span> by fixpoint induction›</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">P</span> <span class="skolem">Q</span> <span class="skolem">xs</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">xs</span><span class="main">.</span> lfilter <span class="skolem">P</span> <span class="main">(</span>lfilter <span class="skolem">Q</span> <span class="bound">xs</span><span class="main">)</span> <span class="main">⊑</span> lfilter <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">P</span> <span class="bound">x</span> <span class="main">∧</span> <span class="skolem">Q</span> <span class="bound">x</span><span class="main">)</span> <span class="bound">xs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> lfilter.fixp_induct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">xs</span><span class="main">.</span> lfilter <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">P</span> <span class="bound">x</span> <span class="main">∧</span> <span class="skolem">Q</span> <span class="bound">x</span><span class="main">)</span> <span class="bound">xs</span> <span class="main">⊑</span> lfilter <span class="skolem">P</span> <span class="main">(</span>lfilter <span class="skolem">Q</span> <span class="bound">xs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> lfilter.fixp_induct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lfilter <span class="skolem">P</span> <span class="main">(</span>lfilter <span class="skolem">Q</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">=</span> lfilter <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">P</span> <span class="bound">x</span> <span class="main">∧</span> <span class="skolem">Q</span> <span class="bound">x</span><span class="main">)</span> <span class="skolem">xs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> lprefix_antisym<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Coinductive_List-lfilter_idem"><span class="command">lemma</span></span> lfilter_idem <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lfilter <span class="free">P</span> <span class="main">(</span>lfilter <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lfilter <span class="free">P</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lfilter_lfilter<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lfilter_lmap"><span class="command">lemma</span></span> lfilter_lmap<span class="main">:</span> <span class="quoted"><span class="quoted">"lfilter <span class="free">P</span> <span class="main">(</span>lmap <span class="free">f</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lmap <span class="free">f</span> <span class="main">(</span>lfilter <span class="main">(</span><span class="free">P</span> <span class="keyword1">o</span> <span class="free">f</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-lfilter_llist_of"><span class="command">lemma</span></span> lfilter_llist_of <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lfilter <span class="free">P</span> <span class="main">(</span>llist_of <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> llist_of <span class="main">(</span>filter <span class="free">P</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-lfilter_cong"><span class="command">lemma</span></span> lfilter_cong <span class="main">[</span><span class="operator">cong</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> xsys<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="free">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> set<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> lset <span class="free">ys</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">Q</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lfilter <span class="free">P</span> <span class="free">xs</span> <span class="main">=</span> lfilter <span class="free">Q</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> set <span class="keyword1"><span class="command">unfolding</span></span> xsys
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Bex_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llength_lfilter_ile"><span class="command">lemma</span></span> llength_lfilter_ile<span class="main">:</span>
  <span class="quoted"><span class="quoted">"llength <span class="main">(</span>lfilter <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">≤</span> llength <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> order_trans<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lfinite_lfilter"><span class="command">lemma</span></span> lfinite_lfilter<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>lfilter <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟷</span>
   lfinite <span class="free">xs</span> <span class="main">∨</span> finite <span class="main">{</span><span class="bound">n</span><span class="main">.</span> enat <span class="bound">n</span> <span class="main">&lt;</span> llength <span class="free">xs</span> <span class="main">∧</span> <span class="free">P</span> <span class="main">(</span>lnth <span class="free">xs</span> <span class="bound">n</span><span class="main">)</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>lfilter <span class="free">P</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lfinite <span class="free">xs</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹lfinite <span class="main">(</span>lfilter <span class="free">P</span> <span class="free">xs</span><span class="main">)</span>›</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">{</span><span class="bound">n</span><span class="main">.</span> enat <span class="bound">n</span> <span class="main">&lt;</span> llength <span class="free">xs</span> <span class="main">∧</span> <span class="free">P</span> <span class="main">(</span>lnth <span class="free">xs</span> <span class="bound">n</span><span class="main">)</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="skolem">ys</span><span class="main"><span class="main">≡</span></span><span class="quoted"><span class="quoted">"lfilter <span class="free">P</span> <span class="free">xs</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lfinite_induct<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> LNil
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">∈</span>lset <span class="skolem">xs</span><span class="main">.</span> <span class="main">¬</span> <span class="free">P</span> <span class="bound">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
      <span class="keyword1"><span class="command">hence</span></span> eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">n</span><span class="main">.</span> enat <span class="bound">n</span> <span class="main">&lt;</span> llength <span class="skolem">xs</span> <span class="main">∧</span> <span class="free">P</span> <span class="main">(</span>lnth <span class="skolem">xs</span> <span class="bound">n</span><span class="main">)</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lset_conv_lnth<span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> eq <span class="keyword1"><span class="command">..</span></span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>LCons <span class="skolem">xs</span><span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> lnull <span class="main">(</span>lfilter <span class="free">P</span> <span class="skolem">xs</span><span class="main">)</span>›</span></span>
      <span class="keyword1"><span class="command">have</span></span> exP<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span><span class="main">∈</span>lset <span class="skolem">xs</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?xs</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"ltl <span class="main">(</span>ldropWhile <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">¬</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span> <span class="skolem">xs</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?xs'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"ltakeWhile <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">¬</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span> <span class="skolem">xs</span>"</span></span>
      <span class="keyword1"><span class="command">from</span></span> exP <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="keyword2"><span class="keyword">where</span></span> n<span class="main">:</span> <span class="quoted"><span class="quoted">"llength <span class="var">?xs'</span> <span class="main">=</span> enat <span class="skolem">n</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> lfinite_conv_llength_enat<span class="main">[</span><span class="operator">of</span> <span class="var"><span class="quoted"><span class="var">?xs'</span></span></span><span class="main">]</span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lfinite_ltakeWhile<span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="main">{</span><span class="bound">n</span><span class="main">.</span> enat <span class="bound">n</span> <span class="main">&lt;</span> llength <span class="var">?xs</span><span class="main">}</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">n</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span>lnth <span class="var">?xs</span> <span class="bound">n</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"finite <span class="var">?A</span>"</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">using</span></span> LCons <span class="main">[</span><span class="main">[</span><span class="operator">simproc</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finite_Collect<span class="main">]</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltl_lfilter lfinite_ldropWhile<span class="main">)</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">m</span><span class="main">.</span> <span class="skolem">n</span> <span class="main">+</span> <span class="main">1</span> <span class="main">+</span> <span class="bound">m</span><span class="main">)</span> <span class="main">`</span> <span class="main">(</span><span class="main">{</span><span class="bound">n</span><span class="main">.</span> enat <span class="bound">n</span> <span class="main">&lt;</span> llength <span class="var">?xs</span><span class="main">}</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">n</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span>lnth <span class="var">?xs</span> <span class="bound">n</span><span class="main">)</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="var">?f</span> <span class="main">`</span> <span class="main">_</span><span class="main">)</span>"</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> finite_imageI<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> lappend <span class="var">?xs'</span> <span class="main">(</span>LCons <span class="main">(</span>lhd <span class="main">(</span>ldropWhile <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">¬</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span> <span class="skolem">xs</span><span class="main">)</span><span class="main">)</span> <span class="var">?xs</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> exP <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">m</span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">&lt;</span> <span class="skolem">n</span>"</span></span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lnth <span class="var">?xs'</span> <span class="skolem">m</span> <span class="main">∈</span> lset <span class="var">?xs'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> n
          <span class="keyword1"><span class="command">unfolding</span></span> in_lset_conv_lnth <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">P</span> <span class="main">(</span>lnth <span class="var">?xs'</span> <span class="skolem">m</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lset_ltakeWhileD<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">n</span><span class="main">.</span> enat <span class="bound">n</span> <span class="main">&lt;</span> llength <span class="skolem">xs</span> <span class="main">∧</span> <span class="free">P</span> <span class="main">(</span>lnth <span class="skolem">xs</span> <span class="bound">n</span><span class="main">)</span><span class="main">}</span> <span class="main">⊆</span> insert <span class="main">(</span>the_enat <span class="main">(</span>llength <span class="var">?xs'</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="var">?f</span> <span class="main">`</span> <span class="var">?A</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> n <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2<span class="main"><span class="main">)</span></span> xs<span class="main">)</span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"llength <span class="var">?xs</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnth_lappend not_less not_le lnth_LCons' eSuc_enat <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rev_image_eqI<span class="main">)</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_subset<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span> <span class="main">∨</span> finite <span class="main">{</span><span class="bound">n</span><span class="main">.</span> enat <span class="bound">n</span> <span class="main">&lt;</span> llength <span class="free">xs</span> <span class="main">∧</span> <span class="free">P</span> <span class="main">(</span>lnth <span class="free">xs</span> <span class="bound">n</span><span class="main">)</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span> <span class="main">∨</span> finite <span class="main">{</span><span class="bound">n</span><span class="main">.</span> enat <span class="bound">n</span> <span class="main">&lt;</span> llength <span class="free">xs</span> <span class="main">∧</span> <span class="free">P</span> <span class="main">(</span>lnth <span class="free">xs</span> <span class="bound">n</span><span class="main">)</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> llength_lfilter_ile<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">P</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>lfilter <span class="free">P</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lfinite_eq_range_llist_of<span class="main">)</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">assume</span></span> nfin<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lfinite <span class="free">xs</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> len<span class="main">:</span> <span class="quoted"><span class="quoted">"llength <span class="free">xs</span> <span class="main">=</span> <span class="main">∞</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> not_lfinite_llength<span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> fin<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">{</span><span class="bound">n</span><span class="main">.</span> enat <span class="bound">n</span> <span class="main">&lt;</span> llength <span class="free">xs</span> <span class="main">∧</span> <span class="free">P</span> <span class="main">(</span>lnth <span class="free">xs</span> <span class="bound">n</span><span class="main">)</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">m</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">n</span><span class="main">.</span> enat <span class="bound">n</span> <span class="main">&lt;</span> llength <span class="free">xs</span> <span class="main">∧</span> <span class="free">P</span> <span class="main">(</span>lnth <span class="free">xs</span> <span class="bound">n</span><span class="main">)</span><span class="main">}</span> <span class="main">⊆</span> <span class="main">{..&lt;</span><span class="skolem">m</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> finite_nat_iff_bounded <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">n</span><span class="main">.</span> <span class="main">⟦</span> <span class="skolem">m</span> <span class="main">≤</span> <span class="bound">n</span><span class="main">;</span> enat <span class="bound">n</span> <span class="main">&lt;</span> llength <span class="free">xs</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">¬</span> <span class="free">P</span> <span class="main">(</span>lnth <span class="free">xs</span> <span class="bound">n</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>lfilter <span class="free">P</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">m</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> 0
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lnull <span class="main">(</span>lfilter <span class="free">P</span> <span class="skolem">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> in_lset_conv_lnth<span class="main">)</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">m</span><span class="main">)</span>
      <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">n</span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">≤</span> <span class="skolem">n</span>"</span></span> <span class="quoted"><span class="quoted">"enat <span class="skolem">n</span> <span class="main">&lt;</span> llength <span class="main">(</span>ltl <span class="skolem">xs</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"Suc <span class="skolem">m</span> <span class="main">≤</span> Suc <span class="skolem">n</span>"</span></span> <span class="quoted"><span class="quoted">"enat <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span> <span class="main">&lt;</span> llength <span class="skolem">xs</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">xs</span></span></span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Suc_ile_eq<span class="main">)</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">P</span> <span class="main">(</span>lnth <span class="skolem">xs</span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> Suc<span class="main">)</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">P</span> <span class="main">(</span>lnth <span class="main">(</span>ltl <span class="skolem">xs</span><span class="main">)</span> <span class="skolem">n</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹enat <span class="skolem">n</span> <span class="main">&lt;</span> llength <span class="main">(</span>ltl <span class="skolem">xs</span><span class="main">)</span>›</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>lfilter <span class="free">P</span> <span class="main">(</span>ltl <span class="skolem">xs</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> Suc<span class="main">)</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>lfilter <span class="free">P</span> <span class="free">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lfilter_eq_LConsD"><span class="command">lemma</span></span> lfilter_eq_LConsD<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"lfilter <span class="free">P</span> <span class="free">ys</span> <span class="main">=</span> LCons <span class="free">x</span> <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">us</span> <span class="bound">vs</span><span class="main">.</span> <span class="free">ys</span> <span class="main">=</span> lappend <span class="bound">us</span> <span class="main">(</span>LCons <span class="free">x</span> <span class="bound">vs</span><span class="main">)</span> <span class="main">∧</span> lfinite <span class="bound">us</span> <span class="main">∧</span>
                      <span class="main">(</span><span class="main">∀</span><span class="bound">u</span><span class="main">∈</span>lset <span class="bound">us</span><span class="main">.</span> <span class="main">¬</span> <span class="free">P</span> <span class="bound">u</span><span class="main">)</span> <span class="main">∧</span> <span class="free">P</span> <span class="free">x</span> <span class="main">∧</span> <span class="free">xs</span> <span class="main">=</span> lfilter <span class="free">P</span> <span class="bound">vs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?us</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"ltakeWhile <span class="main">(</span>Not <span class="main">∘</span> <span class="free">P</span><span class="main">)</span> <span class="free">ys</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="var"><span class="quoted"><span class="var">?vs</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"ltl <span class="main">(</span>ldropWhile <span class="main">(</span>Not <span class="main">∘</span> <span class="free">P</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lnull <span class="main">(</span>lfilter <span class="free">P</span> <span class="free">ys</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> exP<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span><span class="main">∈</span>lset <span class="free">ys</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">from</span></span> eq_LConsD<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> lhd <span class="main">(</span>ldropWhile <span class="main">(</span>Not <span class="main">∘</span> <span class="free">P</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> ltl <span class="main">(</span>lfilter <span class="free">P</span> <span class="free">ys</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> exP
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">=</span> lappend <span class="var">?us</span> <span class="main">(</span>LCons <span class="free">x</span> <span class="var">?vs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> x <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="var">?us</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> exP <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lfinite_ltakeWhile<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">u</span><span class="main">∈</span>lset <span class="var">?us</span><span class="main">.</span> <span class="main">¬</span> <span class="free">P</span> <span class="bound">u</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lset_ltakeWhileD<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> x o_def
    <span class="keyword1"><span class="command">using</span></span> exP <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> lhd_ldropWhile<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> P<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"Not <span class="main"><span class="main"><span class="main">∘</span></span></span> <span class="free"><span class="free"><span class="free">P</span></span></span>"</span></span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> lfilter <span class="free">P</span> <span class="var">?vs</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> xs <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltl_lfilter<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lfilter_eq_lappend_lfiniteD"><span class="command">lemma</span></span> lfilter_eq_lappend_lfiniteD<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"lfilter <span class="free">P</span> <span class="free">xs</span> <span class="main">=</span> lappend <span class="free">ys</span> <span class="free">zs</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">us</span> <span class="bound">vs</span><span class="main">.</span> <span class="free">xs</span> <span class="main">=</span> lappend <span class="bound">us</span> <span class="bound">vs</span> <span class="main">∧</span> lfinite <span class="bound">us</span> <span class="main">∧</span>
                      <span class="free">ys</span> <span class="main">=</span> lfilter <span class="free">P</span> <span class="bound">us</span> <span class="main">∧</span> <span class="free">zs</span> <span class="main">=</span> lfilter <span class="free">P</span> <span class="bound">vs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹lfinite <span class="free">ys</span>›</span></span> <span class="quoted"><span class="quoted">‹lfilter <span class="free">P</span> <span class="free">xs</span> <span class="main">=</span> lappend <span class="free">ys</span> <span class="free">zs</span>›</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">zs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> lfinite_LNil
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> lappend LNil <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="quoted">"LNil <span class="main">=</span> lfilter <span class="free">P</span> LNil"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">zs</span> <span class="main">=</span> lfilter <span class="free">P</span> <span class="skolem">xs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>lfinite_LConsI <span class="skolem">ys</span> <span class="skolem">y</span><span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> IH <span class="main">=</span> <span class="quoted"><span class="quoted">‹<span class="main">⋀</span><span class="bound">xs</span> <span class="bound">zs</span><span class="main">.</span> lfilter <span class="free">P</span> <span class="bound">xs</span> <span class="main">=</span> lappend <span class="skolem">ys</span> <span class="bound">zs</span> <span class="main">⟹</span>
            <span class="main">∃</span><span class="bound">us</span> <span class="bound">vs</span><span class="main">.</span> <span class="bound">xs</span> <span class="main">=</span> lappend <span class="bound">us</span> <span class="bound">vs</span> <span class="main">∧</span> lfinite <span class="bound">us</span> <span class="main">∧</span>
                    <span class="skolem">ys</span> <span class="main">=</span> lfilter <span class="free">P</span> <span class="bound">us</span> <span class="main">∧</span> <span class="bound">zs</span> <span class="main">=</span> lfilter <span class="free">P</span> <span class="bound">vs</span>›</span></span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹lfilter <span class="free">P</span> <span class="skolem">xs</span> <span class="main">=</span> lappend <span class="main">(</span>LCons <span class="skolem">y</span> <span class="skolem">ys</span><span class="main">)</span> <span class="skolem">zs</span>›</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lfilter <span class="free">P</span> <span class="skolem">xs</span> <span class="main">=</span> LCons <span class="skolem">y</span> <span class="main">(</span>lappend <span class="skolem">ys</span> <span class="skolem">zs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">from</span></span> lfilter_eq_LConsD<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">us</span></span> <span class="skolem"><span class="skolem">vs</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> lappend <span class="skolem">us</span> <span class="main">(</span>LCons <span class="skolem">y</span> <span class="skolem">vs</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="skolem">us</span>"</span></span>
              <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="skolem">y</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">u</span><span class="main">∈</span>lset <span class="skolem">us</span><span class="main">.</span> <span class="main">¬</span> <span class="free">P</span> <span class="bound">u</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> vs<span class="main">:</span> <span class="quoted"><span class="quoted">"lfilter <span class="free">P</span> <span class="skolem">vs</span> <span class="main">=</span> lappend <span class="skolem">ys</span> <span class="skolem">zs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> IH<span class="main">[</span><span class="operator">OF</span> vs<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">us'</span></span> <span class="skolem"><span class="skolem">vs'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">vs</span> <span class="main">=</span> lappend <span class="skolem">us'</span> <span class="skolem">vs'</span>"</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="skolem">us'</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ys</span> <span class="main">=</span> lfilter <span class="free">P</span> <span class="skolem">us'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">zs</span> <span class="main">=</span> lfilter <span class="free">P</span> <span class="skolem">vs'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">with</span></span> xs <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lappend_snocL1_conv_LCons2<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">,</span></span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> ys<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"lappend <span class="skolem">us'</span> <span class="skolem">vs'</span>"</span></span><span class="main"><span class="main">]</span></span>
                           lappend_assoc<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-ldistinct_lfilterI"><span class="command">lemma</span></span> ldistinct_lfilterI<span class="main">:</span> <span class="quoted"><span class="quoted">"ldistinct <span class="free">xs</span> <span class="main">⟹</span> ldistinct <span class="main">(</span>lfilter <span class="free">P</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">notepad</span></span> <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">P</span> <span class="skolem">xs</span>
  <span class="keyword3"><span class="command">assume</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"ldistinct <span class="skolem">xs</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> * <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ldistinct <span class="main">(</span>lfilter <span class="skolem">P</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∧</span> lset <span class="main">(</span>lfilter <span class="skolem">P</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">⊆</span> lset <span class="skolem">xs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lfilter.fixp_induct<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split<span class="main"><span class="keyword3">,</span></span> <span class="operator">fastforce</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> * <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ldistinct <span class="main">(</span>lfilter <span class="skolem">P</span> <span class="skolem">xs</span><span class="main">)</span>"</span></span>
    <span class="comment1">― ‹only works because we use strong fixpoint induction›</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lfilter.fixp_induct<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> 4 4 <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> monotone_lset<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> monotoneD<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_ord_def<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Coinductive_List-ldistinct_lfilterD"><span class="command">lemma</span></span> ldistinct_lfilterD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> ldistinct <span class="main">(</span>lfilter <span class="free">P</span> <span class="free">xs</span><span class="main">)</span><span class="main">;</span> enat <span class="free">n</span> <span class="main">&lt;</span> llength <span class="free">xs</span><span class="main">;</span> enat <span class="free">m</span> <span class="main">&lt;</span> llength <span class="free">xs</span><span class="main">;</span> <span class="free">P</span> <span class="free">a</span><span class="main">;</span> lnth <span class="free">xs</span> <span class="free">n</span> <span class="main">=</span> <span class="free">a</span><span class="main">;</span> lnth <span class="free">xs</span> <span class="free">m</span> <span class="main">=</span> <span class="free">a</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">m</span> <span class="main">=</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">m</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> wlog_linorder_le<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> symmetry <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>le <span class="skolem">n</span> <span class="skolem">m</span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="skolem">m</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">m</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">m'</span><span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> 0 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Suc_ile_eq<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lset_conv_lnth<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹Suc <span class="skolem">n</span> <span class="main">≤</span> <span class="skolem">m</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">m'</span></span> <span class="keyword2"><span class="keyword">where</span></span> m <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">=</span> Suc <span class="skolem">m'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">m</span></span><span class="main">)</span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹Suc <span class="skolem">n</span> <span class="main">≤</span> <span class="skolem">m</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">≤</span> <span class="skolem">m'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹enat <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span> <span class="main">&lt;</span> llength <span class="skolem">xs</span>›</span></span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="skolem"><span class="skolem">xs'</span></span> <span class="keyword2"><span class="keyword">where</span></span> xs <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> LCons <span class="skolem">x</span> <span class="skolem">xs'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹ldistinct <span class="main">(</span>lfilter <span class="free">P</span> <span class="skolem">xs</span><span class="main">)</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ldistinct <span class="main">(</span>lfilter <span class="free">P</span> <span class="skolem">xs'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹enat <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span> <span class="main">&lt;</span> llength <span class="skolem">xs</span>›</span></span> <span class="quoted"><span class="quoted">‹enat <span class="skolem">m</span> <span class="main">&lt;</span> llength <span class="skolem">xs</span>›</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"enat <span class="skolem">n</span> <span class="main">&lt;</span> llength <span class="skolem">xs'</span>"</span></span> <span class="quoted"><span class="quoted">"enat <span class="skolem">m'</span> <span class="main">&lt;</span> llength <span class="skolem">xs'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Suc_ile_eq<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="free">P</span> <span class="free">a</span>›</span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lnth <span class="skolem">xs'</span> <span class="skolem">n</span> <span class="main">=</span> <span class="free">a</span>"</span></span> <span class="quoted"><span class="quoted">"lnth <span class="skolem">xs'</span> <span class="skolem">m'</span> <span class="main">=</span> <span class="free">a</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹lnth <span class="skolem">xs</span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span> <span class="main">=</span> <span class="free">a</span>›</span></span> <span class="quoted"><span class="quoted">‹lnth <span class="skolem">xs</span> <span class="skolem">m</span> <span class="main">=</span> <span class="free">a</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m'</span> <span class="main">=</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> Suc<span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> lfilter_fixp_parallel_induct <span class="main">=</span>
  parallel_fixp_induct_1_1<span class="main">[</span><span class="operator">OF</span> llist_partial_function_definitions llist_partial_function_definitions
    lfilter.mono lfilter.mono lfilter_def lfilter_def<span class="main">,</span> <span class="operator">case_names</span> adm LNil step<span class="main">]</span>

<span class="keyword1" id="Coinductive_List-llist_all2_lfilterI"><span class="command">lemma</span></span> llist_all2_lfilterI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"llist_all2 <span class="free">P</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> Q<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">⟹</span> <span class="free">Q1</span> <span class="bound">x</span> <span class="main">⟷</span> <span class="free">Q2</span> <span class="bound">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"llist_all2 <span class="free">P</span> <span class="main">(</span>lfilter <span class="free">Q1</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>lfilter <span class="free">Q2</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> * <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lfilter_fixp_parallel_induct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Q<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-distinct_filterD"><span class="command">lemma</span></span> distinct_filterD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> distinct <span class="main">(</span>filter <span class="free">P</span> <span class="free">xs</span><span class="main">)</span><span class="main">;</span> <span class="free">n</span> <span class="main">&lt;</span> length <span class="free">xs</span><span class="main">;</span> <span class="free">m</span> <span class="main">&lt;</span> length <span class="free">xs</span><span class="main">;</span> <span class="free">P</span> <span class="free">x</span><span class="main">;</span> <span class="free">xs</span> <span class="main">!</span> <span class="free">n</span> <span class="main">=</span> <span class="free">x</span><span class="main">;</span> <span class="free">xs</span> <span class="main">!</span> <span class="free">m</span> <span class="main">=</span> <span class="free">x</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">m</span> <span class="main">=</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> ldistinct_lfilterD<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">P</span></span> <span class="quoted"><span class="quoted">"llist_of <span class="free">xs</span>"</span></span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">m</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-lprefix_lfilterI"><span class="command">lemma</span></span> lprefix_lfilterI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">⊑</span> <span class="free">ys</span> <span class="main">⟹</span> lfilter <span class="free">P</span> <span class="free">xs</span> <span class="main">⊑</span> lfilter <span class="free">P</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monotoneD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> monotone_lfilter<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> preorder <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Coinductive_List-lsorted_lfilterI"><span class="command">lemma</span></span> lsorted_lfilterI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lsorted <span class="free">xs</span> <span class="main">⟹</span> lsorted <span class="main">(</span>lfilter <span class="free">P</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lsorted_LCons<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lsorted_lfilter_same"><span class="command">lemma</span></span> lsorted_lfilter_same<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lsorted <span class="main">(</span>lfilter <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">c</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lsorted_LCons<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Coinductive_List-lfilter_id_conv"><span class="command">lemma</span></span> lfilter_id_conv<span class="main">:</span> <span class="quoted"><span class="quoted">"lfilter <span class="free">P</span> <span class="free">xs</span> <span class="main">=</span> <span class="free">xs</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">∈</span>lset <span class="free">xs</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword1"><span class="command">with</span></span> lset_lfilter<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">P</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lfilter_repeat"><span class="command">lemma</span></span> lfilter_repeat <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lfilter <span class="free">P</span> <span class="main">(</span>repeat <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">P</span> <span class="free">x</span> <span class="keyword1">then</span> repeat <span class="free">x</span> <span class="keyword1">else</span> LNil<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lfilter_id_conv<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Concatenating all lazy lists in a lazy list: <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"lconcat"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1" id="Coinductive_List-lconcat_simps"><span class="command">lemma</span></span> lconcat_simps <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> lconcat_LNil<span class="main">:</span> <span class="quoted"><span class="quoted">"lconcat LNil <span class="main">=</span> LNil"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> lconcat_LCons<span class="main">:</span> <span class="quoted"><span class="quoted">"lconcat <span class="main">(</span>LCons <span class="free">xs</span> <span class="free">xss</span><span class="main">)</span> <span class="main">=</span> lappend <span class="free">xs</span> <span class="main">(</span>lconcat <span class="free">xss</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lconcat.simps<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> lconcat.mono<span class="main">[</span><span class="operator">cont_intro</span><span class="main">]</span>

<span class="keyword1" id="Coinductive_List-mono2mono_lconcat"><span class="command">lemma</span></span> mono2mono_lconcat<span class="main">[</span><span class="operator">THEN</span> llist.mono2mono<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> monotone_lconcat<span class="main">:</span> <span class="quoted"><span class="quoted">"monotone <span class="main">(⊑)</span> <span class="main">(⊑)</span> lconcat"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> llist.fixp_preserves_mono1<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lconcat.mono lconcat_def<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-mcont2mcont_lconcat"><span class="command">lemma</span></span> mcont2mcont_lconcat<span class="main">[</span><span class="operator">THEN</span> llist.mcont2mcont<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> mcont_lconcat<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont lSup <span class="main">(⊑)</span> lSup <span class="main">(⊑)</span> lconcat"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> llist.fixp_preserves_mcont1<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lconcat.mono lconcat_def<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-lconcat_eq_LNil"><span class="command">lemma</span></span> lconcat_eq_LNil<span class="main">:</span> <span class="quoted"><span class="quoted">"lconcat <span class="free">xss</span> <span class="main">=</span> LNil <span class="main">⟷</span> lset <span class="free">xss</span> <span class="main">⊆</span> <span class="main">{</span>LNil<span class="main">}</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xss</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lappend_eq_LNil_iff<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lnull_lconcat"><span class="command">lemma</span></span> lnull_lconcat <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lnull <span class="main">(</span>lconcat <span class="free">xss</span><span class="main">)</span> <span class="main">⟷</span> lset <span class="free">xss</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> lnull <span class="bound">xs</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> lnull_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lconcat_eq_LNil<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lconcat_llist_of"><span class="command">lemma</span></span> lconcat_llist_of<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lconcat <span class="main">(</span>llist_of <span class="main">(</span>map llist_of <span class="free">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> llist_of <span class="main">(</span>concat <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lappend_llist_of_llist_of<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lhd_lconcat"><span class="command">lemma</span></span> lhd_lconcat <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">¬</span> lnull <span class="free">xss</span><span class="main">;</span> <span class="main">¬</span> lnull <span class="main">(</span>lhd <span class="free">xss</span><span class="main">)</span> <span class="main">⟧</span> <span class="main">⟹</span> lhd <span class="main">(</span>lconcat <span class="free">xss</span><span class="main">)</span> <span class="main">=</span> lhd <span class="main">(</span>lhd <span class="free">xss</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lnull_conv<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ltl_lconcat"><span class="command">lemma</span></span> ltl_lconcat <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">¬</span> lnull <span class="free">xss</span><span class="main">;</span> <span class="main">¬</span> lnull <span class="main">(</span>lhd <span class="free">xss</span><span class="main">)</span> <span class="main">⟧</span> <span class="main">⟹</span> ltl <span class="main">(</span>lconcat <span class="free">xss</span><span class="main">)</span> <span class="main">=</span> lappend <span class="main">(</span>ltl <span class="main">(</span>lhd <span class="free">xss</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>lconcat <span class="main">(</span>ltl <span class="free">xss</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lnull_conv<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lmap_lconcat"><span class="command">lemma</span></span> lmap_lconcat<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lmap <span class="free">f</span> <span class="main">(</span>lconcat <span class="free">xss</span><span class="main">)</span> <span class="main">=</span> lconcat <span class="main">(</span>lmap <span class="main">(</span>lmap <span class="free">f</span><span class="main">)</span> <span class="free">xss</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xss</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lmap_lappend_distrib<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lconcat_lappend"><span class="command">lemma</span></span> lconcat_lappend <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xss</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lconcat <span class="main">(</span>lappend <span class="free">xss</span> <span class="free">yss</span><span class="main">)</span> <span class="main">=</span> lappend <span class="main">(</span>lconcat <span class="free">xss</span><span class="main">)</span> <span class="main">(</span>lconcat <span class="free">yss</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lappend_assoc<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lconcat_eq_LCons_conv"><span class="command">lemma</span></span> lconcat_eq_LCons_conv<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lconcat <span class="free">xss</span> <span class="main">=</span> LCons <span class="free">x</span> <span class="free">xs</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="main">∃</span><span class="bound">xs'</span> <span class="bound">xss'</span> <span class="bound">xss''</span><span class="main">.</span> <span class="free">xss</span> <span class="main">=</span> lappend <span class="main">(</span>llist_of <span class="bound">xss'</span><span class="main">)</span> <span class="main">(</span>LCons <span class="main">(</span>LCons <span class="free">x</span> <span class="bound">xs'</span><span class="main">)</span> <span class="bound">xss''</span><span class="main">)</span> <span class="main">∧</span>
                    <span class="free">xs</span> <span class="main">=</span> lappend <span class="bound">xs'</span> <span class="main">(</span>lconcat <span class="bound">xss''</span><span class="main">)</span> <span class="main">∧</span> set <span class="bound">xss'</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> lnull <span class="bound">xs</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rhs</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xs'</span></span> <span class="skolem"><span class="skolem">xss'</span></span> <span class="skolem"><span class="skolem">xss''</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">xss</span> <span class="main">=</span> lappend <span class="main">(</span>llist_of <span class="skolem">xss'</span><span class="main">)</span> <span class="main">(</span>LCons <span class="main">(</span>LCons <span class="free">x</span> <span class="skolem">xs'</span><span class="main">)</span> <span class="skolem">xss''</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> lappend <span class="skolem">xs'</span> <span class="main">(</span>lconcat <span class="skolem">xss''</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">xss'</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> lnull <span class="bound">xs</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹set <span class="skolem">xss'</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> lnull <span class="bound">xs</span><span class="main">}</span>›</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lnull <span class="main">(</span>lconcat <span class="main">(</span>llist_of <span class="skolem">xss'</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lappend_lnull1<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lnull <span class="main">(</span>lconcat <span class="free">xss</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lset <span class="free">xss</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> lnull <span class="bound">xs</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lnull <span class="main">(</span>lfilter <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">)</span> <span class="free">xss</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="skolem"><span class="skolem">ys</span></span> <span class="keyword2"><span class="keyword">where</span></span> yys<span class="main">:</span> <span class="quoted"><span class="quoted">"lfilter <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">)</span> <span class="free">xss</span> <span class="main">=</span> LCons <span class="skolem">y</span> <span class="skolem">ys</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> not_lnull_conv <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> lfilter_eq_LConsD<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">us</span></span> <span class="skolem"><span class="skolem">vs</span></span> <span class="keyword2"><span class="keyword">where</span></span> xss<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xss</span> <span class="main">=</span> lappend <span class="skolem">us</span> <span class="main">(</span>LCons <span class="skolem">y</span> <span class="skolem">vs</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="skolem">us</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"lset <span class="skolem">us</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> lnull <span class="bound">xs</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lnull <span class="skolem">y</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> ys<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">ys</span> <span class="main">=</span> lfilter <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">)</span> <span class="skolem">vs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹lfinite <span class="skolem">us</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">us'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">us</span> <span class="main">=</span> llist_of <span class="skolem">us'</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> lfinite_eq_range_llist_of <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹lset <span class="skolem">us</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> lnull <span class="bound">xs</span><span class="main">}</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> us<span class="main">:</span> <span class="quoted"><span class="quoted">"lnull <span class="main">(</span>lconcat <span class="skolem">us</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> lnull_lconcat <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> lnull <span class="skolem">y</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y'</span></span> <span class="skolem"><span class="skolem">ys'</span></span> <span class="keyword2"><span class="keyword">where</span></span> y<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">=</span> LCons <span class="skolem">y'</span> <span class="skolem">ys'</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> not_lnull_conv <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?lhs</span>›</span></span> us <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">y'</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> lappend <span class="skolem">ys'</span> <span class="main">(</span>lconcat <span class="skolem">vs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> xss y <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lappend_lnull1<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹lset <span class="skolem">us</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> lnull <span class="bound">xs</span><span class="main">}</span>›</span></span> ys <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> xss y <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-llength_lconcat_lfinite_conv_sum"><span class="command">lemma</span></span> llength_lconcat_lfinite_conv_sum<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xss</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"llength <span class="main">(</span>lconcat <span class="free">xss</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound"><span class="bound">i</span></span> <span class="main">|</span> enat <span class="bound">i</span> <span class="main">&lt;</span> llength <span class="free">xss</span><span class="main">.</span> llength <span class="main">(</span>lnth <span class="free">xss</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> lfinite_LNil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>lfinite_LConsI <span class="skolem">xss</span> <span class="skolem">xs</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">i</span><span class="main">.</span> enat <span class="bound">i</span> <span class="main">≤</span> llength <span class="skolem">xss</span><span class="main">}</span> <span class="main">=</span> insert <span class="main">0</span> <span class="main">{</span>Suc <span class="bound">i</span><span class="main">|</span><span class="bound">i</span><span class="main">.</span> enat <span class="bound">i</span> <span class="main">&lt;</span> llength <span class="skolem">xss</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> Suc_ile_eq gr0_conv_Suc<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> insert <span class="main">0</span> <span class="main">(</span>Suc <span class="main">`</span> <span class="main">{</span><span class="bound">i</span><span class="main">.</span> enat <span class="bound">i</span> <span class="main">&lt;</span> llength <span class="skolem">xss</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">∉</span> Suc <span class="main">`</span> <span class="main">{</span><span class="bound">i</span><span class="main">.</span> enat <span class="bound">i</span> <span class="main">&lt;</span> llength <span class="skolem">xss</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹lfinite <span class="skolem">xss</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">{</span><span class="bound">i</span><span class="main">.</span> enat <span class="bound">i</span> <span class="main">&lt;</span> llength <span class="skolem">xss</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> lfinite_finite_index<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> lfinite_LConsI
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sum.reindex<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lconcat_lfilter_neq_LNil"><span class="command">lemma</span></span> lconcat_lfilter_neq_LNil<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lconcat <span class="main">(</span>lfilter <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">)</span> <span class="free">xss</span><span class="main">)</span> <span class="main">=</span> lconcat <span class="free">xss</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xss</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lappend_lnull1<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> lconcat_fixp_parallel_induct <span class="main">=</span>
  parallel_fixp_induct_1_1<span class="main">[</span><span class="operator">OF</span> llist_partial_function_definitions llist_partial_function_definitions
    lconcat.mono lconcat.mono lconcat_def lconcat_def<span class="main">,</span> <span class="operator">case_names</span> adm LNil step<span class="main">]</span>

<span class="keyword1" id="Coinductive_List-llist_all2_lconcatI"><span class="command">lemma</span></span> llist_all2_lconcatI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"llist_all2 <span class="main">(</span>llist_all2 <span class="free">A</span><span class="main">)</span> <span class="free">xss</span> <span class="free">yss</span>
  <span class="main">⟹</span> llist_all2 <span class="free">A</span> <span class="main">(</span>lconcat <span class="free">xss</span><span class="main">)</span> <span class="main">(</span>lconcat <span class="free">yss</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xss</span></span> <span class="quoted"><span class="free">yss</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lconcat_fixp_parallel_induct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> llist_all2_lappendI<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llength_lconcat_eqI"><span class="command">lemma</span></span> llength_lconcat_eqI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">xss</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist llist"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">yss</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> llist llist"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"llist_all2 <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span> <span class="bound">ys</span><span class="main">.</span> llength <span class="bound">xs</span> <span class="main">=</span> llength <span class="bound">ys</span><span class="main">)</span> <span class="free">xss</span> <span class="free">yss</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"llength <span class="main">(</span>lconcat <span class="free">xss</span><span class="main">)</span> <span class="main">=</span> llength <span class="main">(</span>lconcat <span class="free">yss</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> llist_all2_llengthD<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> P<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">λ</span></span><span class="main"><span class="bound"><span class="main"><span class="bound">_</span></span></span></span> <span class="main"><span class="bound"><span class="main"><span class="bound">_</span></span></span></span><span class="main"><span class="main">.</span></span> True"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> llist_all2_lconcatI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_all2_True<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span> assms<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Coinductive_List-lset_lconcat_lfinite"><span class="command">lemma</span></span> lset_lconcat_lfinite<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">xs</span> <span class="main">∈</span> lset <span class="free">xss</span><span class="main">.</span> lfinite <span class="bound">xs</span> <span class="main">⟹</span> lset <span class="main">(</span>lconcat <span class="free">xss</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">xs</span><span class="main">∈</span>lset <span class="free">xss</span><span class="main">.</span> lset <span class="bound">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xss</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_List-lconcat_ltake"><span class="command">lemma</span></span> lconcat_ltake<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lconcat <span class="main">(</span>ltake <span class="main">(</span>enat <span class="free">n</span><span class="main">)</span> <span class="free">xss</span><span class="main">)</span> <span class="main">=</span> ltake <span class="main">(</span><span class="main">∑</span><span class="bound">i</span><span class="main">&lt;</span><span class="free">n</span><span class="main">.</span> llength <span class="main">(</span>lnth <span class="free">xss</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>lconcat <span class="free">xss</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xss</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xss</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> LNil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>LCons <span class="skolem">xs</span> <span class="skolem">xss'</span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lconcat <span class="main">(</span>ltake <span class="main">(</span>enat <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span><span class="main">)</span> <span class="skolem">xss</span><span class="main">)</span> <span class="main">=</span> lappend <span class="skolem">xs</span> <span class="main">(</span>lconcat <span class="main">(</span>ltake <span class="main">(</span>enat <span class="skolem">n</span><span class="main">)</span> <span class="skolem">xss'</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eSuc_enat<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lconcat <span class="main">(</span>ltake <span class="main">(</span>enat <span class="skolem">n</span><span class="main">)</span> <span class="skolem">xss'</span><span class="main">)</span> <span class="main">=</span> ltake <span class="main">(</span><span class="main">∑</span><span class="bound">i</span><span class="main">&lt;</span><span class="skolem">n</span><span class="main">.</span> llength <span class="main">(</span>lnth <span class="skolem">xss'</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>lconcat <span class="skolem">xss'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> Suc<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lappend <span class="skolem">xs</span> <span class="main">…</span> <span class="main">=</span> ltake <span class="main">(</span>llength <span class="skolem">xs</span> <span class="main">+</span> <span class="main">(</span><span class="main">∑</span><span class="bound">i</span><span class="main">&lt;</span><span class="skolem">n</span><span class="main">.</span> llength <span class="main">(</span>lnth <span class="skolem">xss'</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>lappend <span class="skolem">xs</span> <span class="main">(</span>lconcat <span class="skolem">xss'</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"llength <span class="skolem">xs</span>"</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltake_plus_conv_lappend ltake_lappend1 ltake_all ldropn_lappend2 lappend_inf lfinite_conv_llength_enat ldrop_enat<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">i</span><span class="main">&lt;</span><span class="skolem">n</span><span class="main">.</span> llength <span class="main">(</span>lnth <span class="skolem">xss'</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">i</span><span class="main">=</span><span class="main">1</span><span class="main">..&lt;</span>Suc <span class="skolem">n</span><span class="main">.</span> llength <span class="main">(</span>lnth <span class="skolem">xss</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> sum.reindex_cong <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">,</span></span> <span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted">Suc</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> LCons image_iff less_Suc_eq_0_disj<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"llength <span class="skolem">xs</span> <span class="main">+</span> <span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">i</span><span class="main">&lt;</span>Suc <span class="skolem">n</span><span class="main">.</span> llength <span class="main">(</span>lnth <span class="skolem">xss</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> atLeast0LessThan<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> LCons
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> sum.atLeast_Suc_lessThan<span class="main">)</span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> LCons <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lnth_lconcat_conv"><span class="command">lemma</span></span> lnth_lconcat_conv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"enat <span class="free">n</span> <span class="main">&lt;</span> llength <span class="main">(</span>lconcat <span class="free">xss</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">m</span> <span class="bound">n'</span><span class="main">.</span> lnth <span class="main">(</span>lconcat <span class="free">xss</span><span class="main">)</span> <span class="free">n</span> <span class="main">=</span> lnth <span class="main">(</span>lnth <span class="free">xss</span> <span class="bound">m</span><span class="main">)</span> <span class="bound">n'</span> <span class="main">∧</span> enat <span class="bound">n'</span> <span class="main">&lt;</span> llength <span class="main">(</span>lnth <span class="free">xss</span> <span class="bound">m</span><span class="main">)</span> <span class="main">∧</span>
                enat <span class="bound">m</span> <span class="main">&lt;</span> llength <span class="free">xss</span> <span class="main">∧</span> enat <span class="free">n</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">i</span><span class="main">&lt;</span><span class="bound">m</span> <span class="main">.</span> llength <span class="main">(</span>lnth <span class="free">xss</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span> enat <span class="bound">n'</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xss</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lnull <span class="main">(</span>lconcat <span class="skolem">xss</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="skolem"><span class="skolem">xs</span></span> <span class="keyword2"><span class="keyword">where</span></span> concat_xss<span class="main">:</span> <span class="quoted"><span class="quoted">"lconcat <span class="skolem">xss</span> <span class="main">=</span> LCons <span class="skolem">x</span> <span class="skolem">xs</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> not_lnull_conv <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xs'</span></span> <span class="skolem"><span class="skolem">xss'</span></span> <span class="skolem"><span class="skolem">xss''</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> xss<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xss</span> <span class="main">=</span> lappend <span class="main">(</span>llist_of <span class="skolem">xss'</span><span class="main">)</span> <span class="main">(</span>LCons <span class="main">(</span>LCons <span class="skolem">x</span> <span class="skolem">xs'</span><span class="main">)</span> <span class="skolem">xss''</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> lappend <span class="skolem">xs'</span> <span class="main">(</span>lconcat <span class="skolem">xss''</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> LNil<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="skolem">xss'</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> lnull <span class="bound">xs</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> lconcat_eq_LCons_conv <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">from</span></span> LNil <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lnull <span class="main">(</span>lconcat <span class="main">(</span>llist_of <span class="skolem">xss'</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lnth <span class="skolem">xss</span> <span class="main">(</span>length <span class="skolem">xss'</span><span class="main">)</span> <span class="main">=</span> LCons <span class="skolem">x</span> <span class="skolem">xs'</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> xss <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnth_lappend2<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lnth <span class="main">(</span>lconcat <span class="skolem">xss</span><span class="main">)</span> <span class="main">0</span> <span class="main">=</span> lnth <span class="main">(</span>lnth <span class="skolem">xss</span> <span class="main">(</span>length <span class="skolem">xss'</span><span class="main">)</span><span class="main">)</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> concat_xss xss <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"enat <span class="main">0</span> <span class="main">&lt;</span> llength <span class="main">(</span>lnth <span class="skolem">xss</span> <span class="main">(</span>length <span class="skolem">xss'</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"enat <span class="main">(</span>length <span class="skolem">xss'</span><span class="main">)</span> <span class="main">&lt;</span> llength <span class="skolem">xss</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> xss
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">i</span> <span class="main">&lt;</span> length <span class="skolem">xss'</span><span class="main">.</span> llength <span class="main">(</span>lnth <span class="skolem">xss</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">i</span> <span class="main">&lt;</span> length <span class="skolem">xss'</span><span class="main">.</span> <span class="main">0</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> sum.cong<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">{..&lt;</span> length <span class="skolem">xss'</span><span class="main">}</span> <span class="main">=</span> <span class="main">{..&lt;</span> length <span class="skolem">xss'</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">∈</span> <span class="main">{..&lt;</span> length <span class="skolem">xss'</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xss'</span> <span class="main">!</span> <span class="skolem">i</span> <span class="main">∈</span> set <span class="skolem">xss'</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> in_set_conv_nth <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">with</span></span> LNil <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xss'</span> <span class="main">!</span> <span class="skolem">i</span> <span class="main">=</span> LNil"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">i</span> <span class="main">∈</span> <span class="main">{..&lt;</span> length <span class="skolem">xss'</span><span class="main">}</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lnth <span class="skolem">xss</span> <span class="skolem">i</span> <span class="main">=</span> <span class="skolem">xss'</span> <span class="main">!</span> <span class="skolem">i</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> xss <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnth_lappend1<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"llength <span class="main">(</span>lnth <span class="skolem">xss</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"enat <span class="main">0</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">i</span><span class="main">&lt;</span>length <span class="skolem">xss'</span><span class="main">.</span> llength <span class="main">(</span>lnth <span class="skolem">xss</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span> enat <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹enat <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span> <span class="main">&lt;</span> llength <span class="main">(</span>lconcat <span class="skolem">xss</span><span class="main">)</span>›</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lnull <span class="main">(</span>lconcat <span class="skolem">xss</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="skolem"><span class="skolem">xs</span></span> <span class="keyword2"><span class="keyword">where</span></span> concat_xss<span class="main">:</span> <span class="quoted"><span class="quoted">"lconcat <span class="skolem">xss</span> <span class="main">=</span> LCons <span class="skolem">x</span> <span class="skolem">xs</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> not_lnull_conv <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xs'</span></span> <span class="skolem"><span class="skolem">xss'</span></span> <span class="skolem"><span class="skolem">xss''</span></span> <span class="keyword2"><span class="keyword">where</span></span> xss<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xss</span> <span class="main">=</span> lappend <span class="main">(</span>llist_of <span class="skolem">xss'</span><span class="main">)</span> <span class="main">(</span>LCons <span class="main">(</span>LCons <span class="skolem">x</span> <span class="skolem">xs'</span><span class="main">)</span> <span class="skolem">xss''</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> lappend <span class="skolem">xs'</span> <span class="main">(</span>lconcat <span class="skolem">xss''</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> LNil<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="skolem">xss'</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> lnull <span class="bound">xs</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> lconcat_eq_LCons_conv <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">from</span></span> LNil <span class="keyword1"><span class="command">have</span></span> concat_xss'<span class="main">:</span> <span class="quoted"><span class="quoted">"lnull <span class="main">(</span>lconcat <span class="main">(</span>llist_of <span class="skolem">xss'</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">from</span></span> xs <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> lconcat <span class="main">(</span>LCons <span class="skolem">xs'</span> <span class="skolem">xss''</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">with</span></span> concat_xss <span class="quoted"><span class="quoted">‹enat <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span> <span class="main">&lt;</span> llength <span class="main">(</span>lconcat <span class="skolem">xss</span><span class="main">)</span>›</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"enat <span class="skolem">n</span> <span class="main">&lt;</span> llength <span class="main">(</span>lconcat <span class="main">(</span>LCons <span class="skolem">xs'</span> <span class="skolem">xss''</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Suc_ile_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> Suc.hyps<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">m</span></span> <span class="skolem"><span class="skolem">n'</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> nth_n<span class="main">:</span> <span class="quoted"><span class="quoted">"lnth <span class="main">(</span>lconcat <span class="main">(</span>LCons <span class="skolem">xs'</span> <span class="skolem">xss''</span><span class="main">)</span><span class="main">)</span> <span class="skolem">n</span> <span class="main">=</span> lnth <span class="main">(</span>lnth <span class="main">(</span>LCons <span class="skolem">xs'</span> <span class="skolem">xss''</span><span class="main">)</span> <span class="skolem">m</span><span class="main">)</span> <span class="skolem">n'</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> n'<span class="main">:</span> <span class="quoted"><span class="quoted">"enat <span class="skolem">n'</span> <span class="main">&lt;</span> llength <span class="main">(</span>lnth <span class="main">(</span>LCons <span class="skolem">xs'</span> <span class="skolem">xss''</span><span class="main">)</span> <span class="skolem">m</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> m'<span class="main">:</span> <span class="quoted"><span class="quoted">"enat <span class="skolem">m</span> <span class="main">&lt;</span> llength <span class="main">(</span>LCons <span class="skolem">xs'</span> <span class="skolem">xss''</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> n_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"enat <span class="skolem">n</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">i</span> <span class="main">&lt;</span> <span class="skolem">m</span><span class="main">.</span> llength <span class="main">(</span>lnth <span class="main">(</span>LCons <span class="skolem">xs'</span> <span class="skolem">xss''</span><span class="main">)</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span> enat <span class="skolem">n'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">from</span></span> n_eq <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">N</span></span> <span class="keyword2"><span class="keyword">where</span></span> N<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">i</span> <span class="main">&lt;</span> <span class="skolem">m</span><span class="main">.</span> llength <span class="main">(</span>lnth <span class="main">(</span>LCons <span class="skolem">xs'</span> <span class="skolem">xss''</span><span class="main">)</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> enat <span class="skolem">N</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> n<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">=</span> <span class="skolem">N</span> <span class="main">+</span> <span class="skolem">n'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">∑</span><span class="bound">i</span> <span class="main">&lt;</span> <span class="skolem">m</span><span class="main">.</span> llength <span class="main">(</span>lnth <span class="main">(</span>LCons <span class="skolem">xs'</span> <span class="skolem">xss''</span><span class="main">)</span> <span class="bound">i</span><span class="main">)</span>"</span></span><span class="main">)</span> <span class="operator">simp_all</span>


  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span>
    <span class="keyword3"><span class="command">assume</span></span> i<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> length <span class="skolem">xss'</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xss'</span> <span class="main">!</span> <span class="skolem">i</span> <span class="main">=</span> LNil"</span></span> <span class="keyword1"><span class="command">using</span></span> LNil <span class="keyword1"><span class="command">unfolding</span></span> set_conv_nth <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lnth <span class="skolem">xss</span> <span class="skolem">i</span> <span class="main">=</span> LNil"</span></span> <span class="keyword1"><span class="command">using</span></span> i <span class="keyword1"><span class="command">unfolding</span></span> xss
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnth_lappend1<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">note</span></span> lnth_prefix <span class="main">=</span> this

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">m'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">=</span> Suc <span class="skolem">m'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">m</span></span><span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lnth <span class="main">(</span>lconcat <span class="skolem">xss</span><span class="main">)</span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span> <span class="main">=</span> lnth <span class="main">(</span>lnth <span class="skolem">xss</span> <span class="main">(</span><span class="skolem">m</span> <span class="main">+</span> length <span class="skolem">xss'</span><span class="main">)</span><span class="main">)</span> <span class="skolem">n'</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> concat_xss' nth_n <span class="keyword1"><span class="command">unfolding</span></span> xss <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnth_lappend2 lappend_lnull1<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"enat <span class="skolem">n'</span> <span class="main">&lt;</span> llength <span class="main">(</span>lnth <span class="skolem">xss</span> <span class="main">(</span><span class="skolem">m</span> <span class="main">+</span> length <span class="skolem">xss'</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> concat_xss' n' <span class="keyword1"><span class="command">unfolding</span></span> xss <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnth_lappend2<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"enat <span class="main">(</span><span class="skolem">m</span> <span class="main">+</span> length <span class="skolem">xss'</span><span class="main">)</span> <span class="main">&lt;</span> llength <span class="skolem">xss</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> concat_xss' m' <span class="keyword1"><span class="command">unfolding</span></span> xss
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Suc_ile_eq<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eSuc_enat<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> eSuc_plus_1
        plus_enat_simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> plus_enat_simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"enat <span class="main">(</span><span class="skolem">m</span> <span class="main">+</span> length <span class="skolem">xss'</span><span class="main">)</span> <span class="main">&lt;</span> llength <span class="skolem">xss</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> m' <span class="keyword1"><span class="command">unfolding</span></span> xss
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Suc_ile_eq<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eSuc_enat<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> eSuc_plus_1
        plus_enat_simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> plus_enat_simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">i</span> <span class="main">&lt;</span> <span class="skolem">m</span> <span class="main">+</span> length <span class="skolem">xss'</span><span class="main">.</span> llength <span class="main">(</span>lnth <span class="skolem">xss</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
            <span class="main">(</span><span class="main">∑</span><span class="bound">i</span> <span class="main">&lt;</span> length <span class="skolem">xss'</span><span class="main">.</span> llength <span class="main">(</span>lnth <span class="skolem">xss</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span>
            <span class="main">(</span><span class="main">∑</span><span class="bound">i</span> <span class="main">=</span> length <span class="skolem">xss'</span><span class="main">..&lt;</span><span class="skolem">m</span> <span class="main">+</span> length <span class="skolem">xss'</span><span class="main">.</span> llength <span class="main">(</span>lnth <span class="skolem">xss</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2<span class="main"><span class="main">)</span></span> atLeast0LessThan<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">subst</span> sum.atLeastLessThan_concat<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> lnth_prefix <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">i</span> <span class="main">&lt;</span> length <span class="skolem">xss'</span><span class="main">.</span> llength <span class="main">(</span>lnth <span class="skolem">xss</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span>length <span class="skolem">xss'</span><span class="main">..&lt;</span><span class="skolem">m</span> <span class="main">+</span> length <span class="skolem">xss'</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="main">0</span><span class="main">+</span>length <span class="skolem">xss'</span><span class="main">..&lt;</span><span class="skolem">m</span><span class="main">+</span>length <span class="skolem">xss'</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">i</span> <span class="main">=</span> <span class="main">0</span> <span class="main">+</span> length <span class="skolem">xss'</span><span class="main">..&lt;</span><span class="skolem">m</span> <span class="main">+</span> length <span class="skolem">xss'</span><span class="main">.</span> llength <span class="main">(</span>lnth <span class="skolem">xss</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
                <span class="main">(</span><span class="main">∑</span><span class="bound">i</span> <span class="main">=</span> <span class="main">0</span><span class="main">..&lt;</span><span class="skolem">m</span><span class="main">.</span> llength <span class="main">(</span>lnth <span class="skolem">xss</span> <span class="main">(</span><span class="bound">i</span> <span class="main">+</span> length <span class="skolem">xss'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> sum.shift_bounds_nat_ivl<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">i</span> <span class="main">=</span> <span class="main">0</span><span class="main">..&lt;</span><span class="skolem">m</span><span class="main">.</span> llength <span class="main">(</span>lnth <span class="main">(</span>LCons <span class="main">(</span>LCons <span class="skolem">x</span> <span class="skolem">xs'</span><span class="main">)</span> <span class="skolem">xss''</span><span class="main">)</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> xss <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> lnth_lappend2<span class="main">)</span> <span class="operator">simp</span><span class="main"><span class="keyword3">+</span></span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> eSuc <span class="main">(</span>llength <span class="skolem">xs'</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="main">∑</span><span class="bound">i</span> <span class="main">=</span> Suc <span class="main">0</span><span class="main">..&lt;</span><span class="skolem">m</span><span class="main">.</span> llength <span class="main">(</span>lnth <span class="main">(</span>LCons <span class="main">(</span>LCons <span class="skolem">x</span> <span class="skolem">xs'</span><span class="main">)</span> <span class="skolem">xss''</span><span class="main">)</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> sum.atLeast_Suc_lessThan<span class="main">)</span> <span class="operator">simp_all</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">{</span></span>
        <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">∈</span> <span class="main">{</span>Suc <span class="main">0</span><span class="main">..&lt;</span><span class="skolem">m</span><span class="main">}</span>"</span></span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">i'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">=</span> Suc <span class="skolem">i'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">i</span></span><span class="main">)</span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"llength <span class="main">(</span>lnth <span class="main">(</span>LCons <span class="main">(</span>LCons <span class="skolem">x</span> <span class="skolem">xs'</span><span class="main">)</span> <span class="skolem">xss''</span><span class="main">)</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">=</span> llength <span class="main">(</span>lnth <span class="main">(</span>LCons <span class="skolem">xs'</span> <span class="skolem">xss''</span><span class="main">)</span> <span class="skolem">i</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="keyword1"><span class="command">}</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">i</span> <span class="main">=</span> Suc <span class="main">0</span><span class="main">..&lt;</span><span class="skolem">m</span><span class="main">.</span> llength <span class="main">(</span>lnth <span class="main">(</span>LCons <span class="main">(</span>LCons <span class="skolem">x</span> <span class="skolem">xs'</span><span class="main">)</span> <span class="skolem">xss''</span><span class="main">)</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
             <span class="main">(</span><span class="main">∑</span><span class="bound">i</span> <span class="main">=</span> Suc <span class="main">0</span><span class="main">..&lt;</span><span class="skolem">m</span><span class="main">.</span> llength <span class="main">(</span>lnth <span class="main">(</span>LCons <span class="skolem">xs'</span> <span class="skolem">xss''</span><span class="main">)</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"eSuc <span class="main">(</span>llength <span class="skolem">xs'</span><span class="main">)</span> <span class="main">+</span> <span class="main">…</span> <span class="main">=</span> <span class="main">1</span> <span class="main">+</span> <span class="main">(</span>llength <span class="main">(</span>lnth <span class="main">(</span>LCons <span class="skolem">xs'</span> <span class="skolem">xss''</span><span class="main">)</span> <span class="main">0</span><span class="main">)</span> <span class="main">+</span> <span class="main">…</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eSuc_plus_1 <span class="dynamic"><span class="dynamic">ac_simps</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> sum.atLeast_Suc_lessThan<span class="main">[</span><span class="operator">symmetric</span><span class="main">,</span> <span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="main">0</span> <span class="main">&lt;</span> <span class="skolem">m</span>›</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"enat <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">i</span><span class="main">&lt;</span><span class="skolem">m</span> <span class="main">+</span> length <span class="skolem">xss'</span><span class="main">.</span> llength <span class="main">(</span>lnth <span class="skolem">xss</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span> enat <span class="skolem">n'</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> eSuc_enat<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> n_eq <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eSuc_plus_1 <span class="dynamic"><span class="dynamic">ac_simps</span></span> atLeast0LessThan<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lnth <span class="main">(</span>lconcat <span class="skolem">xss</span><span class="main">)</span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span> <span class="main">=</span> lnth <span class="main">(</span>lnth <span class="skolem">xss</span> <span class="main">(</span>length <span class="skolem">xss'</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Suc <span class="skolem">n'</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> concat_xss n_eq xs n'
      <span class="keyword1"><span class="command">unfolding</span></span> xss <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnth_lappend1 lnth_lappend2<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"enat <span class="main">(</span>Suc <span class="skolem">n'</span><span class="main">)</span> <span class="main">&lt;</span> llength <span class="main">(</span>lnth <span class="skolem">xss</span> <span class="main">(</span>length <span class="skolem">xss'</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> concat_xss n' <span class="keyword1"><span class="command">unfolding</span></span> xss <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnth_lappend2 Suc_ile_eq<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"enat <span class="main">(</span>length <span class="skolem">xss'</span><span class="main">)</span> <span class="main">&lt;</span> llength <span class="skolem">xss</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> xss
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> lnth_prefix <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">i</span><span class="main">&lt;</span>length <span class="skolem">xss'</span><span class="main">.</span> llength <span class="main">(</span>lnth <span class="skolem">xss</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"enat <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">i</span><span class="main">&lt;</span>length <span class="skolem">xss'</span><span class="main">.</span> llength <span class="main">(</span>lnth <span class="skolem">xss</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span> enat <span class="main">(</span>Suc <span class="skolem">n'</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> n_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lprefix_lconcatI"><span class="command">lemma</span></span> lprefix_lconcatI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">xss</span> <span class="main">⊑</span> <span class="free">yss</span> <span class="main">⟹</span> lconcat <span class="free">xss</span> <span class="main">⊑</span> lconcat <span class="free">yss</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monotoneD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> monotone_lconcat<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lnth_lconcat_ltake"><span class="command">lemma</span></span> lnth_lconcat_ltake<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"enat <span class="free">w</span> <span class="main">&lt;</span> llength <span class="main">(</span>lconcat <span class="main">(</span>ltake <span class="main">(</span>enat <span class="free">n</span><span class="main">)</span> <span class="free">xss</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lnth <span class="main">(</span>lconcat <span class="main">(</span>ltake <span class="main">(</span>enat <span class="free">n</span><span class="main">)</span> <span class="free">xss</span><span class="main">)</span><span class="main">)</span> <span class="free">w</span> <span class="main">=</span> lnth <span class="main">(</span>lconcat <span class="free">xss</span><span class="main">)</span> <span class="free">w</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> lprefix_lnthD lprefix_lconcatI<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lfinite_lconcat"><span class="command">lemma</span></span> lfinite_lconcat <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>lconcat <span class="free">xss</span><span class="main">)</span> <span class="main">⟷</span> lfinite <span class="main">(</span>lfilter <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">)</span> <span class="free">xss</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">xs</span> <span class="main">∈</span> lset <span class="free">xss</span><span class="main">.</span> lfinite <span class="bound">xs</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rhs</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?concl</span> <span class="free">xss</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"lconcat <span class="free">xss</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xss</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span><span class="main">:</span> lfinite_LNil
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">hence</span></span></span> <span class="quoted"><span class="quoted">"lnull <span class="main">(</span>lfilter <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">)</span> <span class="skolem">xss</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lconcat_eq_LNil<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>lfinite_LConsI <span class="skolem">xs</span> <span class="skolem">x</span><span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹LCons <span class="skolem">x</span> <span class="skolem">xs</span> <span class="main">=</span> lconcat <span class="skolem">xss</span>›</span></span><span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xs'</span></span> <span class="skolem"><span class="skolem">xss'</span></span> <span class="skolem"><span class="skolem">xss''</span></span> <span class="keyword2"><span class="keyword">where</span></span> xss <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xss</span> <span class="main">=</span> lappend <span class="main">(</span>llist_of <span class="skolem">xss'</span><span class="main">)</span> <span class="main">(</span>LCons <span class="main">(</span>LCons <span class="skolem">x</span> <span class="skolem">xs'</span><span class="main">)</span> <span class="skolem">xss''</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> xs <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> lappend <span class="skolem">xs'</span> <span class="main">(</span>lconcat <span class="skolem">xss''</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> xss'<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="skolem">xss'</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> lnull <span class="bound">xs</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> lconcat_eq_LCons_conv <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> lconcat <span class="main">(</span>LCons <span class="skolem">xs'</span> <span class="skolem">xss''</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="var">?concl</span> <span class="main">(</span>LCons <span class="skolem">xs'</span> <span class="skolem">xss''</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> lfinite_LConsI<span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹lfinite <span class="skolem">xs</span>›</span></span> xss' <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rhs</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>lfilter <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">)</span> <span class="free">xss</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">xs</span><span class="main">∈</span>lset <span class="free">xss</span><span class="main">.</span> lfinite <span class="bound">xs</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"lfilter <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">)</span> <span class="free">xss</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xss</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> lfinite_LNil
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹LNil <span class="main">=</span> lfilter <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">)</span> <span class="skolem">xss</span>›</span></span><span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lset <span class="skolem">xss</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> lnull <span class="bound">xs</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> lfilter_empty_conv <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lnull <span class="main">(</span>lconcat <span class="skolem">xss</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>lfinite_LConsI <span class="skolem">xs</span> <span class="skolem">x</span><span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> lfilter_eq_LConsD<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹LCons <span class="skolem">x</span> <span class="skolem">xs</span> <span class="main">=</span> lfilter <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">)</span> <span class="skolem">xss</span>›</span></span><span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">]</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xss'</span></span> <span class="skolem"><span class="skolem">xss''</span></span> <span class="keyword2"><span class="keyword">where</span></span> xss <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xss</span> <span class="main">=</span> lappend <span class="skolem">xss'</span> <span class="main">(</span>LCons <span class="skolem">x</span> <span class="skolem">xss''</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> xss'<span class="main">:</span> <span class="quoted"><span class="quoted">"lfinite <span class="skolem">xss'</span>"</span></span> <span class="quoted"><span class="quoted">"lset <span class="skolem">xss'</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> lnull <span class="bound">xs</span><span class="main">}</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lnull <span class="skolem">x</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> xs <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> lfilter <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">)</span> <span class="skolem">xss''</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="main">∀</span><span class="bound">xs</span><span class="main">∈</span>lset <span class="skolem">xss</span><span class="main">.</span> lfinite <span class="bound">xs</span>›</span></span> xss' <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">xs</span><span class="main">∈</span>lset <span class="skolem">xss''</span><span class="main">.</span> lfinite <span class="bound">xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> xs <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>lconcat <span class="skolem">xss''</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> lfinite_LConsI<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">∀</span><span class="bound">xs</span><span class="main">∈</span>lset <span class="skolem">xss</span><span class="main">.</span> lfinite <span class="bound">xs</span>›</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-list_of_lconcat"><span class="command">lemma</span></span> list_of_lconcat<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xss</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">xs</span> <span class="main">∈</span> lset <span class="free">xss</span><span class="main">.</span> lfinite <span class="bound">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"list_of <span class="main">(</span>lconcat <span class="free">xss</span><span class="main">)</span> <span class="main">=</span> concat <span class="main">(</span>list_of <span class="main">(</span>lmap list_of <span class="free">xss</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list_of_lappend<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lfilter_lconcat_lfinite"><span class="command">lemma</span></span> lfilter_lconcat_lfinite<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">xs</span><span class="main">∈</span>lset <span class="free">xss</span><span class="main">.</span> lfinite <span class="bound">xs</span>
  <span class="main">⟹</span> lfilter <span class="free">P</span> <span class="main">(</span>lconcat <span class="free">xss</span><span class="main">)</span> <span class="main">=</span> lconcat <span class="main">(</span>lmap <span class="main">(</span>lfilter <span class="free">P</span><span class="main">)</span> <span class="free">xss</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xss</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-lconcat_repeat_LNil"><span class="command">lemma</span></span> lconcat_repeat_LNil <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lconcat <span class="main">(</span>repeat LNil<span class="main">)</span> <span class="main">=</span> LNil"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lconcat_eq_LNil<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lconcat_lmap_singleton"><span class="command">lemma</span></span> lconcat_lmap_singleton <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lconcat <span class="main">(</span>lmap <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> LCons <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> LNil<span class="main">)</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lmap <span class="free">f</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-lset_lconcat_subset"><span class="command">lemma</span></span> lset_lconcat_subset<span class="main">:</span> <span class="quoted"><span class="quoted">"lset <span class="main">(</span>lconcat <span class="free">xss</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">xs</span><span class="main">∈</span>lset <span class="free">xss</span><span class="main">.</span> lset <span class="bound">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xss</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> subsetD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lset_lappend<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ldistinct_lconcat"><span class="command">lemma</span></span> ldistinct_lconcat<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> ldistinct <span class="free">xss</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">ys</span><span class="main">.</span> <span class="bound">ys</span> <span class="main">∈</span> lset <span class="free">xss</span> <span class="main">⟹</span> ldistinct <span class="bound">ys</span><span class="main">;</span>
     <span class="main">⋀</span><span class="bound">ys</span> <span class="bound">zs</span><span class="main">.</span> <span class="main">⟦</span> <span class="bound">ys</span> <span class="main">∈</span> lset <span class="free">xss</span><span class="main">;</span> <span class="bound">zs</span> <span class="main">∈</span> lset <span class="free">xss</span><span class="main">;</span> <span class="bound">ys</span> <span class="main">≠</span> <span class="bound">zs</span> <span class="main">⟧</span> <span class="main">⟹</span> lset <span class="bound">ys</span> <span class="main">∩</span> lset <span class="bound">zs</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">⟧</span>
  <span class="main">⟹</span> ldistinct <span class="main">(</span>lconcat <span class="free">xss</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xss</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lconcat.fixp_induct<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldistinct_lappend fun_ord_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> subsetD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lprefix_lsetD<span class="main"><span class="main">]</span></span> subsetD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lset_lconcat_subset<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Sublist view of a lazy list: <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"lnths"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1" id="Coinductive_List-lnths_empty"><span class="command">lemma</span></span> lnths_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lnths <span class="free">xs</span> <span class="main">{}</span> <span class="main">=</span> LNil"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnths_def split_def lfilter_empty_conv<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lnths_LNil"><span class="command">lemma</span></span> lnths_LNil <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lnths LNil <span class="free">A</span> <span class="main">=</span> LNil"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnths_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lnths_LCons"><span class="command">lemma</span></span> lnths_LCons<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lnths <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="free">A</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="main">0</span> <span class="main">∈</span> <span class="free">A</span> <span class="keyword1">then</span> LCons <span class="free">x</span> <span class="main">(</span>lnths <span class="free">xs</span> <span class="main">{</span><span class="bound">n</span><span class="main">.</span> Suc <span class="bound">n</span> <span class="main">∈</span> <span class="free">A</span><span class="main">}</span><span class="main">)</span> <span class="keyword1">else</span> lnths <span class="free">xs</span> <span class="main">{</span><span class="bound">n</span><span class="main">.</span> Suc <span class="bound">n</span> <span class="main">∈</span> <span class="free">A</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?it</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"iterates Suc"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?f</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> Suc <span class="bound">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">n</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lzip <span class="free">xs</span> <span class="main">(</span><span class="var">?it</span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> lmap <span class="var">?f</span> <span class="main">(</span>lzip <span class="free">xs</span> <span class="main">(</span><span class="var">?it</span> <span class="skolem">n</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="skolem">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lmap fst <span class="main">(</span>lfilter <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free">A</span><span class="main">)</span> <span class="main">(</span>lzip <span class="free">xs</span> <span class="main">(</span><span class="var">?it</span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
           lmap fst <span class="main">(</span>lfilter <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> Suc <span class="bound">y</span> <span class="main">∈</span> <span class="free">A</span><span class="main">)</span> <span class="main">(</span>lzip <span class="free">xs</span> <span class="main">(</span><span class="var">?it</span> <span class="skolem">n</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lfilter_lmap o_def split_def llist.map_comp<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnths_def<span class="main">)</span><span class="main">(</span><span class="operator">subst</span> iterates<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lset_lnths"><span class="command">lemma</span></span> lset_lnths<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lset <span class="main">(</span>lnths <span class="free">xs</span> <span class="free">I</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span>lnth <span class="free">xs</span> <span class="bound">i</span><span class="main">|</span><span class="bound">i</span><span class="main">.</span> enat <span class="bound">i</span><span class="main">&lt;</span>llength <span class="free">xs</span> <span class="main">∧</span> <span class="bound">i</span> <span class="main">∈</span> <span class="free">I</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnths_def lset_lzip<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span>lnth <span class="free">xs</span> <span class="improper">i</span><span class="main">,</span> <span class="improper">i</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> image_eqI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Coinductive_List-lset_lnths_subset"><span class="command">lemma</span></span> lset_lnths_subset<span class="main">:</span> <span class="quoted"><span class="quoted">"lset <span class="main">(</span>lnths <span class="free">xs</span> <span class="free">I</span><span class="main">)</span> <span class="main">⊆</span> lset <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lset_lnths in_lset_conv_lnth<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lnths_singleton"><span class="command">lemma</span></span> lnths_singleton <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lnths <span class="main">(</span>LCons <span class="free">x</span> LNil<span class="main">)</span> <span class="free">A</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="main">0</span> <span class="main">:</span> <span class="free">A</span> <span class="keyword1">then</span> LCons <span class="free">x</span> LNil <span class="keyword1">else</span> LNil<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnths_LCons<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lnths_upt_eq_ltake"><span class="command">lemma</span></span> lnths_upt_eq_ltake <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lnths <span class="free">xs</span> <span class="main">{..&lt;</span><span class="free">n</span><span class="main">}</span> <span class="main">=</span> ltake <span class="main">(</span>enat <span class="free">n</span><span class="main">)</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> sym<span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eSuc_enat<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> lnths_LCons lessThan_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lnths_llist_of"><span class="command">lemma</span></span> lnths_llist_of <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lnths <span class="main">(</span>llist_of <span class="free">xs</span><span class="main">)</span> <span class="free">A</span> <span class="main">=</span> llist_of <span class="main">(</span>nths <span class="free">xs</span> <span class="free">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">A</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnths_LCons nths_Cons<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llength_lnths_ile"><span class="command">lemma</span></span> llength_lnths_ile<span class="main">:</span> <span class="quoted"><span class="quoted">"llength <span class="main">(</span>lnths <span class="free">xs</span> <span class="free">A</span><span class="main">)</span> <span class="main">≤</span> llength <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"llength <span class="main">(</span>lfilter <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free">A</span><span class="main">)</span> <span class="main">(</span>lzip <span class="free">xs</span> <span class="main">(</span>iterates Suc <span class="main">0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span>
        llength <span class="main">(</span>lzip <span class="free">xs</span> <span class="main">(</span>iterates Suc <span class="main">0</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> llength_lfilter_ile<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnths_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lnths_lmap"><span class="command">lemma</span></span> lnths_lmap <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lnths <span class="main">(</span>lmap <span class="free">f</span> <span class="free">xs</span><span class="main">)</span> <span class="free">A</span> <span class="main">=</span> lmap <span class="free">f</span> <span class="main">(</span>lnths <span class="free">xs</span> <span class="free">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnths_def lzip_lmap1 llist.map_comp lfilter_lmap o_def split_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lfilter_conv_lnths"><span class="command">lemma</span></span> lfilter_conv_lnths<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lfilter <span class="free">P</span> <span class="free">xs</span> <span class="main">=</span> lnths <span class="free">xs</span> <span class="main">{</span><span class="bound">n</span><span class="main">.</span> enat <span class="bound">n</span> <span class="main">&lt;</span> llength <span class="free">xs</span> <span class="main">∧</span> <span class="free">P</span> <span class="main">(</span>lnth <span class="free">xs</span> <span class="bound">n</span><span class="main">)</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lnths <span class="free">xs</span> <span class="main">{</span><span class="bound">n</span><span class="main">.</span> enat <span class="bound">n</span> <span class="main">&lt;</span> llength <span class="free">xs</span> <span class="main">∧</span> <span class="free">P</span> <span class="main">(</span>lnth <span class="free">xs</span> <span class="bound">n</span><span class="main">)</span><span class="main">}</span> <span class="main">=</span>
        lmap fst <span class="main">(</span>lfilter <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> enat <span class="bound">y</span> <span class="main">&lt;</span> llength <span class="free">xs</span> <span class="main">∧</span> <span class="free">P</span> <span class="main">(</span>lnth <span class="free">xs</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>
                          <span class="main">(</span>lzip <span class="free">xs</span> <span class="main">(</span>iterates Suc <span class="main">0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnths_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">∈</span>lset <span class="main">(</span>lzip <span class="free">xs</span> <span class="main">(</span>iterates Suc <span class="main">0</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> enat <span class="bound">y</span> <span class="main">&lt;</span> llength <span class="free">xs</span> <span class="main">∧</span> <span class="bound">x</span> <span class="main">=</span> lnth <span class="free">xs</span> <span class="bound">y</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lset_lzip<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lfilter <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> enat <span class="bound">y</span> <span class="main">&lt;</span> llength <span class="free">xs</span> <span class="main">∧</span> <span class="free">P</span> <span class="main">(</span>lnth <span class="free">xs</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>lzip <span class="free">xs</span> <span class="main">(</span>iterates Suc <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
         lfilter <span class="main">(</span><span class="free">P</span> <span class="main">∘</span> fst<span class="main">)</span> <span class="main">(</span>lzip <span class="free">xs</span> <span class="main">(</span>iterates Suc <span class="main">0</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span><span class="main">(</span><span class="operator">rule</span> lfilter_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lmap fst <span class="main">(</span>lfilter <span class="main">(</span><span class="free">P</span> <span class="main">∘</span> fst<span class="main">)</span> <span class="main">(</span>lzip <span class="free">xs</span> <span class="main">(</span>iterates Suc <span class="main">0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
            lfilter <span class="free">P</span> <span class="main">(</span>lmap fst <span class="main">(</span>lzip <span class="free">xs</span> <span class="main">(</span>iterates Suc <span class="main">0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> lfilter_lmap <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lmap fst <span class="main">(</span>lzip <span class="free">xs</span> <span class="main">(</span>iterates Suc <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lmap_fst_lzip_conv_ltake ltake_all<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-ltake_iterates_Suc"><span class="command">lemma</span></span> ltake_iterates_Suc<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ltake <span class="main">(</span>enat <span class="free">n</span><span class="main">)</span> <span class="main">(</span>iterates Suc <span class="free">m</span><span class="main">)</span> <span class="main">=</span> llist_of <span class="main">[</span><span class="free">m</span><span class="main">..&lt;</span><span class="free">n</span> <span class="main">+</span> <span class="free">m</span><span class="main">]</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">m</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ltake <span class="main">(</span>enat <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>iterates Suc <span class="skolem">m</span><span class="main">)</span> <span class="main">=</span>
        LCons <span class="skolem">m</span> <span class="main">(</span>ltake <span class="main">(</span>enat <span class="skolem">n</span><span class="main">)</span> <span class="main">(</span>iterates Suc <span class="main">(</span>Suc <span class="skolem">m</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> iterates<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eSuc_enat<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> Suc
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"LCons <span class="skolem">m</span> <span class="main">(</span>llist_of <span class="main">[</span>Suc <span class="skolem">m</span><span class="main">..&lt;</span><span class="skolem">n</span> <span class="main">+</span> Suc <span class="skolem">m</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> llist_of <span class="main">[</span><span class="skolem">m</span><span class="main">..&lt;</span>Suc <span class="skolem">n</span><span class="main">+</span><span class="skolem">m</span><span class="main">]</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> llist_of.simps<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> llist_of.simps <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> upt_conv_Cons<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lnths_lappend_lfinite"><span class="command">lemma</span></span> lnths_lappend_lfinite<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> len<span class="main">:</span> <span class="quoted"><span class="quoted">"llength <span class="free">xs</span> <span class="main">=</span> enat <span class="free">k</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lnths <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="free">A</span> <span class="main">=</span>
         lappend <span class="main">(</span>lnths <span class="free">xs</span> <span class="free">A</span><span class="main">)</span> <span class="main">(</span>lnths <span class="free">ys</span> <span class="main">{</span><span class="bound">n</span><span class="main">.</span> <span class="bound">n</span> <span class="main">+</span> <span class="free">k</span> <span class="main">∈</span> <span class="free">A</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?it</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"iterates Suc"</span></span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> fin<span class="main">:</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> llength_eq_enat_lfiniteD<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lnths <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="free">A</span> <span class="main">=</span>
    lmap fst <span class="main">(</span>lfilter <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free">A</span><span class="main">)</span> <span class="main">(</span>lzip <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">(</span><span class="var">?it</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnths_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?it</span> <span class="main">0</span> <span class="main">=</span> lappend <span class="main">(</span>ltake <span class="main">(</span>enat <span class="free">k</span><span class="main">)</span> <span class="main">(</span><span class="var">?it</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>ldrop <span class="main">(</span>enat <span class="free">k</span><span class="main">)</span> <span class="main">(</span><span class="var">?it</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> lappend_ltake_ldrop<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> lzip_lappend
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> lfilter_lappend_lfinite
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> lmap_lappend_distrib
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lzip <span class="free">xs</span> <span class="main">(</span>ltake <span class="main">(</span>enat <span class="free">k</span><span class="main">)</span> <span class="main">(</span><span class="var">?it</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> lzip <span class="free">xs</span> <span class="main">(</span><span class="var">?it</span> <span class="main">0</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> len <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2<span class="main"><span class="main">)</span></span> lzip_conv_lzip_ltake_min_llength<span class="main">)</span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> lnths_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ldrop <span class="main">(</span>enat <span class="free">k</span><span class="main">)</span> <span class="main">(</span><span class="var">?it</span> <span class="main">0</span><span class="main">)</span> <span class="main">=</span> <span class="var">?it</span> <span class="free">k</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldrop_iterates<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">n</span> <span class="skolem">m</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?it</span> <span class="main">(</span><span class="skolem">n</span> <span class="main">+</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">=</span> lmap <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="bound">n</span> <span class="main">+</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">(</span><span class="var">?it</span> <span class="skolem">n</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">force</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="main">0</span></span> <span class="quoted"><span class="free">k</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?it</span> <span class="free">k</span> <span class="main">=</span> lmap <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="bound">n</span> <span class="main">+</span> <span class="free">k</span><span class="main">)</span> <span class="main">(</span><span class="var">?it</span> <span class="main">0</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> lzip_lmap2
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> lfilter_lmap
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> llist.map_comp
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"fst <span class="main">∘</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span> <span class="main">+</span> <span class="free">k</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> fst"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_def split_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free">A</span><span class="main">)</span> <span class="main">∘</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span> <span class="main">+</span> <span class="free">k</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">y</span> <span class="main">∈</span> <span class="main">{</span><span class="bound">n</span><span class="main">.</span> <span class="bound">n</span> <span class="main">+</span> <span class="free">k</span> <span class="main">∈</span> <span class="free">A</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> lnths_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> len <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lnths_split"><span class="command">lemma</span></span> lnths_split<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lnths <span class="free">xs</span> <span class="free">A</span> <span class="main">=</span>
   lappend <span class="main">(</span>lnths <span class="main">(</span>ltake <span class="main">(</span>enat <span class="free">n</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span> <span class="free">A</span><span class="main">)</span> <span class="main">(</span>lnths <span class="main">(</span>ldropn <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">{</span><span class="bound">m</span><span class="main">.</span> <span class="free">n</span> <span class="main">+</span> <span class="bound">m</span> <span class="main">∈</span> <span class="free">A</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"enat <span class="free">n</span> <span class="main">≤</span> llength <span class="free">xs</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> False <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltake_all ldropn_all<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> lappend <span class="main">(</span>ltake <span class="main">(</span>enat <span class="free">n</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>ldrop <span class="main">(</span>enat <span class="free">n</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> lappend_ltake_ldrop<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> lappend <span class="main">(</span>ltake <span class="main">(</span>enat <span class="free">n</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>ldropn <span class="free">n</span> <span class="free">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lnths <span class="free">xs</span> <span class="free">A</span> <span class="main">=</span> lnths <span class="main">(</span>lappend <span class="main">(</span>ltake <span class="main">(</span>enat <span class="free">n</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>ldropn <span class="free">n</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span> <span class="free">A</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> lnths_lappend_lfinite<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> k<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">n</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> True <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> min_def <span class="dynamic"><span class="dynamic">ac_simps</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lnths_cong"><span class="command">lemma</span></span> lnths_cong<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="free">ys</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">n</span><span class="main">.</span> enat <span class="bound">n</span> <span class="main">&lt;</span> llength <span class="free">ys</span> <span class="main">⟹</span> <span class="bound">n</span> <span class="main">∈</span> <span class="free">A</span> <span class="main">⟷</span> <span class="bound">n</span> <span class="main">∈</span> <span class="free">B</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lnths <span class="free">xs</span> <span class="free">A</span> <span class="main">=</span> lnths <span class="free">ys</span> <span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lfilter <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free">A</span><span class="main">)</span> <span class="main">(</span>lzip <span class="free">ys</span> <span class="main">(</span>iterates Suc <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
        lfilter <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free">B</span><span class="main">)</span> <span class="main">(</span>lzip <span class="free">ys</span> <span class="main">(</span>iterates Suc <span class="main">0</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> lfilter_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lset_lzip A<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> <span class="quoted"><span class="quoted">‹<span class="free">xs</span> <span class="main">=</span> <span class="free">ys</span>›</span></span> lnths_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lnths_insert"><span class="command">lemma</span></span> lnths_insert<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> n<span class="main">:</span> <span class="quoted"><span class="quoted">"enat <span class="free">n</span> <span class="main">&lt;</span> llength <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lnths <span class="free">xs</span> <span class="main">(</span>insert <span class="free">n</span> <span class="free">A</span><span class="main">)</span> <span class="main">=</span>
         lappend <span class="main">(</span>lnths <span class="main">(</span>ltake <span class="main">(</span>enat <span class="free">n</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span> <span class="free">A</span><span class="main">)</span> <span class="main">(</span>LCons <span class="main">(</span>lnth <span class="free">xs</span> <span class="free">n</span><span class="main">)</span>
                 <span class="main">(</span>lnths <span class="main">(</span>ldropn <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span> <span class="main">{</span><span class="bound">m</span><span class="main">.</span> Suc <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="bound">m</span><span class="main">)</span> <span class="main">∈</span> <span class="free">A</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lnths <span class="free">xs</span> <span class="main">(</span>insert <span class="free">n</span> <span class="free">A</span><span class="main">)</span> <span class="main">=</span>
        lappend <span class="main">(</span>lnths <span class="main">(</span>ltake <span class="main">(</span>enat <span class="free">n</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>insert <span class="free">n</span> <span class="free">A</span><span class="main">)</span><span class="main">)</span>
                <span class="main">(</span>lnths <span class="main">(</span>ldropn <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">{</span><span class="bound">m</span><span class="main">.</span> <span class="free">n</span> <span class="main">+</span> <span class="bound">m</span> <span class="main">∈</span> <span class="main">(</span>insert <span class="free">n</span> <span class="free">A</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> lnths_split<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lnths <span class="main">(</span>ltake <span class="main">(</span>enat <span class="free">n</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>insert <span class="free">n</span> <span class="free">A</span><span class="main">)</span> <span class="main">=</span>
            lnths <span class="main">(</span>ltake <span class="main">(</span>enat <span class="free">n</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span> <span class="free">A</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> lnths_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">{</span></span> <span class="keyword1"><span class="command">from</span></span> n <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">X</span></span> <span class="skolem"><span class="skolem">XS</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"ldropn <span class="free">n</span> <span class="free">xs</span> <span class="main">=</span> LCons <span class="skolem">X</span> <span class="skolem">XS</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"ldropn <span class="free">n</span> <span class="free">xs</span>"</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldropn_eq_LNil<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lnth <span class="main">(</span>ldropn <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">0</span> <span class="main">=</span> lnth <span class="free">xs</span> <span class="free">n</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> n <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ltl <span class="main">(</span>ldropn <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> ldropn <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="free">xs</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltl_ldropn<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ldropn <span class="free">n</span> <span class="free">xs</span> <span class="main">=</span> LCons <span class="main">(</span>lnth <span class="free">xs</span> <span class="free">n</span><span class="main">)</span> <span class="main">(</span>ldropn <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lnths <span class="main">(</span>ldropn <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">{</span><span class="bound">m</span><span class="main">.</span> <span class="free">n</span> <span class="main">+</span> <span class="bound">m</span> <span class="main">∈</span> insert <span class="free">n</span> <span class="free">A</span><span class="main">}</span> <span class="main">=</span>
           LCons <span class="main">(</span>lnth <span class="free">xs</span> <span class="free">n</span><span class="main">)</span> <span class="main">(</span>lnths <span class="main">(</span>ldropn <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span> <span class="main">{</span><span class="bound">m</span><span class="main">.</span> Suc <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="bound">m</span><span class="main">)</span> <span class="main">∈</span> <span class="free">A</span><span class="main">}</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnths_LCons<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lfinite_lnths"><span class="command">lemma</span></span> lfinite_lnths <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>lnths <span class="free">xs</span> <span class="free">A</span><span class="main">)</span> <span class="main">⟷</span> lfinite <span class="free">xs</span> <span class="main">∨</span> finite <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>lnths <span class="free">xs</span> <span class="free">A</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span> <span class="main">∨</span>
         finite <span class="main">{</span><span class="bound">n</span><span class="main">.</span> enat <span class="bound">n</span> <span class="main">&lt;</span> llength <span class="free">xs</span> <span class="main">∧</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free">A</span><span class="main">)</span> <span class="main">(</span>lnth <span class="main">(</span>lzip <span class="free">xs</span> <span class="main">(</span>iterates Suc <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="bound">n</span><span class="main">)</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnths_def lfinite_lfilter<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">n</span><span class="main">.</span> enat <span class="bound">n</span> <span class="main">&lt;</span> llength <span class="free">xs</span> <span class="main">∧</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free">A</span><span class="main">)</span> <span class="main">(</span>lnth <span class="main">(</span>lzip <span class="free">xs</span> <span class="main">(</span>iterates Suc <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="bound">n</span><span class="main">)</span><span class="main">}</span> <span class="main">=</span>
            <span class="main">{</span><span class="bound">n</span><span class="main">.</span> enat <span class="bound">n</span> <span class="main">&lt;</span> llength <span class="free">xs</span> <span class="main">∧</span> <span class="bound">n</span> <span class="main">∈</span> <span class="free">A</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnth_lzip<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span> <span class="main">∨</span> finite <span class="free">A</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lfinite_llength <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> contrapos_np<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span> <span class="main">∨</span> finite <span class="free">A</span>"</span></span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">n</span><span class="main">.</span> enat <span class="bound">n</span> <span class="main">&lt;</span> llength <span class="free">xs</span> <span class="main">∧</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free">A</span><span class="main">)</span> <span class="main">(</span>lnth <span class="main">(</span>lzip <span class="free">xs</span> <span class="main">(</span>iterates Suc <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="bound">n</span><span class="main">)</span><span class="main">}</span> <span class="main">=</span>
        <span class="main">{</span><span class="bound">n</span><span class="main">.</span> enat <span class="bound">n</span> <span class="main">&lt;</span> llength <span class="free">xs</span> <span class="main">∧</span> <span class="bound">n</span> <span class="main">∈</span> <span class="free">A</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnth_lzip<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>lnths <span class="free">xs</span> <span class="free">A</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnths_def lfinite_lfilter<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "lsum_list"<span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">context</span></span> monoid_add <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Coinductive_List-lsum_list_0"><span class="command">lemma</span></span> lsum_list_0 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lsum_list <span class="main">(</span>lmap <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">0</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lsum_list_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lsum_list_llist_of"><span class="command">lemma</span></span> lsum_list_llist_of <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lsum_list <span class="main">(</span>llist_of <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> sum_list <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lsum_list_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lsum_list_lappend"><span class="command">lemma</span></span> lsum_list_lappend<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> lfinite <span class="free">xs</span><span class="main">;</span> lfinite <span class="free">ys</span> <span class="main">⟧</span> <span class="main">⟹</span> lsum_list <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> lsum_list <span class="free">xs</span> <span class="main">+</span> lsum_list <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lsum_list_def list_of_lappend<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lsum_list_LNil"><span class="command">lemma</span></span> lsum_list_LNil <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lsum_list LNil <span class="main">=</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lsum_list_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lsum_list_LCons"><span class="command">lemma</span></span> lsum_list_LCons <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span> <span class="main">⟹</span> lsum_list <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">x</span> <span class="main">+</span> lsum_list <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lsum_list_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lsum_list_inf"><span class="command">lemma</span></span> lsum_list_inf <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lfinite <span class="free">xs</span> <span class="main">⟹</span> lsum_list <span class="free">xs</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lsum_list_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Coinductive_List-lsum_list_mono"><span class="command">lemma</span></span> lsum_list_mono<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">::</span> <span class="main">{</span>monoid_add<span class="main">,</span> ordered_ab_semigroup_add<span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> lset <span class="free">xs</span> <span class="main">⟹</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">≤</span> <span class="free">g</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lsum_list <span class="main">(</span>lmap <span class="free">f</span> <span class="free">xs</span><span class="main">)</span> <span class="main">≤</span> lsum_list <span class="main">(</span>lmap <span class="free">g</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lsum_list_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> sum_list_mono<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹
  Alternative view on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> llist"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> as datatype
  with constructors <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"llist_of"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"inf_llist"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
›</span></span>

<span class="keyword1" id="Coinductive_List-lnull_inf_llist"><span class="command">lemma</span></span> lnull_inf_llist <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lnull <span class="main">(</span>inf_llist <span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inf_llist_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-inf_llist_neq_LNil"><span class="command">lemma</span></span> inf_llist_neq_LNil<span class="main">:</span> <span class="quoted"><span class="quoted">"inf_llist <span class="free">f</span> <span class="main">≠</span> LNil"</span></span>
<span class="keyword1"><span class="command">using</span></span> lnull_inf_llist <span class="keyword1"><span class="command">unfolding</span></span> lnull_def <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> LNil_neq_inf_llist <span class="main">=</span> inf_llist_neq_LNil<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>

<span class="keyword1" id="Coinductive_List-lhd_inf_llist"><span class="command">lemma</span></span> lhd_inf_llist <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lhd <span class="main">(</span>inf_llist <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inf_llist_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ltl_inf_llist"><span class="command">lemma</span></span> ltl_inf_llist <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ltl <span class="main">(</span>inf_llist <span class="free">f</span><span class="main">)</span> <span class="main">=</span> inf_llist <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span>Suc <span class="bound">n</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inf_llist_def lmap_iterates<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> llist.map_comp<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-inf_llist_rec"><span class="command">lemma</span></span> inf_llist_rec <span class="main">[</span><span class="operator">code</span><span class="main">,</span> <span class="operator">nitpick_simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"inf_llist <span class="free">f</span> <span class="main">=</span> LCons <span class="main">(</span><span class="free">f</span> <span class="main">0</span><span class="main">)</span> <span class="main">(</span>inf_llist <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span>Suc <span class="bound">n</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> llist.expand<span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List-lfinite_inf_llist"><span class="command">lemma</span></span> lfinite_inf_llist <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lfinite <span class="main">(</span>inf_llist <span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inf_llist_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-iterates_conv_inf_llist"><span class="command">lemma</span></span> iterates_conv_inf_llist<span class="main">:</span>
  <span class="quoted"><span class="quoted">"iterates <span class="free">f</span> <span class="free">a</span> <span class="main">=</span> inf_llist <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="main">(</span><span class="free">f</span> <span class="main">^^</span> <span class="bound">n</span><span class="main">)</span> <span class="free">a</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">a</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> funpow_swap1<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-inf_llist_neq_llist_of"><span class="command">lemma</span></span> inf_llist_neq_llist_of <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"llist_of <span class="free">xs</span> <span class="main">≠</span> inf_llist <span class="free">f</span>"</span></span>
   <span class="quoted"><span class="quoted">"inf_llist <span class="free">f</span> <span class="main">≠</span> llist_of <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> lfinite_llist_of<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">xs</span></span><span class="main">]</span> lfinite_inf_llist<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">f</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Coinductive_List-lnth_inf_llist"><span class="command">lemma</span></span> lnth_inf_llist <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lnth <span class="main">(</span>inf_llist <span class="free">f</span><span class="main">)</span> <span class="free">n</span> <span class="main">=</span> <span class="free">f</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">f</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> inf_llist_rec<span class="main">)</span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> Suc<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="skolem">f</span> <span class="main">(</span>Suc <span class="bound">n</span><span class="main">)</span>"</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> inf_llist_rec<span class="main">)</span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-inf_llist_lprefix"><span class="command">lemma</span></span> inf_llist_lprefix <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"inf_llist <span class="free">f</span> <span class="main">⊑</span> <span class="free">xs</span> <span class="main">⟷</span> <span class="free">xs</span> <span class="main">=</span> inf_llist <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lfinite_lprefix_conv_eq<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llength_inf_llist"><span class="command">lemma</span></span> llength_inf_llist <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"llength <span class="main">(</span>inf_llist <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="main">∞</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inf_llist_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lset_inf_llist"><span class="command">lemma</span></span> lset_inf_llist <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lset <span class="main">(</span>inf_llist <span class="free">f</span><span class="main">)</span> <span class="main">=</span> range <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lset_conv_lnth<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-inf_llist_inj"><span class="command">lemma</span></span> inf_llist_inj <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"inf_llist <span class="free">f</span> <span class="main">=</span> inf_llist <span class="free">g</span> <span class="main">⟷</span> <span class="free">f</span> <span class="main">=</span> <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> inf_llist_def lmap_eq_lmap_conv_llist_all2
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> iterates_conv_inf_llist fun_eq_iff<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-inf_llist_lnth"><span class="command">lemma</span></span> inf_llist_lnth <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lfinite <span class="free">xs</span> <span class="main">⟹</span> inf_llist <span class="main">(</span>lnth <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnth_0_conv_lhd fun_eq_iff lnth_ltl<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llist_exhaust"><span class="command">lemma</span></span> llist_exhaust<span class="main">:</span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="main">(</span>llist_of<span class="main">)</span> <span class="free">ys</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> llist_of <span class="free">ys</span>"</span></span>
       <span class="main">|</span> <span class="main">(</span>inf_llist<span class="main">)</span> <span class="free">f</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> inf_llist <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">ys</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> llist_of <span class="skolem">ys</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> lfinite_eq_range_llist_of <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> that<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> inf_llist <span class="main">(</span>lnth <span class="free">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="free">thesis</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> that<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lappend_inf_llist"><span class="command">lemma</span></span> lappend_inf_llist <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lappend <span class="main">(</span>inf_llist <span class="free">f</span><span class="main">)</span> <span class="free">xs</span> <span class="main">=</span> inf_llist <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lappend_inf<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lmap_inf_llist"><span class="command">lemma</span></span> lmap_inf_llist <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lmap <span class="free">f</span> <span class="main">(</span>inf_llist <span class="free">g</span><span class="main">)</span> <span class="main">=</span> inf_llist <span class="main">(</span><span class="free">f</span> <span class="keyword1">o</span> <span class="free">g</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inf_llist_def llist.map_comp<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ltake_enat_inf_llist"><span class="command">lemma</span></span> ltake_enat_inf_llist <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"ltake <span class="main">(</span>enat <span class="free">n</span><span class="main">)</span> <span class="main">(</span>inf_llist <span class="free">f</span><span class="main">)</span> <span class="main">=</span> llist_of <span class="main">(</span>map <span class="free">f</span> <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inf_llist_def ltake_iterates_Suc<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ldropn_inf_llist"><span class="command">lemma</span></span> ldropn_inf_llist <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"ldropn <span class="free">n</span> <span class="main">(</span>inf_llist <span class="free">f</span><span class="main">)</span> <span class="main">=</span> inf_llist <span class="main">(</span><span class="main">λ</span><span class="bound">m</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="bound">m</span> <span class="main">+</span> <span class="free">n</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> inf_llist_def ldropn_lmap ldropn_iterates
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> iterates_conv_inf_llist o_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ldrop_enat_inf_llist"><span class="command">lemma</span></span> ldrop_enat_inf_llist<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ldrop <span class="main">(</span>enat <span class="free">n</span><span class="main">)</span> <span class="main">(</span>inf_llist <span class="free">f</span><span class="main">)</span> <span class="main">=</span> inf_llist <span class="main">(</span><span class="main">λ</span><span class="bound">m</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="bound">m</span> <span class="main">+</span> <span class="free">n</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">f</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Suc <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> inf_llist_rec<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eSuc_enat<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lzip_inf_llist_inf_llist"><span class="command">lemma</span></span> lzip_inf_llist_inf_llist <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lzip <span class="main">(</span>inf_llist <span class="free">f</span><span class="main">)</span> <span class="main">(</span>inf_llist <span class="free">g</span><span class="main">)</span> <span class="main">=</span> inf_llist <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="main">(</span><span class="free">f</span> <span class="bound">n</span><span class="main">,</span> <span class="free">g</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="free">g</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_List-lzip_llist_of_inf_llist"><span class="command">lemma</span></span> lzip_llist_of_inf_llist <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lzip <span class="main">(</span>llist_of <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>inf_llist <span class="free">f</span><span class="main">)</span> <span class="main">=</span> llist_of <span class="main">(</span>zip <span class="free">xs</span> <span class="main">(</span>map <span class="free">f</span> <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span>length <span class="free">xs</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">f</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map <span class="skolem">f</span> <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span>length <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span><span class="main">]</span> <span class="main">=</span> <span class="skolem">f</span> <span class="main">0</span> <span class="main">#</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="skolem">f</span> <span class="main">(</span>Suc <span class="bound">n</span><span class="main">)</span><span class="main">)</span> <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span>length <span class="skolem">xs</span><span class="main">]</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> upt_conv_Cons map_Suc_upt<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> upt_Suc<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> Cons<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="skolem">f</span> <span class="main">(</span>Suc <span class="bound">n</span><span class="main">)</span>"</span></span><span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> inf_llist_rec<span class="main">)</span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-lzip_inf_llist_llist_of"><span class="command">lemma</span></span> lzip_inf_llist_llist_of <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lzip <span class="main">(</span>inf_llist <span class="free">f</span><span class="main">)</span> <span class="main">(</span>llist_of <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> llist_of <span class="main">(</span>zip <span class="main">(</span>map <span class="free">f</span> <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span>length <span class="free">xs</span><span class="main">]</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">f</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map <span class="skolem">f</span> <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span>length <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span><span class="main">]</span> <span class="main">=</span> <span class="skolem">f</span> <span class="main">0</span> <span class="main">#</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="skolem">f</span> <span class="main">(</span>Suc <span class="bound">n</span><span class="main">)</span><span class="main">)</span> <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span>length <span class="skolem">xs</span><span class="main">]</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> upt_conv_Cons map_Suc_upt<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> upt_Suc<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> Cons<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="skolem">f</span> <span class="main">(</span>Suc <span class="bound">n</span><span class="main">)</span>"</span></span><span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> inf_llist_rec<span class="main">)</span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-llist_all2_inf_llist"><span class="command">lemma</span></span> llist_all2_inf_llist <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"llist_all2 <span class="free">P</span> <span class="main">(</span>inf_llist <span class="free">f</span><span class="main">)</span> <span class="main">(</span>inf_llist <span class="free">g</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">n</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span><span class="free">f</span> <span class="bound">n</span><span class="main">)</span> <span class="main">(</span><span class="free">g</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_all2_conv_lzip<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llist_all2_llist_of_inf_llist"><span class="command">lemma</span></span> llist_all2_llist_of_inf_llist <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">¬</span> llist_all2 <span class="free">P</span> <span class="main">(</span>llist_of <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>inf_llist <span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_all2_conv_lzip<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llist_all2_inf_llist_llist_of"><span class="command">lemma</span></span> llist_all2_inf_llist_llist_of <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">¬</span> llist_all2 <span class="free">P</span> <span class="main">(</span>inf_llist <span class="free">f</span><span class="main">)</span> <span class="main">(</span>llist_of <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_all2_conv_lzip<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> monoid_add<span class="main">)</span> lsum_list_infllist<span class="main">:</span> <span class="quoted"><span class="quoted">"lsum_list <span class="main">(</span>inf_llist <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Setup for lifting and transfer›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Relator and predicator properties›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">llist_all</span> <span class="main">==</span> pred_llist"</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Transfer rules for the Transfer package›</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Coinductive_List-set1_pre_llist_transfer"><span class="command">lemma</span></span> set1_pre_llist_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_pre_llist <span class="free">A</span> <span class="free">B</span> <span class="main">===&gt;</span> rel_set <span class="free">A</span><span class="main">)</span> set1_pre_llist set1_pre_llist"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_pre_llist_def vimage2p_def rel_fun_def set1_pre_llist_def rel_set_def collect_def sum_set_defs prod_set_defs <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> rel_sum.cases <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> sum.split_asm<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-set2_pre_llist_transfer"><span class="command">lemma</span></span> set2_pre_llist_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_pre_llist <span class="free">A</span> <span class="free">B</span> <span class="main">===&gt;</span> rel_set <span class="free">B</span><span class="main">)</span> set2_pre_llist set2_pre_llist"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_pre_llist_def vimage2p_def rel_fun_def set2_pre_llist_def rel_set_def collect_def sum_set_defs prod_set_defs <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> rel_sum.cases <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> sum.split_asm<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-LNil_transfer"><span class="command">lemma</span></span> LNil_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"llist_all2 <span class="free">P</span> LNil LNil"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-LCons_transfer"><span class="command">lemma</span></span> LCons_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> llist_all2 <span class="free">A</span> <span class="main">===&gt;</span> llist_all2 <span class="free">A</span><span class="main">)</span> LCons LCons"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> rel_fun_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_List-case_llist_transfer"><span class="command">lemma</span></span> case_llist_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">B</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> llist_all2 <span class="free">A</span> <span class="main">===&gt;</span> <span class="free">B</span><span class="main">)</span> <span class="main">===&gt;</span> llist_all2 <span class="free">A</span> <span class="main">===&gt;</span> <span class="free">B</span><span class="main">)</span>
    case_llist case_llist"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> rel_fun_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-unfold_llist_transfer"><span class="command">lemma</span></span> unfold_llist_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">B</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">A</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">A</span> <span class="main">===&gt;</span> llist_all2 <span class="free">B</span><span class="main">)</span> unfold_llist unfold_llist"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> rel_funI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">IS_LNIL1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">IS_LNIL2</span> <span class="skolem">LHD1</span> <span class="skolem">LHD2</span> <span class="skolem">LTL1</span> <span class="skolem">LTL2</span> <span class="skolem">x</span> <span class="skolem">y</span>
  <span class="keyword3"><span class="command">assume</span></span> rel<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="skolem">IS_LNIL1</span> <span class="skolem">IS_LNIL2</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">B</span><span class="main">)</span> <span class="skolem">LHD1</span> <span class="skolem">LHD2</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">A</span><span class="main">)</span> <span class="skolem">LTL1</span> <span class="skolem">LTL2</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="skolem">x</span> <span class="skolem">y</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="free">A</span> <span class="skolem">x</span> <span class="skolem">y</span>›</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"llist_all2 <span class="free">B</span> <span class="main">(</span>unfold_llist <span class="skolem">IS_LNIL1</span> <span class="skolem">LHD1</span> <span class="skolem">LTL1</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span>unfold_llist <span class="skolem">IS_LNIL2</span> <span class="skolem">LHD2</span> <span class="skolem">LTL2</span> <span class="skolem">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">x</span></span> <span class="quoted"><span class="skolem">y</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> rel <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 4 <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> rel_funE<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-llist_corec_transfer"><span class="command">lemma</span></span> llist_corec_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">B</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> llist_all2 <span class="free">B</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">A</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">A</span> <span class="main">===&gt;</span> llist_all2 <span class="free">B</span><span class="main">)</span> corec_llist corec_llist"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> rel_funI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">IS_LNIL1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">IS_LNIL2</span> <span class="skolem">LHD1</span> <span class="skolem">LHD2</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">STOP1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">STOP2</span> <span class="skolem">MORE1</span> <span class="skolem">MORE2</span> <span class="skolem">LTL1</span> <span class="skolem">LTL2</span> <span class="skolem">x</span> <span class="skolem">y</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="skolem">IS_LNIL1</span> <span class="skolem">IS_LNIL2</span> "</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">B</span><span class="main">)</span> <span class="skolem">LHD1</span> <span class="skolem">LHD2</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="skolem">STOP1</span> <span class="skolem">STOP2</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> llist_all2 <span class="free">B</span><span class="main">)</span> <span class="skolem">MORE1</span> <span class="skolem">MORE2</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">A</span><span class="main">)</span> <span class="skolem">LTL1</span> <span class="skolem">LTL2</span>"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="skolem">x</span> <span class="skolem">y</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"llist_all2 <span class="free">B</span> <span class="main">(</span>corec_llist <span class="skolem">IS_LNIL1</span> <span class="skolem">LHD1</span> <span class="skolem">STOP1</span> <span class="skolem">MORE1</span> <span class="skolem">LTL1</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span>corec_llist <span class="skolem">IS_LNIL2</span> <span class="skolem">LHD2</span> <span class="skolem">STOP2</span> <span class="skolem">MORE2</span> <span class="skolem">LTL2</span> <span class="skolem">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">x</span></span> <span class="quoted"><span class="skolem">y</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="main">(</span>LNil <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="operator">transfer_prover</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>LCons <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span>
    <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span> <span class="main">=</span> <span class="quoted"><span class="quoted">‹<span class="free">A</span> <span class="skolem">x</span> <span class="skolem">y</span>›</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?lhd</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> LCons<span class="main"><span class="main">[</span></span><span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">transfer_prover</span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">STOP1</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">STOP2</span> <span class="skolem">y</span>"</span></span> <span class="quoted"><span class="quoted">"llist_all2 <span class="free">B</span> <span class="main">(</span><span class="skolem">MORE1</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="skolem">MORE2</span> <span class="skolem">y</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">(</span><span class="skolem">LTL1</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="skolem">LTL2</span> <span class="skolem">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="var"><span class="quoted"><span class="var">?ltl</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> LCons<span class="main"><span class="main">[</span></span><span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-ltl_transfer"><span class="command">lemma</span></span> ltl_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>llist_all2 <span class="free">A</span> <span class="main">===&gt;</span> llist_all2 <span class="free">A</span><span class="main">)</span> ltl ltl"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ltl_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Coinductive_List-lset_transfer"><span class="command">lemma</span></span> lset_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>llist_all2 <span class="free">A</span> <span class="main">===&gt;</span> rel_set <span class="free">A</span><span class="main">)</span> lset lset"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> rel_funI rel_setI<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> in_lset_conv_lnth llist_all2_conv_all_lnth Bex_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lmap_transfer"><span class="command">lemma</span></span> lmap_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">B</span><span class="main">)</span> <span class="main">===&gt;</span> llist_all2 <span class="free">A</span> <span class="main">===&gt;</span> llist_all2 <span class="free">B</span><span class="main">)</span> lmap lmap"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def llist_all2_lmap1 llist_all2_lmap2 <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> llist_all2_mono<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lappend_transfer"><span class="command">lemma</span></span> lappend_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>llist_all2 <span class="free">A</span> <span class="main">===&gt;</span> llist_all2 <span class="free">A</span> <span class="main">===&gt;</span> llist_all2 <span class="free">A</span><span class="main">)</span> lappend lappend"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> llist_all2_lappendI<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-iterates_transfer"><span class="command">lemma</span></span> iterates_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">A</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">A</span> <span class="main">===&gt;</span> llist_all2 <span class="free">A</span><span class="main">)</span> iterates iterates"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> iterates_def split_def corec_llist_never_stop <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Coinductive_List-lfinite_transfer"><span class="command">lemma</span></span> lfinite_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>llist_all2 <span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> lfinite lfinite"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> llist_all2_lfiniteD<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-llist_of_transfer"><span class="command">lemma</span></span> llist_of_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>list_all2 <span class="free">A</span> <span class="main">===&gt;</span> llist_all2 <span class="free">A</span><span class="main">)</span> llist_of llist_of"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> llist_of_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Coinductive_List-llength_transfer"><span class="command">lemma</span></span> llength_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>llist_all2 <span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> llength llength"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> llist_all2_llengthD<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ltake_transfer"><span class="command">lemma</span></span> ltake_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> llist_all2 <span class="free">A</span> <span class="main">===&gt;</span> llist_all2 <span class="free">A</span><span class="main">)</span> ltake ltake"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> llist_all2_ltakeI<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ldropn_transfer"><span class="command">lemma</span></span> ldropn_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> llist_all2 <span class="free">A</span> <span class="main">===&gt;</span> llist_all2 <span class="free">A</span><span class="main">)</span> ldropn ldropn"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> ldropn_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Coinductive_List-ldrop_transfer"><span class="command">lemma</span></span> ldrop_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> llist_all2 <span class="free">A</span> <span class="main">===&gt;</span> llist_all2 <span class="free">A</span><span class="main">)</span> ldrop ldrop"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> llist_all2_ldropI<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-ltakeWhile_transfer"><span class="command">lemma</span></span> ltakeWhile_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span> llist_all2 <span class="free">A</span> <span class="main">===&gt;</span> llist_all2 <span class="free">A</span><span class="main">)</span> ltakeWhile ltakeWhile"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> rel_funI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">P</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">Q</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">ys</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> llist"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> PQ<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="skolem">P</span> <span class="skolem">Q</span>"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"llist_all2 <span class="free">A</span> <span class="skolem">xs</span> <span class="skolem">ys</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"llist_all2 <span class="free">A</span> <span class="main">(</span>ltakeWhile <span class="skolem">P</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">(</span>ltakeWhile <span class="skolem">Q</span> <span class="skolem">ys</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quoted"><span class="skolem">ys</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> PQ <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 4 <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> rel_funE <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lnull_conv llist_all2_LCons2 llist_all2_LCons1<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-ldropWhile_transfer"><span class="command">lemma</span></span> ldropWhile_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span> llist_all2 <span class="free">A</span> <span class="main">===&gt;</span> llist_all2 <span class="free">A</span><span class="main">)</span> ldropWhile ldropWhile"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> ldropWhile_eq_ldrop<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Coinductive_List-lzip_ltransfer"><span class="command">lemma</span></span> lzip_ltransfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>llist_all2 <span class="free">A</span> <span class="main">===&gt;</span> llist_all2 <span class="free">B</span> <span class="main">===&gt;</span> llist_all2 <span class="main">(</span>rel_prod <span class="free">A</span> <span class="free">B</span><span class="main">)</span><span class="main">)</span> lzip lzip"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> llist_all2_lzipI<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-inf_llist_transfer"><span class="command">lemma</span></span> inf_llist_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> <span class="free">A</span><span class="main">)</span> <span class="main">===&gt;</span> llist_all2 <span class="free">A</span><span class="main">)</span> inf_llist inf_llist"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> inf_llist_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Coinductive_List-lfilter_transfer"><span class="command">lemma</span></span> lfilter_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span> llist_all2 <span class="free">A</span> <span class="main">===&gt;</span> llist_all2 <span class="free">A</span><span class="main">)</span> lfilter lfilter"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> llist_all2_lfilterI<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lconcat_transfer"><span class="command">lemma</span></span> lconcat_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>llist_all2 <span class="main">(</span>llist_all2 <span class="free">A</span><span class="main">)</span> <span class="main">===&gt;</span> llist_all2 <span class="free">A</span><span class="main">)</span> lconcat lconcat"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> llist_all2_lconcatI<span class="main">)</span>

<span class="keyword1" id="Coinductive_List-lnths_transfer"><span class="command">lemma</span></span> lnths_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>llist_all2 <span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> llist_all2 <span class="free">A</span><span class="main">)</span> lnths lnths"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> lnths_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Coinductive_List-llist_all_transfer"><span class="command">lemma</span></span> llist_all_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span> llist_all2 <span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> llist_all llist_all"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> pred_llist_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Coinductive_List-llist_all2_rsp"><span class="command">lemma</span></span> llist_all2_rsp<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> r<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">R</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∀</span><span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> <span class="free">R</span> <span class="bound">a</span> <span class="bound">b</span> <span class="main">⟶</span> <span class="free">S</span> <span class="bound">x</span> <span class="bound">a</span> <span class="main">=</span> <span class="free">T</span> <span class="bound">y</span> <span class="bound">b</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> l1<span class="main">:</span> <span class="quoted"><span class="quoted">"llist_all2 <span class="free">R</span> <span class="free">x</span> <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> l2<span class="main">:</span> <span class="quoted"><span class="quoted">"llist_all2 <span class="free">R</span> <span class="free">a</span> <span class="free">b</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"llist_all2 <span class="free">S</span> <span class="free">x</span> <span class="free">a</span> <span class="main">=</span> llist_all2 <span class="free">T</span> <span class="free">y</span> <span class="free">b</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"llength <span class="free">x</span> <span class="main">=</span> llength <span class="free">a</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> l1 l2
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_all2_conv_all_lnth<span class="main">)</span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> r<span class="main"><span class="main">[</span></span><span class="operator">rule_format</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">with</span></span> llist_all2_llengthD<span class="main">[</span><span class="operator">OF</span> l1<span class="main">]</span> llist_all2_llengthD<span class="main">[</span><span class="operator">OF</span> l2<span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_all2_conv_all_lnth<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_List-llist_all2_transfer"><span class="command">lemma</span></span> llist_all2_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">R</span> <span class="main">===&gt;</span> <span class="free">R</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span> llist_all2 <span class="free">R</span> <span class="main">===&gt;</span> llist_all2 <span class="free">R</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> llist_all2 llist_all2"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_all2_rsp rel_fun_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">no_notation</span></span> lprefix <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">⊑</span>"</span> 65<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Coinductive_List_Prefix">
<div class="head">
<h1>Theory Coinductive_List_Prefix</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Prefix ordering on coinductive lists as ordering for type class order
    Author:      Andreas Lochbihler
    Maintainer:  Andreas Lochbihler
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Instantiation of the order type classes for lazy lists›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Coinductive_List_Prefix <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="#Coinductive_List">Coinductive_List</a>
  <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/Prefix_Order.html">HOL-Library.Prefix_Order</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Instantiation of the order type class›</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> llist <span class="main">::</span> <span class="main">(</span><span class="quoted">type</span><span class="main">)</span> <span class="quoted">order</span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">=</span> lprefix <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">=</span> lstrict_prefix <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span>"</span></span>

<span class="keyword1"><span class="command">instance</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">intro_classes</span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="skolem">ys</span> <span class="skolem">zs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">xs</span> <span class="main">&lt;</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">xs</span> <span class="main">≤</span> <span class="skolem">ys</span> <span class="main">∧</span> <span class="main">¬</span> <span class="skolem">ys</span> <span class="main">≤</span> <span class="skolem">xs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> less_llist_def less_eq_llist_def lstrict_prefix_def
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> lprefix_antisym<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">≤</span> <span class="skolem">xs</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> less_eq_llist_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> lprefix_refl<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="skolem">xs</span> <span class="main">≤</span> <span class="skolem">ys</span><span class="main">;</span> <span class="skolem">ys</span> <span class="main">≤</span> <span class="skolem">zs</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="skolem">xs</span> <span class="main">≤</span> <span class="skolem">zs</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> less_eq_llist_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> lprefix_trans<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="skolem">xs</span> <span class="main">≤</span> <span class="skolem">ys</span><span class="main">;</span> <span class="skolem">ys</span> <span class="main">≤</span> <span class="skolem">xs</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="skolem">xs</span> <span class="main">=</span> <span class="skolem">ys</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> less_eq_llist_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> lprefix_antisym<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Coinductive_List_Prefix-le_llist_conv_lprefix"><span class="command">lemma</span></span> le_llist_conv_lprefix <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(≤)</span> <span class="main">=</span> lprefix"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_eq_llist_def fun_eq_iff<span class="main">)</span>

<span class="keyword1" id="Coinductive_List_Prefix-less_llist_conv_lstrict_prefix"><span class="command">lemma</span></span> less_llist_conv_lstrict_prefix <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(&lt;)</span> <span class="main">=</span> lstrict_prefix"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_llist_def fun_eq_iff<span class="main">)</span>

<span class="keyword1"><span class="command">instantiation</span></span> llist <span class="main">::</span> <span class="main">(</span><span class="quoted">type</span><span class="main">)</span> <span class="quoted">order_bot</span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"bot <span class="main">=</span> LNil"</span></span>

<span class="keyword1"><span class="command">instance</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro_classes</span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bot_llist_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Coinductive_List_Prefix-llist_of_lprefix_llist_of"><span class="command">lemma</span></span> llist_of_lprefix_llist_of <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lprefix <span class="main">(</span>llist_of <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>llist_of <span class="free">ys</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">xs</span> <span class="main">≤</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> LCons_lprefix_conv<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Prefix ordering as a lower semilattice›</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> llist <span class="main">::</span> <span class="main">(</span><span class="quoted">type</span><span class="main">)</span> <span class="quoted">semilattice_inf</span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"inf <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">=</span> 
   unfold_llist <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="bound">ys</span><span class="main">)</span><span class="main">.</span> <span class="bound">xs</span> <span class="main">≠</span> LNil <span class="main">⟶</span> <span class="bound">ys</span> <span class="main">≠</span> LNil <span class="main">⟶</span> lhd <span class="bound">xs</span> <span class="main">≠</span> lhd <span class="bound">ys</span><span class="main">)</span>
     <span class="main">(</span>lhd <span class="main">∘</span> snd<span class="main">)</span> <span class="main">(</span>map_prod ltl ltl<span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Coinductive_List_Prefix-llist_inf_simps"><span class="command">lemma</span></span> llist_inf_simps <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span><span class="main">,</span> <span class="operator">nitpick_simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"inf LNil <span class="free">xs</span> <span class="main">=</span> LNil"</span></span>
  <span class="quoted"><span class="quoted">"inf <span class="free">xs</span> LNil <span class="main">=</span> LNil"</span></span>
  <span class="quoted"><span class="quoted">"inf <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>LCons <span class="free">y</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span> <span class="keyword1">then</span> LCons <span class="free">x</span> <span class="main">(</span>inf <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="keyword1">else</span> LNil<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> inf_llist_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_List_Prefix-llist_inf_eq_LNil"><span class="command">lemma</span></span> llist_inf_eq_LNil <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lnull <span class="main">(</span>inf <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">xs</span> <span class="main">≠</span> LNil <span class="main">⟶</span> <span class="free">ys</span> <span class="main">≠</span> LNil <span class="main">⟶</span> lhd <span class="free">xs</span> <span class="main">≠</span> lhd <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inf_llist_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> LNil"</span></span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">≠</span> LNil"</span></span> <span class="quoted"><span class="quoted">"lhd <span class="free">xs</span> <span class="main">=</span> lhd <span class="free">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> lhd_llist_inf<span class="main">:</span> <span class="quoted"><span class="quoted">"lhd <span class="main">(</span>inf <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> lhd <span class="free">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>  ltl_llist_inf<span class="main">:</span> <span class="quoted"><span class="quoted">"ltl <span class="main">(</span>inf <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> inf <span class="main">(</span>ltl <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>ltl <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inf_llist_def<span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="skolem">ys</span> <span class="skolem">zs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"inf <span class="skolem">xs</span> <span class="skolem">ys</span> <span class="main">≤</span> <span class="skolem">xs</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> le_llist_conv_lprefix
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quoted"><span class="skolem">ys</span></span><span class="main">)</span> <span class="operator">auto</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"inf <span class="skolem">xs</span> <span class="skolem">ys</span> <span class="main">≤</span> <span class="skolem">ys</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> le_llist_conv_lprefix
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quoted"><span class="skolem">ys</span></span><span class="main">)</span> <span class="operator">auto</span>

  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">≤</span> <span class="skolem">ys</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">≤</span> <span class="skolem">zs</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">≤</span> inf <span class="skolem">ys</span> <span class="skolem">zs</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> le_llist_conv_lprefix
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quoted"><span class="skolem">ys</span></span> <span class="quoted"><span class="skolem">zs</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>lprefix <span class="skolem">xs</span> <span class="skolem">ys</span> <span class="skolem">zs</span><span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 4 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> LCons_lprefix_conv<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Coinductive_List_Prefix-llength_inf"><span class="command">lemma</span></span> llength_inf <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"llength <span class="main">(</span>inf <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> llcp <span class="free">xs</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_coinduct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llcp_eq_0_iff epred_llength epred_llcp<span class="main">)</span>

<span class="keyword1"><span class="command">instantiation</span></span> llist <span class="main">::</span> <span class="main">(</span><span class="quoted">type</span><span class="main">)</span> <span class="quoted">ccpo</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"Sup <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">=</span> lSup <span class="free"><span class="bound"><span class="entity">A</span></span></span>"</span></span>

<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span>
     <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Sup_llist_def less_eq_llist_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> llist.lub_upper llist.lub_least<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Coinductive_Stream">
<div class="head">
<h1>Theory Coinductive_Stream</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Coinductive/Coinductive_Stream.thy
    Author:     Peter Gammie and Andreas Lochbihler
*)</span>
<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Infinite lists as a codatatype›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Coinductive_Stream
<span class="keyword2"><span class="keyword">imports</span></span>
  <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/Stream.html">HOL-Library.Stream</a>"</span>
  <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/Linear_Temporal_Logic_on_Streams.html">HOL-Library.Linear_Temporal_Logic_on_Streams</a>"</span>
  <a href="#Coinductive_List">Coinductive_List</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Coinductive_Stream-eq_onpI"><span class="command">lemma</span></span> eq_onpI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">x</span> <span class="main">⟹</span> eq_onp <span class="free">P</span> <span class="free">x</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_onp_def<span class="main">)</span>

<span class="keyword1"><span class="command">primcorec</span></span> <span class="entity">unfold_stream</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> stream"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">unfold_stream</span> <span class="free"><span class="bound"><span class="entity">g1</span></span></span> <span class="free"><span class="bound"><span class="entity">g2</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">g1</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">##</span> <span class="free">unfold_stream</span> <span class="free"><span class="bound"><span class="entity">g1</span></span></span> <span class="free"><span class="bound"><span class="entity">g2</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">g2</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The following setup should be done by the BNF package.
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹congruence rule›</span></span>

<span class="keyword1"><span class="command">declare</span></span> stream.map_cong <span class="main">[</span><span class="operator">cong</span><span class="main">]</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹lemmas about generated constants›</span></span>

<span class="keyword1" id="Coinductive_Stream-eq_SConsD"><span class="command">lemma</span></span> eq_SConsD<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> SCons <span class="free">y</span> <span class="free">ys</span> <span class="main">⟹</span> shd <span class="free">xs</span> <span class="main">=</span> <span class="free">y</span> <span class="main">∧</span> stl <span class="free">xs</span> <span class="main">=</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">declare</span></span> stream.map_ident<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>

<span class="keyword1" id="Coinductive_Stream-smap_eq_SCons_conv"><span class="command">lemma</span></span> smap_eq_SCons_conv<span class="main">:</span>
  <span class="quoted"><span class="quoted">"smap <span class="free">f</span> <span class="free">xs</span> <span class="main">=</span> <span class="free">y</span> <span class="main">##</span> <span class="free">ys</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="main">∃</span><span class="bound">x</span> <span class="bound">xs'</span><span class="main">.</span> <span class="free">xs</span> <span class="main">=</span> <span class="bound">x</span> <span class="main">##</span> <span class="bound">xs'</span> <span class="main">∧</span> <span class="free">y</span> <span class="main">=</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">∧</span> <span class="free">ys</span> <span class="main">=</span> smap <span class="free">f</span> <span class="bound">xs'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="Coinductive_Stream-smap_unfold_stream"><span class="command">lemma</span></span> smap_unfold_stream<span class="main">:</span>
  <span class="quoted"><span class="quoted">"smap <span class="free">f</span> <span class="main">(</span>unfold_stream <span class="free">SHD</span> <span class="free">STL</span> <span class="free">b</span><span class="main">)</span> <span class="main">=</span> unfold_stream <span class="main">(</span><span class="free">f</span> <span class="main">∘</span> <span class="free">SHD</span><span class="main">)</span> <span class="free">STL</span> <span class="free">b</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">b</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_Stream-smap_corec_stream"><span class="command">lemma</span></span> smap_corec_stream<span class="main">:</span>
  <span class="quoted"><span class="quoted">"smap <span class="free">f</span> <span class="main">(</span>corec_stream <span class="free">SHD</span> <span class="free">endORmore</span> <span class="free">STL_end</span> <span class="free">STL_more</span> <span class="free">b</span><span class="main">)</span> <span class="main">=</span>
   corec_stream <span class="main">(</span><span class="free">f</span> <span class="main">∘</span> <span class="free">SHD</span><span class="main">)</span> <span class="free">endORmore</span> <span class="main">(</span>smap <span class="free">f</span> <span class="main">∘</span> <span class="free">STL_end</span><span class="main">)</span> <span class="free">STL_more</span> <span class="free">b</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">b</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> stream.coinduct_strong<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_Stream-unfold_stream_ltl_unroll"><span class="command">lemma</span></span> unfold_stream_ltl_unroll<span class="main">:</span>
  <span class="quoted"><span class="quoted">"unfold_stream <span class="free">SHD</span> <span class="free">STL</span> <span class="main">(</span><span class="free">STL</span> <span class="free">b</span><span class="main">)</span> <span class="main">=</span> unfold_stream <span class="main">(</span><span class="free">SHD</span> <span class="main">∘</span> <span class="free">STL</span><span class="main">)</span> <span class="free">STL</span> <span class="free">b</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">b</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_Stream-unfold_stream_eq_SCons"><span class="command">lemma</span></span> unfold_stream_eq_SCons <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"unfold_stream <span class="free">SHD</span> <span class="free">STL</span> <span class="free">b</span> <span class="main">=</span> <span class="free">x</span> <span class="main">##</span> <span class="free">xs</span> <span class="main">⟷</span>
  <span class="free">x</span> <span class="main">=</span> <span class="free">SHD</span> <span class="free">b</span> <span class="main">∧</span> <span class="free">xs</span> <span class="main">=</span> unfold_stream <span class="free">SHD</span> <span class="free">STL</span> <span class="main">(</span><span class="free">STL</span> <span class="free">b</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> unfold_stream.ctr<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_Stream-unfold_stream_id"><span class="command">lemma</span></span> unfold_stream_id <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"unfold_stream shd stl <span class="free">xs</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_Stream-sset_neq_empty"><span class="command">lemma</span></span> sset_neq_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sset <span class="free">xs</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">declare</span></span> stream.set_sel<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">simp</span><span class="main">]</span>

<span class="keyword1" id="Coinductive_Stream-sset_stl"><span class="command">lemma</span></span> sset_stl<span class="main">:</span> <span class="quoted"><span class="quoted">"sset <span class="main">(</span>stl <span class="free">xs</span><span class="main">)</span> <span class="main">⊆</span> sset <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹induction rules›</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> stream_set_induct <span class="main">=</span> sset_induct

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Lemmas about operations from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> "<a href="../../HOL/HOL-Library/Stream.html"></a><a href="../../HOL/HOL-Library/Stream.html">HOL-Library.Stream</a>"<span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1" id="Coinductive_Stream-szip_iterates"><span class="command">lemma</span></span> szip_iterates<span class="main">:</span>
  <span class="quoted"><span class="quoted">"szip <span class="main">(</span>siterate <span class="free">f</span> <span class="free">a</span><span class="main">)</span> <span class="main">(</span>siterate <span class="free">g</span> <span class="free">b</span><span class="main">)</span> <span class="main">=</span> siterate <span class="main">(</span>map_prod <span class="free">f</span> <span class="free">g</span><span class="main">)</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="free">b</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">a</span></span> <span class="quoted"><span class="free">b</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_Stream-szip_smap1"><span class="command">lemma</span></span> szip_smap1<span class="main">:</span> <span class="quoted"><span class="quoted">"szip <span class="main">(</span>smap <span class="free">f</span> <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span> <span class="main">=</span> smap <span class="main">(</span>apfst <span class="free">f</span><span class="main">)</span> <span class="main">(</span>szip <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_Stream-szip_smap2"><span class="command">lemma</span></span> szip_smap2<span class="main">:</span> <span class="quoted"><span class="quoted">"szip <span class="free">xs</span> <span class="main">(</span>smap <span class="free">g</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> smap <span class="main">(</span>apsnd <span class="free">g</span><span class="main">)</span> <span class="main">(</span>szip <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_Stream-szip_smap"><span class="command">lemma</span></span> szip_smap <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"szip <span class="main">(</span>smap <span class="free">f</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>smap <span class="free">g</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> smap <span class="main">(</span>map_prod <span class="free">f</span> <span class="free">g</span><span class="main">)</span> <span class="main">(</span>szip <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_Stream-smap_fst_szip"><span class="command">lemma</span></span> smap_fst_szip <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"smap fst <span class="main">(</span>szip <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_Stream-smap_snd_szip"><span class="command">lemma</span></span> smap_snd_szip <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"smap snd <span class="main">(</span>szip <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_Stream-snth_shift"><span class="command">lemma</span></span> snth_shift<span class="main">:</span> <span class="quoted"><span class="quoted">"snth <span class="main">(</span>shift <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="free">n</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> length <span class="free">xs</span> <span class="keyword1">then</span> <span class="free">xs</span> <span class="main">!</span> <span class="free">n</span> <span class="keyword1">else</span> snth <span class="free">ys</span> <span class="main">(</span><span class="free">n</span> <span class="main">-</span> length <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">declare</span></span> szip_unfold <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">nitpick_simp</span><span class="main">]</span>

<span class="keyword1" id="Coinductive_Stream-szip_shift"><span class="command">lemma</span></span> szip_shift<span class="main">:</span>
  <span class="quoted"><span class="quoted">"length <span class="free">xs</span> <span class="main">=</span> length <span class="free">us</span>
  <span class="main">⟹</span> szip <span class="main">(</span><span class="free">xs</span> <span class="main">@-</span> <span class="free">ys</span><span class="main">)</span> <span class="main">(</span><span class="free">us</span> <span class="main">@-</span> <span class="free">zs</span><span class="main">)</span> <span class="main">=</span> zip <span class="free">xs</span> <span class="free">us</span> <span class="main">@-</span> szip <span class="free">ys</span> <span class="free">zs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">us</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Suc_length_conv<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Link <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> stream"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> llist"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">llist_of_stream</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> stream <span class="main">⇒</span> <span class="tfree">'a</span> llist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">llist_of_stream</span> <span class="main">=</span> unfold_llist <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> False<span class="main">)</span> shd stl"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">stream_of_llist</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">⇒</span> <span class="tfree">'a</span> stream"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">stream_of_llist</span> <span class="main">=</span> unfold_stream lhd ltl"</span></span>

<span class="keyword1" id="Coinductive_Stream-lnull_llist_of_stream"><span class="command">lemma</span></span> lnull_llist_of_stream <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lnull <span class="main">(</span>llist_of_stream <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_of_stream_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_Stream-ltl_llist_of_stream"><span class="command">lemma</span></span> ltl_llist_of_stream <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ltl <span class="main">(</span>llist_of_stream <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> llist_of_stream <span class="main">(</span>stl <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_of_stream_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_Stream-stl_stream_of_llist"><span class="command">lemma</span></span> stl_stream_of_llist <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"stl <span class="main">(</span>stream_of_llist <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> stream_of_llist <span class="main">(</span>ltl <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> stream_of_llist_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_Stream-shd_stream_of_llist"><span class="command">lemma</span></span> shd_stream_of_llist <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"shd <span class="main">(</span>stream_of_llist <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lhd <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> stream_of_llist_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_Stream-lhd_llist_of_stream"><span class="command">lemma</span></span> lhd_llist_of_stream <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lhd <span class="main">(</span>llist_of_stream <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> shd <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_of_stream_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_Stream-stream_of_llist_llist_of_stream"><span class="command">lemma</span></span> stream_of_llist_llist_of_stream <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"stream_of_llist <span class="main">(</span>llist_of_stream <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_Stream-llist_of_stream_stream_of_llist"><span class="command">lemma</span></span> llist_of_stream_stream_of_llist <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">¬</span> lfinite <span class="free">xs</span> <span class="main">⟹</span> llist_of_stream <span class="main">(</span>stream_of_llist <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_Stream-lfinite_llist_of_stream"><span class="command">lemma</span></span> lfinite_llist_of_stream <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lfinite <span class="main">(</span>llist_of_stream <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>llist_of_stream <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted">False</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"llist_of_stream <span class="free">xs</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lfinite_induct<span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_Stream-stream_from_llist"><span class="command">lemma</span></span> stream_from_llist<span class="main">:</span> <span class="quoted"><span class="quoted">"type_definition llist_of_stream stream_of_llist <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lfinite <span class="bound">xs</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">interpretation</span></span> stream<span class="main">:</span> type_definition <span class="quoted">llist_of_stream</span> <span class="quoted">stream_of_llist</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lfinite <span class="bound">xs</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> stream_from_llist<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> stream.exhaust<span class="main">[</span><span class="operator">cases</span> <span class="quasi_keyword">type</span><span class="main"><span class="main">:</span></span> stream<span class="main">]</span>

<span class="keyword1"><span class="command">locale</span></span> stream_from_llist_setup
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">setup_lifting</span></span> stream_from_llist
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> stream_from_llist_setup <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1" id="Coinductive_Stream-cr_streamI"><span class="command">lemma</span></span> cr_streamI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lfinite <span class="free">xs</span> <span class="main">⟹</span> cr_stream <span class="free">xs</span> <span class="main">(</span>stream_of_llist <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cr_stream_def Abs_stream_inverse<span class="main">)</span>

<span class="keyword1" id="Coinductive_Stream-llist_of_stream_unfold_stream"><span class="command">lemma</span></span> llist_of_stream_unfold_stream <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"llist_of_stream <span class="main">(</span>unfold_stream <span class="free">SHD</span> <span class="free">STL</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> unfold_llist <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> False<span class="main">)</span> <span class="free">SHD</span> <span class="free">STL</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_Stream-llist_of_stream_corec_stream"><span class="command">lemma</span></span> llist_of_stream_corec_stream <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"llist_of_stream <span class="main">(</span>corec_stream <span class="free">SHD</span> <span class="free">endORmore</span> <span class="free">STL_more</span> <span class="free">STL_end</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span>
   corec_llist <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> False<span class="main">)</span> <span class="free">SHD</span> <span class="free">endORmore</span> <span class="main">(</span>llist_of_stream <span class="main">∘</span> <span class="free">STL_more</span><span class="main">)</span> <span class="free">STL_end</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> llist.coinduct_strong<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_Stream-LCons_llist_of_stream"><span class="command">lemma</span></span> LCons_llist_of_stream <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"LCons <span class="free">x</span> <span class="main">(</span>llist_of_stream <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> llist_of_stream <span class="main">(</span><span class="free">x</span> <span class="main">##</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> sym<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_of_stream_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_Stream-lmap_llist_of_stream"><span class="command">lemma</span></span> lmap_llist_of_stream <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lmap <span class="free">f</span> <span class="main">(</span>llist_of_stream <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> llist_of_stream <span class="main">(</span>smap <span class="free">f</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_Stream-lset_llist_of_stream"><span class="command">lemma</span></span> lset_llist_of_stream <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lset <span class="main">(</span>llist_of_stream <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> sset <span class="free">xs</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">intro</span> set_eqI iffI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="var">?lhs</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="var">?rhs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"llist_of_stream <span class="free">xs</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> llist_set_induct<span class="main">)</span>
      <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> stream.set_sel<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="var">?rhs</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="var">?lhs</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>shd <span class="skolem">xs</span><span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> llist.set_sel<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"llist_of_stream <span class="skolem">xs</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> stl
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltl_llist_of_stream<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> ltl_llist_of_stream <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> in_lset_ltlD<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_Stream-lnth_list_of_stream"><span class="command">lemma</span></span> lnth_list_of_stream <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lnth <span class="main">(</span>llist_of_stream <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> snth <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">n</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"lnth <span class="main">(</span>llist_of_stream <span class="free">xs</span><span class="main">)</span> <span class="skolem">n</span> <span class="main">=</span> snth <span class="free">xs</span> <span class="skolem">n</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnth_0_conv_lhd lnth_ltl<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_Stream-llist_of_stream_siterates"><span class="command">lemma</span></span> llist_of_stream_siterates <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"llist_of_stream <span class="main">(</span>siterate <span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> iterates <span class="free">f</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_Stream-lappend_llist_of_stream_conv_shift"><span class="command">lemma</span></span> lappend_llist_of_stream_conv_shift <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lappend <span class="main">(</span>llist_of <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>llist_of_stream <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> llist_of_stream <span class="main">(</span><span class="free">xs</span> <span class="main">@-</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Coinductive_Stream-lzip_llist_of_stream"><span class="command">lemma</span></span> lzip_llist_of_stream <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lzip <span class="main">(</span>llist_of_stream <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>llist_of_stream <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> llist_of_stream <span class="main">(</span>szip <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Coinductive_Stream-lmap_infinite_transfer"><span class="command">lemma</span></span> lmap_infinite_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> eq_onp <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lfinite <span class="bound">xs</span><span class="main">)</span> <span class="main">===&gt;</span> eq_onp <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lfinite <span class="bound">xs</span><span class="main">)</span><span class="main">)</span> lmap lmap"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def eq_onp_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_Stream-lset_infinite_transfer"><span class="command">lemma</span></span> lset_infinite_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>eq_onp <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lfinite <span class="bound">xs</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> lset lset"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def eq_onp_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_Stream-unfold_stream_transfer"><span class="command">lemma</span></span> unfold_stream_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> pcr_stream <span class="main">(=)</span><span class="main">)</span> <span class="main">(</span>unfold_llist <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> False<span class="main">)</span><span class="main">)</span> unfold_stream"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> stream.pcr_cr_eq cr_stream_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_funI<span class="main">)</span>

<span class="keyword1" id="Coinductive_Stream-corec_stream_transfer"><span class="command">lemma</span></span> corec_stream_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> pcr_stream <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> pcr_stream <span class="main">(=)</span><span class="main">)</span>
   <span class="main">(</span>corec_llist <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> False<span class="main">)</span><span class="main">)</span> corec_stream"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_funI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cr_stream_def stream.pcr_cr_eq<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> fun_cong<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">back</span></span></span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">yc</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> fun_cong<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">xb</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> arg_cong<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> rel_funE<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Coinductive_Stream-shd_transfer"><span class="command">lemma</span></span> shd_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>pcr_stream <span class="free">A</span> <span class="main">===&gt;</span> <span class="free">A</span><span class="main">)</span> lhd shd"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pcr_stream_def cr_stream_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_funI relcomppI<span class="main">)</span><span class="main">(</span><span class="operator">frule</span> llist_all2_lhdD<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> llist_all2_lnullD<span class="main">)</span>

<span class="keyword1" id="Coinductive_Stream-stl_transfer"><span class="command">lemma</span></span> stl_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>pcr_stream <span class="free">A</span> <span class="main">===&gt;</span> pcr_stream <span class="free">A</span><span class="main">)</span> ltl stl"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pcr_stream_def cr_stream_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_funI relcomppI <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> llist_all2_ltlI<span class="main">)</span>

<span class="keyword1" id="Coinductive_Stream-llist_of_stream_transfer"><span class="command">lemma</span></span> llist_of_stream_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>pcr_stream <span class="main">(=)</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> id llist_of_stream"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def stream.pcr_cr_eq cr_stream_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_Stream-stream_of_llist_transfer"><span class="command">lemma</span></span> stream_of_llist_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>eq_onp <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lfinite <span class="bound">xs</span><span class="main">)</span> <span class="main">===&gt;</span> pcr_stream <span class="main">(=)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="bound">xs</span><span class="main">)</span> stream_of_llist"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_onp_def rel_fun_def stream.pcr_cr_eq cr_stream_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_Stream-SCons_transfer"><span class="command">lemma</span></span> SCons_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> pcr_stream <span class="free">A</span> <span class="main">===&gt;</span> pcr_stream <span class="free">A</span><span class="main">)</span> LCons <span class="main">(##)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cr_stream_def pcr_stream_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_funI relcomppI <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> llist_all2_expand<span class="main">)</span>

<span class="keyword1" id="Coinductive_Stream-sset_transfer"><span class="command">lemma</span></span> sset_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>pcr_stream <span class="free">A</span> <span class="main">===&gt;</span> rel_set <span class="free">A</span><span class="main">)</span> lset sset"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pcr_stream_def cr_stream_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_funI relcomppI rel_setI <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> llist_all2_lsetD1 llist_all2_lsetD2<span class="main">)</span>

<span class="keyword1" id="Coinductive_Stream-smap_transfer"><span class="command">lemma</span></span> smap_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">B</span><span class="main">)</span> <span class="main">===&gt;</span> pcr_stream <span class="free">A</span> <span class="main">===&gt;</span> pcr_stream <span class="free">B</span><span class="main">)</span> lmap smap"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cr_stream_def pcr_stream_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_funI relcomppI <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lmap_transfer<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> rel_funD<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> rel_funD<span class="main">)</span>

<span class="keyword1" id="Coinductive_Stream-snth_transfer"><span class="command">lemma</span></span> snth_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>pcr_stream <span class="main">(=)</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> lnth snth"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> rel_funI<span class="main">)</span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> stream.pcr_cr_eq cr_stream_def fun_eq_iff<span class="main">)</span>

<span class="keyword1" id="Coinductive_Stream-siterate_transfer"><span class="command">lemma</span></span> siterate_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> pcr_stream <span class="main">(=)</span><span class="main">)</span> iterates siterate"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> rel_funI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> stream.pcr_cr_eq cr_stream_def<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">xs</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> inf<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lfinite <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span> <span class="main">=</span> eq_onpI<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> P<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lfinite <span class="bound">xs</span>"</span></span><span class="main">,</span> <span class="operator">OF</span> inf<span class="main">]</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Coinductive_Stream-smap_stream_of_llist"><span class="command">lemma</span></span> smap_stream_of_llist <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"smap <span class="free">f</span> <span class="main">(</span>stream_of_llist <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> stream_of_llist <span class="main">(</span>lmap <span class="free">f</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_Stream-sset_stream_of_llist"><span class="command">lemma</span></span> sset_stream_of_llist <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lfinite <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sset <span class="main">(</span>stream_of_llist <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lset <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Coinductive_Stream-llist_all2_llist_of_stream"><span class="command">lemma</span></span> llist_all2_llist_of_stream <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"llist_all2 <span class="free">P</span> <span class="main">(</span>llist_of_stream <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>llist_of_stream <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> stream_all2 <span class="free">P</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> stream.Abs_cases<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> stream.Abs_cases<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_all2_def stream_all2_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">safe</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> GrpE<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> b<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"stream_of_llist <span class="improper">b</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> relcomppI<span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> GrpI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> b<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"llist_of_stream <span class="improper">b</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> relcomppI<span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> GrpI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Coinductive_Stream-stream_all2_transfer"><span class="command">lemma</span></span> stream_all2_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> pcr_stream <span class="main">(=)</span> <span class="main">===&gt;</span> pcr_stream <span class="main">(=)</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> llist_all2 stream_all2"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def stream.pcr_cr_eq cr_stream_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_Stream-stream_all2_coinduct"><span class="command">lemma</span></span> stream_all2_coinduct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span> <span class="bound">ys</span><span class="main">.</span> <span class="free">X</span> <span class="bound">xs</span> <span class="bound">ys</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span>shd <span class="bound">xs</span><span class="main">)</span> <span class="main">(</span>shd <span class="bound">ys</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="free">X</span> <span class="main">(</span>stl <span class="bound">xs</span><span class="main">)</span> <span class="main">(</span>stl <span class="bound">ys</span><span class="main">)</span> <span class="main">∨</span> stream_all2 <span class="free">P</span> <span class="main">(</span>stl <span class="bound">xs</span><span class="main">)</span> <span class="main">(</span>stl <span class="bound">ys</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"stream_all2 <span class="free">P</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> X<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">xs</span> <span class="bound">ys</span><span class="main">.</span> <span class="main">¬</span> lfinite <span class="bound">xs</span> <span class="main">∧</span> <span class="main">¬</span> lfinite <span class="bound">ys</span> <span class="main">∧</span> <span class="improper">X</span> <span class="bound">xs</span> <span class="bound">ys</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> llist_all2_coinduct<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Coinductive_Stream-shift_transfer"><span class="command">lemma</span></span> shift_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> pcr_stream <span class="main">(=)</span> <span class="main">===&gt;</span> pcr_stream <span class="main">(=)</span><span class="main">)</span> <span class="main">(</span>lappend <span class="main">∘</span> llist_of<span class="main">)</span> shift"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def stream.pcr_cr_eq cr_stream_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_Stream-szip_transfer"><span class="command">lemma</span></span> szip_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>pcr_stream <span class="main">(=)</span> <span class="main">===&gt;</span> pcr_stream <span class="main">(=)</span> <span class="main">===&gt;</span> pcr_stream <span class="main">(=)</span><span class="main">)</span> lzip szip"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> stream.pcr_cr_eq cr_stream_def rel_fun_def<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Link <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> stream"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"nat <span class="main"><span class="main">⇒</span></span> <span class="tfree"><span class="tfree">'a</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> of_seq <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> stream"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"inf_llist"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_Stream-of_seq_rec"><span class="command">lemma</span></span> of_seq_rec <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"of_seq <span class="free">f</span> <span class="main">=</span> <span class="free">f</span> <span class="main">0</span> <span class="main">##</span> of_seq <span class="main">(</span><span class="free">f</span> <span class="main">∘</span> Suc<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">subst</span> inf_llist_rec<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_Stream-snth_of_seq"><span class="command">lemma</span></span> snth_of_seq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"snth <span class="main">(</span>of_seq <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>

<span class="keyword1" id="Coinductive_Stream-snth_SCons"><span class="command">lemma</span></span> snth_SCons<span class="main">:</span> <span class="quoted"><span class="quoted">"snth <span class="main">(</span><span class="free">x</span> <span class="main">##</span> <span class="free">xs</span><span class="main">)</span> <span class="free">n</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">n</span> <span class="keyword1">of</span> <span class="main">0</span> <span class="main">⇒</span> <span class="free">x</span> <span class="main">|</span> Suc <span class="bound">n'</span> <span class="main">⇒</span> snth <span class="free">xs</span> <span class="bound">n'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> nat.split<span class="main">)</span>

<span class="keyword1" id="Coinductive_Stream-snth_SCons_simps"><span class="command">lemma</span></span> snth_SCons_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> snth_SCons_0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">##</span> <span class="free">xs</span><span class="main">)</span> <span class="main">!!</span> <span class="main">0</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> snth_SCons_Suc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">##</span> <span class="free">xs</span><span class="main">)</span> <span class="main">!!</span> Suc <span class="free">n</span> <span class="main">=</span> <span class="free">xs</span> <span class="main">!!</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> snth_SCons<span class="main">)</span>

<span class="keyword1" id="Coinductive_Stream-of_seq_snth"><span class="command">lemma</span></span> of_seq_snth <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"of_seq <span class="main">(</span>snth <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_Stream-shd_of_seq"><span class="command">lemma</span></span> shd_of_seq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"shd <span class="main">(</span>of_seq <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_Stream-stl_of_seq"><span class="command">lemma</span></span> stl_of_seq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"stl <span class="main">(</span>of_seq <span class="free">f</span><span class="main">)</span> <span class="main">=</span> of_seq <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span>Suc <span class="bound">n</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_Stream-sset_of_seq"><span class="command">lemma</span></span> sset_of_seq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sset <span class="main">(</span>of_seq <span class="free">f</span><span class="main">)</span> <span class="main">=</span> range <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Coinductive_Stream-smap_of_seq"><span class="command">lemma</span></span> smap_of_seq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"smap <span class="free">f</span> <span class="main">(</span>of_seq <span class="free">g</span><span class="main">)</span> <span class="main">=</span> of_seq <span class="main">(</span><span class="free">f</span> <span class="main">∘</span> <span class="free">g</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Function iteration <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> siterate<span class="antiquote"><span class="antiquote">}</span></span></span></span>  and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">sconst</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> siterate <span class="main">[</span><span class="operator">nitpick_simp</span><span class="main">]</span> <span class="main">=</span> siterate.code

<span class="keyword1" id="Coinductive_Stream-smap_iterates"><span class="command">lemma</span></span> smap_iterates<span class="main">:</span> <span class="quoted"><span class="quoted">"smap <span class="free">f</span> <span class="main">(</span>siterate <span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> siterate <span class="free">f</span> <span class="main">(</span><span class="free">f</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">rule</span> lmap_iterates<span class="main">)</span>

<span class="keyword1" id="Coinductive_Stream-siterate_smap"><span class="command">lemma</span></span> siterate_smap<span class="main">:</span> <span class="quoted"><span class="quoted">"siterate <span class="free">f</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span> <span class="main">##</span> <span class="main">(</span>smap <span class="free">f</span> <span class="main">(</span>siterate <span class="free">f</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">rule</span> iterates_lmap<span class="main">)</span>

<span class="keyword1" id="Coinductive_Stream-siterate_conv_of_seq"><span class="command">lemma</span></span> siterate_conv_of_seq<span class="main">:</span> <span class="quoted"><span class="quoted">"siterate <span class="free">f</span> <span class="free">a</span> <span class="main">=</span> of_seq <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="main">(</span><span class="free">f</span> <span class="main">^^</span> <span class="bound">n</span><span class="main">)</span> <span class="free">a</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">rule</span> iterates_conv_inf_llist<span class="main">)</span>

<span class="keyword1" id="Coinductive_Stream-sconst_conv_of_seq"><span class="command">lemma</span></span> sconst_conv_of_seq<span class="main">:</span> <span class="quoted"><span class="quoted">"sconst <span class="free">a</span> <span class="main">=</span> of_seq <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">a</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> siterate_conv_of_seq<span class="main">)</span>

<span class="keyword1" id="Coinductive_Stream-szip_sconst1"><span class="command">lemma</span></span> szip_sconst1 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"szip <span class="main">(</span>sconst <span class="free">a</span><span class="main">)</span> <span class="free">xs</span> <span class="main">=</span> smap <span class="main">(</span>Pair <span class="free">a</span><span class="main">)</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_Stream-szip_sconst2"><span class="command">lemma</span></span> szip_sconst2 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"szip <span class="free">xs</span> <span class="main">(</span>sconst <span class="free">b</span><span class="main">)</span> <span class="main">=</span> smap <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="free">b</span><span class="main">)</span><span class="main">)</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹ Counting elements ›</span></span>

<span class="keyword1"><span class="command">partial_function</span></span> <span class="main">(</span>lfp<span class="main">)</span> <span class="entity">scount</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span> stream <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'s</span> stream <span class="main">⇒</span> enat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">scount</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">ω</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">ω</span></span></span> <span class="keyword1">then</span> eSuc <span class="main">(</span><span class="free">scount</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">(</span>stl <span class="free"><span class="bound"><span class="entity">ω</span></span></span><span class="main">)</span><span class="main">)</span> <span class="keyword1">else</span> <span class="free">scount</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">(</span>stl <span class="free"><span class="bound"><span class="entity">ω</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Coinductive_Stream-scount_simps"><span class="command">lemma</span></span> scount_simps<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">ω</span> <span class="main">⟹</span> scount <span class="free">P</span> <span class="free">ω</span> <span class="main">=</span> eSuc <span class="main">(</span>scount <span class="free">P</span> <span class="main">(</span>stl <span class="free">ω</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">P</span> <span class="free">ω</span> <span class="main">⟹</span> scount <span class="free">P</span> <span class="free">ω</span> <span class="main">=</span> scount <span class="free">P</span> <span class="main">(</span>stl <span class="free">ω</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> scount.simps<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">P</span></span> <span class="quoted"><span class="free">ω</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_Stream-scount_eq_0I"><span class="command">lemma</span></span> scount_eq_0I<span class="main">:</span> <span class="quoted"><span class="quoted">"alw <span class="main">(</span>not <span class="free">P</span><span class="main">)</span> <span class="free">ω</span> <span class="main">⟹</span> scount <span class="free">P</span> <span class="free">ω</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">ω</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> scount.fixp_induct<span class="main">)</span>
     <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> bot_enat_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> admissible_all admissible_imp admissible_eq_mcontI mcont_const<span class="main">)</span>

<span class="keyword1" id="Coinductive_Stream-scount_eq_0D"><span class="command">lemma</span></span> scount_eq_0D<span class="main">:</span> <span class="quoted"><span class="quoted">"scount <span class="free">P</span> <span class="free">ω</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟹</span> alw <span class="main">(</span>not <span class="free">P</span><span class="main">)</span> <span class="free">ω</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> alw.coinduct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>alw <span class="skolem">ω</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> scount.simps<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">P</span></span> <span class="quoted"><span class="skolem">ω</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_Stream-scount_eq_0_iff"><span class="command">lemma</span></span> scount_eq_0_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"scount <span class="free">P</span> <span class="free">ω</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟷</span> alw <span class="main">(</span>not <span class="free">P</span><span class="main">)</span> <span class="free">ω</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> scount_eq_0D scount_eq_0I<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ev <span class="main">(</span>alw <span class="main">(</span>not <span class="free">P</span><span class="main">)</span><span class="main">)</span> <span class="free">ω</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> scount_eq_card<span class="main">:</span> <span class="quoted"><span class="quoted">"scount <span class="free">P</span> <span class="free">ω</span> <span class="main">=</span> enat <span class="main">(</span>card <span class="main">{</span><span class="bound">i</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span>sdrop <span class="bound">i</span> <span class="free">ω</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> ev_alw_not_HLD_finite<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">{</span><span class="bound">i</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span>sdrop <span class="bound">i</span> <span class="free">ω</span><span class="main">)</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">ω</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">ω</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">i</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span>sdrop <span class="bound">i</span> <span class="skolem">ω</span><span class="main">)</span><span class="main">}</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">P</span> <span class="skolem">ω</span> <span class="keyword1">then</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span> <span class="keyword1">else</span> <span class="main">{}</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>Suc <span class="main">`</span> <span class="main">{</span><span class="bound">i</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span>sdrop <span class="bound">i</span> <span class="main">(</span>stl <span class="skolem">ω</span><span class="main">)</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> set_eqI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> image_iff<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">case</span></span> 1 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> step <span class="keyword1"><span class="command">unfolding</span></span> eq <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> scount_simps card_image zero_notin_Suc_image eSuc_enat<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">case</span></span> 2 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> step <span class="keyword1"><span class="command">unfolding</span></span> eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> <span class="keyword1"><span class="command">}</span></span>
<span class="keyword1"><span class="command">next</span></span>
   <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>base <span class="skolem">ω</span><span class="main">)</span>
   <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">i</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span>sdrop <span class="bound">i</span> <span class="skolem">ω</span><span class="main">)</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
     <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_HLD alw_iff_sdrop<span class="main">)</span>
   <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">case</span></span> 1 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> base <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> scount_eq_0I enat_0<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
   <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">case</span></span> 2 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="keyword1"><span class="command">}</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_Stream-scount_finite"><span class="command">lemma</span></span> scount_finite<span class="main">:</span> <span class="quoted"><span class="quoted">"ev <span class="main">(</span>alw <span class="main">(</span>not <span class="free">P</span><span class="main">)</span><span class="main">)</span> <span class="free">ω</span> <span class="main">⟹</span> scount <span class="free">P</span> <span class="free">ω</span> <span class="main">&lt;</span> <span class="main">∞</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> scount_eq_card<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">P</span></span> <span class="quoted"><span class="free">ω</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_Stream-scount_infinite"><span class="command">lemma</span></span> scount_infinite<span class="main">:</span>
  <span class="quoted"><span class="quoted">"alw <span class="main">(</span>ev <span class="free">P</span><span class="main">)</span> <span class="free">ω</span> <span class="main">⟹</span> scount <span class="free">P</span> <span class="free">ω</span> <span class="main">=</span> <span class="main">∞</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">ω</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_coinduct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Eq_enat <span class="skolem">ω</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ev <span class="free">P</span> <span class="skolem">ω</span>"</span></span> <span class="quoted"><span class="quoted">"alw <span class="main">(</span>ev <span class="free">P</span><span class="main">)</span> <span class="skolem">ω</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> ev_induct_strong<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> scount_simps<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_Stream-scount_infinite_iff"><span class="command">lemma</span></span> scount_infinite_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"scount <span class="free">P</span> <span class="free">ω</span> <span class="main">=</span> <span class="main">∞</span> <span class="main">⟷</span> alw <span class="main">(</span>ev <span class="free">P</span><span class="main">)</span> <span class="free">ω</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> enat_ord_simps<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span> not_alw_not scount_finite scount_infinite<span class="main">)</span>

<span class="keyword1" id="Coinductive_Stream-scount_eq"><span class="command">lemma</span></span> scount_eq<span class="main">:</span>
  <span class="quoted"><span class="quoted">"scount <span class="free">P</span> <span class="free">ω</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> alw <span class="main">(</span>ev <span class="free">P</span><span class="main">)</span> <span class="free">ω</span> <span class="keyword1">then</span> <span class="main">∞</span> <span class="keyword1">else</span> enat <span class="main">(</span>card <span class="main">{</span><span class="bound">i</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span>sdrop <span class="bound">i</span> <span class="free">ω</span><span class="main">)</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> scount_infinite_iff scount_eq_card not_alw_iff not_ev_iff<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹ First index of an element ›</span></span>

<span class="keyword1"><span class="command">partial_function</span></span> <span class="main">(</span>gfp<span class="main">)</span> <span class="entity">sfirst</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span> stream <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'s</span> stream <span class="main">⇒</span> enat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">sfirst</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">ω</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">ω</span></span></span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> eSuc <span class="main">(</span><span class="free">sfirst</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">(</span>stl <span class="free"><span class="bound"><span class="entity">ω</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Coinductive_Stream-sfirst_eq_0"><span class="command">lemma</span></span> sfirst_eq_0<span class="main">:</span> <span class="quoted"><span class="quoted">"sfirst <span class="free">P</span> <span class="free">ω</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟷</span> <span class="free">P</span> <span class="free">ω</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> sfirst.simps<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_Stream-sfirst_0"><span class="command">lemma</span></span> sfirst_0<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">ω</span> <span class="main">⟹</span> sfirst <span class="free">P</span> <span class="free">ω</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> sfirst.simps<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_Stream-sfirst_eSuc"><span class="command">lemma</span></span> sfirst_eSuc<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">P</span> <span class="free">ω</span> <span class="main">⟹</span> sfirst <span class="free">P</span> <span class="free">ω</span> <span class="main">=</span> eSuc <span class="main">(</span>sfirst <span class="free">P</span> <span class="main">(</span>stl <span class="free">ω</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> sfirst.simps<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Coinductive_Stream-less_sfirstD"><span class="command">lemma</span></span> less_sfirstD<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">n</span> <span class="main">::</span> <span class="quoted">nat</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"enat <span class="free">n</span> <span class="main">&lt;</span> sfirst <span class="free">P</span> <span class="free">ω</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">P</span> <span class="main">(</span>sdrop <span class="free">n</span> <span class="free">ω</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">ω</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sfirst.simps<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="skolem">ω</span></span><span class="main"><span class="main">]</span></span> eSuc_enat<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> enat_0 sfirst_eq_0<span class="main">)</span>

<span class="keyword1" id="Coinductive_Stream-sfirst_finite"><span class="command">lemma</span></span> sfirst_finite<span class="main">:</span> <span class="quoted"><span class="quoted">"sfirst <span class="free">P</span> <span class="free">ω</span> <span class="main">&lt;</span> <span class="main">∞</span> <span class="main">⟷</span> ev <span class="free">P</span> <span class="free">ω</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"sfirst <span class="free">P</span> <span class="free">ω</span> <span class="main">&lt;</span> <span class="main">∞</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"sfirst <span class="free">P</span> <span class="free">ω</span> <span class="main">=</span> enat <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ev <span class="free">P</span> <span class="free">ω</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">ω</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eSuc_enat<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> sfirst.simps<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">P</span></span> <span class="quoted"><span class="skolem">ω</span></span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> enat_0 sfirst_eq_0<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"ev <span class="free">P</span> <span class="free">ω</span>"</span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"sfirst <span class="free">P</span> <span class="free">ω</span> <span class="main">&lt;</span> <span class="main">∞</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> ev_induct_strong<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> eSuc_enat<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_Stream-sfirst_Stream"><span class="command">lemma</span></span> sfirst_Stream<span class="main">:</span> <span class="quoted"><span class="quoted">"sfirst <span class="free">P</span> <span class="main">(</span><span class="free">s</span> <span class="main">##</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">P</span> <span class="main">(</span><span class="free">s</span> <span class="main">##</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> eSuc <span class="main">(</span>sfirst <span class="free">P</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> sfirst.simps<span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> HLD_iff<span class="main">)</span>

<span class="keyword1" id="Coinductive_Stream-less_sfirst_iff"><span class="command">lemma</span></span> less_sfirst_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>not <span class="free">P</span> <span class="keyword1">until</span> <span class="main">(</span>alw <span class="free">P</span><span class="main">)</span><span class="main">)</span> <span class="free">ω</span> <span class="main">⟹</span> enat <span class="free">n</span> <span class="main">&lt;</span> sfirst <span class="free">P</span> <span class="free">ω</span> <span class="main">⟷</span> <span class="main">¬</span> <span class="free">P</span> <span class="main">(</span>sdrop <span class="free">n</span> <span class="free">ω</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">ω</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> enat_0 sfirst_eq_0 HLD_iff<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> Suc.prems <span class="keyword1"><span class="command">have</span></span> **<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="skolem">ω</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span>stl <span class="skolem">ω</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> UNTIL.cases<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">P</span> <span class="main">(</span>sdrop <span class="skolem">n</span> <span class="main">(</span>stl <span class="skolem">ω</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> enat <span class="skolem">n</span> <span class="main">&lt;</span> sfirst <span class="free">P</span> <span class="main">(</span>stl <span class="skolem">ω</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> Suc.prems <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> Suc.IH<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> UNTIL.intros <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> UNTIL.cases<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> sdrop.simps * <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="skolem">ω</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ** eSuc_enat<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_Stream-sfirst_eq_Inf"><span class="command">lemma</span></span> sfirst_eq_Inf<span class="main">:</span> <span class="quoted"><span class="quoted">"sfirst <span class="free">P</span> <span class="free">ω</span> <span class="main">=</span> Inf <span class="main">{</span>enat <span class="bound">i</span> <span class="main">|</span> <span class="bound">i</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span>sdrop <span class="bound">i</span> <span class="free">ω</span><span class="main">)</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> antisym<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"sfirst <span class="free">P</span> <span class="free">ω</span> <span class="main">≤</span> <span class="main">⨅</span><span class="main">{</span>enat <span class="bound">i</span> <span class="main">|</span><span class="bound">i</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span>sdrop <span class="bound">i</span> <span class="free">ω</span><span class="main">)</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">safe</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Inf_greatest<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">ω</span> <span class="skolem">i</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span>sdrop <span class="skolem">i</span> <span class="skolem">ω</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"sfirst <span class="free">P</span> <span class="skolem">ω</span> <span class="main">≤</span> enat <span class="skolem">i</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">i</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">ω</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
       <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sfirst.simps<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">P</span></span> <span class="quoted"><span class="skolem">ω</span></span><span class="main"><span class="main">]</span></span> eSuc_enat<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">⨅</span><span class="main">{</span>enat <span class="bound">i</span> <span class="main">|</span><span class="bound">i</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span>sdrop <span class="bound">i</span> <span class="free">ω</span><span class="main">)</span><span class="main">}</span> <span class="main">≤</span> sfirst <span class="free">P</span> <span class="free">ω</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">ω</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> sfirst.fixp_induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>3 <span class="skolem">f</span><span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span>enat <span class="bound">i</span> <span class="main">|</span><span class="bound">i</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span>sdrop <span class="bound">i</span> <span class="skolem">ω</span><span class="main">)</span><span class="main">}</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">P</span> <span class="skolem">ω</span> <span class="keyword1">then</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span> <span class="keyword1">else</span> <span class="main">{}</span><span class="main">)</span> <span class="main">∪</span> eSuc <span class="main">`</span> <span class="main">{</span>enat <span class="bound">i</span> <span class="main">|</span><span class="bound">i</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span>sdrop <span class="bound">i</span> <span class="main">(</span>stl <span class="skolem">ω</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> set_eqI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_coexhaust<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> enat_0_iff image_iff eSuc_enat_iff<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">with</span></span> 3<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"stl <span class="skolem">ω</span>"</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inf.absorb1 eSuc_Inf<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Coinductive_Stream-sfirst_eq_enat_iff"><span class="command">lemma</span></span> sfirst_eq_enat_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"sfirst <span class="free">P</span> <span class="free">ω</span> <span class="main">=</span> enat <span class="free">n</span> <span class="main">⟷</span> ev_at <span class="free">P</span> <span class="free">n</span> <span class="free">ω</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">ω</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eSuc_enat<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> sfirst.simps enat_0<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>stakeWhile›</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">stakeWhile</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> stream <span class="main">⇒</span> <span class="tfree">'a</span> llist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">stakeWhile</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> ltakeWhile <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">(</span>llist_of_stream <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Coinductive_Stream-stakeWhile_SCons"><span class="command">lemma</span></span> stakeWhile_SCons <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"stakeWhile <span class="free">P</span> <span class="main">(</span><span class="free">x</span> <span class="main">##</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">P</span> <span class="free">x</span> <span class="keyword1">then</span> LCons <span class="free">x</span> <span class="main">(</span>stakeWhile <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="keyword1">else</span> LNil<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> stakeWhile_def LCons_llist_of_stream<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> LCons_llist_of_stream<span class="main">)</span>

<span class="keyword1" id="Coinductive_Stream-lnull_stakeWhile"><span class="command">lemma</span></span> lnull_stakeWhile <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lnull <span class="main">(</span>stakeWhile <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">¬</span> <span class="free">P</span> <span class="main">(</span>shd <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> stakeWhile_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_Stream-lhd_stakeWhile"><span class="command">lemma</span></span> lhd_stakeWhile <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span>shd <span class="free">xs</span><span class="main">)</span> <span class="main">⟹</span> lhd <span class="main">(</span>stakeWhile <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> shd <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> stakeWhile_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_Stream-ltl_stakeWhile"><span class="command">lemma</span></span> ltl_stakeWhile <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"ltl <span class="main">(</span>stakeWhile <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">P</span> <span class="main">(</span>shd <span class="free">xs</span><span class="main">)</span> <span class="keyword1">then</span> stakeWhile <span class="free">P</span> <span class="main">(</span>stl <span class="free">xs</span><span class="main">)</span> <span class="keyword1">else</span> LNil<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> stakeWhile_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_Stream-stakeWhile_K_False"><span class="command">lemma</span></span> stakeWhile_K_False <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"stakeWhile <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> False<span class="main">)</span> <span class="free">xs</span> <span class="main">=</span> LNil"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> stakeWhile_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_Stream-stakeWhile_K_True"><span class="command">lemma</span></span> stakeWhile_K_True <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"stakeWhile <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> <span class="free">xs</span> <span class="main">=</span> llist_of_stream <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> stakeWhile_def<span class="main">)</span>

<span class="keyword1" id="Coinductive_Stream-stakeWhile_smap"><span class="command">lemma</span></span> stakeWhile_smap<span class="main">:</span> <span class="quoted"><span class="quoted">"stakeWhile <span class="free">P</span> <span class="main">(</span>smap <span class="free">f</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lmap <span class="free">f</span> <span class="main">(</span>stakeWhile <span class="main">(</span><span class="free">P</span> <span class="main">∘</span> <span class="free">f</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> stakeWhile_def ltakeWhile_lmap<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> o_apply<span class="main">)</span>

<span class="keyword1" id="Coinductive_Stream-lfinite_stakeWhile"><span class="command">lemma</span></span> lfinite_stakeWhile <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>stakeWhile <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">∈</span>sset <span class="free">xs</span><span class="main">.</span> <span class="main">¬</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> stakeWhile_def lfinite_ltakeWhile<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="TLList">
<div class="head">
<h1>Theory TLList</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Terminated coinductive list
    Author:      Andreas Lochbihler
    Maintainer:  Andreas Lochbihler
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Terminated coinductive lists and their operations›</span></span>

<span class="keyword1"><span class="command">theory</span></span> TLList <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="#Coinductive_List">Coinductive_List</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Terminated coinductive lists <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>('a, 'b) tllist›</span></span></span></span> are the codatatype defined by the construtors
  <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>TNil›</span></span></span></span> of type <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'b ⇒ ('a, 'b) tllist›</span></span></span></span> and
  <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>TCons›</span></span></span></span> of type <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a ⇒ ('a, 'b) tllist ⇒ ('a, 'b) tllist›</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Auxiliary lemmas›</span></span>

<span class="keyword1" id="TLList-split_fst"><span class="command">lemma</span></span> split_fst<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">(</span>fst <span class="free">p</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">p</span> <span class="main">=</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">R</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1" id="TLList-split_fst_asm"><span class="command">lemma</span></span> split_fst_asm<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">(</span>fst <span class="free">p</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">¬</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">p</span> <span class="main">=</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∧</span> <span class="main">¬</span> <span class="free">R</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Type definition›</span></span>

<span class="keyword1"><span class="command">consts</span></span> terminal0 <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span>"</span></span>

<span class="keyword1"><span class="command">codatatype</span></span> <span class="main">(</span>tset<span class="main">:</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist <span class="main">=</span>
    TNil <span class="main">(</span><span class="free"><span class="free"><span class="entity">terminal</span></span></span> <span class="main">:</span> <span class="tfree"><span class="quoted"><span class="tfree">'b</span></span></span><span class="main">)</span>
  <span class="main">|</span> TCons <span class="main">(</span><span class="free"><span class="free"><span class="entity">thd</span></span></span> <span class="main">:</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="free"><span class="entity">ttl</span></span></span> <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist"</span></span><span class="main">)</span>
<span class="keyword2"><span class="keyword">for</span></span>
  map<span class="main">:</span> tmap
  rel<span class="main">:</span> tllist_all2
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">thd</span> <span class="main">(</span>TNil <span class="main">_</span><span class="main">)</span> <span class="main">=</span> undefined"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ttl</span> <span class="main">(</span>TNil <span class="free">b</span><span class="main">)</span> <span class="main">=</span> TNil <span class="free">b</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">terminal</span> <span class="main">(</span>TCons <span class="main">_</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> terminal0 <span class="free">xs</span>"</span></span>

<span class="keyword1"><span class="command">overloading</span></span>
  terminal0 <span class="main">==</span> <span class="quoted"><span class="quoted">"terminal0<span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">partial_function</span></span> <span class="main">(</span>tailrec<span class="main">)</span> <span class="entity">terminal0</span> 
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">terminal0</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> is_TNil <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">then</span> case_tllist id undefined <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">else</span> <span class="free">terminal0</span> <span class="main">(</span>ttl <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="TLList-terminal0_terminal"><span class="command">lemma</span></span> terminal0_terminal <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"terminal0 <span class="main">=</span> terminal"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> terminal0.simps<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> terminal_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemmas</span></span> terminal_TNil <span class="main">[</span><span class="operator">code</span><span class="main">,</span> <span class="operator">nitpick_simp</span><span class="main">]</span> <span class="main">=</span> tllist.sel<span class="main">(</span>1<span class="main">)</span>

<span class="keyword1" id="TLList-terminal_TCons"><span class="command">lemma</span></span> terminal_TCons <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span><span class="main">,</span> <span class="operator">nitpick_simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"terminal <span class="main">(</span>TCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> terminal <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">declare</span></span> tllist.sel<span class="main">(</span>2<span class="main">)</span> <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>

<span class="keyword1"><span class="command">primcorec</span></span> <span class="entity">unfold_tllist</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">⟹</span> <span class="free">unfold_tllist</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">g1</span></span></span> <span class="free"><span class="bound"><span class="entity">g21</span></span></span> <span class="free"><span class="bound"><span class="entity">g22</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">=</span> TNil <span class="main">(</span><span class="free"><span class="bound"><span class="entity">g1</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">⟹</span> <span class="free">unfold_tllist</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">g1</span></span></span> <span class="free"><span class="bound"><span class="entity">g21</span></span></span> <span class="free"><span class="bound"><span class="entity">g22</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">=</span>
     TCons <span class="main">(</span><span class="free"><span class="bound"><span class="entity">g21</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free">unfold_tllist</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">g1</span></span></span> <span class="free"><span class="bound"><span class="entity">g21</span></span></span> <span class="free"><span class="bound"><span class="entity">g22</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">g22</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">declare</span></span>
  unfold_tllist.ctr<span class="main">(</span>1<span class="main">)</span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  tllist.corec<span class="main">(</span>1<span class="main">)</span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Code generator setup›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Test quickcheck setup›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> TNil <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">quickcheck</span></span><span class="main">[</span>random<span class="main">,</span> expect<span class="main">=</span>counterexample<span class="main">]</span>
<span class="keyword1"><span class="command">quickcheck</span></span><span class="main">[</span>exhaustive<span class="main">,</span> expect<span class="main">=</span>counterexample<span class="main">]</span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"TCons <span class="free">x</span> <span class="free">xs</span> <span class="main">=</span> TCons <span class="free">x</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">quickcheck</span></span><span class="main">[</span>narrowing<span class="main">,</span> expect<span class="main">=</span>no_counterexample<span class="main">]</span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹More lemmas about generated constants›</span></span>

<span class="keyword1" id="TLList-ttl_unfold_tllist"><span class="command">lemma</span></span> ttl_unfold_tllist<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ttl <span class="main">(</span>unfold_tllist <span class="free">IS_TNIL</span> <span class="free">TNIL</span> <span class="free">THD</span> <span class="free">TTL</span> <span class="free">a</span><span class="main">)</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">IS_TNIL</span> <span class="free">a</span> <span class="keyword1">then</span> TNil <span class="main">(</span><span class="free">TNIL</span> <span class="free">a</span><span class="main">)</span> <span class="keyword1">else</span> unfold_tllist <span class="free">IS_TNIL</span> <span class="free">TNIL</span> <span class="free">THD</span> <span class="free">TTL</span> <span class="main">(</span><span class="free">TTL</span> <span class="free">a</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="TLList-is_TNil_ttl"><span class="command">lemma</span></span> is_TNil_ttl <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"is_TNil <span class="free">xs</span> <span class="main">⟹</span> is_TNil <span class="main">(</span>ttl <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="TLList-terminal_ttl"><span class="command">lemma</span></span> terminal_ttl <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"terminal <span class="main">(</span>ttl <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> terminal <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="TLList-unfold_tllist_eq_TNil"><span class="command">lemma</span></span> unfold_tllist_eq_TNil <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"unfold_tllist <span class="free">IS_TNIL</span> <span class="free">TNIL</span> <span class="free">THD</span> <span class="free">TTL</span> <span class="free">a</span> <span class="main">=</span> TNil <span class="free">b</span> <span class="main">⟷</span> <span class="free">IS_TNIL</span> <span class="free">a</span> <span class="main">∧</span> <span class="free">b</span> <span class="main">=</span> <span class="free">TNIL</span> <span class="free">a</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> unfold_tllist.code<span class="main">)</span>

<span class="keyword1" id="TLList-TNil_eq_unfold_tllist"><span class="command">lemma</span></span> TNil_eq_unfold_tllist <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"TNil <span class="free">b</span> <span class="main">=</span> unfold_tllist <span class="free">IS_TNIL</span> <span class="free">TNIL</span> <span class="free">THD</span> <span class="free">TTL</span> <span class="free">a</span> <span class="main">⟷</span> <span class="free">IS_TNIL</span> <span class="free">a</span> <span class="main">∧</span> <span class="free">b</span> <span class="main">=</span> <span class="free">TNIL</span> <span class="free">a</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> unfold_tllist.code<span class="main">)</span>

<span class="keyword1" id="TLList-tmap_is_TNil"><span class="command">lemma</span></span> tmap_is_TNil<span class="main">:</span> <span class="quoted"><span class="quoted">"is_TNil <span class="free">xs</span> <span class="main">⟹</span> tmap <span class="free">f</span> <span class="free">g</span> <span class="free">xs</span> <span class="main">=</span> TNil <span class="main">(</span><span class="free">g</span> <span class="main">(</span>terminal <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> is_TNil_def<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> tllist.map_sel<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">simp</span><span class="main">]</span>

<span class="keyword1" id="TLList-ttl_tmap"><span class="command">lemma</span></span> ttl_tmap <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ttl <span class="main">(</span>tmap <span class="free">f</span> <span class="free">g</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> tmap <span class="free">f</span> <span class="free">g</span> <span class="main">(</span>ttl <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="TLList-tmap_eq_TNil_conv"><span class="command">lemma</span></span> tmap_eq_TNil_conv<span class="main">:</span>
  <span class="quoted"><span class="quoted">"tmap <span class="free">f</span> <span class="free">g</span> <span class="free">xs</span> <span class="main">=</span> TNil <span class="free">y</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y'</span><span class="main">.</span> <span class="free">xs</span> <span class="main">=</span> TNil <span class="bound">y'</span> <span class="main">∧</span> <span class="free">g</span> <span class="bound">y'</span> <span class="main">=</span> <span class="free">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="TLList-TNil_eq_tmap_conv"><span class="command">lemma</span></span> TNil_eq_tmap_conv<span class="main">:</span>
  <span class="quoted"><span class="quoted">"TNil <span class="free">y</span> <span class="main">=</span> tmap <span class="free">f</span> <span class="free">g</span> <span class="free">xs</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y'</span><span class="main">.</span> <span class="free">xs</span> <span class="main">=</span> TNil <span class="bound">y'</span> <span class="main">∧</span> <span class="free">g</span> <span class="bound">y'</span> <span class="main">=</span> <span class="free">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">declare</span></span> tllist.set_sel<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">simp</span><span class="main">]</span>

<span class="keyword1" id="TLList-tset_ttl"><span class="command">lemma</span></span> tset_ttl<span class="main">:</span> <span class="quoted"><span class="quoted">"tset <span class="main">(</span>ttl <span class="free">xs</span><span class="main">)</span> <span class="main">⊆</span> tset <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="TLList-in_tset_ttlD"><span class="command">lemma</span></span> in_tset_ttlD<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> tset <span class="main">(</span>ttl <span class="free">xs</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">∈</span> tset <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> tset_ttl<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">xs</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">theorem</span></span> tllist_set_induct<span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> find step<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> tset <span class="free">xs</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> is_TNil <span class="bound">xs</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span>thd <span class="bound">xs</span><span class="main">)</span> <span class="bound">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span> <span class="bound">y</span><span class="main">.</span> <span class="main">⟦</span><span class="main">¬</span> is_TNil <span class="bound">xs</span><span class="main">;</span> <span class="bound">y</span> <span class="main">∈</span> tset <span class="main">(</span>ttl <span class="bound">xs</span><span class="main">)</span><span class="main">;</span> <span class="free">P</span> <span class="bound">y</span> <span class="main">(</span>ttl <span class="bound">xs</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">y</span> <span class="bound">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">x</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span><span class="main">)</span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> tllist.disc<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> <span class="quasi_keyword">iff</span><span class="main"><span class="main">:</span></span> tllist.disc<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">theorem</span></span> set2_tllist_induct<span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> find step<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> set2_tllist <span class="free">xs</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span><span class="main">.</span> is_TNil <span class="bound">xs</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span>terminal <span class="bound">xs</span><span class="main">)</span> <span class="bound">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span> <span class="bound">y</span><span class="main">.</span> <span class="main">⟦</span><span class="main">¬</span> is_TNil <span class="bound">xs</span><span class="main">;</span> <span class="bound">y</span> <span class="main">∈</span> set2_tllist <span class="main">(</span>ttl <span class="bound">xs</span><span class="main">)</span><span class="main">;</span> <span class="free">P</span> <span class="bound">y</span> <span class="main">(</span>ttl <span class="bound">xs</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">y</span> <span class="bound">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">x</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span><span class="main">)</span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> tllist.disc<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> <span class="quasi_keyword">iff</span><span class="main"><span class="main">:</span></span> tllist.disc<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Connection with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> llist"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">b</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'b</span></span></span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">primcorec</span></span> <span class="entity">tllist_of_llist</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">tllist_of_llist</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">of</span> LNil <span class="main">⇒</span> TNil <span class="free">b</span> <span class="main">|</span> LCons <span class="bound">x</span> <span class="bound">xs'</span> <span class="main">⇒</span> TCons <span class="bound">x</span> <span class="main">(</span><span class="free">tllist_of_llist</span> <span class="bound">xs'</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">primcorec</span></span> <span class="entity">llist_of_tllist</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist <span class="main">⇒</span> <span class="tfree">'a</span> llist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">llist_of_tllist</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">of</span> TNil <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> LNil <span class="main">|</span> TCons <span class="bound">x</span> <span class="bound">xs'</span> <span class="main">⇒</span> LCons <span class="bound">x</span> <span class="main">(</span><span class="free">llist_of_tllist</span> <span class="bound">xs'</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">simps_of_case</span></span> tllist_of_llist_simps <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span><span class="main">,</span> <span class="operator">nitpick_simp</span><span class="main">]</span><span class="main">:</span> tllist_of_llist.code

<span class="keyword1"><span class="command">lemmas</span></span> tllist_of_llist_LNil <span class="main">=</span> tllist_of_llist_simps<span class="main">(</span>1<span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> tllist_of_llist_LCons <span class="main">=</span> tllist_of_llist_simps<span class="main">(</span>2<span class="main">)</span>

<span class="keyword1" id="TLList-terminal_tllist_of_llist_lnull"><span class="command">lemma</span></span> terminal_tllist_of_llist_lnull <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lnull <span class="free">xs</span> <span class="main">⟹</span> terminal <span class="main">(</span>tllist_of_llist <span class="free">b</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">b</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> lnull_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">declare</span></span> tllist_of_llist.sel<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>

<span class="keyword1" id="TLList-lhd_LNil"><span class="command">lemma</span></span> lhd_LNil<span class="main">:</span> <span class="quoted"><span class="quoted">"lhd LNil <span class="main">=</span> undefined"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lhd_def<span class="main">)</span>

<span class="keyword1" id="TLList-thd_TNil"><span class="command">lemma</span></span> thd_TNil<span class="main">:</span> <span class="quoted"><span class="quoted">"thd <span class="main">(</span>TNil <span class="free">b</span><span class="main">)</span> <span class="main">=</span> undefined"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> thd_def<span class="main">)</span>

<span class="keyword1" id="TLList-thd_tllist_of_llist"><span class="command">lemma</span></span> thd_tllist_of_llist <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"thd <span class="main">(</span>tllist_of_llist <span class="free">b</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lhd <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> thd_TNil lhd_LNil<span class="main">)</span>

<span class="keyword1" id="TLList-ttl_tllist_of_llist"><span class="command">lemma</span></span> ttl_tllist_of_llist <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ttl <span class="main">(</span>tllist_of_llist <span class="free">b</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> tllist_of_llist <span class="free">b</span> <span class="main">(</span>ltl <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="TLList-llist_of_tllist_eq_LNil"><span class="command">lemma</span></span> llist_of_tllist_eq_LNil<span class="main">:</span>
  <span class="quoted"><span class="quoted">"llist_of_tllist <span class="free">xs</span> <span class="main">=</span> LNil <span class="main">⟷</span> is_TNil <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> llist_of_tllist.disc_iff<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> lnull_def <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">simps_of_case</span></span> llist_of_tllist_simps <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span><span class="main">,</span> <span class="operator">nitpick_simp</span><span class="main">]</span><span class="main">:</span> llist_of_tllist.code

<span class="keyword1"><span class="command">lemmas</span></span> llist_of_tllist_TNil <span class="main">=</span> llist_of_tllist_simps<span class="main">(</span>1<span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> llist_of_tllist_TCons <span class="main">=</span> llist_of_tllist_simps<span class="main">(</span>2<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> llist_of_tllist.sel <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword">del</span></span><span class="main">]</span>

<span class="keyword1" id="TLList-lhd_llist_of_tllist"><span class="command">lemma</span></span> lhd_llist_of_tllist <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> is_TNil <span class="free">xs</span> <span class="main">⟹</span> lhd <span class="main">(</span>llist_of_tllist <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> thd <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="TLList-ltl_llist_of_tllist"><span class="command">lemma</span></span> ltl_llist_of_tllist <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"ltl <span class="main">(</span>llist_of_tllist <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> llist_of_tllist <span class="main">(</span>ttl <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="TLList-tllist_of_llist_cong"><span class="command">lemma</span></span> tllist_of_llist_cong <span class="main">[</span><span class="operator">cong</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="free">xs'</span>"</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs'</span> <span class="main">⟹</span> <span class="free">b</span> <span class="main">=</span> <span class="free">b'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"tllist_of_llist <span class="free">b</span> <span class="free">xs</span> <span class="main">=</span> tllist_of_llist <span class="free">b'</span> <span class="free">xs'</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">unfold</span> <span class="quoted"><span class="quoted">‹<span class="free">xs</span> <span class="main">=</span> <span class="free">xs'</span>›</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs'</span> <span class="main">⟶</span> <span class="free">b</span> <span class="main">=</span> <span class="free">b'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"tllist_of_llist <span class="free">b</span> <span class="free">xs'</span> <span class="main">=</span> tllist_of_llist <span class="free">b'</span> <span class="free">xs'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs'</span></span><span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="TLList-llist_of_tllist_inverse"><span class="command">lemma</span></span> llist_of_tllist_inverse <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"tllist_of_llist <span class="main">(</span>terminal <span class="free">b</span><span class="main">)</span> <span class="main">(</span>llist_of_tllist <span class="free">b</span><span class="main">)</span> <span class="main">=</span> <span class="free">b</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">b</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="TLList-tllist_of_llist_eq"><span class="command">lemma</span></span> tllist_of_llist_eq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"tllist_of_llist <span class="free">b'</span> <span class="free">xs</span> <span class="main">=</span> TNil <span class="free">b</span> <span class="main">⟷</span> <span class="free">b</span> <span class="main">=</span> <span class="free">b'</span> <span class="main">∧</span> <span class="free">xs</span> <span class="main">=</span> LNil"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="TLList-TNil_eq_tllist_of_llist"><span class="command">lemma</span></span> TNil_eq_tllist_of_llist <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"TNil <span class="free">b</span> <span class="main">=</span> tllist_of_llist <span class="free">b'</span> <span class="free">xs</span> <span class="main">⟷</span> <span class="free">b</span> <span class="main">=</span> <span class="free">b'</span> <span class="main">∧</span> <span class="free">xs</span> <span class="main">=</span> LNil"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="TLList-tllist_of_llist_inject"><span class="command">lemma</span></span> tllist_of_llist_inject <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"tllist_of_llist <span class="free">b</span> <span class="free">xs</span> <span class="main">=</span> tllist_of_llist <span class="free">c</span> <span class="free">ys</span> <span class="main">⟷</span> <span class="free">xs</span> <span class="main">=</span> <span class="free">ys</span> <span class="main">∧</span> <span class="main">(</span>lfinite <span class="free">ys</span> <span class="main">⟶</span> <span class="free">b</span> <span class="main">=</span> <span class="free">c</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">intro</span> iffI conjI impI<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> tllist_of_llist_cong<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="free">ys</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnull_def neq_LNil_conv<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">ys</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">=</span> <span class="free">c</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?lhs</span>›</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> <span class="quoted"><span class="quoted">‹<span class="free">xs</span> <span class="main">=</span> <span class="free">ys</span>›</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="TLList-tllist_of_llist_inverse"><span class="command">lemma</span></span> tllist_of_llist_inverse <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"llist_of_tllist <span class="main">(</span>tllist_of_llist <span class="free">b</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">cr_tllist</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> llist <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">cr_tllist</span> <span class="main">≡</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="bound">ys</span><span class="main">.</span> tllist_of_llist <span class="bound">b</span> <span class="bound">xs</span> <span class="main">=</span> <span class="bound">ys</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="TLList-Quotient_tllist"><span class="command">lemma</span></span> Quotient_tllist<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Quotient <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="bound">a</span><span class="main">)</span> <span class="main">(</span><span class="bound">ys</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">.</span> <span class="bound">xs</span> <span class="main">=</span> <span class="bound">ys</span> <span class="main">∧</span> <span class="main">(</span>lfinite <span class="bound">ys</span> <span class="main">⟶</span> <span class="bound">a</span> <span class="main">=</span> <span class="bound">b</span><span class="main">)</span><span class="main">)</span>
     <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="bound">a</span><span class="main">)</span><span class="main">.</span> tllist_of_llist <span class="bound">a</span> <span class="bound">xs</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">ys</span><span class="main">.</span> <span class="main">(</span>llist_of_tllist <span class="bound">ys</span><span class="main">,</span> terminal <span class="bound">ys</span><span class="main">)</span><span class="main">)</span> cr_tllist"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Quotient_alt_def cr_tllist_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> tllist_of_llist_cong<span class="main">)</span>

<span class="keyword1" id="TLList-reflp_tllist"><span class="command">lemma</span></span> reflp_tllist<span class="main">:</span> <span class="quoted"><span class="quoted">"reflp <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="bound">a</span><span class="main">)</span> <span class="main">(</span><span class="bound">ys</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">.</span> <span class="bound">xs</span> <span class="main">=</span> <span class="bound">ys</span> <span class="main">∧</span> <span class="main">(</span>lfinite <span class="bound">ys</span> <span class="main">⟶</span> <span class="bound">a</span> <span class="main">=</span> <span class="bound">b</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> reflp_def<span class="main">)</span>

<span class="keyword1"><span class="command">setup_lifting</span></span> Quotient_tllist reflp_tllist

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="TLList-TNil_transfer"><span class="command">lemma</span></span> TNil_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">B</span> <span class="main">===&gt;</span> pcr_tllist <span class="free">A</span> <span class="free">B</span><span class="main">)</span> <span class="main">(</span>Pair LNil<span class="main">)</span> TNil"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pcr_tllist_def cr_tllist_def<span class="main">)</span>

<span class="keyword1" id="TLList-TCons_transfer"><span class="command">lemma</span></span> TCons_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> pcr_tllist <span class="free">A</span> <span class="free">B</span> <span class="main">===&gt;</span> pcr_tllist <span class="free">A</span> <span class="free">B</span><span class="main">)</span> <span class="main">(</span>apfst <span class="main">∘</span> LCons<span class="main">)</span> TCons"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pcr_tllist_def llist_all2_LCons1 cr_tllist_def<span class="main">)</span>

<span class="keyword1" id="TLList-tmap_tllist_of_llist"><span class="command">lemma</span></span> tmap_tllist_of_llist<span class="main">:</span>
  <span class="quoted"><span class="quoted">"tmap <span class="free">f</span> <span class="free">g</span> <span class="main">(</span>tllist_of_llist <span class="free">b</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> tllist_of_llist <span class="main">(</span><span class="free">g</span> <span class="free">b</span><span class="main">)</span> <span class="main">(</span>lmap <span class="free">f</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tmap_is_TNil<span class="main">)</span>

<span class="keyword1" id="TLList-tmap_transfer"><span class="command">lemma</span></span> tmap_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> pcr_tllist <span class="main">(=)</span> <span class="main">(=)</span> <span class="main">===&gt;</span> pcr_tllist <span class="main">(=)</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">(</span>map_prod <span class="main">∘</span> lmap<span class="main">)</span> tmap"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cr_tllist_def tllist.pcr_cr_eq tmap_tllist_of_llist<span class="main">)</span>

<span class="keyword1" id="TLList-lset_llist_of_tllist"><span class="command">lemma</span></span> lset_llist_of_tllist <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lset <span class="main">(</span>llist_of_tllist <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> tset <span class="free">xs</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">intro</span> set_eqI iffI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="var">?lhs</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="var">?rhs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"llist_of_tllist <span class="free">xs</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> llist_set_induct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> tllist.set_sel<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="var">?rhs</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="var">?lhs</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> tllist_set_induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>find <span class="skolem">xs</span><span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> step
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltl_llist_of_tllist<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> ltl_llist_of_tllist <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> in_lset_ltlD<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="TLList-tset_tllist_of_llist"><span class="command">lemma</span></span> tset_tllist_of_llist <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"tset <span class="main">(</span>tllist_of_llist <span class="free">b</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lset <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lset_llist_of_tllist<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> lset_llist_of_tllist<span class="main">)</span>

<span class="keyword1" id="TLList-tset_transfer"><span class="command">lemma</span></span> tset_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>pcr_tllist <span class="main">(=)</span> <span class="main">(=)</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">(</span>lset <span class="main">∘</span> fst<span class="main">)</span> tset"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cr_tllist_def tllist.pcr_cr_eq<span class="main">)</span>

<span class="keyword1" id="TLList-is_TNil_transfer"><span class="command">lemma</span></span> is_TNil_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>pcr_tllist <span class="main">(=)</span> <span class="main">(=)</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">.</span> lnull <span class="bound">xs</span><span class="main">)</span> is_TNil"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tllist.pcr_cr_eq cr_tllist_def<span class="main">)</span>

<span class="keyword1" id="TLList-thd_transfer"><span class="command">lemma</span></span> thd_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>pcr_tllist <span class="main">(=)</span> <span class="main">(=)</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">(</span>lhd <span class="main">∘</span> fst<span class="main">)</span> thd"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cr_tllist_def tllist.pcr_cr_eq<span class="main">)</span>

<span class="keyword1" id="TLList-ttl_transfer"><span class="command">lemma</span></span> ttl_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>pcr_tllist <span class="free">A</span> <span class="free">B</span> <span class="main">===&gt;</span> pcr_tllist <span class="free">A</span> <span class="free">B</span><span class="main">)</span> <span class="main">(</span>apfst ltl<span class="main">)</span> ttl"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pcr_tllist_def cr_tllist_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> llist_all2_ltlI<span class="main">)</span>

<span class="keyword1" id="TLList-llist_of_tllist_transfer"><span class="command">lemma</span></span> llist_of_tllist_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>pcr_tllist <span class="main">(=)</span> <span class="free">B</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> fst llist_of_tllist"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pcr_tllist_def cr_tllist_def llist.rel_eq<span class="main">)</span>

<span class="keyword1" id="TLList-tllist_of_llist_transfer"><span class="command">lemma</span></span> tllist_of_llist_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> pcr_tllist <span class="main">(=)</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">b</span> <span class="bound">xs</span><span class="main">.</span> <span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">)</span> tllist_of_llist"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tllist.pcr_cr_eq cr_tllist_def<span class="main">)</span>

<span class="keyword1" id="TLList-terminal_tllist_of_llist_lfinite"><span class="command">lemma</span></span> terminal_tllist_of_llist_lfinite <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span> <span class="main">⟹</span> terminal <span class="main">(</span>tllist_of_llist <span class="free">b</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">b</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lfinite.induct<span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="TLList-set2_tllist_tllist_of_llist"><span class="command">lemma</span></span> set2_tllist_tllist_of_llist <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"set2_tllist <span class="main">(</span>tllist_of_llist <span class="free">b</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> lfinite <span class="free">xs</span> <span class="keyword1">then</span> <span class="main">{</span><span class="free">b</span><span class="main">}</span> <span class="keyword1">else</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span><span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> set2_tllist <span class="main">(</span>tllist_of_llist <span class="free">b</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> False
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"tllist_of_llist <span class="free">b</span> <span class="free">xs</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> set2_tllist_induct<span class="main">)</span> <span class="operator">fastforce</span><span class="main"><span class="keyword3">+</span></span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> False <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="TLList-set2_tllist_transfer"><span class="command">lemma</span></span> set2_tllist_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>pcr_tllist <span class="free">A</span> <span class="free">B</span> <span class="main">===&gt;</span> rel_set <span class="free">B</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">if</span> lfinite <span class="bound">xs</span> <span class="keyword1">then</span> <span class="main">{</span><span class="bound">b</span><span class="main">}</span> <span class="keyword1">else</span> <span class="main">{}</span><span class="main">)</span> set2_tllist"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 4 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pcr_tllist_def cr_tllist_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> llist_all2_lfiniteD <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rel_setI<span class="main">)</span>

<span class="keyword1" id="TLList-tllist_all2_transfer"><span class="command">lemma</span></span> tllist_all2_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> pcr_tllist <span class="main">(=)</span> <span class="main">(=)</span> <span class="main">===&gt;</span> pcr_tllist <span class="main">(=)</span> <span class="main">(=)</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span>
     <span class="main">(</span><span class="main">λ</span><span class="bound">P</span> <span class="bound">Q</span> <span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="main">(</span><span class="bound">ys</span><span class="main">,</span> <span class="bound">b'</span><span class="main">)</span><span class="main">.</span> llist_all2 <span class="bound">P</span> <span class="bound">xs</span> <span class="bound">ys</span> <span class="main">∧</span> <span class="main">(</span>lfinite <span class="bound">xs</span> <span class="main">⟶</span> <span class="bound">Q</span> <span class="bound">b</span> <span class="bound">b'</span><span class="main">)</span><span class="main">)</span> tllist_all2"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> tllist.pcr_cr_eq
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> rel_funI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cr_tllist_def llist_all2_def tllist_all2_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">safe</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> GrpE<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> b<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"tllist_of_llist <span class="main">(</span><span class="improper">b</span><span class="main">,</span> <span class="improper">ba</span><span class="main">)</span> <span class="improper">bb</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> relcomppI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> GrpI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tmap_tllist_of_llist<span class="main">)</span><span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> b<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"tllist_of_llist <span class="main">(</span><span class="improper">b</span><span class="main">,</span> <span class="improper">ba</span><span class="main">)</span> <span class="improper">bb</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> relcomppI<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tmap_tllist_of_llist <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> GrpI <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span><span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> b<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"llist_of_tllist <span class="improper">bb</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> relcomppI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> GrpI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> GrpI <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Library function definitions›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We lift the constants from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> llist"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">,</span></span> <span class="tfree"><span class="tfree">'b</span></span><span class="main"><span class="main">)</span></span> tllist"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> using the lifting package.
  This way, many results are transferred easily.
›</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> tappend <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'c</span><span class="main">)</span> tllist<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'c</span><span class="main">)</span> tllist"</span></span>
<span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="bound">f</span><span class="main">.</span> apfst <span class="main">(</span>lappend <span class="bound">xs</span><span class="main">)</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">b</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_def lappend_inf<span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> lappendt <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist"</span></span>
<span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"apfst <span class="main">∘</span> lappend"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_def<span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> tfilter <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist"</span></span>
<span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">b</span> <span class="bound">P</span> <span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="bound">b'</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span>lfilter <span class="bound">P</span> <span class="bound">xs</span><span class="main">,</span> <span class="keyword1">if</span> lfinite <span class="bound">xs</span> <span class="keyword1">then</span> <span class="bound">b'</span> <span class="keyword1">else</span> <span class="bound">b</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta<span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> tconcat <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> llist<span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist"</span></span>
<span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">b</span> <span class="main">(</span><span class="bound">xss</span><span class="main">,</span> <span class="bound">b'</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span>lconcat <span class="bound">xss</span><span class="main">,</span> <span class="keyword1">if</span> lfinite <span class="bound">xss</span> <span class="keyword1">then</span> <span class="bound">b'</span> <span class="keyword1">else</span> <span class="bound">b</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta<span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> tnth <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist <span class="main">⇒</span> nat <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
<span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"lnth <span class="main">∘</span> fst"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> tlength <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist <span class="main">⇒</span> enat"</span></span>
<span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"llength <span class="main">∘</span> fst"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lift_definition</span></span> tdropn <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist"</span></span>
<span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"apfst <span class="main">∘</span> ldropn"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">tfinite</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">tfinite</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≡</span> lfinite <span class="main">(</span>llist_of_tllist <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"tfinite"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1" id="TLList-tfinite_induct"><span class="command">lemma</span></span> tfinite_induct <span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> TNil TCons<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"tfinite <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">y</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span>TNil <span class="bound">y</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">xs</span><span class="main">.</span> <span class="main">⟦</span>tfinite <span class="bound">xs</span><span class="main">;</span> <span class="free">P</span> <span class="bound">xs</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span>TCons <span class="bound">x</span> <span class="bound">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">clarsimp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">erule</span> lfinite.induct<span class="main">)</span>

<span class="keyword1" id="TLList-is_TNil_tfinite"><span class="command">lemma</span></span> is_TNil_tfinite <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"is_TNil <span class="free">xs</span> <span class="main">⟹</span> tfinite <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">clarsimp</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The terminal element <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"terminal"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1" id="TLList-terminal_tinfinite"><span class="command">lemma</span></span> terminal_tinfinite<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> tfinite <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"terminal <span class="free">xs</span> <span class="main">=</span> undefined"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> terminal0_terminal<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> contrapos_np<span class="main">)</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> terminal0.raw_induct<span class="main"><span class="main">[</span></span><span class="operator">rotated</span> 1<span class="main"><span class="main">,</span></span> <span class="operator">OF</span> refl<span class="main"><span class="main">,</span></span> <span class="operator">consumes</span> 1<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> tllist.split_asm<span class="main">)</span> 

<span class="keyword1" id="TLList-terminal_tllist_of_llist"><span class="command">lemma</span></span> terminal_tllist_of_llist<span class="main">:</span>
  <span class="quoted"><span class="quoted">"terminal <span class="main">(</span>tllist_of_llist <span class="free">y</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> lfinite <span class="free">xs</span> <span class="keyword1">then</span> <span class="free">y</span> <span class="keyword1">else</span> undefined<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> terminal_tinfinite<span class="main">)</span>

<span class="keyword1" id="TLList-terminal_transfer"><span class="command">lemma</span></span> terminal_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>pcr_tllist <span class="free">A</span> <span class="main">(=)</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">if</span> lfinite <span class="bound">xs</span> <span class="keyword1">then</span> <span class="bound">b</span> <span class="keyword1">else</span> undefined<span class="main">)</span> terminal"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cr_tllist_def pcr_tllist_def terminal_tllist_of_llist <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> llist_all2_lfiniteD<span class="main">)</span>

<span class="keyword1" id="TLList-terminal_tmap"><span class="command">lemma</span></span> terminal_tmap <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"tfinite <span class="free">xs</span> <span class="main">⟹</span> terminal <span class="main">(</span>tmap <span class="free">f</span> <span class="free">g</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">g</span> <span class="main">(</span>terminal <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> tfinite_induct<span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"tmap"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1" id="TLList-tmap_eq_TCons_conv"><span class="command">lemma</span></span> tmap_eq_TCons_conv<span class="main">:</span>
  <span class="quoted"><span class="quoted">"tmap <span class="free">f</span> <span class="free">g</span> <span class="free">xs</span> <span class="main">=</span> TCons <span class="free">y</span> <span class="free">ys</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="main">∃</span><span class="bound">z</span> <span class="bound">zs</span><span class="main">.</span> <span class="free">xs</span> <span class="main">=</span> TCons <span class="bound">z</span> <span class="bound">zs</span> <span class="main">∧</span> <span class="free">f</span> <span class="bound">z</span> <span class="main">=</span> <span class="free">y</span> <span class="main">∧</span> tmap <span class="free">f</span> <span class="free">g</span> <span class="bound">zs</span> <span class="main">=</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="TLList-TCons_eq_tmap_conv"><span class="command">lemma</span></span> TCons_eq_tmap_conv<span class="main">:</span>
  <span class="quoted"><span class="quoted">"TCons <span class="free">y</span> <span class="free">ys</span> <span class="main">=</span> tmap <span class="free">f</span> <span class="free">g</span> <span class="free">xs</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="main">∃</span><span class="bound">z</span> <span class="bound">zs</span><span class="main">.</span> <span class="free">xs</span> <span class="main">=</span> TCons <span class="bound">z</span> <span class="bound">zs</span> <span class="main">∧</span> <span class="free">f</span> <span class="bound">z</span> <span class="main">=</span> <span class="free">y</span> <span class="main">∧</span> tmap <span class="free">f</span> <span class="free">g</span> <span class="bound">zs</span> <span class="main">=</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Appending two terminated lazy lists <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"tappend"</span></span> <span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1" id="TLList-tappend_TNil"><span class="command">lemma</span></span> tappend_TNil <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span><span class="main">,</span> <span class="operator">nitpick_simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"tappend <span class="main">(</span>TNil <span class="free">b</span><span class="main">)</span> <span class="free">f</span> <span class="main">=</span> <span class="free">f</span> <span class="free">b</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>

<span class="keyword1" id="TLList-tappend_TCons"><span class="command">lemma</span></span> tappend_TCons <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span><span class="main">,</span> <span class="operator">nitpick_simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"tappend <span class="main">(</span>TCons <span class="free">a</span> <span class="free">tr</span><span class="main">)</span> <span class="free">f</span> <span class="main">=</span> TCons <span class="free">a</span> <span class="main">(</span>tappend <span class="free">tr</span> <span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> apfst_def map_prod_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>

<span class="keyword1" id="TLList-tappend_TNil2"><span class="command">lemma</span></span> tappend_TNil2 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"tappend <span class="free">xs</span> TNil <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>

<span class="keyword1" id="TLList-tappend_assoc"><span class="command">lemma</span></span> tappend_assoc<span class="main">:</span> <span class="quoted"><span class="quoted">"tappend <span class="main">(</span>tappend <span class="free">xs</span> <span class="free">f</span><span class="main">)</span> <span class="free">g</span> <span class="main">=</span> tappend <span class="free">xs</span> <span class="main">(</span><span class="main">λ</span><span class="bound">b</span><span class="main">.</span> tappend <span class="main">(</span><span class="free">f</span> <span class="bound">b</span><span class="main">)</span> <span class="free">g</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta lappend_assoc<span class="main">)</span>

<span class="keyword1" id="TLList-terminal_tappend"><span class="command">lemma</span></span> terminal_tappend<span class="main">:</span>
  <span class="quoted"><span class="quoted">"terminal <span class="main">(</span>tappend <span class="free">xs</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> tfinite <span class="free">xs</span> <span class="keyword1">then</span> terminal <span class="main">(</span><span class="free">f</span> <span class="main">(</span>terminal <span class="free">xs</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">else</span> terminal <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta<span class="main">)</span>

<span class="keyword1" id="TLList-tfinite_tappend"><span class="command">lemma</span></span> tfinite_tappend<span class="main">:</span> <span class="quoted"><span class="quoted">"tfinite <span class="main">(</span>tappend <span class="free">xs</span> <span class="free">f</span><span class="main">)</span> <span class="main">⟷</span> tfinite <span class="free">xs</span> <span class="main">∧</span> tfinite <span class="main">(</span><span class="free">f</span> <span class="main">(</span>terminal <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lift_definition</span></span> tcast <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'c</span><span class="main">)</span> tllist"</span></span>
<span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="bound">a</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">xs</span><span class="main">,</span> undefined<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span>

<span class="keyword1" id="TLList-tappend_inf"><span class="command">lemma</span></span> tappend_inf<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> tfinite <span class="free">xs</span> <span class="main">⟹</span> tappend <span class="free">xs</span> <span class="free">f</span> <span class="main">=</span> tcast <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> apfst_def map_prod_def split_beta lappend_inf<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">tappend</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is the monadic bind on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">,</span></span> <span class="tfree"><span class="tfree">'b</span></span><span class="main"><span class="main">)</span></span> tllist"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> tllist_monad <span class="main">=</span> tappend_TNil tappend_TNil2 tappend_assoc

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Appending a terminated lazy list to a lazy list <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"lappendt"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1" id="TLList-lappendt_LNil"><span class="command">lemma</span></span> lappendt_LNil <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span><span class="main">,</span> <span class="operator">nitpick_simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lappendt LNil <span class="free">tr</span> <span class="main">=</span> <span class="free">tr</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>

<span class="keyword1" id="TLList-lappendt_LCons"><span class="command">lemma</span></span> lappendt_LCons <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span><span class="main">,</span> <span class="operator">nitpick_simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lappendt <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="free">tr</span> <span class="main">=</span> TCons <span class="free">x</span> <span class="main">(</span>lappendt <span class="free">xs</span> <span class="free">tr</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>

<span class="keyword1" id="TLList-terminal_lappendt_lfinite"><span class="command">lemma</span></span> terminal_lappendt_lfinite <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span> <span class="main">⟹</span> terminal <span class="main">(</span>lappendt <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> terminal <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>

<span class="keyword1" id="TLList-tllist_of_llist_eq_lappendt_conv"><span class="command">lemma</span></span> tllist_of_llist_eq_lappendt_conv<span class="main">:</span>
  <span class="quoted"><span class="quoted">"tllist_of_llist <span class="free">a</span> <span class="free">xs</span> <span class="main">=</span> lappendt <span class="free">ys</span> <span class="free">zs</span> <span class="main">⟷</span> 
  <span class="main">(</span><span class="main">∃</span><span class="bound">xs'</span> <span class="bound">a'</span><span class="main">.</span> <span class="free">xs</span> <span class="main">=</span> lappend <span class="free">ys</span> <span class="bound">xs'</span> <span class="main">∧</span> <span class="free">zs</span> <span class="main">=</span> tllist_of_llist <span class="bound">a'</span> <span class="bound">xs'</span> <span class="main">∧</span> <span class="main">(</span>lfinite <span class="free">ys</span> <span class="main">⟶</span> <span class="free">a</span> <span class="main">=</span> <span class="bound">a'</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>

<span class="keyword1" id="TLList-tset_lappendt_lfinite"><span class="command">lemma</span></span> tset_lappendt_lfinite <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span> <span class="main">⟹</span> tset <span class="main">(</span>lappendt <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> lset <span class="free">xs</span> <span class="main">∪</span> tset <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Filtering terminated lazy lists <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">tfilter</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1" id="TLList-tfilter_TNil"><span class="command">lemma</span></span> tfilter_TNil <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"tfilter <span class="free">b'</span> <span class="free">P</span> <span class="main">(</span>TNil <span class="free">b</span><span class="main">)</span> <span class="main">=</span> TNil <span class="free">b</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>

<span class="keyword1" id="TLList-tfilter_TCons"><span class="command">lemma</span></span> tfilter_TCons <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"tfilter <span class="free">b</span> <span class="free">P</span> <span class="main">(</span>TCons <span class="free">a</span> <span class="free">tr</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">P</span> <span class="free">a</span> <span class="keyword1">then</span> TCons <span class="free">a</span> <span class="main">(</span>tfilter <span class="free">b</span> <span class="free">P</span> <span class="free">tr</span><span class="main">)</span> <span class="keyword1">else</span> tfilter <span class="free">b</span> <span class="free">P</span> <span class="free">tr</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>

<span class="keyword1" id="TLList-is_TNil_tfilter"><span class="command">lemma</span></span> is_TNil_tfilter<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"is_TNil <span class="main">(</span>tfilter <span class="free">y</span> <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> tset <span class="free">xs</span><span class="main">.</span> <span class="main">¬</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>

<span class="keyword1" id="TLList-tfilter_empty_conv"><span class="command">lemma</span></span> tfilter_empty_conv<span class="main">:</span>
  <span class="quoted"><span class="quoted">"tfilter <span class="free">y</span> <span class="free">P</span> <span class="free">xs</span> <span class="main">=</span> TNil <span class="free">y'</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> tset <span class="free">xs</span><span class="main">.</span> <span class="main">¬</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="keyword1">if</span> tfinite <span class="free">xs</span> <span class="keyword1">then</span> terminal <span class="free">xs</span> <span class="main">=</span> <span class="free">y'</span> <span class="keyword1">else</span> <span class="free">y</span> <span class="main">=</span> <span class="free">y'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lfilter_eq_LNil<span class="main">)</span>

<span class="keyword1" id="TLList-tfilter_eq_TConsD"><span class="command">lemma</span></span> tfilter_eq_TConsD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"tfilter <span class="free">a</span> <span class="free">P</span> <span class="free">ys</span> <span class="main">=</span> TCons <span class="free">x</span> <span class="free">xs</span> <span class="main">⟹</span>
   <span class="main">∃</span><span class="bound">us</span> <span class="bound">vs</span><span class="main">.</span> <span class="free">ys</span> <span class="main">=</span> lappendt <span class="bound">us</span> <span class="main">(</span>TCons <span class="free">x</span> <span class="bound">vs</span><span class="main">)</span> <span class="main">∧</span> lfinite <span class="bound">us</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">u</span><span class="main">∈</span>lset <span class="bound">us</span><span class="main">.</span> <span class="main">¬</span> <span class="free">P</span> <span class="bound">u</span><span class="main">)</span> <span class="main">∧</span> <span class="free">P</span> <span class="free">x</span> <span class="main">∧</span> <span class="free">xs</span> <span class="main">=</span> tfilter <span class="free">a</span> <span class="free">P</span> <span class="bound">vs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lfilter_eq_LConsD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> sym<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Use a version of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"tfilter"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> for code generation that does not evaluate the first argument›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">tfilter'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>unit <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">tfilter'</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">=</span> tfilter <span class="main">(</span><span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">()</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="TLList-tfilter_code"><span class="command">lemma</span></span> tfilter_code <span class="main">[</span><span class="operator">code</span><span class="main">,</span> <span class="operator">code_unfold</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"tfilter <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">b</span><span class="main">.</span> tfilter' <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">b</span><span class="main">)</span><span class="main">)</span>"</span></span> 
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="TLList-tfilter'_code"><span class="command">lemma</span></span> tfilter'_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"tfilter' <span class="free">b'</span> <span class="free">P</span> <span class="main">(</span>TNil <span class="free">b</span><span class="main">)</span> <span class="main">=</span> TNil <span class="free">b</span>"</span></span>
  <span class="quoted"><span class="quoted">"tfilter' <span class="free">b'</span> <span class="free">P</span> <span class="main">(</span>TCons <span class="free">a</span> <span class="free">tr</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">P</span> <span class="free">a</span> <span class="keyword1">then</span> TCons <span class="free">a</span> <span class="main">(</span>tfilter' <span class="free">b'</span> <span class="free">P</span> <span class="free">tr</span><span class="main">)</span> <span class="keyword1">else</span> tfilter' <span class="free">b'</span> <span class="free">P</span> <span class="free">tr</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> tfilter'

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Concatenating a terminated lazy list of lazy lists <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">tconcat</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1" id="TLList-tconcat_TNil"><span class="command">lemma</span></span> tconcat_TNil <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"tconcat <span class="free">b</span> <span class="main">(</span>TNil <span class="free">b'</span><span class="main">)</span> <span class="main">=</span> TNil <span class="free">b'</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>

<span class="keyword1" id="TLList-tconcat_TCons"><span class="command">lemma</span></span> tconcat_TCons <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"tconcat <span class="free">b</span> <span class="main">(</span>TCons <span class="free">a</span> <span class="free">tr</span><span class="main">)</span> <span class="main">=</span> lappendt <span class="free">a</span> <span class="main">(</span>tconcat <span class="free">b</span> <span class="free">tr</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Use a version of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"tconcat"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> for code generation that does not evaluate the first argument›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">tconcat'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>unit <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> llist<span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">tconcat'</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">=</span> tconcat <span class="main">(</span><span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">()</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="TLList-tconcat_code"><span class="command">lemma</span></span> tconcat_code <span class="main">[</span><span class="operator">code</span><span class="main">,</span> <span class="operator">code_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"tconcat <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">b</span><span class="main">.</span> tconcat' <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">b</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="TLList-tconcat'_code"><span class="command">lemma</span></span> tconcat'_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"tconcat' <span class="free">b</span> <span class="main">(</span>TNil <span class="free">b'</span><span class="main">)</span> <span class="main">=</span> TNil <span class="free">b'</span>"</span></span>
  <span class="quoted"><span class="quoted">"tconcat' <span class="free">b</span> <span class="main">(</span>TCons <span class="free">a</span> <span class="free">tr</span><span class="main">)</span> <span class="main">=</span> lappendt <span class="free">a</span> <span class="main">(</span>tconcat' <span class="free">b</span> <span class="free">tr</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> tconcat'

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">tllist_all2</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> tllist_all2_TNil <span class="main">=</span> tllist.rel_inject<span class="main">(</span>1<span class="main">)</span>
<span class="keyword1"><span class="command">lemmas</span></span> tllist_all2_TCons <span class="main">=</span> tllist.rel_inject<span class="main">(</span>2<span class="main">)</span>

<span class="keyword1" id="TLList-tllist_all2_TNil1"><span class="command">lemma</span></span> tllist_all2_TNil1<span class="main">:</span> <span class="quoted"><span class="quoted">"tllist_all2 <span class="free">P</span> <span class="free">Q</span> <span class="main">(</span>TNil <span class="free">b</span><span class="main">)</span> <span class="free">ts</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">b'</span><span class="main">.</span> <span class="free">ts</span> <span class="main">=</span> TNil <span class="bound">b'</span> <span class="main">∧</span> <span class="free">Q</span> <span class="free">b</span> <span class="bound">b'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>

<span class="keyword1" id="TLList-tllist_all2_TNil2"><span class="command">lemma</span></span> tllist_all2_TNil2<span class="main">:</span> <span class="quoted"><span class="quoted">"tllist_all2 <span class="free">P</span> <span class="free">Q</span> <span class="free">ts</span> <span class="main">(</span>TNil <span class="free">b'</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">b</span><span class="main">.</span> <span class="free">ts</span> <span class="main">=</span> TNil <span class="bound">b</span> <span class="main">∧</span> <span class="free">Q</span> <span class="bound">b</span> <span class="free">b'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>

<span class="keyword1" id="TLList-tllist_all2_TCons1"><span class="command">lemma</span></span> tllist_all2_TCons1<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"tllist_all2 <span class="free">P</span> <span class="free">Q</span> <span class="main">(</span>TCons <span class="free">x</span> <span class="free">ts</span><span class="main">)</span> <span class="free">ts'</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x'</span> <span class="bound">ts''</span><span class="main">.</span> <span class="free">ts'</span> <span class="main">=</span> TCons <span class="bound">x'</span> <span class="bound">ts''</span> <span class="main">∧</span> <span class="free">P</span> <span class="free">x</span> <span class="bound">x'</span> <span class="main">∧</span> tllist_all2 <span class="free">P</span> <span class="free">Q</span> <span class="free">ts</span> <span class="bound">ts''</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_all2_LCons1 <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> llist_all2_lfiniteD<span class="main">)</span>

<span class="keyword1" id="TLList-tllist_all2_TCons2"><span class="command">lemma</span></span> tllist_all2_TCons2<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"tllist_all2 <span class="free">P</span> <span class="free">Q</span> <span class="free">ts'</span> <span class="main">(</span>TCons <span class="free">x</span> <span class="free">ts</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x'</span> <span class="bound">ts''</span><span class="main">.</span> <span class="free">ts'</span> <span class="main">=</span> TCons <span class="bound">x'</span> <span class="bound">ts''</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">x'</span> <span class="free">x</span> <span class="main">∧</span> tllist_all2 <span class="free">P</span> <span class="free">Q</span> <span class="bound">ts''</span> <span class="free">ts</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_all2_LCons2 <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> llist_all2_lfiniteD<span class="main">)</span>

<span class="keyword1" id="TLList-tllist_all2_coinduct"><span class="command">lemma</span></span> tllist_all2_coinduct <span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> tllist_all2<span class="main">,</span> <span class="operator">case_conclusion</span> tllist_all2 is_TNil TNil TCons<span class="main">,</span> <span class="operator">coinduct</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">pred</span></span></span><span class="main"><span class="main"><span class="main"><span class="main">:</span></span></span></span> tllist_all2<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span> <span class="bound">ys</span><span class="main">.</span> <span class="free">X</span> <span class="bound">xs</span> <span class="bound">ys</span> <span class="main">⟹</span>
  <span class="main">(</span>is_TNil <span class="bound">xs</span> <span class="main">⟷</span> is_TNil <span class="bound">ys</span><span class="main">)</span> <span class="main">∧</span>
  <span class="main">(</span>is_TNil <span class="bound">xs</span> <span class="main">⟶</span> is_TNil <span class="bound">ys</span> <span class="main">⟶</span> <span class="free">R</span> <span class="main">(</span>terminal <span class="bound">xs</span><span class="main">)</span> <span class="main">(</span>terminal <span class="bound">ys</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
  <span class="main">(</span><span class="main">¬</span> is_TNil <span class="bound">xs</span> <span class="main">⟶</span> <span class="main">¬</span> is_TNil <span class="bound">ys</span> <span class="main">⟶</span> <span class="free">P</span> <span class="main">(</span>thd <span class="bound">xs</span><span class="main">)</span> <span class="main">(</span>thd <span class="bound">ys</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="free">X</span> <span class="main">(</span>ttl <span class="bound">xs</span><span class="main">)</span> <span class="main">(</span>ttl <span class="bound">ys</span><span class="main">)</span> <span class="main">∨</span> tllist_all2 <span class="free">P</span> <span class="free">R</span> <span class="main">(</span>ttl <span class="bound">xs</span><span class="main">)</span> <span class="main">(</span>ttl <span class="bound">ys</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"tllist_all2 <span class="free">P</span> <span class="free">R</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">transfer</span> <span class="quasi_keyword">fixing</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">P</span></span> <span class="quoted"><span class="free">R</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> conjI<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule</span> llist_all2_coinduct<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> impI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> prems <span class="keyword2"><span class="keyword">for</span></span> X xs b ys c
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹lfinite <span class="skolem">xs</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">X</span> <span class="main">(</span><span class="skolem">xs</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">(</span><span class="skolem">ys</span><span class="main">,</span> <span class="skolem">c</span><span class="main">)</span>›</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="skolem">b</span> <span class="skolem">c</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lfinite_induct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> prems<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="TLList-tllist_all2_cases"><span class="command">lemma</span></span> tllist_all2_cases<span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> TNil TCons<span class="main">,</span> <span class="operator">cases</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">pred</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"tllist_all2 <span class="free">P</span> <span class="free">Q</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="main">(</span>TNil<span class="main">)</span> <span class="free">b</span> <span class="free">b'</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> TNil <span class="free">b</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">=</span> TNil <span class="free">b'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="free">b</span> <span class="free">b'</span>"</span></span>
  <span class="main">|</span> <span class="main">(</span>TCons<span class="main">)</span> <span class="free">x</span> <span class="free">xs'</span> <span class="free">y</span> <span class="free">ys'</span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> TCons <span class="free">x</span> <span class="free">xs'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">=</span> TCons <span class="free">y</span> <span class="free">ys'</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">x</span> <span class="free">y</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"tllist_all2 <span class="free">P</span> <span class="free">Q</span> <span class="free">xs'</span> <span class="free">ys'</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tllist_all2_TCons1 tllist_all2_TNil1<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="TLList-tllist_all2_tmap1"><span class="command">lemma</span></span> tllist_all2_tmap1<span class="main">:</span>
  <span class="quoted"><span class="quoted">"tllist_all2 <span class="free">P</span> <span class="free">Q</span> <span class="main">(</span>tmap <span class="free">f</span> <span class="free">g</span> <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span> <span class="main">⟷</span> tllist_all2 <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">Q</span> <span class="main">(</span><span class="free">g</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_all2_lmap1<span class="main">)</span>

<span class="keyword1" id="TLList-tllist_all2_tmap2"><span class="command">lemma</span></span> tllist_all2_tmap2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"tllist_all2 <span class="free">P</span> <span class="free">Q</span> <span class="free">xs</span> <span class="main">(</span>tmap <span class="free">f</span> <span class="free">g</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟷</span> tllist_all2 <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="main">(</span><span class="free">f</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">x</span> <span class="main">(</span><span class="free">g</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_all2_lmap2<span class="main">)</span>

<span class="keyword1" id="TLList-tllist_all2_mono"><span class="command">lemma</span></span> tllist_all2_mono<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> tllist_all2 <span class="free">P</span> <span class="free">Q</span> <span class="free">xs</span> <span class="free">ys</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">⟹</span> <span class="free">P'</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">⟹</span> <span class="free">Q'</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">⟧</span>
  <span class="main">⟹</span> tllist_all2 <span class="free">P'</span> <span class="free">Q'</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> llist_all2_mono<span class="main">)</span>

<span class="keyword1" id="TLList-tllist_all2_tlengthD"><span class="command">lemma</span></span> tllist_all2_tlengthD<span class="main">:</span> <span class="quoted"><span class="quoted">"tllist_all2 <span class="free">P</span> <span class="free">Q</span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">⟹</span> tlength <span class="free">xs</span> <span class="main">=</span> tlength <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> llist_all2_llengthD<span class="main">)</span>

<span class="keyword1" id="TLList-tllist_all2_tfiniteD"><span class="command">lemma</span></span> tllist_all2_tfiniteD<span class="main">:</span> <span class="quoted"><span class="quoted">"tllist_all2 <span class="free">P</span> <span class="free">Q</span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">⟹</span> tfinite <span class="free">xs</span> <span class="main">=</span> tfinite <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> llist_all2_lfiniteD<span class="main">)</span>

<span class="keyword1" id="TLList-tllist_all2_tfinite1_terminalD"><span class="command">lemma</span></span> tllist_all2_tfinite1_terminalD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> tllist_all2 <span class="free">P</span> <span class="free">Q</span> <span class="free">xs</span> <span class="free">ys</span><span class="main">;</span> tfinite <span class="free">xs</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Q</span> <span class="main">(</span>terminal <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>terminal <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">frule</span> tllist_all2_tfiniteD<span class="main">)</span><span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="TLList-tllist_all2_tfinite2_terminalD"><span class="command">lemma</span></span> tllist_all2_tfinite2_terminalD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> tllist_all2 <span class="free">P</span> <span class="free">Q</span> <span class="free">xs</span> <span class="free">ys</span><span class="main">;</span> tfinite <span class="free">ys</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Q</span> <span class="main">(</span>terminal <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>terminal <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">metis</span> tllist_all2_tfinite1_terminalD tllist_all2_tfiniteD<span class="main">)</span>

<span class="keyword1" id="TLList-tllist_all2D_llist_all2_llist_of_tllist"><span class="command">lemma</span></span> tllist_all2D_llist_all2_llist_of_tllist<span class="main">:</span>
  <span class="quoted"><span class="quoted">"tllist_all2 <span class="free">P</span> <span class="free">Q</span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">⟹</span> llist_all2 <span class="free">P</span> <span class="main">(</span>llist_of_tllist <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>llist_of_tllist <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="TLList-tllist_all2_is_TNilD"><span class="command">lemma</span></span> tllist_all2_is_TNilD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"tllist_all2 <span class="free">P</span> <span class="free">Q</span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">⟹</span> is_TNil <span class="free">xs</span> <span class="main">⟷</span> is_TNil <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tllist_all2_TNil1 tllist_all2_TCons1<span class="main">)</span>

<span class="keyword1" id="TLList-tllist_all2_thdD"><span class="command">lemma</span></span> tllist_all2_thdD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> tllist_all2 <span class="free">P</span> <span class="free">Q</span> <span class="free">xs</span> <span class="free">ys</span><span class="main">;</span> <span class="main">¬</span> is_TNil <span class="free">xs</span> <span class="main">∨</span> <span class="main">¬</span> is_TNil <span class="free">ys</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span>thd <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>thd <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tllist_all2_TNil1 tllist_all2_TCons1<span class="main">)</span>

<span class="keyword1" id="TLList-tllist_all2_ttlI"><span class="command">lemma</span></span> tllist_all2_ttlI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> tllist_all2 <span class="free">P</span> <span class="free">Q</span> <span class="free">xs</span> <span class="free">ys</span><span class="main">;</span> <span class="main">¬</span> is_TNil <span class="free">xs</span> <span class="main">∨</span> <span class="main">¬</span> is_TNil <span class="free">ys</span> <span class="main">⟧</span> <span class="main">⟹</span> tllist_all2 <span class="free">P</span> <span class="free">Q</span> <span class="main">(</span>ttl <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>ttl <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tllist_all2_TNil1 tllist_all2_TCons1<span class="main">)</span>

<span class="keyword1" id="TLList-tllist_all2_refl"><span class="command">lemma</span></span> tllist_all2_refl<span class="main">:</span>
  <span class="quoted"><span class="quoted">"tllist_all2 <span class="free">P</span> <span class="free">Q</span> <span class="free">xs</span> <span class="free">xs</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> tset <span class="free">xs</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="bound">x</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span>tfinite <span class="free">xs</span> <span class="main">⟶</span> <span class="free">Q</span> <span class="main">(</span>terminal <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>terminal <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="TLList-tllist_all2_reflI"><span class="command">lemma</span></span> tllist_all2_reflI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> tset <span class="free">xs</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">x</span> <span class="bound">x</span><span class="main">;</span> tfinite <span class="free">xs</span> <span class="main">⟹</span> <span class="free">Q</span> <span class="main">(</span>terminal <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>terminal <span class="free">xs</span><span class="main">)</span> <span class="main">⟧</span>
  <span class="main">⟹</span> tllist_all2 <span class="free">P</span> <span class="free">Q</span> <span class="free">xs</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tllist_all2_refl<span class="main">)</span>

<span class="keyword1" id="TLList-tllist_all2_conv_all_tnth"><span class="command">lemma</span></span> tllist_all2_conv_all_tnth<span class="main">:</span>
  <span class="quoted"><span class="quoted">"tllist_all2 <span class="free">P</span> <span class="free">Q</span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">⟷</span> 
  tlength <span class="free">xs</span> <span class="main">=</span> tlength <span class="free">ys</span> <span class="main">∧</span> 
  <span class="main">(</span><span class="main">∀</span><span class="bound">n</span><span class="main">.</span> enat <span class="bound">n</span> <span class="main">&lt;</span> tlength <span class="free">xs</span> <span class="main">⟶</span> <span class="free">P</span> <span class="main">(</span>tnth <span class="free">xs</span> <span class="bound">n</span><span class="main">)</span> <span class="main">(</span>tnth <span class="free">ys</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
  <span class="main">(</span>tfinite <span class="free">xs</span> <span class="main">⟶</span> <span class="free">Q</span> <span class="main">(</span>terminal <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>terminal <span class="free">ys</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">auto</span> 4 4 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_all2_conv_all_lnth <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lfinite_llength_enat not_lfinite_llength<span class="main">)</span>

<span class="keyword1" id="TLList-tllist_all2_tnthD"><span class="command">lemma</span></span> tllist_all2_tnthD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> tllist_all2 <span class="free">P</span> <span class="free">Q</span> <span class="free">xs</span> <span class="free">ys</span><span class="main">;</span> enat <span class="free">n</span> <span class="main">&lt;</span> tlength <span class="free">xs</span> <span class="main">⟧</span> 
  <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span>tnth <span class="free">xs</span> <span class="free">n</span><span class="main">)</span> <span class="main">(</span>tnth <span class="free">ys</span> <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tllist_all2_conv_all_tnth<span class="main">)</span>

<span class="keyword1" id="TLList-tllist_all2_tnthD2"><span class="command">lemma</span></span> tllist_all2_tnthD2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> tllist_all2 <span class="free">P</span> <span class="free">Q</span> <span class="free">xs</span> <span class="free">ys</span><span class="main">;</span> enat <span class="free">n</span> <span class="main">&lt;</span> tlength <span class="free">ys</span> <span class="main">⟧</span> 
  <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span>tnth <span class="free">xs</span> <span class="free">n</span><span class="main">)</span> <span class="main">(</span>tnth <span class="free">ys</span> <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tllist_all2_conv_all_tnth<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> tllist_all2_eq <span class="main">=</span> tllist.rel_eq

<span class="keyword1" id="TLList-tmap_eq_tmap_conv_tllist_all2"><span class="command">lemma</span></span> tmap_eq_tmap_conv_tllist_all2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"tmap <span class="free">f</span> <span class="free">g</span> <span class="free">xs</span> <span class="main">=</span> tmap <span class="free">f'</span> <span class="free">g'</span> <span class="free">ys</span> <span class="main">⟷</span>
  tllist_all2 <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">f'</span> <span class="bound">y</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">g</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">g'</span> <span class="bound">y</span><span class="main">)</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lmap_eq_lmap_conv_llist_all2<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> llist_all2_lfiniteD<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="TLList-tllist_all2_trans"><span class="command">lemma</span></span> tllist_all2_trans<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> tllist_all2 <span class="free">P</span> <span class="free">Q</span> <span class="free">xs</span> <span class="free">ys</span><span class="main">;</span> tllist_all2 <span class="free">P</span> <span class="free">Q</span> <span class="free">ys</span> <span class="free">zs</span><span class="main">;</span> transp <span class="free">P</span><span class="main">;</span> transp <span class="free">Q</span> <span class="main">⟧</span>
  <span class="main">⟹</span> tllist_all2 <span class="free">P</span> <span class="free">Q</span> <span class="free">xs</span> <span class="free">zs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> llist_all2_trans <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> llist_all2_lfiniteD transpD<span class="main">)</span>

<span class="keyword1" id="TLList-tllist_all2_tappendI"><span class="command">lemma</span></span> tllist_all2_tappendI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> tllist_all2 <span class="free">P</span> <span class="free">Q</span> <span class="free">xs</span> <span class="free">ys</span><span class="main">;</span>
     <span class="main">⟦</span> tfinite <span class="free">xs</span><span class="main">;</span> tfinite <span class="free">ys</span><span class="main">;</span> <span class="free">Q</span> <span class="main">(</span>terminal <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>terminal <span class="free">ys</span><span class="main">)</span> <span class="main">⟧</span>
     <span class="main">⟹</span> tllist_all2 <span class="free">P</span> <span class="free">R</span> <span class="main">(</span><span class="free">xs'</span> <span class="main">(</span>terminal <span class="free">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">ys'</span> <span class="main">(</span>terminal <span class="free">ys</span><span class="main">)</span><span class="main">)</span> <span class="main">⟧</span>
  <span class="main">⟹</span> tllist_all2 <span class="free">P</span> <span class="free">R</span> <span class="main">(</span>tappend <span class="free">xs</span> <span class="free">xs'</span><span class="main">)</span> <span class="main">(</span>tappend <span class="free">ys</span> <span class="free">ys'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> apfst_def map_prod_def lappend_inf <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split_asm <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> llist_all2_lfiniteD <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> llist_all2_lappendI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">frule</span> llist_all2_lfiniteD<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lappend_inf<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="TLList-llist_all2_tllist_of_llistI"><span class="command">lemma</span></span> llist_all2_tllist_of_llistI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"tllist_all2 <span class="free">A</span> <span class="free">B</span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">⟹</span> llist_all2 <span class="free">A</span> <span class="main">(</span>llist_of_tllist <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>llist_of_tllist <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> tllist_all2_is_TNilD tllist_all2_thdD <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> tllist_all2_ttlI<span class="main">)</span>

<span class="keyword1" id="TLList-tllist_all2_tllist_of_llist"><span class="command">lemma</span></span> tllist_all2_tllist_of_llist <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"tllist_all2 <span class="free">A</span> <span class="free">B</span> <span class="main">(</span>tllist_of_llist <span class="free">b</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>tllist_of_llist <span class="free">c</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟷</span>
  llist_all2 <span class="free">A</span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">∧</span> <span class="main">(</span>lfinite <span class="free">xs</span> <span class="main">⟶</span> <span class="free">B</span> <span class="free">b</span> <span class="free">c</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹From a terminated lazy list to a lazy list <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">llist_of_tllist</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1" id="TLList-llist_of_tllist_tmap"><span class="command">lemma</span></span> llist_of_tllist_tmap <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"llist_of_tllist <span class="main">(</span>tmap <span class="free">f</span> <span class="free">g</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lmap <span class="free">f</span> <span class="main">(</span>llist_of_tllist <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>

<span class="keyword1" id="TLList-llist_of_tllist_tappend"><span class="command">lemma</span></span> llist_of_tllist_tappend<span class="main">:</span>
  <span class="quoted"><span class="quoted">"llist_of_tllist <span class="main">(</span>tappend <span class="free">xs</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> lappend <span class="main">(</span>llist_of_tllist <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>llist_of_tllist <span class="main">(</span><span class="free">f</span> <span class="main">(</span>terminal <span class="free">xs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lappend_inf<span class="main">)</span>

<span class="keyword1" id="TLList-llist_of_tllist_lappendt"><span class="command">lemma</span></span> llist_of_tllist_lappendt <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"llist_of_tllist <span class="main">(</span>lappendt <span class="free">xs</span> <span class="free">tr</span><span class="main">)</span> <span class="main">=</span> lappend <span class="free">xs</span> <span class="main">(</span>llist_of_tllist <span class="free">tr</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>

<span class="keyword1" id="TLList-llist_of_tllist_tfilter"><span class="command">lemma</span></span> llist_of_tllist_tfilter <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"llist_of_tllist <span class="main">(</span>tfilter <span class="free">b</span> <span class="free">P</span> <span class="free">tr</span><span class="main">)</span> <span class="main">=</span> lfilter <span class="free">P</span> <span class="main">(</span>llist_of_tllist <span class="free">tr</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>

<span class="keyword1" id="TLList-llist_of_tllist_tconcat"><span class="command">lemma</span></span> llist_of_tllist_tconcat<span class="main">:</span>
  <span class="quoted"><span class="quoted">"llist_of_tllist <span class="main">(</span>tconcat <span class="free">b</span> <span class="free">trs</span><span class="main">)</span> <span class="main">=</span> lconcat <span class="main">(</span>llist_of_tllist <span class="free">trs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>

<span class="keyword1" id="TLList-llist_of_tllist_eq_lappend_conv"><span class="command">lemma</span></span> llist_of_tllist_eq_lappend_conv<span class="main">:</span>
  <span class="quoted"><span class="quoted">"llist_of_tllist <span class="free">xs</span> <span class="main">=</span> lappend <span class="free">us</span> <span class="free">vs</span> <span class="main">⟷</span> 
  <span class="main">(</span><span class="main">∃</span><span class="bound">ys</span><span class="main">.</span> <span class="free">xs</span> <span class="main">=</span> lappendt <span class="free">us</span> <span class="bound">ys</span> <span class="main">∧</span> <span class="free">vs</span> <span class="main">=</span> llist_of_tllist <span class="bound">ys</span> <span class="main">∧</span> terminal <span class="free">xs</span> <span class="main">=</span> terminal <span class="bound">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The nth element of a terminated lazy list <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"tnth"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1" id="TLList-tnth_TNil"><span class="command">lemma</span></span> tnth_TNil <span class="main">[</span><span class="operator">nitpick_simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"tnth <span class="main">(</span>TNil <span class="free">b</span><span class="main">)</span> <span class="free">n</span> <span class="main">=</span> undefined <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnth_LNil<span class="main">)</span>

<span class="keyword1" id="TLList-tnth_TCons"><span class="command">lemma</span></span> tnth_TCons<span class="main">:</span>
  <span class="quoted"><span class="quoted">"tnth <span class="main">(</span>TCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="free">n</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">n</span> <span class="keyword1">of</span> <span class="main">0</span> <span class="main">⇒</span> <span class="free">x</span> <span class="main">|</span> Suc <span class="bound">n'</span> <span class="main">⇒</span> tnth <span class="free">xs</span> <span class="bound">n'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnth_LCons <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> nat.split<span class="main">)</span>

<span class="keyword1" id="TLList-tnth_code"><span class="command">lemma</span></span> tnth_code <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">nitpick_simp</span><span class="main">,</span> <span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> tnth_0<span class="main">:</span> <span class="quoted"><span class="quoted">"tnth <span class="main">(</span>TCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">0</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> tnth_Suc_TCons<span class="main">:</span> <span class="quoted"><span class="quoted">"tnth <span class="main">(</span>TCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="main">=</span> tnth <span class="free">xs</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tnth_TCons<span class="main">)</span>

<span class="keyword1" id="TLList-lnth_llist_of_tllist"><span class="command">lemma</span></span> lnth_llist_of_tllist <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lnth <span class="main">(</span>llist_of_tllist <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> tnth <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="TLList-tnth_tmap"><span class="command">lemma</span></span> tnth_tmap <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"enat <span class="free">n</span> <span class="main">&lt;</span> tlength <span class="free">xs</span> <span class="main">⟹</span> tnth <span class="main">(</span>tmap <span class="free">f</span> <span class="free">g</span> <span class="free">xs</span><span class="main">)</span> <span class="free">n</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span>tnth <span class="free">xs</span> <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The length of a terminated lazy list <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"tlength"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">nitpick_simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> tlength_TNil<span class="main">:</span> <span class="quoted"><span class="quoted">"tlength <span class="main">(</span>TNil <span class="free">b</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> tlength_TCons<span class="main">:</span> <span class="quoted"><span class="quoted">"tlength <span class="main">(</span>TCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> eSuc <span class="main">(</span>tlength <span class="free">xs</span><span class="main">)</span>"</span></span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="TLList-llength_llist_of_tllist"><span class="command">lemma</span></span> llength_llist_of_tllist <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"llength <span class="main">(</span>llist_of_tllist <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> tlength <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>

<span class="keyword1" id="TLList-tlength_tmap"><span class="command">lemma</span></span> tlength_tmap <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"tlength <span class="main">(</span>tmap <span class="free">f</span> <span class="free">g</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> tlength <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">gen_tlength</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist <span class="main">⇒</span> enat"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">gen_tlength</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> enat <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">+</span> tlength <span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>

<span class="keyword1" id="TLList-gen_tlength_code"><span class="command">lemma</span></span> gen_tlength_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"gen_tlength <span class="free">n</span> <span class="main">(</span>TNil <span class="free">b</span><span class="main">)</span> <span class="main">=</span> enat <span class="free">n</span>"</span></span>
  <span class="quoted"><span class="quoted">"gen_tlength <span class="free">n</span> <span class="main">(</span>TCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> gen_tlength <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gen_tlength_def iadd_Suc eSuc_enat<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> iadd_Suc_right<span class="main">)</span>

<span class="keyword1" id="TLList-tlength_code"><span class="command">lemma</span></span> tlength_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"tlength <span class="main">=</span> gen_tlength <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gen_tlength_def fun_eq_iff zero_enat_def<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"tdropn"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1" id="TLList-tdropn_0"><span class="command">lemma</span></span> tdropn_0 <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span><span class="main">,</span> <span class="operator">nitpick_simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"tdropn <span class="main">0</span> <span class="free">xs</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>

<span class="keyword1" id="TLList-tdropn_TNil"><span class="command">lemma</span></span> tdropn_TNil <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"tdropn <span class="free">n</span> <span class="main">(</span>TNil <span class="free">b</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>TNil <span class="free">b</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="TLList-tdropn_Suc_TCons"><span class="command">lemma</span></span> tdropn_Suc_TCons <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"tdropn <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="main">(</span>TCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> tdropn <span class="free">n</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="TLList-tdropn_Suc"><span class="command">lemma</span></span> tdropn_Suc <span class="main">[</span><span class="operator">nitpick_simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"tdropn <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="free">xs</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">xs</span> <span class="keyword1">of</span> TNil <span class="bound">b</span> <span class="main">⇒</span> TNil <span class="bound">b</span> <span class="main">|</span> TCons <span class="bound">x</span> <span class="bound">xs'</span> <span class="main">⇒</span> tdropn <span class="free">n</span> <span class="bound">xs'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="TLList-lappendt_ltake_tdropn"><span class="command">lemma</span></span> lappendt_ltake_tdropn<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lappendt <span class="main">(</span>ltake <span class="main">(</span>enat <span class="free">n</span><span class="main">)</span> <span class="main">(</span>llist_of_tllist <span class="free">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>tdropn <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="TLList-llist_of_tllist_tdropn"><span class="command">lemma</span></span> llist_of_tllist_tdropn <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"llist_of_tllist <span class="main">(</span>tdropn <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> ldropn <span class="free">n</span> <span class="main">(</span>llist_of_tllist <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>

<span class="keyword1" id="TLList-tdropn_Suc_conv_tdropn"><span class="command">lemma</span></span> tdropn_Suc_conv_tdropn<span class="main">:</span>
  <span class="quoted"><span class="quoted">"enat <span class="free">n</span> <span class="main">&lt;</span> tlength <span class="free">xs</span> <span class="main">⟹</span> TCons <span class="main">(</span>tnth <span class="free">xs</span> <span class="free">n</span><span class="main">)</span> <span class="main">(</span>tdropn <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> tdropn <span class="free">n</span> <span class="free">xs</span>"</span></span> 
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldropn_Suc_conv_ldropn<span class="main">)</span>

<span class="keyword1" id="TLList-tlength_tdropn"><span class="command">lemma</span></span> tlength_tdropn <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"tlength <span class="main">(</span>tdropn <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> tlength <span class="free">xs</span> <span class="main">-</span> enat <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>

<span class="keyword1" id="TLList-tnth_tdropn"><span class="command">lemma</span></span> tnth_tdropn <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"enat <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="free">m</span><span class="main">)</span> <span class="main">&lt;</span> tlength <span class="free">xs</span> <span class="main">⟹</span> tnth <span class="main">(</span>tdropn <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span> tnth <span class="free">xs</span> <span class="main">(</span><span class="free">m</span> <span class="main">+</span> <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"tset"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1" id="TLList-tset_induct"><span class="command">lemma</span></span> tset_induct <span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> find step<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> tset <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span>TCons <span class="free">x</span> <span class="bound">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x'</span> <span class="bound">xs</span><span class="main">.</span> <span class="main">⟦</span> <span class="free">x</span> <span class="main">∈</span> tset <span class="bound">xs</span><span class="main">;</span> <span class="free">x</span> <span class="main">≠</span> <span class="bound">x'</span><span class="main">;</span> <span class="free">P</span> <span class="bound">xs</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span>TCons <span class="bound">x'</span> <span class="bound">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">clarsimp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">erule</span> lset_induct<span class="main">)</span>

<span class="keyword1" id="TLList-tset_conv_tnth"><span class="command">lemma</span></span> tset_conv_tnth<span class="main">:</span> <span class="quoted"><span class="quoted">"tset <span class="free">xs</span> <span class="main">=</span> <span class="main">{</span>tnth <span class="free">xs</span> <span class="bound">n</span><span class="main">|</span><span class="bound">n</span> <span class="main">.</span> enat <span class="bound">n</span> <span class="main">&lt;</span> tlength <span class="free">xs</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lset_conv_lnth<span class="main">)</span>

<span class="keyword1" id="TLList-in_tset_conv_tnth"><span class="command">lemma</span></span> in_tset_conv_tnth<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> tset <span class="free">xs</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">n</span><span class="main">.</span> enat <span class="bound">n</span> <span class="main">&lt;</span> tlength <span class="free">xs</span> <span class="main">∧</span> tnth <span class="free">xs</span> <span class="bound">n</span> <span class="main">=</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> tset_conv_tnth<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">xs</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Setup for Lifting/Transfer›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Relator and predicator properties›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">tllist_all</span> <span class="main">==</span> pred_tllist"</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Transfer rules for the Transfer package›</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="TLList-set1_pre_tllist_transfer"><span class="command">lemma</span></span> set1_pre_tllist_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_pre_tllist <span class="free">A</span> <span class="free">B</span> <span class="free">C</span> <span class="main">===&gt;</span> rel_set <span class="free">A</span><span class="main">)</span> set1_pre_tllist set1_pre_tllist"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_pre_tllist_def vimage2p_def rel_fun_def set1_pre_tllist_def rel_set_def collect_def sum_set_defs prod_set_defs <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> rel_sum.cases <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> sum.split_asm<span class="main">)</span>

<span class="keyword1" id="TLList-set2_pre_tllist_transfer"><span class="command">lemma</span></span> set2_pre_tllist_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_pre_tllist <span class="free">A</span> <span class="free">B</span> <span class="free">C</span> <span class="main">===&gt;</span> rel_set <span class="free">B</span><span class="main">)</span> set2_pre_tllist set2_pre_tllist"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_pre_tllist_def vimage2p_def rel_fun_def set2_pre_tllist_def rel_set_def collect_def sum_set_defs prod_set_defs <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> rel_sum.cases <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> sum.split_asm<span class="main">)</span>

<span class="keyword1" id="TLList-set3_pre_tllist_transfer"><span class="command">lemma</span></span> set3_pre_tllist_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_pre_tllist <span class="free">A</span> <span class="free">B</span> <span class="free">C</span> <span class="main">===&gt;</span> rel_set <span class="free">C</span><span class="main">)</span> set3_pre_tllist set3_pre_tllist"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_pre_tllist_def vimage2p_def rel_fun_def set3_pre_tllist_def rel_set_def collect_def sum_set_defs prod_set_defs <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> rel_sum.cases <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> sum.split_asm<span class="main">)</span>

<span class="keyword1" id="TLList-TNil_transfer2"><span class="command">lemma</span></span> TNil_transfer2 <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">B</span> <span class="main">===&gt;</span> tllist_all2 <span class="free">A</span> <span class="free">B</span><span class="main">)</span> TNil TNil"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">declare</span></span> TNil_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>

<span class="keyword1" id="TLList-TCons_transfer2"><span class="command">lemma</span></span> TCons_transfer2 <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> tllist_all2 <span class="free">A</span> <span class="free">B</span> <span class="main">===&gt;</span> tllist_all2 <span class="free">A</span> <span class="free">B</span><span class="main">)</span> TCons TCons"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> rel_fun_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">declare</span></span> TCons_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>

<span class="keyword1" id="TLList-case_tllist_transfer"><span class="command">lemma</span></span> case_tllist_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">B</span> <span class="main">===&gt;</span> <span class="free">C</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> tllist_all2 <span class="free">A</span> <span class="free">B</span> <span class="main">===&gt;</span> <span class="free">C</span><span class="main">)</span> <span class="main">===&gt;</span> tllist_all2 <span class="free">A</span> <span class="free">B</span> <span class="main">===&gt;</span> <span class="free">C</span><span class="main">)</span>
    case_tllist case_tllist"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> rel_fun_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tllist_all2_TNil1 tllist_all2_TNil2 <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> tllist.split<span class="main">)</span>

<span class="keyword1" id="TLList-unfold_tllist_transfer"><span class="command">lemma</span></span> unfold_tllist_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">B</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">C</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">A</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">A</span> <span class="main">===&gt;</span> tllist_all2 <span class="free">C</span> <span class="free">B</span><span class="main">)</span> unfold_tllist unfold_tllist"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> rel_funI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">IS_TNIL1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">IS_TNIL2</span>
    <span class="skolem">TERMINAL1</span> <span class="skolem">TERMINAL2</span> <span class="skolem">THD1</span> <span class="skolem">THD2</span> <span class="skolem">TTL1</span> <span class="skolem">TTL2</span> <span class="skolem">x</span> <span class="skolem">y</span>
  <span class="keyword3"><span class="command">assume</span></span> rel<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="skolem">IS_TNIL1</span> <span class="skolem">IS_TNIL2</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">B</span><span class="main">)</span> <span class="skolem">TERMINAL1</span> <span class="skolem">TERMINAL2</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">C</span><span class="main">)</span> <span class="skolem">THD1</span> <span class="skolem">THD2</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">A</span><span class="main">)</span> <span class="skolem">TTL1</span> <span class="skolem">TTL2</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="skolem">x</span> <span class="skolem">y</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"tllist_all2 <span class="free">C</span> <span class="free">B</span> <span class="main">(</span>unfold_tllist <span class="skolem">IS_TNIL1</span> <span class="skolem">TERMINAL1</span> <span class="skolem">THD1</span> <span class="skolem">TTL1</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span>unfold_tllist <span class="skolem">IS_TNIL2</span> <span class="skolem">TERMINAL2</span> <span class="skolem">THD2</span> <span class="skolem">TTL2</span> <span class="skolem">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">A</span> <span class="skolem">x</span> <span class="skolem">y</span>›</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">x</span></span> <span class="quoted"><span class="skolem">y</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> rel <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 4 <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> rel_funE<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="TLList-corec_tllist_transfer"><span class="command">lemma</span></span> corec_tllist_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">B</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">C</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> tllist_all2 <span class="free">C</span> <span class="free">B</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">A</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">A</span> <span class="main">===&gt;</span> tllist_all2 <span class="free">C</span> <span class="free">B</span><span class="main">)</span> corec_tllist corec_tllist"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> rel_funI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">IS_TNIL1</span> <span class="skolem">MORE1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">IS_TNIL2</span>
    <span class="skolem">TERMINAL1</span> <span class="skolem">TERMINAL2</span> <span class="skolem">THD1</span> <span class="skolem">THD2</span> <span class="skolem">MORE2</span> <span class="skolem">STOP1</span> <span class="skolem">STOP2</span> <span class="skolem">TTL1</span> <span class="skolem">TTL2</span> <span class="skolem">x</span> <span class="skolem">y</span>
  <span class="keyword3"><span class="command">assume</span></span> rel<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="skolem">IS_TNIL1</span> <span class="skolem">IS_TNIL2</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">B</span><span class="main">)</span> <span class="skolem">TERMINAL1</span> <span class="skolem">TERMINAL2</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">C</span><span class="main">)</span> <span class="skolem">THD1</span> <span class="skolem">THD2</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="skolem">MORE1</span> <span class="skolem">MORE2</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> tllist_all2 <span class="free">C</span> <span class="free">B</span><span class="main">)</span> <span class="skolem">STOP1</span> <span class="skolem">STOP2</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">A</span><span class="main">)</span> <span class="skolem">TTL1</span> <span class="skolem">TTL2</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="skolem">x</span> <span class="skolem">y</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"tllist_all2 <span class="free">C</span> <span class="free">B</span> <span class="main">(</span>corec_tllist <span class="skolem">IS_TNIL1</span> <span class="skolem">TERMINAL1</span> <span class="skolem">THD1</span> <span class="skolem">MORE1</span> <span class="skolem">STOP1</span> <span class="skolem">TTL1</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span>corec_tllist <span class="skolem">IS_TNIL2</span> <span class="skolem">TERMINAL2</span> <span class="skolem">THD2</span> <span class="skolem">MORE2</span> <span class="skolem">STOP2</span> <span class="skolem">TTL2</span> <span class="skolem">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">A</span> <span class="skolem">x</span> <span class="skolem">y</span>›</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">x</span></span> <span class="quoted"><span class="skolem">y</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> rel <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 4 <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> rel_funE<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="TLList-ttl_transfer2"><span class="command">lemma</span></span> ttl_transfer2 <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>tllist_all2 <span class="free">A</span> <span class="free">B</span> <span class="main">===&gt;</span> tllist_all2 <span class="free">A</span> <span class="free">B</span><span class="main">)</span> ttl ttl"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ttl_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
<span class="keyword1"><span class="command">declare</span></span> ttl_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>

<span class="keyword1" id="TLList-tset_transfer2"><span class="command">lemma</span></span> tset_transfer2 <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>tllist_all2 <span class="free">A</span> <span class="free">B</span> <span class="main">===&gt;</span> rel_set <span class="free">A</span><span class="main">)</span> tset tset"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> rel_funI rel_setI<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> in_tset_conv_tnth tllist_all2_conv_all_tnth Bex_def<span class="main">)</span>

<span class="keyword1" id="TLList-tmap_transfer2"><span class="command">lemma</span></span> tmap_transfer2 <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">B</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">C</span> <span class="main">===&gt;</span> <span class="free">D</span><span class="main">)</span> <span class="main">===&gt;</span> tllist_all2 <span class="free">A</span> <span class="free">C</span> <span class="main">===&gt;</span> tllist_all2 <span class="free">B</span> <span class="free">D</span><span class="main">)</span> tmap tmap"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def tllist_all2_tmap1 tllist_all2_tmap2 <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> tllist_all2_mono<span class="main">)</span>
<span class="keyword1"><span class="command">declare</span></span> tmap_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>

<span class="keyword1" id="TLList-is_TNil_transfer2"><span class="command">lemma</span></span> is_TNil_transfer2 <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>tllist_all2 <span class="free">A</span> <span class="free">B</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> is_TNil is_TNil"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> tllist_all2_is_TNilD<span class="main">)</span>
<span class="keyword1"><span class="command">declare</span></span> is_TNil_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>

<span class="keyword1" id="TLList-tappend_transfer"><span class="command">lemma</span></span> tappend_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>tllist_all2 <span class="free">A</span> <span class="free">B</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">B</span> <span class="main">===&gt;</span> tllist_all2 <span class="free">A</span> <span class="free">C</span><span class="main">)</span> <span class="main">===&gt;</span> tllist_all2 <span class="free">A</span> <span class="free">C</span><span class="main">)</span> tappend tappend"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> tllist_all2_tappendI <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> rel_funE<span class="main">)</span>
<span class="keyword1"><span class="command">declare</span></span> tappend.transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>

<span class="keyword1" id="TLList-lappendt_transfer"><span class="command">lemma</span></span> lappendt_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>llist_all2 <span class="free">A</span> <span class="main">===&gt;</span> tllist_all2 <span class="free">A</span> <span class="free">B</span> <span class="main">===&gt;</span> tllist_all2 <span class="free">A</span> <span class="free">B</span><span class="main">)</span> lappendt lappendt"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> rel_fun_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> llist_all2_lappendI<span class="main">)</span>
<span class="keyword1"><span class="command">declare</span></span> lappendt.transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>

<span class="keyword1" id="TLList-llist_of_tllist_transfer2"><span class="command">lemma</span></span> llist_of_tllist_transfer2 <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>tllist_all2 <span class="free">A</span> <span class="free">B</span> <span class="main">===&gt;</span> llist_all2 <span class="free">A</span><span class="main">)</span> llist_of_tllist llist_of_tllist"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> llist_all2_tllist_of_llistI<span class="main">)</span>
<span class="keyword1"><span class="command">declare</span></span> llist_of_tllist_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>

<span class="keyword1" id="TLList-tllist_of_llist_transfer2"><span class="command">lemma</span></span> tllist_of_llist_transfer2 <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">B</span> <span class="main">===&gt;</span> llist_all2 <span class="free">A</span> <span class="main">===&gt;</span> tllist_all2 <span class="free">A</span> <span class="free">B</span><span class="main">)</span> tllist_of_llist tllist_of_llist"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_funI<span class="main">)</span>
<span class="keyword1"><span class="command">declare</span></span> tllist_of_llist_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>

<span class="keyword1" id="TLList-tlength_transfer"><span class="command">lemma</span></span> tlength_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>tllist_all2 <span class="free">A</span> <span class="free">B</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> tlength tlength"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> tllist_all2_tlengthD<span class="main">)</span>
<span class="keyword1"><span class="command">declare</span></span> tlength.transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>

<span class="keyword1" id="TLList-tdropn_transfer"><span class="command">lemma</span></span> tdropn_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> tllist_all2 <span class="free">A</span> <span class="free">B</span> <span class="main">===&gt;</span> tllist_all2 <span class="free">A</span> <span class="free">B</span><span class="main">)</span> tdropn tdropn"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> rel_fun_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> llist_all2_ldropnI<span class="main">)</span>
<span class="keyword1"><span class="command">declare</span></span> tdropn.transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>

<span class="keyword1" id="TLList-tfilter_transfer"><span class="command">lemma</span></span> tfilter_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">B</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span> tllist_all2 <span class="free">A</span> <span class="free">B</span> <span class="main">===&gt;</span> tllist_all2 <span class="free">A</span> <span class="free">B</span><span class="main">)</span> tfilter tfilter"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> rel_fun_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> llist_all2_lfilterI <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> llist_all2_lfiniteD<span class="main">)</span>
<span class="keyword1"><span class="command">declare</span></span> tfilter.transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>

<span class="keyword1" id="TLList-tconcat_transfer"><span class="command">lemma</span></span> tconcat_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">B</span> <span class="main">===&gt;</span> tllist_all2 <span class="main">(</span>llist_all2 <span class="free">A</span><span class="main">)</span> <span class="free">B</span> <span class="main">===&gt;</span> tllist_all2 <span class="free">A</span> <span class="free">B</span><span class="main">)</span> tconcat tconcat"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> rel_fun_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> llist_all2_lconcatI <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> llist_all2_lfiniteD<span class="main">)</span>
<span class="keyword1"><span class="command">declare</span></span> tconcat.transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>

<span class="keyword1" id="TLList-tllist_all2_rsp"><span class="command">lemma</span></span> tllist_all2_rsp<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> R1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">R1</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∀</span><span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> <span class="free">R1</span> <span class="bound">a</span> <span class="bound">b</span> <span class="main">⟶</span> <span class="free">S</span> <span class="bound">x</span> <span class="bound">a</span> <span class="main">=</span> <span class="free">T</span> <span class="bound">y</span> <span class="bound">b</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> R2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">R2</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∀</span><span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> <span class="free">R2</span> <span class="bound">a</span> <span class="bound">b</span> <span class="main">⟶</span> <span class="free">S'</span> <span class="bound">x</span> <span class="bound">a</span> <span class="main">=</span> <span class="free">T'</span> <span class="bound">y</span> <span class="bound">b</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> xsys<span class="main">:</span> <span class="quoted"><span class="quoted">"tllist_all2 <span class="free">R1</span> <span class="free">R2</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> xs'ys'<span class="main">:</span> <span class="quoted"><span class="quoted">"tllist_all2 <span class="free">R1</span> <span class="free">R2</span> <span class="free">xs'</span> <span class="free">ys'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"tllist_all2 <span class="free">S</span> <span class="free">S'</span> <span class="free">xs</span> <span class="free">xs'</span> <span class="main">=</span> tllist_all2 <span class="free">T</span> <span class="free">T'</span> <span class="free">ys</span> <span class="free">ys'</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"tllist_all2 <span class="free">S</span> <span class="free">S'</span> <span class="free">xs</span> <span class="free">xs'</span>"</span></span>
  <span class="keyword1"><span class="command">with</span></span> xsys xs'ys' <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"tllist_all2 <span class="free">T</span> <span class="free">T'</span> <span class="free">ys</span> <span class="free">ys'</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quoted"><span class="free">ys'</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">xs'</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>tllist_all2 <span class="skolem">ys</span> <span class="skolem">ys'</span> <span class="skolem">xs</span> <span class="skolem">xs'</span><span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">cases</span> <span class="main">(</span><span class="operator">auto</span> 4 4 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tllist_all2_TCons1 tllist_all2_TCons2 tllist_all2_TNil1 tllist_all2_TNil2 <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> R1<span class="main"><span class="main">[</span></span><span class="operator">rule_format</span><span class="main"><span class="main">]</span></span> R2<span class="main"><span class="main">[</span></span><span class="operator">rule_format</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"tllist_all2 <span class="free">T</span> <span class="free">T'</span> <span class="free">ys</span> <span class="free">ys'</span>"</span></span>
  <span class="keyword1"><span class="command">with</span></span> xsys xs'ys' <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"tllist_all2 <span class="free">S</span> <span class="free">S'</span> <span class="free">xs</span> <span class="free">xs'</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">xs'</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quoted"><span class="free">ys'</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>tllist_all2 <span class="skolem">xs</span> <span class="skolem">xs'</span> <span class="skolem">ys</span> <span class="skolem">ys'</span><span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">cases</span><span class="main">(</span><span class="operator">auto</span> 4 4 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tllist_all2_TCons1 tllist_all2_TCons2 tllist_all2_TNil1 tllist_all2_TNil2 <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> R1<span class="main"><span class="main">[</span></span><span class="operator">rule_format</span><span class="main"><span class="main">]</span></span> R2<span class="main"><span class="main">[</span></span><span class="operator">rule_format</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="TLList-tllist_all2_transfer2"><span class="command">lemma</span></span> tllist_all2_transfer2 <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">R1</span> <span class="main">===&gt;</span> <span class="free">R1</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">R2</span> <span class="main">===&gt;</span> <span class="free">R2</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span>
    tllist_all2 <span class="free">R1</span> <span class="free">R2</span> <span class="main">===&gt;</span> tllist_all2 <span class="free">R1</span> <span class="free">R2</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> tllist_all2 tllist_all2"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tllist_all2_rsp rel_fun_def<span class="main">)</span>
<span class="keyword1"><span class="command">declare</span></span> tllist_all2_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Delete lifting rules for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">,</span></span> <span class="tfree"><span class="tfree">'b</span></span><span class="main"><span class="main">)</span></span> tllist"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> 
  because the parametricity rules take precedence over
  most of the transfer rules. They can be restored by 
  including the bundle <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>tllist.lifting›</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">lifting_update</span></span> tllist.lifting
<span class="keyword1"><span class="command">lifting_forget</span></span> tllist.lifting

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Quotient_Coinductive_List">
<div class="head">
<h1>Theory Quotient_Coinductive_List</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Preservation and respectfulness theorems for coinductive lists
    Author:      Andreas Lochbihler
    Maintainer:  Andreas Lochbihler
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Setup for Isabelle's quotient package for lazy lists›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Quotient_Coinductive_List <span class="keyword2"><span class="keyword">imports</span></span>
  <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/Quotient_List.html">HOL-Library.Quotient_List</a>"</span>
  <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/Quotient_Set.html">HOL-Library.Quotient_Set</a>"</span>
  <a href="#Coinductive_List">Coinductive_List</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Rules for the Quotient package›</span></span>

<span class="keyword1"><span class="command">declare</span></span> llist.rel_eq<span class="main">[</span><span class="operator">id_simps</span><span class="main">]</span>

<span class="keyword1" id="Quotient_Coinductive_List-transpD"><span class="command">lemma</span></span> transpD<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> transp <span class="free">R</span><span class="main">;</span> <span class="free">R</span> <span class="free">a</span> <span class="free">b</span><span class="main">;</span> <span class="free">R</span> <span class="free">b</span> <span class="free">c</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">R</span> <span class="free">a</span> <span class="free">c</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">erule</span> transpE<span class="main">)</span> <span class="operator">blast</span>

<span class="keyword1" id="Quotient_Coinductive_List-id_respect"><span class="command">lemma</span></span> id_respect <span class="main">[</span><span class="operator">quot_respect</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">R</span> <span class="main">===&gt;</span> <span class="free">R</span><span class="main">)</span> id id"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fact</span> id_rsp<span class="main">)</span>

<span class="keyword1" id="Quotient_Coinductive_List-id_preserve"><span class="command">lemma</span></span> id_preserve <span class="main">[</span><span class="operator">quot_preserve</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R</span> <span class="free">Abs</span> <span class="free">Rep</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Rep</span> <span class="main">---&gt;</span> <span class="free">Abs</span><span class="main">)</span> id <span class="main">=</span> id"</span></span>
  <span class="keyword1"><span class="command">using</span></span> Quotient3_abs_rep <span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>

<span class="keyword1"><span class="command">functor</span></span> lmap<span class="main">:</span> <span class="quoted">lmap</span>
   <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff id_def llist.map_comp<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> llist.map_id0 <span class="main">[</span><span class="operator">id_simps</span><span class="main">]</span>

<span class="keyword1" id="Quotient_Coinductive_List-reflp_llist_all2"><span class="command">lemma</span></span> reflp_llist_all2<span class="main">:</span> <span class="quoted"><span class="quoted">"reflp <span class="free">R</span> <span class="main">⟹</span> reflp <span class="main">(</span>llist_all2 <span class="free">R</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> reflpI<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_all2_conv_all_lnth <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> reflpE<span class="main">)</span>

<span class="keyword1" id="Quotient_Coinductive_List-symp_llist_all2"><span class="command">lemma</span></span> symp_llist_all2<span class="main">:</span> <span class="quoted"><span class="quoted">"symp <span class="free">R</span> <span class="main">⟹</span> symp <span class="main">(</span>llist_all2 <span class="free">R</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> sympI<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_all2_conv_all_lnth <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> sympE<span class="main">)</span>

<span class="keyword1" id="Quotient_Coinductive_List-transp_llist_all2"><span class="command">lemma</span></span> transp_llist_all2<span class="main">:</span> <span class="quoted"><span class="quoted">"transp <span class="free">R</span> <span class="main">⟹</span> transp <span class="main">(</span>llist_all2 <span class="free">R</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> transpI<span class="main">)</span> <span class="main">(</span><span class="operator">rule</span> llist_all2_trans<span class="main">)</span>

<span class="keyword1" id="Quotient_Coinductive_List-llist_equivp"><span class="command">lemma</span></span> llist_equivp <span class="main">[</span><span class="operator">quot_equiv</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"equivp <span class="free">R</span> <span class="main">⟹</span> equivp <span class="main">(</span>llist_all2 <span class="free">R</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> equivp_reflp_symp_transp reflp_llist_all2 symp_llist_all2 transp_llist_all2<span class="main">)</span>

<span class="keyword1" id="Quotient_Coinductive_List-unfold_llist_preserve"><span class="command">lemma</span></span> unfold_llist_preserve <span class="main">[</span><span class="operator">quot_preserve</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> q1<span class="main">:</span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R1</span> <span class="free">Abs1</span> <span class="free">Rep1</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> q2<span class="main">:</span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R2</span> <span class="free">Abs2</span> <span class="free">Rep2</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">Abs1</span> <span class="main">---&gt;</span> id<span class="main">)</span> <span class="main">---&gt;</span> <span class="main">(</span><span class="free">Abs1</span> <span class="main">---&gt;</span> <span class="free">Rep2</span><span class="main">)</span> <span class="main">---&gt;</span> <span class="main">(</span><span class="free">Abs1</span> <span class="main">---&gt;</span> <span class="free">Rep1</span><span class="main">)</span> <span class="main">---&gt;</span> <span class="free">Rep1</span> <span class="main">---&gt;</span> lmap <span class="free">Abs2</span><span class="main">)</span> unfold_llist <span class="main">=</span> unfold_llist"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">intro</span> ext<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">IS_LNIL</span> <span class="skolem">LHD</span> <span class="skolem">LTL</span> <span class="skolem">a</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="skolem">IS_LNIL</span> <span class="skolem">LHD</span> <span class="skolem">LTL</span> <span class="skolem">a</span> <span class="main">=</span> <span class="var">?rhs</span> <span class="skolem">IS_LNIL</span> <span class="skolem">LHD</span> <span class="skolem">LTL</span> <span class="skolem">a</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">a</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Quotient3_abs_rep<span class="main"><span class="main">[</span></span><span class="operator">OF</span> q1<span class="main"><span class="main">]</span></span> Quotient3_abs_rep<span class="main"><span class="main">[</span></span><span class="operator">OF</span> q2<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Quotient_Coinductive_List-Quotient_lmap_Abs_Rep"><span class="command">lemma</span></span> Quotient_lmap_Abs_Rep<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R</span> <span class="free">Abs</span> <span class="free">Rep</span> <span class="main">⟹</span> lmap <span class="free">Abs</span> <span class="main">(</span>lmap <span class="free">Rep</span> <span class="free">a</span><span class="main">)</span> <span class="main">=</span> <span class="free">a</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">drule</span> abs_o_rep<span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist.map_id0 llist.map_comp<span class="main">)</span>

<span class="keyword1" id="Quotient_Coinductive_List-llist_all2_rel"><span class="command">lemma</span></span> llist_all2_rel<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R</span> <span class="free">Abs</span> <span class="free">Rep</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"llist_all2 <span class="free">R</span> <span class="free">r</span> <span class="free">s</span> <span class="main">⟷</span> llist_all2 <span class="free">R</span> <span class="free">r</span> <span class="free">r</span> <span class="main">∧</span> llist_all2 <span class="free">R</span> <span class="free">s</span> <span class="free">s</span> <span class="main">∧</span> <span class="main">(</span>lmap <span class="free">Abs</span> <span class="free">r</span> <span class="main">=</span> lmap <span class="free">Abs</span> <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"llist_all2 <span class="free">R</span> <span class="free">r</span> <span class="free">r</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> llist_all2_reflI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lset_conv_lnth<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">metis</span> Quotient3_rel<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span> llist_all2_lnthD<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?lhs</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"llist_all2 <span class="free">R</span> <span class="free">s</span> <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> llist_all2_reflI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lset_conv_lnth<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">metis</span> Quotient3_rel<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span> llist_all2_lnthD2<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?lhs</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"llength <span class="free">r</span> <span class="main">=</span> llength <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> llist_all2_llengthD<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lmap <span class="free">Abs</span> <span class="free">r</span> <span class="main">=</span> lmap <span class="free">Abs</span> <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?lhs</span>›</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> lmap_eq_lmap_conv_llist_all2
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule</span> llist_all2_all_lnthI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> llist_all2_lnthD<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">metis</span> Quotient3_rel<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> lmap_eq_lmap_conv_llist_all2
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_all2_conv_all_lnth <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> llist_all2_same<span class="main">)</span><span class="main">(</span><span class="operator">metis</span> Quotient3_rel<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Quotient_Coinductive_List-Quotient_llist_all2_lmap_Rep"><span class="command">lemma</span></span> Quotient_llist_all2_lmap_Rep<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R</span> <span class="free">Abs</span> <span class="free">Rep</span> <span class="main">⟹</span> llist_all2 <span class="free">R</span> <span class="main">(</span>lmap <span class="free">Rep</span> <span class="free">a</span><span class="main">)</span> <span class="main">(</span>lmap <span class="free">Rep</span> <span class="free">a</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> llist_all2_all_lnthI <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> Quotient3_rep_reflp<span class="main">)</span>

<span class="keyword1" id="Quotient_Coinductive_List-llist_quotient"><span class="command">lemma</span></span> llist_quotient <span class="main">[</span><span class="operator">quot_thm</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R</span> <span class="free">Abs</span> <span class="free">Rep</span> <span class="main">⟹</span> Quotient3 <span class="main">(</span>llist_all2 <span class="free">R</span><span class="main">)</span> <span class="main">(</span>lmap <span class="free">Abs</span><span class="main">)</span> <span class="main">(</span>lmap <span class="free">Rep</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> Quotient3I <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Quotient_lmap_Abs_Rep Quotient_llist_all2_lmap_Rep llist_all2_rel<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">mapQ3</span> llist <span class="main"><span class="main">=</span></span> <span class="main"><span class="main">(</span></span>llist_all2<span class="main"><span class="main">,</span></span> llist_quotient<span class="main"><span class="main">)</span></span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Quotient_Coinductive_List-LCons_preserve"><span class="command">lemma</span></span> LCons_preserve <span class="main">[</span><span class="operator">quot_preserve</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R</span> <span class="free">Abs</span> <span class="free">Rep</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Rep</span> <span class="main">---&gt;</span> <span class="main">(</span>lmap <span class="free">Rep</span><span class="main">)</span> <span class="main">---&gt;</span> <span class="main">(</span>lmap <span class="free">Abs</span><span class="main">)</span><span class="main">)</span> LCons <span class="main">=</span> LCons"</span></span>
<span class="keyword1"><span class="command">using</span></span> Quotient3_abs_rep<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff llist.map_comp o_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> LCons_respect <span class="main">[</span><span class="operator">quot_respect</span><span class="main">]</span> <span class="main">=</span> LCons_transfer 

<span class="keyword1" id="Quotient_Coinductive_List-LNil_preserve"><span class="command">lemma</span></span> LNil_preserve <span class="main">[</span><span class="operator">quot_preserve</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lmap <span class="free">Abs</span> LNil <span class="main">=</span> LNil"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemmas</span></span> LNil_respect <span class="main">[</span><span class="operator">quot_respect</span><span class="main">]</span> <span class="main">=</span> LNil_transfer

<span class="keyword1" id="Quotient_Coinductive_List-lmap_preserve"><span class="command">lemma</span></span> lmap_preserve <span class="main">[</span><span class="operator">quot_preserve</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R1</span> <span class="free">abs1</span> <span class="free">rep1</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>     b<span class="main">:</span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R2</span> <span class="free">abs2</span> <span class="free">rep2</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">abs1</span> <span class="main">---&gt;</span> <span class="free">rep2</span><span class="main">)</span> <span class="main">---&gt;</span> <span class="main">(</span>lmap <span class="free">rep1</span><span class="main">)</span> <span class="main">---&gt;</span> <span class="main">(</span>lmap <span class="free">abs2</span><span class="main">)</span><span class="main">)</span> lmap <span class="main">=</span> lmap"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">abs1</span> <span class="main">---&gt;</span> id<span class="main">)</span> <span class="main">---&gt;</span> lmap <span class="free">rep1</span> <span class="main">---&gt;</span> id<span class="main">)</span> lmap <span class="main">=</span> lmap"</span></span>
<span class="keyword1"><span class="command">using</span></span> Quotient3_abs_rep<span class="main">[</span><span class="operator">OF</span> a<span class="main">]</span> Quotient3_abs_rep<span class="main">[</span><span class="operator">OF</span> b<span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff llist.map_comp o_def<span class="main">)</span>

<span class="keyword1" id="Quotient_Coinductive_List-lmap_respect"><span class="command">lemma</span></span> lmap_respect <span class="main">[</span><span class="operator">quot_respect</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">R1</span> <span class="main">===&gt;</span> <span class="free">R2</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span>llist_all2 <span class="free">R1</span><span class="main">)</span> <span class="main">===&gt;</span> llist_all2 <span class="free">R2</span><span class="main">)</span> lmap lmap"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">R1</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span>llist_all2 <span class="free">R1</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> lmap lmap"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> lmap_transfer<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_all2_conv_all_lnth lmap_eq_lmap_conv_llist_all2 rel_fun_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> llist_all2_respect <span class="main">[</span><span class="operator">quot_respect</span><span class="main">]</span> <span class="main">=</span> llist_all2_transfer

<span class="keyword1" id="Quotient_Coinductive_List-llist_all2_preserve"><span class="command">lemma</span></span> llist_all2_preserve <span class="main">[</span><span class="operator">quot_preserve</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R</span> <span class="free">Abs</span> <span class="free">Rep</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">Abs</span> <span class="main">---&gt;</span> <span class="free">Abs</span> <span class="main">---&gt;</span> id<span class="main">)</span> <span class="main">---&gt;</span> lmap <span class="free">Rep</span> <span class="main">---&gt;</span> lmap <span class="free">Rep</span> <span class="main">---&gt;</span> id<span class="main">)</span> llist_all2 <span class="main">=</span> llist_all2"</span></span>
<span class="keyword1"><span class="command">using</span></span> Quotient3_abs_rep<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff llist_all2_lmap1 llist_all2_lmap2<span class="main">)</span>

<span class="keyword1" id="Quotient_Coinductive_List-llist_all2_preserve2"><span class="command">lemma</span></span> llist_all2_preserve2 <span class="main">[</span><span class="operator">quot_preserve</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R</span> <span class="free">Abs</span> <span class="free">Rep</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>llist_all2 <span class="main">(</span><span class="main">(</span><span class="free">Rep</span> <span class="main">---&gt;</span> <span class="free">Rep</span> <span class="main">---&gt;</span> id<span class="main">)</span> <span class="free">R</span><span class="main">)</span> <span class="free">l</span> <span class="free">m</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">l</span> <span class="main">=</span> <span class="free">m</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_fun_def <span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span> Quotient3_rel_rep <span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span> llist.rel_eq comp_def<span class="main">)</span>

<span class="keyword1" id="Quotient_Coinductive_List-corec_llist_preserve"><span class="command">lemma</span></span> corec_llist_preserve <span class="main">[</span><span class="operator">quot_preserve</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> q1<span class="main">:</span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R1</span> <span class="free">Abs1</span> <span class="free">Rep1</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> q2<span class="main">:</span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R2</span> <span class="free">Abs2</span> <span class="free">Rep2</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">Abs1</span> <span class="main">---&gt;</span> id<span class="main">)</span> <span class="main">---&gt;</span> <span class="main">(</span><span class="free">Abs1</span> <span class="main">---&gt;</span> <span class="free">Rep2</span><span class="main">)</span> <span class="main">---&gt;</span> <span class="main">(</span><span class="free">Abs1</span> <span class="main">---&gt;</span> id<span class="main">)</span> <span class="main">---&gt;</span> 
          <span class="main">(</span><span class="free">Abs1</span> <span class="main">---&gt;</span> lmap <span class="free">Rep2</span><span class="main">)</span> <span class="main">---&gt;</span> <span class="main">(</span><span class="free">Abs1</span> <span class="main">---&gt;</span> <span class="free">Rep1</span><span class="main">)</span> <span class="main">---&gt;</span> <span class="free">Rep1</span> <span class="main">---&gt;</span> lmap <span class="free">Abs2</span><span class="main">)</span> corec_llist <span class="main">=</span> corec_llist"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">intro</span> ext<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">IS_LNIL</span> <span class="skolem">LHD</span> <span class="skolem">endORmore</span> <span class="skolem">LTL_end</span> <span class="skolem">LTL_more</span> <span class="skolem">b</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="skolem">IS_LNIL</span> <span class="skolem">LHD</span> <span class="skolem">endORmore</span> <span class="skolem">LTL_end</span> <span class="skolem">LTL_more</span> <span class="skolem">b</span> <span class="main">=</span> <span class="var">?rhs</span> <span class="skolem">IS_LNIL</span> <span class="skolem">LHD</span> <span class="skolem">endORmore</span> <span class="skolem">LTL_end</span> <span class="skolem">LTL_more</span> <span class="skolem">b</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">b</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> llist.coinduct_strong<span class="main">)</span>
      <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Quotient3_abs_rep<span class="main"><span class="main">[</span></span><span class="operator">OF</span> q1<span class="main"><span class="main">]</span></span> Quotient3_abs_rep<span class="main"><span class="main">[</span></span><span class="operator">OF</span> q2<span class="main"><span class="main">]</span></span> Quotient_lmap_Abs_Rep<span class="main"><span class="main">[</span></span><span class="operator">OF</span> q2<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Quotient_TLList">
<div class="head">
<h1>Theory Quotient_TLList</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Preservation and respectfulness theorems for terminated coinductive lists
    Author:      Andreas Lochbihler
    Maintainer:  Andreas Lochbihler
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Setup for Isabelle's quotient package for terminated lazy lists›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Quotient_TLList <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="#TLList">TLList</a>
  <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/Quotient_Product.html">HOL-Library.Quotient_Product</a>"</span>
  <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/Quotient_Sum.html">HOL-Library.Quotient_Sum</a>"</span>
  <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/Quotient_Set.html">HOL-Library.Quotient_Set</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Rules for the Quotient package›</span></span>

<span class="keyword1" id="Quotient_TLList-tmap_id_id"><span class="command">lemma</span></span> tmap_id_id <span class="main">[</span><span class="operator">id_simps</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"tmap id id <span class="main">=</span> id"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff tllist.map_id<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> tllist_all2_eq<span class="main">[</span><span class="operator">id_simps</span><span class="main">]</span>

<span class="keyword1" id="Quotient_TLList-case_sum_preserve"><span class="command">lemma</span></span> case_sum_preserve <span class="main">[</span><span class="operator">quot_preserve</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> q1<span class="main">:</span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R1</span> <span class="free">Abs1</span> <span class="free">Rep1</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> q2<span class="main">:</span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R2</span> <span class="free">Abs2</span> <span class="free">Rep2</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> q3<span class="main">:</span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R3</span> <span class="free">Abs3</span> <span class="free">Rep3</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">Abs1</span> <span class="main">---&gt;</span> <span class="free">Rep2</span><span class="main">)</span> <span class="main">---&gt;</span> <span class="main">(</span><span class="free">Abs3</span> <span class="main">---&gt;</span> <span class="free">Rep2</span><span class="main">)</span> <span class="main">---&gt;</span> map_sum <span class="free">Rep1</span> <span class="free">Rep3</span> <span class="main">---&gt;</span> <span class="free">Abs2</span><span class="main">)</span> case_sum <span class="main">=</span> case_sum"</span></span>
<span class="keyword1"><span class="command">using</span></span> Quotient3_abs_rep<span class="main">[</span><span class="operator">OF</span> q1<span class="main">]</span> Quotient3_abs_rep<span class="main">[</span><span class="operator">OF</span> q2<span class="main">]</span> Quotient3_abs_rep<span class="main">[</span><span class="operator">OF</span> q3<span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> sum.split<span class="main">)</span>

<span class="keyword1" id="Quotient_TLList-case_sum_preserve2"><span class="command">lemma</span></span> case_sum_preserve2 <span class="main">[</span><span class="operator">quot_preserve</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> q<span class="main">:</span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R</span> <span class="free">Abs</span> <span class="free">Rep</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>id <span class="main">---&gt;</span> <span class="free">Rep</span><span class="main">)</span> <span class="main">---&gt;</span> <span class="main">(</span>id <span class="main">---&gt;</span> <span class="free">Rep</span><span class="main">)</span> <span class="main">---&gt;</span> id <span class="main">---&gt;</span> <span class="free">Abs</span><span class="main">)</span> case_sum <span class="main">=</span> case_sum"</span></span>
<span class="keyword1"><span class="command">using</span></span> Quotient3_abs_rep<span class="main">[</span><span class="operator">OF</span> q<span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ext <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> sum.split<span class="main">)</span>

<span class="keyword1" id="Quotient_TLList-case_prod_preserve"><span class="command">lemma</span></span> case_prod_preserve <span class="main">[</span><span class="operator">quot_preserve</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> q1<span class="main">:</span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R1</span> <span class="free">Abs1</span> <span class="free">Rep1</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> q2<span class="main">:</span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R2</span> <span class="free">Abs2</span> <span class="free">Rep2</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> q3<span class="main">:</span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R3</span> <span class="free">Abs3</span> <span class="free">Rep3</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">Abs1</span> <span class="main">---&gt;</span> <span class="free">Abs2</span> <span class="main">---&gt;</span> <span class="free">Rep3</span><span class="main">)</span> <span class="main">---&gt;</span> map_prod <span class="free">Rep1</span> <span class="free">Rep2</span> <span class="main">---&gt;</span> <span class="free">Abs3</span><span class="main">)</span> case_prod <span class="main">=</span> case_prod"</span></span>
<span class="keyword1"><span class="command">using</span></span> Quotient3_abs_rep<span class="main">[</span><span class="operator">OF</span> q1<span class="main">]</span> Quotient3_abs_rep<span class="main">[</span><span class="operator">OF</span> q2<span class="main">]</span> Quotient3_abs_rep<span class="main">[</span><span class="operator">OF</span> q3<span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>

<span class="keyword1" id="Quotient_TLList-case_prod_preserve2"><span class="command">lemma</span></span> case_prod_preserve2 <span class="main">[</span><span class="operator">quot_preserve</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> q<span class="main">:</span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R</span> <span class="free">Abs</span> <span class="free">Rep</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>id <span class="main">---&gt;</span> id <span class="main">---&gt;</span> <span class="free">Rep</span><span class="main">)</span> <span class="main">---&gt;</span> id <span class="main">---&gt;</span> <span class="free">Abs</span><span class="main">)</span> case_prod <span class="main">=</span> case_prod"</span></span>
<span class="keyword1"><span class="command">using</span></span> Quotient3_abs_rep<span class="main">[</span><span class="operator">OF</span> q<span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ext<span class="main">)</span>

<span class="keyword1" id="Quotient_TLList-id_preserve"><span class="command">lemma</span></span> id_preserve <span class="main">[</span><span class="operator">quot_preserve</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R</span> <span class="free">Abs</span> <span class="free">Rep</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Rep</span> <span class="main">---&gt;</span> <span class="free">Abs</span><span class="main">)</span> id <span class="main">=</span> id"</span></span>
<span class="keyword1"><span class="command">using</span></span> Quotient3_abs_rep<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> ext<span class="main">)</span>

<span class="keyword1"><span class="command">functor</span></span> tmap<span class="main">:</span> <span class="quoted">tmap</span>
   <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff tmap_id_id tllist.map_comp<span class="main">)</span>

<span class="keyword1" id="Quotient_TLList-reflp_tllist_all2"><span class="command">lemma</span></span> reflp_tllist_all2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> R<span class="main">:</span> <span class="quoted"><span class="quoted">"reflp <span class="free">R</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> Q<span class="main">:</span> <span class="quoted"><span class="quoted">"reflp <span class="free">Q</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"reflp <span class="main">(</span>tllist_all2 <span class="free">R</span> <span class="free">Q</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> reflpI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"tllist_all2 <span class="free">R</span> <span class="free">Q</span> <span class="skolem">xs</span> <span class="skolem">xs</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> reflpE<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Quotient_TLList-symp_tllist_all2"><span class="command">lemma</span></span> symp_tllist_all2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> symp <span class="free">R</span><span class="main">;</span> symp <span class="free">S</span> <span class="main">⟧</span> <span class="main">⟹</span> symp <span class="main">(</span>tllist_all2 <span class="free">R</span> <span class="free">S</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> sympI<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tllist_all2_conv_all_tnth <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> sympE <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lfinite_llength_enat not_lfinite_llength<span class="main">)</span>

<span class="keyword1" id="Quotient_TLList-transp_tllist_all2"><span class="command">lemma</span></span> transp_tllist_all2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> transp <span class="free">R</span><span class="main">;</span> transp <span class="free">S</span> <span class="main">⟧</span> <span class="main">⟹</span> transp <span class="main">(</span>tllist_all2 <span class="free">R</span> <span class="free">S</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> transpI<span class="main">)</span> <span class="main">(</span><span class="operator">rule</span> tllist_all2_trans<span class="main">)</span>

<span class="keyword1" id="Quotient_TLList-tllist_equivp"><span class="command">lemma</span></span> tllist_equivp <span class="main">[</span><span class="operator">quot_equiv</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> equivp <span class="free">R</span><span class="main">;</span> equivp <span class="free">S</span> <span class="main">⟧</span> <span class="main">⟹</span> equivp <span class="main">(</span>tllist_all2 <span class="free">R</span> <span class="free">S</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> equivp_reflp_symp_transp reflp_tllist_all2 symp_tllist_all2 transp_tllist_all2<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> tllist_all2_eq <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">id_simps</span><span class="main">]</span>

<span class="keyword1" id="Quotient_TLList-tmap_preserve"><span class="command">lemma</span></span> tmap_preserve <span class="main">[</span><span class="operator">quot_preserve</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> q1<span class="main">:</span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R1</span> <span class="free">Abs1</span> <span class="free">Rep1</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> q2<span class="main">:</span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R2</span> <span class="free">Abs2</span> <span class="free">Rep2</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> q3<span class="main">:</span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R3</span> <span class="free">Abs3</span> <span class="free">Rep3</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> q4<span class="main">:</span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R4</span> <span class="free">Abs4</span> <span class="free">Rep4</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">Abs1</span> <span class="main">---&gt;</span> <span class="free">Rep2</span><span class="main">)</span> <span class="main">---&gt;</span> <span class="main">(</span><span class="free">Abs3</span> <span class="main">---&gt;</span> <span class="free">Rep4</span><span class="main">)</span> <span class="main">---&gt;</span> tmap <span class="free">Rep1</span> <span class="free">Rep3</span> <span class="main">---&gt;</span> tmap <span class="free">Abs2</span> <span class="free">Abs4</span><span class="main">)</span> tmap <span class="main">=</span> tmap"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">Abs1</span> <span class="main">---&gt;</span> id<span class="main">)</span> <span class="main">---&gt;</span> <span class="main">(</span><span class="free">Abs2</span> <span class="main">---&gt;</span> id<span class="main">)</span> <span class="main">---&gt;</span> tmap <span class="free">Rep1</span> <span class="free">Rep2</span> <span class="main">---&gt;</span> id<span class="main">)</span> tmap <span class="main">=</span> tmap"</span></span>
<span class="keyword1"><span class="command">using</span></span> Quotient3_abs_rep<span class="main">[</span><span class="operator">OF</span> q1<span class="main">]</span> Quotient3_abs_rep<span class="main">[</span><span class="operator">OF</span> q2<span class="main">]</span> Quotient3_abs_rep<span class="main">[</span><span class="operator">OF</span> q3<span class="main">]</span> Quotient3_abs_rep<span class="main">[</span><span class="operator">OF</span> q4<span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff tllist.map_comp o_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> tmap_respect <span class="main">[</span><span class="operator">quot_respect</span><span class="main">]</span> <span class="main">=</span> tmap_transfer2

<span class="keyword1" id="Quotient_TLList-Quotient3_tmap_Abs_Rep"><span class="command">lemma</span></span> Quotient3_tmap_Abs_Rep<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>Quotient3 <span class="free">R1</span> <span class="free">Abs1</span> <span class="free">Rep1</span><span class="main">;</span> Quotient3 <span class="free">R2</span> <span class="free">Abs2</span> <span class="free">Rep2</span><span class="main">⟧</span>
  <span class="main">⟹</span> tmap <span class="free">Abs1</span> <span class="free">Abs2</span> <span class="main">(</span>tmap <span class="free">Rep1</span> <span class="free">Rep2</span> <span class="free">ts</span><span class="main">)</span> <span class="main">=</span> <span class="free">ts</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">drule</span> abs_o_rep<span class="main">)</span><span class="main"><span class="keyword3">+</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tllist.map_comp tmap_id_id<span class="main">)</span>

<span class="keyword1" id="Quotient_TLList-Quotient3_tllist_all2_tmap_tmapI"><span class="command">lemma</span></span> Quotient3_tllist_all2_tmap_tmapI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> q1<span class="main">:</span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R1</span> <span class="free">Abs1</span> <span class="free">Rep1</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> q2<span class="main">:</span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R2</span> <span class="free">Abs2</span> <span class="free">Rep2</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"tllist_all2 <span class="free">R1</span> <span class="free">R2</span> <span class="main">(</span>tmap <span class="free">Rep1</span> <span class="free">Rep2</span> <span class="free">ts</span><span class="main">)</span> <span class="main">(</span>tmap <span class="free">Rep1</span> <span class="free">Rep2</span> <span class="free">ts</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">ts</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Quotient3_rep_reflp<span class="main"><span class="main">[</span></span><span class="operator">OF</span> q1<span class="main"><span class="main">]</span></span> Quotient3_rep_reflp<span class="main"><span class="main">[</span></span><span class="operator">OF</span> q2<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Quotient_TLList-tllist_all2_rel"><span class="command">lemma</span></span> tllist_all2_rel<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> q1<span class="main">:</span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R1</span> <span class="free">Abs1</span> <span class="free">Rep1</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> q2<span class="main">:</span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R2</span> <span class="free">Abs2</span> <span class="free">Rep2</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"tllist_all2 <span class="free">R1</span> <span class="free">R2</span> <span class="free">r</span> <span class="free">s</span> <span class="main">⟷</span> <span class="main">(</span>tllist_all2 <span class="free">R1</span> <span class="free">R2</span> <span class="free">r</span> <span class="free">r</span> <span class="main">∧</span> tllist_all2 <span class="free">R1</span> <span class="free">R2</span> <span class="free">s</span> <span class="free">s</span> <span class="main">∧</span> tmap <span class="free">Abs1</span> <span class="free">Abs2</span> <span class="free">r</span> <span class="main">=</span> tmap <span class="free">Abs1</span> <span class="free">Abs2</span> <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">intro</span> iffI conjI<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"tllist_all2 <span class="free">R1</span> <span class="free">R2</span> <span class="free">r</span> <span class="free">r</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> tllist_all2_reflI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> in_tset_conv_tnth<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">metis</span> tllist_all2_tnthD Quotient3_rel <span class="main"><span class="main">[</span></span><span class="operator">OF</span> q1<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">metis</span> tllist_all2_tfinite1_terminalD Quotient3_rel <span class="main"><span class="main">[</span></span><span class="operator">OF</span> q2<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?lhs</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"tllist_all2 <span class="free">R1</span> <span class="free">R2</span> <span class="free">s</span> <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> tllist_all2_reflI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> in_tset_conv_tnth<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">metis</span> tllist_all2_tnthD2 Quotient3_rel <span class="main"><span class="main">[</span></span><span class="operator">OF</span> q1<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">metis</span> tllist_all2_tfinite2_terminalD Quotient3_rel <span class="main"><span class="main">[</span></span><span class="operator">OF</span> q2<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?lhs</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"tmap <span class="free">Abs1</span> <span class="free">Abs2</span> <span class="free">r</span> <span class="main">=</span> tmap <span class="free">Abs1</span> <span class="free">Abs2</span> <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> tmap_eq_tmap_conv_tllist_all2
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> tllist_all2_mono<span class="main">)</span><span class="main">(</span><span class="operator">metis</span> Quotient3_rel<span class="main"><span class="main">[</span></span><span class="operator">OF</span> q1<span class="main"><span class="main">]</span></span> Quotient3_rel<span class="main"><span class="main">[</span></span><span class="operator">OF</span> q2<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rhs</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> tmap_eq_tmap_conv_tllist_all2
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tllist_all2_conv_all_tnth<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> Quotient3_rel<span class="main"><span class="main">[</span></span><span class="operator">OF</span> q1<span class="main"><span class="main">,</span></span> <span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> Quotient3_rel<span class="main"><span class="main">[</span></span><span class="operator">OF</span> q2<span class="main"><span class="main">,</span></span> <span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lfinite_llength_enat not_lfinite_llength<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Quotient_TLList-tllist_quotient"><span class="command">lemma</span></span> tllist_quotient <span class="main">[</span><span class="operator">quot_thm</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> Quotient3 <span class="free">R1</span> <span class="free">Abs1</span> <span class="free">Rep1</span><span class="main">;</span> Quotient3 <span class="free">R2</span> <span class="free">Abs2</span> <span class="free">Rep2</span> <span class="main">⟧</span>
  <span class="main">⟹</span> Quotient3 <span class="main">(</span>tllist_all2 <span class="free">R1</span> <span class="free">R2</span><span class="main">)</span> <span class="main">(</span>tmap <span class="free">Abs1</span> <span class="free">Abs2</span><span class="main">)</span> <span class="main">(</span>tmap <span class="free">Rep1</span> <span class="free">Rep2</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> Quotient3I <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Quotient3_tmap_Abs_Rep Quotient3_tllist_all2_tmap_tmapI tllist_all2_rel<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">mapQ3</span> tllist <span class="main"><span class="main">=</span></span> <span class="main"><span class="main">(</span></span>tllist_all2<span class="main"><span class="main">,</span></span> tllist_quotient<span class="main"><span class="main">)</span></span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Quotient_TLList-TCons_preserve"><span class="command">lemma</span></span> TCons_preserve <span class="main">[</span><span class="operator">quot_preserve</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> q1<span class="main">:</span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R1</span> <span class="free">Abs1</span> <span class="free">Rep1</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> q2<span class="main">:</span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R2</span> <span class="free">Abs2</span> <span class="free">Rep2</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Rep1</span> <span class="main">---&gt;</span> <span class="main">(</span>tmap <span class="free">Rep1</span> <span class="free">Rep2</span><span class="main">)</span> <span class="main">---&gt;</span> <span class="main">(</span>tmap <span class="free">Abs1</span> <span class="free">Abs2</span><span class="main">)</span><span class="main">)</span> TCons <span class="main">=</span> TCons"</span></span>
<span class="keyword1"><span class="command">using</span></span> Quotient3_abs_rep<span class="main">[</span><span class="operator">OF</span> q1<span class="main">]</span> Quotient3_abs_rep<span class="main">[</span><span class="operator">OF</span> q2<span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff tllist.map_comp o_def tmap_id_id<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> id_def<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> TCons_respect <span class="main">[</span><span class="operator">quot_respect</span><span class="main">]</span> <span class="main">=</span> TCons_transfer2

<span class="keyword1" id="Quotient_TLList-TNil_preserve"><span class="command">lemma</span></span> TNil_preserve <span class="main">[</span><span class="operator">quot_preserve</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R2</span> <span class="free">Abs2</span> <span class="free">Rep2</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Rep2</span> <span class="main">---&gt;</span> tmap <span class="free">Abs1</span> <span class="free">Abs2</span><span class="main">)</span> TNil <span class="main">=</span> TNil"</span></span>
<span class="keyword1"><span class="command">using</span></span> Quotient3_abs_rep<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> TNil_respect <span class="main">[</span><span class="operator">quot_respect</span><span class="main">]</span> <span class="main">=</span> TNil_transfer2

<span class="keyword1"><span class="command">lemmas</span></span> tllist_all2_respect <span class="main">[</span><span class="operator">quot_respect</span><span class="main">]</span> <span class="main">=</span> tllist_all2_transfer

<span class="keyword1" id="Quotient_TLList-tllist_all2_prs"><span class="command">lemma</span></span> tllist_all2_prs<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> q1<span class="main">:</span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R1</span> <span class="free">Abs1</span> <span class="free">Rep1</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> q2<span class="main">:</span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R2</span> <span class="free">Abs2</span> <span class="free">Rep2</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"tllist_all2 <span class="main">(</span><span class="main">(</span><span class="free">Abs1</span> <span class="main">---&gt;</span> <span class="free">Abs1</span> <span class="main">---&gt;</span> id<span class="main">)</span> <span class="free">P</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="free">Abs2</span> <span class="main">---&gt;</span> <span class="free">Abs2</span> <span class="main">---&gt;</span> id<span class="main">)</span> <span class="free">Q</span><span class="main">)</span>
                     <span class="main">(</span>tmap <span class="free">Rep1</span> <span class="free">Rep2</span> <span class="free">ts</span><span class="main">)</span> <span class="main">(</span>tmap <span class="free">Rep1</span> <span class="free">Rep2</span> <span class="free">ts'</span><span class="main">)</span>
         <span class="main">⟷</span> tllist_all2 <span class="free">P</span> <span class="free">Q</span> <span class="free">ts</span> <span class="free">ts'</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduct</span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>tllist_all2 <span class="skolem">ts</span> <span class="skolem">ts'</span><span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> Quotient3_abs_rep<span class="main">[</span><span class="operator">OF</span> q1<span class="main">]</span> Quotient3_abs_rep<span class="main">[</span><span class="operator">OF</span> q2<span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ts</span></span><span class="main">)</span><span class="main">(</span><span class="operator">case_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">ts'</span></span></span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tllist_all2_TNil1 tllist_all2_TCons1<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">ts</span></span> <span class="quoted"><span class="free">ts'</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> Quotient3_abs_rep<span class="main">[</span><span class="operator">OF</span> q1<span class="main">]</span> Quotient3_abs_rep<span class="main">[</span><span class="operator">OF</span> q2<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> tllist_all2_is_TNilD <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> tllist_all2_tfinite1_terminalD tllist_all2_thdD tllist_all2_ttlI<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Quotient_TLList-tllist_all2_preserve"><span class="command">lemma</span></span> tllist_all2_preserve <span class="main">[</span><span class="operator">quot_preserve</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R1</span> <span class="free">Abs1</span> <span class="free">Rep1</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R2</span> <span class="free">Abs2</span> <span class="free">Rep2</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">Abs1</span> <span class="main">---&gt;</span> <span class="free">Abs1</span> <span class="main">---&gt;</span> id<span class="main">)</span> <span class="main">---&gt;</span> <span class="main">(</span><span class="free">Abs2</span> <span class="main">---&gt;</span> <span class="free">Abs2</span> <span class="main">---&gt;</span> id<span class="main">)</span> <span class="main">---&gt;</span>
          tmap <span class="free">Rep1</span> <span class="free">Rep2</span> <span class="main">---&gt;</span> tmap <span class="free">Rep1</span> <span class="free">Rep2</span> <span class="main">---&gt;</span> id<span class="main">)</span> tllist_all2 <span class="main">=</span> tllist_all2"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff tllist_all2_prs<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Quotient_TLList-tllist_all2_preserve2"><span class="command">lemma</span></span> tllist_all2_preserve2 <span class="main">[</span><span class="operator">quot_preserve</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> q1<span class="main">:</span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R1</span> <span class="free">Abs1</span> <span class="free">Rep1</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> q2<span class="main">:</span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R2</span> <span class="free">Abs2</span> <span class="free">Rep2</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>tllist_all2 <span class="main">(</span><span class="main">(</span><span class="free">Rep1</span> <span class="main">---&gt;</span> <span class="free">Rep1</span> <span class="main">---&gt;</span> id<span class="main">)</span> <span class="free">R1</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="free">Rep2</span> <span class="main">---&gt;</span> <span class="free">Rep2</span> <span class="main">---&gt;</span> id<span class="main">)</span> <span class="free">R2</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(=)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff map_fun_def comp_def Quotient3_rel_rep<span class="main"><span class="main">[</span></span><span class="operator">OF</span> q1<span class="main"><span class="main">]</span></span> Quotient3_rel_rep<span class="main"><span class="main">[</span></span><span class="operator">OF</span> q2<span class="main"><span class="main">]</span></span>
    tllist_all2_eq<span class="main">)</span>

<span class="keyword1" id="Quotient_TLList-corec_tllist_preserve"><span class="command">lemma</span></span> corec_tllist_preserve <span class="main">[</span><span class="operator">quot_preserve</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> q1<span class="main">:</span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R1</span> <span class="free">Abs1</span> <span class="free">Rep1</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> q2<span class="main">:</span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R2</span> <span class="free">Abs2</span> <span class="free">Rep2</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> q3<span class="main">:</span> <span class="quoted"><span class="quoted">"Quotient3 <span class="free">R3</span> <span class="free">Abs3</span> <span class="free">Rep3</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">Abs1</span> <span class="main">---&gt;</span> id<span class="main">)</span> <span class="main">---&gt;</span> <span class="main">(</span><span class="free">Abs1</span> <span class="main">---&gt;</span> <span class="free">Rep2</span><span class="main">)</span> <span class="main">---&gt;</span> <span class="main">(</span><span class="free">Abs1</span> <span class="main">---&gt;</span> <span class="free">Rep3</span><span class="main">)</span> <span class="main">---&gt;</span> <span class="main">(</span><span class="free">Abs1</span> <span class="main">---&gt;</span> id<span class="main">)</span> <span class="main">---&gt;</span> <span class="main">(</span><span class="free">Abs1</span> <span class="main">---&gt;</span> tmap <span class="free">Rep3</span> <span class="free">Rep2</span><span class="main">)</span> <span class="main">---&gt;</span> <span class="main">(</span><span class="free">Abs1</span> <span class="main">---&gt;</span> <span class="free">Rep1</span><span class="main">)</span> <span class="main">---&gt;</span> <span class="free">Rep1</span> <span class="main">---&gt;</span> tmap <span class="free">Abs3</span> <span class="free">Abs2</span><span class="main">)</span> corec_tllist <span class="main">=</span> corec_tllist"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">intro</span> ext<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">IS_TNIL</span> <span class="skolem">TNIL</span> <span class="skolem">THD</span> <span class="skolem">endORmore</span> <span class="skolem">TTL_end</span> <span class="skolem">TTL_more</span> <span class="skolem">b</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="skolem">IS_TNIL</span> <span class="skolem">TNIL</span> <span class="skolem">THD</span> <span class="skolem">endORmore</span> <span class="skolem">TTL_end</span> <span class="skolem">TTL_more</span> <span class="skolem">b</span> <span class="main">=</span> <span class="var">?rhs</span> <span class="skolem">IS_TNIL</span> <span class="skolem">TNIL</span> <span class="skolem">THD</span> <span class="skolem">endORmore</span> <span class="skolem">TTL_end</span> <span class="skolem">TTL_more</span> <span class="skolem">b</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">b</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> tllist.coinduct_strong<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Quotient3_abs_rep<span class="main"><span class="main">[</span></span><span class="operator">OF</span> q1<span class="main"><span class="main">]</span></span> Quotient3_abs_rep<span class="main"><span class="main">[</span></span><span class="operator">OF</span> q2<span class="main"><span class="main">]</span></span> Quotient3_abs_rep<span class="main"><span class="main">[</span></span><span class="operator">OF</span> q3<span class="main"><span class="main">]</span></span> Quotient3_tmap_Abs_Rep<span class="main"><span class="main">[</span></span><span class="operator">OF</span> q3 q2<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Coinductive">
<div class="head">
<h1>Theory Coinductive</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Coinductive developments in Isabelle/HOL
    Author:      Andreas Lochbihler
    Maintainer:  Andreas Lochbihler
*)</span>
<span class="keyword1"><span class="command">theory</span></span> Coinductive <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="#Coinductive_List_Prefix">Coinductive_List_Prefix</a>
  <a href="#Coinductive_Stream">Coinductive_Stream</a>
  <a href="#TLList">TLList</a>
  <a href="#Quotient_Coinductive_List">Quotient_Coinductive_List</a>
  <a href="#Quotient_TLList">Quotient_TLList</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Lazy_LList">
<div class="head">
<h1>Theory Lazy_LList</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Lazy_LList.thy
    Author:      Andreas Lochbihler
*)</span>
<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Code generator setup to implement lazy lists lazily›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Lazy_LList <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="#Coinductive_List">Coinductive_List</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Lazy lists›</span></span>

<span class="keyword1"><span class="command">code_identifier</span></span> <span class="keyword2"><span class="keyword">code_module</span></span> Lazy_LList <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> Coinductive_List <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> Coinductive_List <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> Coinductive_List <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> Coinductive_List

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Lazy_llist</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>unit <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span> llist<span class="main">)</span> option<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> llist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">Lazy_llist</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">()</span> <span class="keyword1">of</span> None <span class="main">⇒</span> LNil <span class="main">|</span> Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">⇒</span> LCons <span class="bound">x</span> <span class="bound">ys</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">force</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span> llist<span class="main">)</span> option"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">force</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">of</span> LNil <span class="main">⇒</span> None <span class="main">|</span> LCons <span class="bound">x</span> <span class="bound">ys</span> <span class="main">⇒</span> Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">ys</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">code_datatype</span></span> <span class="quoted">Lazy_llist</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="comment1">― ‹Restore consistency in code equations between <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> partial_term_of<span class="antiquote">}</span></span> and <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> narrowing<span class="antiquote">}</span></span> for <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"<span class="tfree">'a</span> llist"</span><span class="antiquote">}</span></span>›</span>
   <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">"partial_term_of <span class="main">::</span> <span class="main">_</span> llist itself <span class="main">=&gt;</span> <span class="main">_</span>"</span></span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_LList-partial_term_of_llist_code"><span class="command">lemma</span></span> partial_term_of_llist_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">tytok</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> partial_term_of llist itself"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"partial_term_of <span class="free">tytok</span> <span class="main">(</span>Quickcheck_Narrowing.Narrowing_variable <span class="free">p</span> <span class="free">tt</span><span class="main">)</span> <span class="main">≡</span>
   Code_Evaluation.Free <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''_''</span><span class="main">)</span> <span class="main">(</span>Typerep.typerep <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span> llist<span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"partial_term_of <span class="free">tytok</span> <span class="main">(</span>Quickcheck_Narrowing.Narrowing_constructor <span class="main">0</span> <span class="main">[]</span><span class="main">)</span> <span class="main">≡</span>
   Code_Evaluation.Const <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Coinductive_List.llist.LNil''</span><span class="main">)</span> <span class="main">(</span>Typerep.typerep <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span> llist<span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"partial_term_of <span class="free">tytok</span> <span class="main">(</span>Quickcheck_Narrowing.Narrowing_constructor <span class="main">1</span> <span class="main">[</span><span class="free">head</span><span class="main">,</span> <span class="free">tail</span><span class="main">]</span><span class="main">)</span> <span class="main">≡</span>
   Code_Evaluation.App
     <span class="main">(</span>Code_Evaluation.App
        <span class="main">(</span>Code_Evaluation.Const
           <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Coinductive_List.llist.LCons''</span><span class="main">)</span>
           <span class="main">(</span>Typerep.typerep <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> llist <span class="main">⇒</span> <span class="tfree">'a</span> llist<span class="main">)</span><span class="main">)</span><span class="main">)</span>
        <span class="main">(</span>partial_term_of <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="free">head</span><span class="main">)</span><span class="main">)</span>
     <span class="main">(</span>partial_term_of <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span> llist<span class="main">)</span> <span class="free">tail</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="operator">-</span><span class="main">(</span><span class="operator">rule</span> partial_term_of_anything<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">declare</span></span> option.splits <span class="main">[</span><span class="operator">split</span><span class="main">]</span>

<span class="keyword1" id="Lazy_LList-Lazy_llist_inject"><span class="command">lemma</span></span> Lazy_llist_inject <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Lazy_llist <span class="free">xs</span> <span class="main">=</span> Lazy_llist <span class="free">ys</span> <span class="main">⟷</span> <span class="free">xs</span> <span class="main">=</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>

<span class="keyword1" id="Lazy_LList-Lazy_llist_inverse"><span class="command">lemma</span></span> Lazy_llist_inverse <span class="main">[</span><span class="operator">code</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"force <span class="main">(</span>Lazy_llist <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">xs</span> <span class="main">()</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="Lazy_LList-force_inverse"><span class="command">lemma</span></span> force_inverse <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Lazy_llist <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> force <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split<span class="main">)</span>

<span class="keyword1" id="Lazy_LList-LNil_Lazy_llist"><span class="command">lemma</span></span> LNil_Lazy_llist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"LNil <span class="main">=</span> Lazy_llist <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> None<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Lazy_LList-LCons_Lazy_llist"><span class="command">lemma</span></span> LCons_Lazy_llist <span class="main">[</span><span class="operator">code</span><span class="main">,</span> <span class="operator">code_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"LCons <span class="free">x</span> <span class="free">xs</span> <span class="main">=</span> Lazy_llist <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Some <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Lazy_LList-lnull_lazy"><span class="command">lemma</span></span> lnull_lazy <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lnull <span class="main">=</span> Option.is_none <span class="main">∘</span> force"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> lnull_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Option.is_none_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">"equal_class.equal <span class="main">::</span> <span class="tfree">'a</span> <span class="main">::</span> equal llist <span class="main">⇒</span> <span class="main">_</span>"</span></span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_LList-equal_llist_Lazy_llist"><span class="command">lemma</span></span> equal_llist_Lazy_llist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"equal_class.equal <span class="main">(</span>Lazy_llist <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>Lazy_llist <span class="free">ys</span><span class="main">)</span> <span class="main">⟷</span>
   <span class="main">(</span><span class="keyword1">case</span> <span class="free">xs</span> <span class="main">()</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">ys</span> <span class="main">()</span> <span class="keyword1">of</span> None <span class="main">⇒</span> True <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> False<span class="main">)</span>
    <span class="main">|</span> Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">xs'</span><span class="main">)</span> <span class="main">⇒</span> 
       <span class="main">(</span><span class="keyword1">case</span> <span class="free">ys</span> <span class="main">()</span> <span class="keyword1">of</span> None <span class="main">⇒</span> False 
        <span class="main">|</span> Some <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">ys'</span><span class="main">)</span> <span class="main">⇒</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">y</span> <span class="keyword1">then</span> equal_class.equal <span class="bound">xs'</span> <span class="bound">ys'</span> <span class="keyword1">else</span> False<span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> equal_llist_def<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">corec_llist</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_LList-corec_llist_Lazy_llist"><span class="command">lemma</span></span> corec_llist_Lazy_llist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"corec_llist <span class="free">IS_LNIL</span> <span class="free">LHD</span> <span class="free">endORmore</span> <span class="free">LTL_end</span> <span class="free">LTL_more</span> <span class="free">b</span> <span class="main">=</span>
  Lazy_llist <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="keyword1">if</span> <span class="free">IS_LNIL</span> <span class="free">b</span> <span class="keyword1">then</span> None 
     <span class="keyword1">else</span> Some <span class="main">(</span><span class="free">LHD</span> <span class="free">b</span><span class="main">,</span>
       <span class="keyword1">if</span> <span class="free">endORmore</span> <span class="free">b</span> <span class="keyword1">then</span> <span class="free">LTL_end</span> <span class="free">b</span>
       <span class="keyword1">else</span> corec_llist <span class="free">IS_LNIL</span> <span class="free">LHD</span> <span class="free">endORmore</span> <span class="free">LTL_end</span> <span class="free">LTL_more</span> <span class="main">(</span><span class="free">LTL_more</span> <span class="free">b</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> llist.corec_code<span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">unfold_llist</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_LList-unfold_llist_Lazy_llist"><span class="command">lemma</span></span> unfold_llist_Lazy_llist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"unfold_llist <span class="free">IS_LNIL</span> <span class="free">LHD</span> <span class="free">LTL</span> <span class="free">b</span> <span class="main">=</span>
  Lazy_llist <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="keyword1">if</span> <span class="free">IS_LNIL</span> <span class="free">b</span> <span class="keyword1">then</span> None <span class="keyword1">else</span> Some <span class="main">(</span><span class="free">LHD</span> <span class="free">b</span><span class="main">,</span> unfold_llist <span class="free">IS_LNIL</span> <span class="free">LHD</span> <span class="free">LTL</span> <span class="main">(</span><span class="free">LTL</span> <span class="free">b</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> unfold_llist.code<span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">case_llist</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_LList-case_llist_Lazy_llist"><span class="command">lemma</span></span> case_llist_Lazy_llist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"case_llist <span class="free">n</span> <span class="free">c</span> <span class="main">(</span>Lazy_llist <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">xs</span> <span class="main">()</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="free">n</span> <span class="main">|</span> Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">⇒</span> <span class="free">c</span> <span class="bound">x</span> <span class="bound">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">lappend</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_LList-lappend_Lazy_llist"><span class="command">lemma</span></span> lappend_Lazy_llist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lappend <span class="main">(</span>Lazy_llist <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span> <span class="main">=</span> 
  Lazy_llist <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="keyword1">case</span> <span class="free">xs</span> <span class="main">()</span> <span class="keyword1">of</span> None <span class="main">⇒</span> force <span class="free">ys</span> <span class="main">|</span> Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">xs'</span><span class="main">)</span> <span class="main">⇒</span> Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span> lappend <span class="bound">xs'</span> <span class="free">ys</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.splits<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">lmap</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_LList-lmap_Lazy_llist"><span class="command">lemma</span></span> lmap_Lazy_llist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lmap <span class="free">f</span> <span class="main">(</span>Lazy_llist <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> Lazy_llist <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> map_option <span class="main">(</span>map_prod <span class="free">f</span> <span class="main">(</span>lmap <span class="free">f</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">xs</span> <span class="main">()</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">lfinite</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_LList-lfinite_Lazy_llist"><span class="command">lemma</span></span> lfinite_Lazy_llist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>Lazy_llist <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">xs</span> <span class="main">()</span> <span class="keyword1">of</span> None <span class="main">⇒</span> True <span class="main">|</span> Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">⇒</span> lfinite <span class="bound">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">list_of_aux</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_LList-list_of_aux_Lazy_llist"><span class="command">lemma</span></span> list_of_aux_Lazy_llist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"list_of_aux <span class="free">xs</span> <span class="main">(</span>Lazy_llist <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">case</span> <span class="free">ys</span> <span class="main">()</span> <span class="keyword1">of</span> None <span class="main">⇒</span> rev <span class="free">xs</span> <span class="main">|</span> Some <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">⇒</span> list_of_aux <span class="main">(</span><span class="bound">y</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="bound">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list_of_aux_code<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">gen_llength</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_LList-gen_llength_Lazy_llist"><span class="command">lemma</span></span> gen_llength_Lazy_llist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"gen_llength <span class="free">n</span> <span class="main">(</span>Lazy_llist <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">xs</span> <span class="main">()</span> <span class="keyword1">of</span> None <span class="main">⇒</span> enat <span class="free">n</span> <span class="main">|</span> Some <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">⇒</span> gen_llength <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="bound">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gen_llength_code<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">ltake</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_LList-ltake_Lazy_llist"><span class="command">lemma</span></span> ltake_Lazy_llist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"ltake <span class="free">n</span> <span class="main">(</span>Lazy_llist <span class="free">xs</span><span class="main">)</span> <span class="main">=</span>
  Lazy_llist <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="keyword1">if</span> <span class="free">n</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> None <span class="keyword1">else</span> <span class="keyword1">case</span> <span class="free">xs</span> <span class="main">()</span> <span class="keyword1">of</span> None <span class="main">⇒</span> None <span class="main">|</span> Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">⇒</span> Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span> ltake <span class="main">(</span><span class="free">n</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="bound">ys</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_coexhaust<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">ldropn</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_LList-ldropn_Lazy_llist"><span class="command">lemma</span></span> ldropn_Lazy_llist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"ldropn <span class="free">n</span> <span class="main">(</span>Lazy_llist <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> 
   Lazy_llist <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="keyword1">if</span> <span class="free">n</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="free">xs</span> <span class="main">()</span> <span class="keyword1">else</span>
                   <span class="keyword1">case</span> <span class="free">xs</span> <span class="main">()</span> <span class="keyword1">of</span> None <span class="main">⇒</span> None <span class="main">|</span> Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">⇒</span> force <span class="main">(</span>ldropn <span class="main">(</span><span class="free">n</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="bound">ys</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eSuc_enat<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">ltakeWhile</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_LList-ltakeWhile_Lazy_llist"><span class="command">lemma</span></span> ltakeWhile_Lazy_llist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"ltakeWhile <span class="free">P</span> <span class="main">(</span>Lazy_llist <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> 
  Lazy_llist <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="keyword1">case</span> <span class="free">xs</span> <span class="main">()</span> <span class="keyword1">of</span> None <span class="main">⇒</span> None <span class="main">|</span> Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">⇒</span> <span class="keyword1">if</span> <span class="free">P</span> <span class="bound">x</span> <span class="keyword1">then</span> Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span> ltakeWhile <span class="free">P</span> <span class="bound">ys</span><span class="main">)</span> <span class="keyword1">else</span> None<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">ldropWhile</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_LList-ldropWhile_Lazy_llist"><span class="command">lemma</span></span> ldropWhile_Lazy_llist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"ldropWhile <span class="free">P</span> <span class="main">(</span>Lazy_llist <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> 
   Lazy_llist <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="keyword1">case</span> <span class="free">xs</span> <span class="main">()</span> <span class="keyword1">of</span> None <span class="main">⇒</span> None <span class="main">|</span> Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">⇒</span> <span class="keyword1">if</span> <span class="free">P</span> <span class="bound">x</span> <span class="keyword1">then</span> force <span class="main">(</span>ldropWhile <span class="free">P</span> <span class="bound">ys</span><span class="main">)</span> <span class="keyword1">else</span> Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">ys</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">lzip</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_LList-lzip_Lazy_llist"><span class="command">lemma</span></span> lzip_Lazy_llist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lzip <span class="main">(</span>Lazy_llist <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>Lazy_llist <span class="free">ys</span><span class="main">)</span> <span class="main">=</span>
  Lazy_llist <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Option.bind <span class="main">(</span><span class="free">xs</span> <span class="main">()</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">xs'</span><span class="main">)</span><span class="main">.</span> map_option <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">ys'</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">,</span> lzip <span class="bound">xs'</span> <span class="bound">ys'</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">ys</span> <span class="main">()</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">gen_lset</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_LList-lset_Lazy_llist"><span class="command">lemma</span></span> lset_Lazy_llist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"gen_lset <span class="free">A</span> <span class="main">(</span>Lazy_llist <span class="free">xs</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> <span class="free">xs</span> <span class="main">()</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="free">A</span> <span class="main">|</span> Some <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">⇒</span> gen_lset <span class="main">(</span>insert <span class="bound">y</span> <span class="free">A</span><span class="main">)</span> <span class="bound">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gen_lset_code<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">lmember</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_LList-lmember_Lazy_llist"><span class="command">lemma</span></span> lmember_Lazy_llist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"lmember <span class="free">x</span> <span class="main">(</span>Lazy_llist <span class="free">xs</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> <span class="free">xs</span> <span class="main">()</span> <span class="keyword1">of</span> None <span class="main">⇒</span> False <span class="main">|</span> Some <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">⇒</span> <span class="free">x</span> <span class="main">=</span> <span class="bound">y</span> <span class="main">∨</span> lmember <span class="free">x</span> <span class="bound">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lmember_def<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">llist_all2</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_LList-llist_all2_Lazy_llist"><span class="command">lemma</span></span> llist_all2_Lazy_llist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"llist_all2 <span class="free">P</span> <span class="main">(</span>Lazy_llist <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>Lazy_llist <span class="free">ys</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> <span class="free">xs</span> <span class="main">()</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="free">ys</span> <span class="main">()</span> <span class="main">=</span> None 
      <span class="main">|</span> Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">xs'</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">ys</span> <span class="main">()</span> <span class="keyword1">of</span> None <span class="main">⇒</span> False 
                            <span class="main">|</span> Some <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">ys'</span><span class="main">)</span> <span class="main">⇒</span> <span class="free">P</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">∧</span> llist_all2 <span class="free">P</span> <span class="bound">xs'</span> <span class="bound">ys'</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">lhd</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_LList-lhd_Lazy_llist"><span class="command">lemma</span></span> lhd_Lazy_llist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lhd <span class="main">(</span>Lazy_llist <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">xs</span> <span class="main">()</span> <span class="keyword1">of</span> None <span class="main">⇒</span> undefined <span class="main">|</span> Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">xs'</span><span class="main">)</span> <span class="main">⇒</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lhd_def<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">ltl</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_LList-ltl_Lazy_llist"><span class="command">lemma</span></span> ltl_Lazy_llist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"ltl <span class="main">(</span>Lazy_llist <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> Lazy_llist <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="keyword1">case</span> <span class="free">xs</span> <span class="main">()</span> <span class="keyword1">of</span> None <span class="main">⇒</span> None <span class="main">|</span> Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">⇒</span> force <span class="bound">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">llast</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_LList-llast_Lazy_llist"><span class="command">lemma</span></span> llast_Lazy_llist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"llast <span class="main">(</span>Lazy_llist <span class="free">xs</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> <span class="free">xs</span> <span class="main">()</span> <span class="keyword1">of</span> 
    None <span class="main">⇒</span> undefined 
  <span class="main">|</span> Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">xs'</span><span class="main">)</span> <span class="main">⇒</span> 
    <span class="main">(</span><span class="keyword1">case</span> force <span class="bound">xs'</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="bound">x</span> <span class="main">|</span> Some <span class="main">(</span><span class="bound">x'</span><span class="main">,</span> <span class="bound">xs''</span><span class="main">)</span> <span class="main">⇒</span> llast <span class="main">(</span>LCons <span class="bound">x'</span> <span class="bound">xs''</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llast_def zero_enat_def eSuc_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> enat.split llist.splits<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">ldistinct</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_LList-ldistinct_Lazy_llist"><span class="command">lemma</span></span> ldistinct_Lazy_llist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"ldistinct <span class="main">(</span>Lazy_llist <span class="free">xs</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> <span class="free">xs</span> <span class="main">()</span> <span class="keyword1">of</span> None <span class="main">⇒</span> True <span class="main">|</span> Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">⇒</span> <span class="bound">x</span> <span class="main">∉</span> lset <span class="bound">ys</span> <span class="main">∧</span> ldistinct <span class="bound">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">lprefix</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_LList-lprefix_Lazy_llist"><span class="command">lemma</span></span> lprefix_Lazy_llist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lprefix <span class="main">(</span>Lazy_llist <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>Lazy_llist <span class="free">ys</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> <span class="free">xs</span> <span class="main">()</span> <span class="keyword1">of</span> 
    None <span class="main">⇒</span> True
  <span class="main">|</span> Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">xs'</span><span class="main">)</span> <span class="main">⇒</span> 
    <span class="main">(</span><span class="keyword1">case</span> <span class="free">ys</span> <span class="main">()</span> <span class="keyword1">of</span> None <span class="main">⇒</span> False <span class="main">|</span> Some <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">ys'</span><span class="main">)</span> <span class="main">⇒</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">y</span> <span class="main">∧</span> lprefix <span class="bound">xs'</span> <span class="bound">ys'</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">lstrict_prefix</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_LList-lstrict_prefix_Lazy_llist"><span class="command">lemma</span></span> lstrict_prefix_Lazy_llist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lstrict_prefix <span class="main">(</span>Lazy_llist <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>Lazy_llist <span class="free">ys</span><span class="main">)</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="keyword1">case</span> <span class="free">ys</span> <span class="main">()</span> <span class="keyword1">of</span>
    None <span class="main">⇒</span> False 
  <span class="main">|</span> Some <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">ys'</span><span class="main">)</span> <span class="main">⇒</span> 
    <span class="main">(</span><span class="keyword1">case</span> <span class="free">xs</span> <span class="main">()</span> <span class="keyword1">of</span> None <span class="main">⇒</span> True <span class="main">|</span> Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">xs'</span><span class="main">)</span> <span class="main">⇒</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">y</span> <span class="main">∧</span> lstrict_prefix <span class="bound">xs'</span> <span class="bound">ys'</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">llcp</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_LList-llcp_Lazy_llist"><span class="command">lemma</span></span> llcp_Lazy_llist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"llcp <span class="main">(</span>Lazy_llist <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>Lazy_llist <span class="free">ys</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> <span class="free">xs</span> <span class="main">()</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="main">0</span> 
   <span class="main">|</span> Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">xs'</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">ys</span> <span class="main">()</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="main">0</span>
                     <span class="main">|</span> Some <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">ys'</span><span class="main">)</span> <span class="main">⇒</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">y</span> <span class="keyword1">then</span> eSuc <span class="main">(</span>llcp <span class="bound">xs'</span> <span class="bound">ys'</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">llexord</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_LList-llexord_Lazy_llist"><span class="command">lemma</span></span> llexord_Lazy_llist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"llexord <span class="free">r</span> <span class="main">(</span>Lazy_llist <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>Lazy_llist <span class="free">ys</span><span class="main">)</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="keyword1">case</span> <span class="free">xs</span> <span class="main">()</span> <span class="keyword1">of</span> 
    None <span class="main">⇒</span> True 
  <span class="main">|</span> Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">xs'</span><span class="main">)</span> <span class="main">⇒</span> 
    <span class="main">(</span><span class="keyword1">case</span> <span class="free">ys</span> <span class="main">()</span> <span class="keyword1">of</span> None <span class="main">⇒</span> False <span class="main">|</span> Some <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">ys'</span><span class="main">)</span> <span class="main">⇒</span> <span class="free">r</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">∨</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">y</span> <span class="main">∧</span> llexord <span class="free">r</span> <span class="bound">xs'</span> <span class="bound">ys'</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">lfilter</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_LList-lfilter_Lazy_llist"><span class="command">lemma</span></span> lfilter_Lazy_llist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lfilter <span class="free">P</span> <span class="main">(</span>Lazy_llist <span class="free">xs</span><span class="main">)</span> <span class="main">=</span>
  Lazy_llist <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="keyword1">case</span> <span class="free">xs</span> <span class="main">()</span> <span class="keyword1">of</span> None <span class="main">⇒</span> None 
                  <span class="main">|</span> Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">⇒</span> <span class="keyword1">if</span> <span class="free">P</span> <span class="bound">x</span> <span class="keyword1">then</span> Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span> lfilter <span class="free">P</span> <span class="bound">ys</span><span class="main">)</span> <span class="keyword1">else</span> force <span class="main">(</span>lfilter <span class="free">P</span> <span class="bound">ys</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">lconcat</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_LList-lconcat_Lazy_llist"><span class="command">lemma</span></span> lconcat_Lazy_llist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lconcat <span class="main">(</span>Lazy_llist <span class="free">xss</span><span class="main">)</span> <span class="main">=</span>
  Lazy_llist <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="keyword1">case</span> <span class="free">xss</span> <span class="main">()</span> <span class="keyword1">of</span> None <span class="main">⇒</span> None <span class="main">|</span> Some <span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="bound">xss'</span><span class="main">)</span> <span class="main">⇒</span> force <span class="main">(</span>lappend <span class="bound">xs</span> <span class="main">(</span>lconcat <span class="bound">xss'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> option.splits <span class="main">[</span><span class="operator">split</span> <span class="quasi_keyword"><span class="quasi_keyword">del</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> Lazy_llist_def <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Simple ML test for laziness›</span></span>

<span class="keyword1"><span class="command">ML_val</span></span> <span class="quoted">‹
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">zeros</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">iterates</span><span class="antiquote">}</span></span></span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="entity">x</span> + <span class="inner_numeral">1</span><span class="main">)</span> <span class="inner_numeral">0</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhd</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">lhd</span><span class="antiquote">}</span></span></span> <span class="entity">zeros</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ltl</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">ltl</span><span class="antiquote">}</span></span></span> <span class="entity">zeros</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ltl'</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">force</span><span class="antiquote">}</span></span></span> <span class="entity">ltl</span><span class="main">;</span>
  
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ltake</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">ltake</span><span class="antiquote">}</span></span></span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">eSuc</span><span class="antiquote">}</span></span></span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">eSuc</span><span class="antiquote">}</span></span></span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">"<span class="main">0</span><span class="main">::</span>enat"</span><span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">)</span> <span class="entity">zeros</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ldrop</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">ldrop</span><span class="antiquote">}</span></span></span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">eSuc</span><span class="antiquote">}</span></span></span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">"<span class="main">0</span><span class="main">::</span>enat"</span><span class="antiquote">}</span></span></span><span class="main">)</span> <span class="entity">zeros</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">list_of</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">list_of</span><span class="antiquote">}</span></span></span> <span class="entity">ltake</span><span class="main">;</span>
  
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ltakeWhile</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">ltakeWhile</span><span class="antiquote">}</span></span></span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> true<span class="main">)</span> <span class="entity">zeros</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ldropWhile</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">ldropWhile</span><span class="antiquote">}</span></span></span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> false<span class="main">)</span> <span class="entity">zeros</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">hd</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">lhd</span><span class="antiquote">}</span></span></span> <span class="entity">ldropWhile</span><span class="main">;</span>
  
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lfilter</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">lfilter</span><span class="antiquote">}</span></span></span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> false<span class="main">)</span> <span class="entity">zeros</span><span class="main">;</span>
›</span>

<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> force

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Lazy_TLList">
<div class="head">
<h1>Theory Lazy_TLList</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Lazy_TLList.thy
    Author:      Andreas Lochbihler
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Code generator setup to implement terminated lazy lists lazily›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Lazy_TLList <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="#TLList">TLList</a>
  <a href="#Lazy_LList">Lazy_LList</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">code_identifier</span></span> <span class="keyword2"><span class="keyword">code_module</span></span> Lazy_TLList <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> TLList <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> TLList <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> TLList <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> TLList

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Lazy_tllist</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>unit <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">×</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist <span class="main">+</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">Lazy_tllist</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">()</span> <span class="keyword1">of</span> Inl <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">⇒</span> TCons <span class="bound">x</span> <span class="bound">ys</span> <span class="main">|</span> Inr <span class="bound">b</span> <span class="main">⇒</span> TNil <span class="bound">b</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">force</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">×</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist <span class="main">+</span> <span class="tfree">'b</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">force</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">of</span> TNil <span class="bound">b</span> <span class="main">⇒</span> Inr <span class="bound">b</span> <span class="main">|</span> TCons <span class="bound">x</span> <span class="bound">ys</span> <span class="main">⇒</span> Inl <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">ys</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">code_datatype</span></span> <span class="quoted">Lazy_tllist</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="comment1">― ‹Restore consistency in code equations between <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> partial_term_of<span class="antiquote">}</span></span> and <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> narrowing<span class="antiquote">}</span></span> for <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist"</span><span class="antiquote">}</span></span>›</span>
   <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">"partial_term_of <span class="main">::</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> tllist itself <span class="main">=&gt;</span> <span class="main">_</span>"</span></span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_TLList-partial_term_of_tllist_code"><span class="command">lemma</span></span> partial_term_of_tllist_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">tytok</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> partial_term_of<span class="main">,</span> <span class="tfree">'b</span> <span class="main">::</span> partial_term_of<span class="main">)</span> tllist itself"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"partial_term_of <span class="free">tytok</span> <span class="main">(</span>Quickcheck_Narrowing.Narrowing_variable <span class="free">p</span> <span class="free">tt</span><span class="main">)</span> <span class="main">≡</span>
   Code_Evaluation.Free <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''_''</span><span class="main">)</span> <span class="main">(</span>Typerep.typerep <span class="keyword1">TYPE</span><span class="main">(</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist<span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"partial_term_of <span class="free">tytok</span> <span class="main">(</span>Quickcheck_Narrowing.Narrowing_constructor <span class="main">0</span> <span class="main">[</span><span class="free">b</span><span class="main">]</span><span class="main">)</span> <span class="main">≡</span>
   Code_Evaluation.App
     <span class="main">(</span>Code_Evaluation.Const <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''TLList.tllist.TNil''</span><span class="main">)</span> <span class="main">(</span>Typerep.typerep <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist<span class="main">)</span><span class="main">)</span><span class="main">)</span>
     <span class="main">(</span>partial_term_of <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="free">b</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"partial_term_of <span class="free">tytok</span> <span class="main">(</span>Quickcheck_Narrowing.Narrowing_constructor <span class="main">1</span> <span class="main">[</span><span class="free">head</span><span class="main">,</span> <span class="free">tail</span><span class="main">]</span><span class="main">)</span> <span class="main">≡</span>
   Code_Evaluation.App
     <span class="main">(</span>Code_Evaluation.App
        <span class="main">(</span>Code_Evaluation.Const
           <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''TLList.tllist.TCons''</span><span class="main">)</span>
           <span class="main">(</span>Typerep.typerep <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist<span class="main">)</span><span class="main">)</span><span class="main">)</span>
        <span class="main">(</span>partial_term_of <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="free">head</span><span class="main">)</span><span class="main">)</span>
     <span class="main">(</span>partial_term_of <span class="keyword1">TYPE</span><span class="main">(</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist<span class="main">)</span> <span class="free">tail</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="operator">-</span><span class="main">(</span><span class="operator">rule</span> partial_term_of_anything<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">declare</span></span> Lazy_tllist_def <span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> sum.splits <span class="main">[</span><span class="operator">split</span><span class="main">]</span>

<span class="keyword1" id="Lazy_TLList-TNil_Lazy_tllist"><span class="command">lemma</span></span> TNil_Lazy_tllist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"TNil <span class="free">b</span> <span class="main">=</span> Lazy_tllist <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Inr <span class="free">b</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Lazy_TLList-TCons_Lazy_tllist"><span class="command">lemma</span></span> TCons_Lazy_tllist <span class="main">[</span><span class="operator">code</span><span class="main">,</span> <span class="operator">code_unfold</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"TCons <span class="free">x</span> <span class="free">xs</span> <span class="main">=</span> Lazy_tllist <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Inl <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Lazy_TLList-Lazy_tllist_inverse"><span class="command">lemma</span></span> Lazy_tllist_inverse <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"force <span class="main">(</span>Lazy_tllist <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">xs</span> <span class="main">()</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">"equal_class.equal <span class="main">::</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> tllist <span class="main">⇒</span> <span class="main">_</span>"</span></span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_TLList-equal_tllist_Lazy_tllist"><span class="command">lemma</span></span> equal_tllist_Lazy_tllist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"equal_class.equal <span class="main">(</span>Lazy_tllist <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>Lazy_tllist <span class="free">ys</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> <span class="free">xs</span> <span class="main">()</span> <span class="keyword1">of</span> 
     Inr <span class="bound">b</span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">ys</span> <span class="main">()</span> <span class="keyword1">of</span> Inr <span class="bound">b'</span> <span class="main">⇒</span> <span class="bound">b</span> <span class="main">=</span> <span class="bound">b'</span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> False<span class="main">)</span>
   <span class="main">|</span> Inl <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">xs'</span><span class="main">)</span> <span class="main">⇒</span>
     <span class="main">(</span><span class="keyword1">case</span> <span class="free">ys</span> <span class="main">()</span> <span class="keyword1">of</span> Inr <span class="bound">b'</span> <span class="main">⇒</span> False <span class="main">|</span> Inl <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">ys'</span><span class="main">)</span> <span class="main">⇒</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">y</span> <span class="keyword1">then</span> equal_class.equal <span class="bound">xs'</span> <span class="bound">ys'</span> <span class="keyword1">else</span> False<span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> equal_tllist_def<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span>
  <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">thd</span> <span class="quoted">ttl</span><span class="main">]</span><span class="main">]</span>
  thd_def <span class="main">[</span><span class="operator">code</span><span class="main">]</span>
  ttl_def <span class="main">[</span><span class="operator">code</span><span class="main">]</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">is_TNil</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_TLList-is_TNil_code"><span class="command">lemma</span></span> is_TNil_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"is_TNil <span class="main">(</span>Lazy_tllist <span class="free">xs</span><span class="main">)</span> <span class="main">⟷</span> 
  <span class="main">(</span><span class="keyword1">case</span> <span class="free">xs</span> <span class="main">()</span> <span class="keyword1">of</span> Inl <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> False <span class="main">|</span> Inr <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> True<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">corec_tllist</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_TLList-corec_tllist_Lazy_tllist"><span class="command">lemma</span></span> corec_tllist_Lazy_tllist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"corec_tllist <span class="free">IS_TNIL</span> <span class="free">TNIL</span> <span class="free">THD</span> <span class="free">endORmore</span> <span class="free">TTL_end</span> <span class="free">TTL_more</span> <span class="free">b</span> <span class="main">=</span> Lazy_tllist
  <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="keyword1">if</span> <span class="free">IS_TNIL</span> <span class="free">b</span> <span class="keyword1">then</span> Inr <span class="main">(</span><span class="free">TNIL</span> <span class="free">b</span><span class="main">)</span>
       <span class="keyword1">else</span> Inl <span class="main">(</span><span class="free">THD</span> <span class="free">b</span><span class="main">,</span> <span class="keyword1">if</span> <span class="free">endORmore</span> <span class="free">b</span> <span class="keyword1">then</span> <span class="free">TTL_end</span> <span class="free">b</span> <span class="keyword1">else</span> corec_tllist <span class="free">IS_TNIL</span> <span class="free">TNIL</span> <span class="free">THD</span> <span class="free">endORmore</span> <span class="free">TTL_end</span> <span class="free">TTL_more</span> <span class="main">(</span><span class="free">TTL_more</span> <span class="free">b</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> tllist.expand<span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">unfold_tllist</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_TLList-unfold_tllist_Lazy_tllist"><span class="command">lemma</span></span> unfold_tllist_Lazy_tllist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"unfold_tllist <span class="free">IS_TNIL</span> <span class="free">TNIL</span> <span class="free">THD</span> <span class="free">TTL</span> <span class="free">b</span> <span class="main">=</span> Lazy_tllist
  <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="keyword1">if</span> <span class="free">IS_TNIL</span> <span class="free">b</span> <span class="keyword1">then</span> Inr <span class="main">(</span><span class="free">TNIL</span> <span class="free">b</span><span class="main">)</span>
       <span class="keyword1">else</span> Inl <span class="main">(</span><span class="free">THD</span> <span class="free">b</span><span class="main">,</span> unfold_tllist <span class="free">IS_TNIL</span> <span class="free">TNIL</span> <span class="free">THD</span> <span class="free">TTL</span> <span class="main">(</span><span class="free">TTL</span> <span class="free">b</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> tllist.expand<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">case_tllist</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_TLList-case_tllist_Lazy_tllist"><span class="command">lemma</span></span> case_tllist_Lazy_tllist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"case_tllist <span class="free">n</span> <span class="free">c</span> <span class="main">(</span>Lazy_tllist <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">case</span> <span class="free">xs</span> <span class="main">()</span> <span class="keyword1">of</span> Inl <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">⇒</span> <span class="free">c</span> <span class="bound">x</span> <span class="bound">ys</span> <span class="main">|</span> Inr <span class="bound">b</span> <span class="main">⇒</span> <span class="free">n</span> <span class="bound">b</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">tllist_of_llist</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_TLList-tllist_of_llist_Lazy_llist"><span class="command">lemma</span></span> tllist_of_llist_Lazy_llist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"tllist_of_llist <span class="free">b</span> <span class="main">(</span>Lazy_llist <span class="free">xs</span><span class="main">)</span> <span class="main">=</span>
  Lazy_tllist <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="keyword1">case</span> <span class="free">xs</span> <span class="main">()</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Inr <span class="free">b</span> <span class="main">|</span> Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">⇒</span> Inl <span class="main">(</span><span class="bound">x</span><span class="main">,</span> tllist_of_llist <span class="free">b</span> <span class="bound">ys</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Lazy_llist_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">terminal</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_TLList-terminal_Lazy_tllist"><span class="command">lemma</span></span> terminal_Lazy_tllist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"terminal <span class="main">(</span>Lazy_tllist <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">case</span> <span class="free">xs</span> <span class="main">()</span> <span class="keyword1">of</span> Inl <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">⇒</span> terminal <span class="bound">ys</span> <span class="main">|</span> Inr <span class="bound">b</span> <span class="main">⇒</span> <span class="bound">b</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">tmap</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_TLList-tmap_Lazy_tllist"><span class="command">lemma</span></span> tmap_Lazy_tllist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"tmap <span class="free">f</span> <span class="free">g</span> <span class="main">(</span>Lazy_tllist <span class="free">xs</span><span class="main">)</span> <span class="main">=</span>
  Lazy_tllist <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="keyword1">case</span> <span class="free">xs</span> <span class="main">()</span> <span class="keyword1">of</span> Inl <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">⇒</span> Inl <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">,</span> tmap <span class="free">f</span> <span class="free">g</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">|</span> Inr <span class="bound">b</span> <span class="main">⇒</span> Inr <span class="main">(</span><span class="free">g</span> <span class="bound">b</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">tappend</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_TLList-tappend_Lazy_tllist"><span class="command">lemma</span></span> tappend_Lazy_tllist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"tappend <span class="main">(</span>Lazy_tllist <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span> <span class="main">=</span>
  Lazy_tllist <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="keyword1">case</span> <span class="free">xs</span> <span class="main">()</span> <span class="keyword1">of</span> Inl <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">xs'</span><span class="main">)</span> <span class="main">⇒</span> Inl <span class="main">(</span><span class="bound">x</span><span class="main">,</span> tappend <span class="bound">xs'</span> <span class="free">ys</span><span class="main">)</span> <span class="main">|</span> Inr <span class="bound">b</span> <span class="main">⇒</span> force <span class="main">(</span><span class="free">ys</span> <span class="bound">b</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> tllist.split<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">lappendt</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_TLList-lappendt_Lazy_llist"><span class="command">lemma</span></span> lappendt_Lazy_llist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lappendt <span class="main">(</span>Lazy_llist <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span> <span class="main">=</span>
  Lazy_tllist <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="keyword1">case</span> <span class="free">xs</span> <span class="main">()</span> <span class="keyword1">of</span> None <span class="main">⇒</span> force <span class="free">ys</span> <span class="main">|</span> Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">xs'</span><span class="main">)</span> <span class="main">⇒</span> Inl <span class="main">(</span><span class="bound">x</span><span class="main">,</span> lappendt <span class="bound">xs'</span> <span class="free">ys</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Lazy_llist_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split tllist.split<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">TLList.tfilter'</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_TLList-tfilter'_Lazy_tllist"><span class="command">lemma</span></span> tfilter'_Lazy_tllist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"TLList.tfilter' <span class="free">b</span> <span class="free">P</span> <span class="main">(</span>Lazy_tllist <span class="free">xs</span><span class="main">)</span> <span class="main">=</span>
   Lazy_tllist <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="keyword1">case</span> <span class="free">xs</span> <span class="main">()</span> <span class="keyword1">of</span> Inl <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">xs'</span><span class="main">)</span> <span class="main">⇒</span> <span class="keyword1">if</span> <span class="free">P</span> <span class="bound">x</span> <span class="keyword1">then</span> Inl <span class="main">(</span><span class="bound">x</span><span class="main">,</span> TLList.tfilter' <span class="free">b</span> <span class="free">P</span> <span class="bound">xs'</span><span class="main">)</span> <span class="keyword1">else</span> force <span class="main">(</span>TLList.tfilter' <span class="free">b</span> <span class="free">P</span> <span class="bound">xs'</span><span class="main">)</span> <span class="main">|</span> Inr <span class="bound">b'</span> <span class="main">⇒</span> Inr <span class="bound">b'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> tllist.split<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">TLList.tconcat'</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_TLList-tconcat_Lazy_tllist"><span class="command">lemma</span></span> tconcat_Lazy_tllist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"TLList.tconcat' <span class="free">b</span> <span class="main">(</span>Lazy_tllist <span class="free">xss</span><span class="main">)</span> <span class="main">=</span>
  Lazy_tllist <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="keyword1">case</span> <span class="free">xss</span> <span class="main">()</span> <span class="keyword1">of</span> Inr <span class="bound">b'</span> <span class="main">⇒</span> Inr <span class="bound">b'</span> <span class="main">|</span> Inl <span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="bound">xss'</span><span class="main">)</span> <span class="main">⇒</span> force <span class="main">(</span>lappendt <span class="bound">xs</span> <span class="main">(</span>TLList.tconcat' <span class="free">b</span> <span class="bound">xss'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> tllist.split<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">tllist_all2</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_TLList-tllist_all2_Lazy_tllist"><span class="command">lemma</span></span> tllist_all2_Lazy_tllist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"tllist_all2 <span class="free">P</span> <span class="free">Q</span> <span class="main">(</span>Lazy_tllist <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>Lazy_tllist <span class="free">ys</span><span class="main">)</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="keyword1">case</span> <span class="free">xs</span> <span class="main">()</span> <span class="keyword1">of</span> 
    Inr <span class="bound">b</span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">ys</span> <span class="main">()</span> <span class="keyword1">of</span> Inr <span class="bound">b'</span> <span class="main">⇒</span> <span class="free">Q</span> <span class="bound">b</span> <span class="bound">b'</span> <span class="main">|</span> Inl <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> False<span class="main">)</span>
  <span class="main">|</span> Inl <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">xs'</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">ys</span> <span class="main">()</span> <span class="keyword1">of</span> Inr <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> False <span class="main">|</span> Inl <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">ys'</span><span class="main">)</span> <span class="main">⇒</span> <span class="free">P</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">∧</span> tllist_all2 <span class="free">P</span> <span class="free">Q</span> <span class="bound">xs'</span> <span class="bound">ys'</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tllist_all2_TNil1 tllist_all2_TNil2<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">llist_of_tllist</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_TLList-llist_of_tllist_Lazy_tllist"><span class="command">lemma</span></span> llist_of_tllist_Lazy_tllist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"llist_of_tllist <span class="main">(</span>Lazy_tllist <span class="free">xs</span><span class="main">)</span> <span class="main">=</span>
  Lazy_llist <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="keyword1">case</span> <span class="free">xs</span> <span class="main">()</span> <span class="keyword1">of</span> Inl <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">⇒</span> Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span> llist_of_tllist <span class="bound">ys</span><span class="main">)</span> <span class="main">|</span> Inr <span class="bound">b</span> <span class="main">⇒</span> None<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Lazy_llist_def<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">tnth</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_TLList-tnth_Lazy_tllist"><span class="command">lemma</span></span> tnth_Lazy_tllist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"tnth <span class="main">(</span>Lazy_tllist <span class="free">xs</span><span class="main">)</span> <span class="free">n</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> <span class="free">xs</span> <span class="main">()</span> <span class="keyword1">of</span> Inr <span class="bound">b</span> <span class="main">⇒</span> undefined <span class="free">n</span> <span class="main">|</span> Inl <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">⇒</span> <span class="keyword1">if</span> <span class="free">n</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="bound">x</span> <span class="keyword1">else</span> tnth <span class="bound">ys</span> <span class="main">(</span><span class="free">n</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tnth_TNil<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">gen_tlength</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_TLList-gen_tlength_Lazy_tllist"><span class="command">lemma</span></span> gen_tlength_Lazy_tllist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"gen_tlength <span class="free">n</span> <span class="main">(</span>Lazy_tllist <span class="free">xs</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> <span class="free">xs</span> <span class="main">()</span> <span class="keyword1">of</span> Inr <span class="bound">b</span> <span class="main">⇒</span> enat <span class="free">n</span> <span class="main">|</span> Inl <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">xs'</span><span class="main">)</span> <span class="main">⇒</span> gen_tlength <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="bound">xs'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gen_tlength_code<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">tdropn</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Lazy_TLList-tdropn_Lazy_tllist"><span class="command">lemma</span></span> tdropn_Lazy_tllist <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"tdropn <span class="free">n</span> <span class="main">(</span>Lazy_tllist <span class="free">xs</span><span class="main">)</span> <span class="main">=</span>
  Lazy_tllist <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="keyword1">if</span> <span class="free">n</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="free">xs</span> <span class="main">()</span> <span class="keyword1">else</span> <span class="keyword1">case</span> <span class="free">xs</span> <span class="main">()</span> <span class="keyword1">of</span> Inr <span class="bound">b</span> <span class="main">⇒</span> Inr <span class="bound">b</span> <span class="main">|</span> Inl <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">xs'</span><span class="main">)</span> <span class="main">⇒</span> force <span class="main">(</span>tdropn <span class="main">(</span><span class="free">n</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="bound">xs'</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> tllist.split<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> Lazy_tllist_def <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> sum.splits <span class="main">[</span><span class="operator">split</span> <span class="quasi_keyword"><span class="quasi_keyword">del</span></span><span class="main">]</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Simple ML test for laziness›</span></span>

<span class="keyword1"><span class="command">ML_val</span></span> <span class="quoted">‹
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">zeros</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">unfold_tllist</span><span class="antiquote">}</span></span></span> <span class="main">(</span>K false<span class="main">)</span> <span class="main">(</span>K <span class="inner_numeral">0</span><span class="main">)</span> <span class="main">(</span>K <span class="inner_numeral">0</span><span class="main">)</span> I <span class="main">(</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thd</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">thd</span><span class="antiquote">}</span></span></span> <span class="entity">zeros</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ttl</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">ttl</span><span class="antiquote">}</span></span></span> <span class="entity">zeros</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ttl'</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">force</span><span class="antiquote">}</span></span></span> <span class="entity">ttl</span><span class="main">;</span>
  
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tdropn</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">tdropn</span><span class="antiquote">}</span></span></span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">Suc</span><span class="antiquote">}</span></span></span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">"<span class="main">0</span><span class="main">::</span>nat"</span><span class="antiquote">}</span></span></span><span class="main">)</span> <span class="entity">zeros</span><span class="main">;</span>
  
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tfilter</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">tfilter</span><span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span> <span class="main">(</span>K false<span class="main">)</span> <span class="entity">zeros</span><span class="main">;</span>
›</span>

<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> force

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="CCPO_Topology">
<div class="head">
<h1>Theory CCPO_Topology</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       CCPO_Topology.thy
    Author:      Johannes Hölzl, TU Munich
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹CCPO topologies›</span></span>

<span class="keyword1"><span class="command">theory</span></span> CCPO_Topology
<span class="keyword2"><span class="keyword">imports</span></span>
  <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Analysis/Extended_Real_Limits.html">HOL-Analysis.Extended_Real_Limits</a>"</span>
  <span class="quoted">"<a href="#Coinductive_Nat">../Coinductive_Nat</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="CCPO_Topology-dropWhile_append"><span class="command">lemma</span></span> dropWhile_append<span class="main">:</span>
  <span class="quoted"><span class="quoted">"dropWhile <span class="free">P</span> <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="main">∀</span><span class="bound">x</span><span class="main">∈</span>set <span class="free">xs</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="keyword1">then</span> dropWhile <span class="free">P</span> <span class="free">ys</span> <span class="keyword1">else</span> dropWhile <span class="free">P</span> <span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="CCPO_Topology-dropWhile_False"><span class="command">lemma</span></span> dropWhile_False<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> set <span class="free">xs</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⟹</span> dropWhile <span class="free">P</span> <span class="free">xs</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> order<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">chain</span> <span class="main">≡</span> Complete_Partial_Order.chain <span class="main">(≤)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> linorder<span class="main">)</span> chain_linorder<span class="main">:</span> <span class="quoted"><span class="quoted">"chain <span class="free">C</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> chain_def linear<span class="main">)</span>

<span class="keyword1" id="CCPO_Topology-continuous_add_ereal"><span class="command">lemma</span></span> continuous_add_ereal<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">≤</span> <span class="free">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"continuous_on <span class="main">{</span><span class="main">-</span><span class="main">∞</span><span class="main">::</span>ereal <span class="main">&lt;..}</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">t</span> <span class="main">+</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">subst</span> continuous_on_open_vimage<span class="main"><span class="keyword3">,</span></span> <span class="main">(</span><span class="operator">intro</span> open_greaterThan allI impI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">B</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"ereal set"</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"open <span class="skolem">B</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"open <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">t</span> <span class="main">+</span> <span class="bound">x</span><span class="main">)</span> <span class="main">-`</span> <span class="skolem">B</span> <span class="main">∩</span> <span class="main">{</span><span class="main">-</span> <span class="main">∞</span><span class="main">&lt;..}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>real <span class="skolem">t'</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">t</span> <span class="main">+</span> <span class="bound">x</span><span class="main">)</span> <span class="main">-`</span> <span class="skolem">B</span> <span class="main">∩</span> <span class="main">{</span><span class="main">-</span> <span class="main">∞</span><span class="main">&lt;..}</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">1</span> <span class="main">*</span> <span class="bound">x</span> <span class="main">+</span> <span class="main">(</span><span class="main">-</span><span class="free">t</span><span class="main">)</span><span class="main">)</span> <span class="main">`</span> <span class="main">(</span><span class="skolem">B</span> <span class="main">∩</span> <span class="main">{</span><span class="main">-</span><span class="main">∞</span> <span class="main">&lt;..}</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_eq_iff image_iff Bex_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> allI iffI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="improper">x</span> <span class="main">+</span> ereal <span class="skolem">t'</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">ac_simps</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> *
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ereal_open_affinity_pos<span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹open <span class="skolem">B</span>›</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> real<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">insert</span> <span class="quoted"><span class="quoted">‹<span class="main">0</span> <span class="main">≤</span> <span class="free">t</span>›</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="CCPO_Topology-tendsto_add_ereal"><span class="command">lemma</span></span> tendsto_add_ereal<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">≤</span> <span class="free">x</span> <span class="main">⟹</span> <span class="main">0</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">f</span> <span class="main">⤏</span> <span class="free">y</span><span class="main">)</span> <span class="free">F</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">z</span><span class="main">.</span> <span class="free">x</span> <span class="main">+</span> <span class="free">f</span> <span class="bound">z</span> <span class="main">::</span> ereal<span class="main">)</span> <span class="main">⤏</span> <span class="free">x</span> <span class="main">+</span> <span class="free">y</span><span class="main">)</span> <span class="free">F</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> tendsto_compose<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">f</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> continuous_add_ereal<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> t<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">x</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">unfolding</span></span> continuous_on_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> at_within_open<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> S<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">-</span> <span class="main">∞</span> <span class="main">&lt;..}</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="CCPO_Topology-tendsto_LimI"><span class="command">lemma</span></span> tendsto_LimI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">⤏</span> <span class="free">y</span><span class="main">)</span> <span class="free">F</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">f</span> <span class="main">⤏</span> Lim <span class="free">F</span> <span class="free">f</span><span class="main">)</span> <span class="free">F</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> tendsto_Lim tendsto_bot<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The filter <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>at'›</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> ccpo<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">compact_element</span> <span class="main">≡</span> ccpo.compact Sup <span class="main">(≤)</span>"</span></span>

<span class="keyword1" id="CCPO_Topology-tendsto_unique_eventually"><span class="command">lemma</span></span> tendsto_unique_eventually<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="free">x'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> t2_space"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">F</span> <span class="main">≠</span> bot <span class="main">⟹</span> eventually <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">g</span> <span class="bound">x</span><span class="main">)</span> <span class="free">F</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">f</span> <span class="main">⤏</span> <span class="free">x</span><span class="main">)</span> <span class="free">F</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">g</span> <span class="main">⤏</span> <span class="free">x'</span><span class="main">)</span> <span class="free">F</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> tendsto_unique filterlim_cong<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> ccpo<span class="main">)</span> ccpo_Sup_upper2<span class="main">:</span> <span class="quoted"><span class="quoted">"chain <span class="free">C</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">∈</span> <span class="free">C</span> <span class="main">⟹</span> <span class="free">y</span> <span class="main">≤</span> <span class="free">x</span> <span class="main">⟹</span> <span class="free">y</span> <span class="main">≤</span> Sup <span class="free">C</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> ccpo_Sup_upper order_trans<span class="main">)</span>

<span class="keyword1" id="CCPO_Topology-tendsto_open_vimage"><span class="command">lemma</span></span> tendsto_open_vimage<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">B</span><span class="main">.</span> open <span class="bound">B</span> <span class="main">⟹</span> open <span class="main">(</span><span class="free">f</span> <span class="main">-`</span> <span class="bound">B</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">─</span><span class="free">l</span><span class="main">→</span> <span class="free">f</span> <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> continuous_on_open_vimage<span class="main">[</span><span class="operator">of</span> <span class="quoted">UNIV</span> <span class="quoted"><span class="free">f</span></span><span class="main">]</span> continuous_on_def<span class="main">[</span><span class="operator">of</span> <span class="quoted">UNIV</span> <span class="quoted"><span class="free">f</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="CCPO_Topology-open_vimageI"><span class="command">lemma</span></span> open_vimageI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="main">─</span><span class="bound">x</span><span class="main">→</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⟹</span> open <span class="free">A</span> <span class="main">⟹</span> open <span class="main">(</span><span class="free">f</span> <span class="main">-`</span> <span class="free">A</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> continuous_on_open_vimage<span class="main">[</span><span class="operator">of</span> <span class="quoted">UNIV</span> <span class="quoted"><span class="free">f</span></span><span class="main">]</span> continuous_on_def<span class="main">[</span><span class="operator">of</span> <span class="quoted">UNIV</span> <span class="quoted"><span class="free">f</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="CCPO_Topology-principal_bot"><span class="command">lemma</span></span> principal_bot<span class="main">:</span> <span class="quoted"><span class="quoted">"principal <span class="free">x</span> <span class="main">=</span> bot <span class="main">⟷</span> <span class="free">x</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> filter_eq_iff eventually_principal<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">at'</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> open <span class="main">{</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">}</span> <span class="keyword1">then</span> principal <span class="main">{</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">at</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="CCPO_Topology-at'_bot"><span class="command">lemma</span></span> at'_bot<span class="main">:</span> <span class="quoted"><span class="quoted">"at' <span class="free">x</span> <span class="main">≠</span> bot"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> at'_def at_eq_bot_iff principal_bot<span class="main">)</span>

<span class="keyword1" id="CCPO_Topology-tendsto_id_at'"><span class="command">lemma</span></span> tendsto_id_at'<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⤏</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span>at' <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> at'_def topological_tendstoI eventually_principal tendsto_ident_at<span class="main">)</span>

<span class="keyword1" id="CCPO_Topology-cont_at'"><span class="command">lemma</span></span> cont_at'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">⤏</span> <span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span>at' <span class="free">x</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">f</span> <span class="main">─</span><span class="free">x</span><span class="main">→</span> <span class="free">f</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> at_eq_bot_iff<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">x</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> topological_tendstoI <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> eventually_principal at'_def<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The type class <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>ccpo_topology›</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Temporarily relax type constraints for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"open"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹Sign.add_const_constraint
  <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "open"<span class="antiquote">}</span></span><span class="main">,</span> SOME <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>open set <span class="main">⇒</span> bool"</span><span class="antiquote">}</span></span><span class="main">)</span>›</span>

<span class="keyword1"><span class="command">class</span></span> ccpo_topology <span class="main">=</span> <span class="quoted">"open"</span> <span class="main">+</span> ccpo <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> open_ccpo<span class="main">:</span> <span class="quoted"><span class="quoted">"open <span class="free">A</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">C</span><span class="main">.</span> chain <span class="bound">C</span> <span class="main">⟶</span> <span class="bound">C</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">⟶</span> Sup <span class="bound">C</span> <span class="main">∈</span> <span class="free">A</span> <span class="main">⟶</span> <span class="bound">C</span> <span class="main">∩</span> <span class="free">A</span> <span class="main">≠</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="CCPO_Topology-open_ccpoD"><span class="command">lemma</span></span> open_ccpoD<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"open <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"chain <span class="free">C</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">C</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="quoted"><span class="quoted">"Sup <span class="free">C</span> <span class="main">∈</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">c</span><span class="main">∈</span><span class="free">C</span><span class="main">.</span> <span class="main">∀</span><span class="bound">c'</span><span class="main">∈</span><span class="free">C</span><span class="main">.</span> <span class="bound">c</span> <span class="main">≤</span> <span class="bound">c'</span> <span class="main">⟶</span> <span class="bound">c'</span> <span class="main">∈</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="var">?thesis</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">c</span><span class="main">.</span> <span class="bound">c</span> <span class="main">∈</span> <span class="free">C</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">c'</span><span class="main">∈</span><span class="free">C</span><span class="main">.</span> <span class="bound">c</span> <span class="main">≤</span> <span class="bound">c'</span> <span class="main">∧</span> <span class="bound">c'</span> <span class="main">∉</span> <span class="free">A</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹chain <span class="free">C</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">C</span> <span class="main">≠</span> <span class="main">{}</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"chain <span class="main">(</span><span class="free">C</span> <span class="main">-</span> <span class="free">A</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">C</span> <span class="main">-</span> <span class="free">A</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> chain_Diff<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Sup <span class="free">C</span> <span class="main">=</span> Sup <span class="main">(</span><span class="free">C</span> <span class="main">-</span> <span class="free">A</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">safe</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> order.antisym ccpo_Sup_least <span class="quoted"><span class="quoted">‹chain <span class="free">C</span>›</span></span> chain_Diff<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">c</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">∈</span> <span class="free">C</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> * <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">c'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c'</span> <span class="main">∈</span> <span class="free">C</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">≤</span> <span class="skolem">c'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c'</span> <span class="main">∉</span> <span class="free">A</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">c</span><span class="main">∈</span><span class="free">C</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">≤</span> <span class="main">⨆</span><span class="main">(</span><span class="free">C</span> <span class="main">-</span> <span class="free">A</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> ccpo_Sup_upper2 <span class="quoted"><span class="quoted">‹chain <span class="main">(</span><span class="free">C</span> <span class="main">-</span> <span class="free">A</span><span class="main">)</span>›</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">‹chain <span class="free">C</span>›</span></span> ccpo_Sup_upper<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹open <span class="free">A</span>›</span></span> <span class="quoted"><span class="quoted">‹Sup <span class="free">C</span> <span class="main">∈</span> <span class="free">A</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> open_ccpo<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="CCPO_Topology-open_ccpo_Iic"><span class="command">lemma</span></span> open_ccpo_Iic<span class="main">:</span> <span class="quoted"><span class="quoted">"open <span class="main">{..</span> <span class="free">b</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> open_ccpo<span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> Int_iff atMost_iff ccpo_Sup_upper empty_iff order_trans<span class="main">)</span>

<span class="keyword1"><span class="command">subclass</span></span> topological_space
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"open <span class="main">(</span>UNIV<span class="main">::</span><span class="tfree">'a</span> set<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> open_ccpo <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">S</span> <span class="skolem">T</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set"</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"open <span class="skolem">S</span>"</span></span> <span class="quoted"><span class="quoted">"open <span class="skolem">T</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"open <span class="main">(</span><span class="skolem">S</span> <span class="main">∩</span> <span class="skolem">T</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> open_ccpo
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> allI impI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">C</span> <span class="keyword3"><span class="command">assume</span></span> C<span class="main">:</span> <span class="quoted"><span class="quoted">"chain <span class="skolem">C</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">C</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⨆</span><span class="skolem">C</span> <span class="main">∈</span> <span class="skolem">S</span> <span class="main">∩</span> <span class="skolem">T</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> open_ccpoD<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹open <span class="skolem">S</span>›</span></span> C<span class="main">]</span> open_ccpoD<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹open <span class="skolem">T</span>›</span></span> C<span class="main">]</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">C</span> <span class="main">∩</span> <span class="main">(</span><span class="skolem">S</span> <span class="main">∩</span> <span class="skolem">T</span><span class="main">)</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> chain_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">K</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set set"</span></span> <span class="keyword3"><span class="command">assume</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">D</span><span class="main">∈</span><span class="skolem">K</span><span class="main">.</span> open <span class="bound">D</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"open <span class="main">(</span><span class="main">⋃</span><span class="skolem">K</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> open_ccpo
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> allI impI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">C</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"chain <span class="skolem">C</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">C</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">⨆</span><span class="skolem">C</span> <span class="main">∈</span> <span class="main">(</span><span class="main">⋃</span><span class="skolem">K</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> * <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">D</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">D</span> <span class="main">∈</span> <span class="skolem">K</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">⨆</span><span class="skolem">C</span> <span class="main">∈</span> <span class="skolem">D</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">C</span> <span class="main">∩</span> <span class="skolem">D</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> open_ccpo<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">C</span> <span class="main">∩</span> <span class="main">(</span><span class="main">⋃</span><span class="skolem">K</span><span class="main">)</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="CCPO_Topology-closed_ccpo"><span class="command">lemma</span></span> closed_ccpo<span class="main">:</span> <span class="quoted"><span class="quoted">"closed <span class="free">A</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">C</span><span class="main">.</span> chain <span class="bound">C</span> <span class="main">⟶</span> <span class="bound">C</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">⟶</span> <span class="bound">C</span> <span class="main">⊆</span> <span class="free">A</span> <span class="main">⟶</span> Sup <span class="bound">C</span> <span class="main">∈</span> <span class="free">A</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> closed_def open_ccpo <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="CCPO_Topology-closed_admissible"><span class="command">lemma</span></span> closed_admissible<span class="main">:</span> <span class="quoted"><span class="quoted">"closed <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">}</span> <span class="main">⟷</span> ccpo.admissible Sup <span class="main">(≤)</span> <span class="free">P</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> closed_ccpo ccpo.admissible_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="CCPO_Topology-open_singletonI_compact"><span class="command">lemma</span></span> open_singletonI_compact<span class="main">:</span> <span class="quoted"><span class="quoted">"compact_element <span class="free">x</span> <span class="main">⟹</span> open <span class="main">{</span><span class="free">x</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> admissible_compact_neq<span class="main">[</span><span class="operator">of</span> <span class="quoted">Sup</span> <span class="quoted"><span class="quoted">"<span class="main">(≤)</span>"</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> closed_admissible<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> open_closed Collect_neg_eq<span class="main">)</span>

<span class="keyword1" id="CCPO_Topology-closed_Ici"><span class="command">lemma</span></span> closed_Ici<span class="main">:</span> <span class="quoted"><span class="quoted">"closed <span class="main">{..</span> <span class="free">b</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> closed_ccpo <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> ccpo_Sup_least<span class="main">)</span>

<span class="keyword1" id="CCPO_Topology-closed_Iic"><span class="command">lemma</span></span> closed_Iic<span class="main">:</span> <span class="quoted"><span class="quoted">"closed <span class="main">{</span><span class="free">b</span> <span class="main">..}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> closed_ccpo <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> ccpo_Sup_upper2<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> ccpo_topology<span class="antiquote"><span class="antiquote">}</span></span></span></span>s are also <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> t2_space<span class="antiquote"><span class="antiquote">}</span></span></span></span>s.
  This is necessary to have a unique continuous extension.
›</span></span>

<span class="keyword1"><span class="command">subclass</span></span> t2_space
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≠</span> <span class="skolem">y</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">U</span> <span class="bound">V</span><span class="main">.</span> open <span class="bound">U</span> <span class="main">∧</span> open <span class="bound">V</span> <span class="main">∧</span> <span class="skolem">x</span> <span class="main">∈</span> <span class="bound">U</span> <span class="main">∧</span> <span class="skolem">y</span> <span class="main">∈</span> <span class="bound">V</span> <span class="main">∧</span> <span class="bound">U</span> <span class="main">∩</span> <span class="bound">V</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≠</span> <span class="skolem">y</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">y</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"open <span class="main">{..</span><span class="skolem">x</span><span class="main">}</span> <span class="main">∧</span> open <span class="main">(</span><span class="main">-</span> <span class="main">{..</span><span class="skolem">x</span><span class="main">}</span><span class="main">)</span> <span class="main">∧</span> <span class="skolem">x</span> <span class="main">∈</span> <span class="main">{..</span><span class="skolem">x</span><span class="main">}</span> <span class="main">∧</span> <span class="skolem">y</span> <span class="main">∈</span> <span class="main">-</span> <span class="main">{..</span><span class="skolem">x</span><span class="main">}</span> <span class="main">∧</span> <span class="main">{..</span><span class="skolem">x</span><span class="main">}</span> <span class="main">∩</span> <span class="main">-</span> <span class="main">{..</span><span class="skolem">x</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> open_ccpo_Iic closed_Ici<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">y</span> <span class="main">∨</span> <span class="skolem">y</span> <span class="main">≤</span> <span class="skolem">x</span>"</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">≠</span> <span class="skolem">y</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Int_commute<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="main">(</span><span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">y</span> <span class="main">∨</span> <span class="skolem">y</span> <span class="main">≤</span> <span class="skolem">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"open <span class="main">(</span><span class="main">{..</span><span class="skolem">x</span><span class="main">}</span> <span class="main">∩</span> <span class="main">-</span> <span class="main">{..</span><span class="skolem">y</span><span class="main">}</span><span class="main">)</span> <span class="main">∧</span> open <span class="main">(</span><span class="main">{..</span><span class="skolem">y</span><span class="main">}</span> <span class="main">∩</span> <span class="main">-</span> <span class="main">{..</span><span class="skolem">x</span><span class="main">}</span><span class="main">)</span> <span class="main">∧</span>
        <span class="skolem">x</span> <span class="main">∈</span> <span class="main">{..</span><span class="skolem">x</span><span class="main">}</span> <span class="main">∩</span> <span class="main">-</span> <span class="main">{..</span><span class="skolem">y</span><span class="main">}</span> <span class="main">∧</span> <span class="skolem">y</span> <span class="main">∈</span> <span class="main">{..</span><span class="skolem">y</span><span class="main">}</span> <span class="main">∩</span> <span class="main">-</span> <span class="main">{..</span><span class="skolem">x</span><span class="main">}</span> <span class="main">∧</span> <span class="main">(</span><span class="main">{..</span><span class="skolem">x</span><span class="main">}</span> <span class="main">∩</span> <span class="main">-</span> <span class="main">{..</span><span class="skolem">y</span><span class="main">}</span><span class="main">)</span> <span class="main">∩</span> <span class="main">(</span><span class="main">{..</span><span class="skolem">y</span><span class="main">}</span> <span class="main">∩</span> <span class="main">-</span> <span class="main">{..</span><span class="skolem">x</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> open_ccpo_Iic closed_Ici<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="CCPO_Topology-tendsto_le_ccpo"><span class="command">lemma</span></span> tendsto_le_ccpo<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="free">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>ccpo_topology"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> F<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> trivial_limit <span class="free">F</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">⤏</span> <span class="free">x</span><span class="main">)</span> <span class="free">F</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> y<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">g</span> <span class="main">⤏</span> <span class="free">y</span><span class="main">)</span> <span class="free">F</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ev<span class="main">:</span> <span class="quoted"><span class="quoted">"eventually <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">g</span> <span class="bound">x</span> <span class="main">≤</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="free">F</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">≤</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">y</span> <span class="main">≤</span> <span class="free">x</span>"</span></span>

  <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≤</span> <span class="free">y</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> <span class="free">y</span> <span class="main">≤</span> <span class="free">x</span>›</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"open <span class="main">{..</span><span class="free">x</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"open <span class="main">(</span><span class="main">-</span> <span class="main">{..</span><span class="free">x</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="main">{..</span><span class="free">x</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> <span class="main">-</span> <span class="main">{..</span><span class="free">x</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">{..</span><span class="free">x</span><span class="main">}</span> <span class="main">∩</span> <span class="main">-</span> <span class="main">{..</span><span class="free">x</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> open_ccpo_Iic closed_Ici<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> topological_tendstoD<span class="main">[</span><span class="operator">OF</span> x<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">{..</span><span class="free">x</span><span class="main">}</span>"</span></span><span class="main">]</span> topological_tendstoD<span class="main">[</span><span class="operator">OF</span> y<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">-</span> <span class="main">{..</span><span class="free">x</span><span class="main">}</span>"</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"eventually <span class="main">(</span><span class="main">λ</span><span class="bound">z</span><span class="main">.</span> <span class="free">f</span> <span class="bound">z</span> <span class="main">≤</span> <span class="free">x</span><span class="main">)</span> <span class="free">F</span>"</span></span> <span class="quoted"><span class="quoted">"eventually <span class="main">(</span><span class="main">λ</span><span class="bound">z</span><span class="main">.</span> <span class="main">¬</span> <span class="free">g</span> <span class="bound">z</span> <span class="main">≤</span> <span class="free">x</span><span class="main">)</span> <span class="free">F</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> ev <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"eventually <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> False<span class="main">)</span> <span class="free">F</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eventually_elim</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> order_trans<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> F <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> eventually_False<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">x</span> <span class="main">≤</span> <span class="free">y</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> <span class="free">y</span> <span class="main">≤</span> <span class="free">x</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"open <span class="main">(</span><span class="main">{..</span><span class="free">x</span><span class="main">}</span> <span class="main">∩</span> <span class="main">-</span> <span class="main">{..</span><span class="free">y</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"open <span class="main">(</span><span class="main">{..</span><span class="free">y</span><span class="main">}</span> <span class="main">∩</span> <span class="main">-</span> <span class="main">{..</span><span class="free">x</span><span class="main">}</span><span class="main">)</span>"</span></span>
        <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="main">{..</span><span class="free">x</span><span class="main">}</span> <span class="main">∩</span> <span class="main">-</span> <span class="main">{..</span><span class="free">y</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> <span class="main">{..</span><span class="free">y</span><span class="main">}</span> <span class="main">∩</span> <span class="main">-</span> <span class="main">{..</span><span class="free">x</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">{..</span><span class="free">x</span><span class="main">}</span> <span class="main">∩</span> <span class="main">-</span> <span class="main">{..</span><span class="free">y</span><span class="main">}</span><span class="main">)</span> <span class="main">∩</span> <span class="main">(</span><span class="main">{..</span><span class="free">y</span><span class="main">}</span> <span class="main">∩</span> <span class="main">-</span> <span class="main">{..</span><span class="free">x</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> open_ccpo_Iic closed_Ici<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> topological_tendstoD<span class="main">[</span><span class="operator">OF</span> x<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">{..</span><span class="free">x</span><span class="main">}</span> <span class="main">∩</span> <span class="main">-</span> <span class="main">{..</span><span class="free">y</span><span class="main">}</span>"</span></span><span class="main">]</span>
         topological_tendstoD<span class="main">[</span><span class="operator">OF</span> y<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">{..</span><span class="free">y</span><span class="main">}</span> <span class="main">∩</span> <span class="main">-</span> <span class="main">{..</span><span class="free">x</span><span class="main">}</span>"</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"eventually <span class="main">(</span><span class="main">λ</span><span class="bound">z</span><span class="main">.</span> <span class="free">f</span> <span class="bound">z</span> <span class="main">≤</span> <span class="free">x</span> <span class="main">∧</span> <span class="main">¬</span> <span class="free">f</span> <span class="bound">z</span> <span class="main">≤</span> <span class="free">y</span><span class="main">)</span> <span class="free">F</span>"</span></span> <span class="quoted"><span class="quoted">"eventually <span class="main">(</span><span class="main">λ</span><span class="bound">z</span><span class="main">.</span> <span class="free">g</span> <span class="bound">z</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">∧</span> <span class="main">¬</span> <span class="free">g</span> <span class="bound">z</span> <span class="main">≤</span> <span class="free">x</span><span class="main">)</span> <span class="free">F</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> ev <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"eventually <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> False<span class="main">)</span> <span class="free">F</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eventually_elim</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> order_trans<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> F <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> eventually_False<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="CCPO_Topology-tendsto_ccpoI"><span class="command">lemma</span></span> tendsto_ccpoI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>ccpo_topology <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>ccpo_topology"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">C</span><span class="main">.</span> chain <span class="bound">C</span> <span class="main">⟹</span> <span class="bound">C</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">⟹</span> chain <span class="main">(</span><span class="free">f</span> <span class="main">`</span> <span class="bound">C</span><span class="main">)</span> <span class="main">∧</span> <span class="free">f</span> <span class="main">(</span>Sup <span class="bound">C</span><span class="main">)</span> <span class="main">=</span> Sup <span class="main">(</span><span class="free">f</span><span class="main">`</span><span class="bound">C</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">─</span><span class="free">x</span><span class="main">→</span> <span class="free">f</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> tendsto_open_vimage<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> open_ccpo<span class="main">)</span>

<span class="keyword1" id="CCPO_Topology-tendsto_mcont"><span class="command">lemma</span></span> tendsto_mcont<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> mcont<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont Sup <span class="main">(≤)</span> Sup <span class="main">(≤)</span> <span class="main">(</span><span class="free">f</span> <span class="main">::</span> <span class="tfree">'a</span> <span class="main">::</span> ccpo_topology <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">::</span> ccpo_topology<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">─</span><span class="free">l</span><span class="main">→</span> <span class="free">f</span> <span class="free">l</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> tendsto_ccpoI conjI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">C</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set"</span></span> <span class="keyword3"><span class="command">assume</span></span> C<span class="main">:</span> <span class="quoted"><span class="quoted">"chain <span class="skolem">C</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">C</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"chain <span class="main">(</span><span class="free">f</span><span class="main">`</span><span class="skolem">C</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> mcont
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> chain_imageI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> le_a<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">(≤)</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span> C<span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mcont_def monotone_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span><span class="main">⨆</span><span class="skolem">C</span><span class="main">)</span> <span class="main">=</span> <span class="main">⨆</span><span class="main">(</span><span class="free">f</span> <span class="main">`</span> <span class="skolem">C</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> mcont C <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mcont_def cont_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Instances for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> ccpo_topology<span class="antiquote"><span class="antiquote">}</span></span></span></span>s and continuity theorems›</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> set <span class="main">::</span> <span class="main">(</span><span class="quoted">type</span><span class="main">)</span> <span class="quoted">ccpo_topology</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity"><span class="class_parameter">open_set</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set set <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">open_set</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">C</span><span class="main">.</span> chain <span class="bound">C</span> <span class="main">⟶</span> <span class="bound">C</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">⟶</span> Sup <span class="bound">C</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">⟶</span> <span class="bound">C</span> <span class="main">∩</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">≠</span> <span class="main">{}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> open_set_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> enat <span class="main">::</span> <span class="quoted">ccpo_topology</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">instance</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">A</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"enat set"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"open <span class="skolem">A</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">C</span><span class="main">.</span> chain <span class="bound">C</span> <span class="main">⟶</span> <span class="bound">C</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">⟶</span> <span class="main">⨆</span><span class="bound">C</span> <span class="main">∈</span> <span class="skolem">A</span> <span class="main">⟶</span> <span class="bound">C</span> <span class="main">∩</span> <span class="skolem">A</span> <span class="main">≠</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> iffI allI impI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">C</span> <span class="skolem">x</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"open <span class="skolem">A</span>"</span></span> <span class="quoted"><span class="quoted">"chain <span class="skolem">C</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">C</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">⨆</span><span class="skolem">C</span> <span class="main">∈</span> <span class="skolem">A</span>"</span></span>

    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">C</span> <span class="main">∩</span> <span class="skolem">A</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">⨆</span><span class="skolem">C</span> <span class="main">=</span> <span class="main">∞</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">⨆</span><span class="skolem">C</span> <span class="main">∈</span> <span class="skolem">A</span>›</span></span> <span class="quoted"><span class="quoted">‹open <span class="skolem">A</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span>enat <span class="skolem">n</span> <span class="main">&lt;..}</span> <span class="main">⊆</span> <span class="skolem">A</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> open_enat_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">⨆</span><span class="skolem">C</span> <span class="main">=</span> <span class="main">∞</span>›</span></span> Sup_eq_top_iff<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">C</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> top_enat_def<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">⨆</span><span class="skolem">C</span> <span class="main">≠</span> <span class="main">∞</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">C</span> <span class="main">⊆</span> <span class="main">{..</span> enat <span class="skolem">n</span><span class="main">}</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> Sup_eq_top_iff top_enat_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> not_less top_enat_def<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">{..</span> enat <span class="skolem">n</span><span class="main">}</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_enat_bounded<span class="main">)</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="skolem">C</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_subset<span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> in_chain_finite<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹chain <span class="skolem">C</span>›</span></span> <span class="quoted"><span class="quoted">‹finite <span class="skolem">C</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">C</span> <span class="main">≠</span> <span class="main">{}</span>›</span></span><span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="main">⨆</span><span class="skolem">C</span> <span class="main">∈</span> <span class="skolem">A</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> C<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">C</span><span class="main">.</span> chain <span class="bound">C</span> <span class="main">⟶</span> <span class="bound">C</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">⟶</span> <span class="main">⨆</span><span class="bound">C</span> <span class="main">∈</span> <span class="skolem">A</span> <span class="main">⟶</span> <span class="bound">C</span> <span class="main">∩</span> <span class="skolem">A</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"open <span class="skolem">A</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> open_enat_iff
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">safe</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">∞</span> <span class="main">∈</span> <span class="skolem">A</span>"</span></span>
      <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">C</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"enat set"</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"infinite <span class="skolem">C</span>"</span></span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⨆</span><span class="skolem">C</span> <span class="main">=</span> <span class="main">∞</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Sup_enat_def<span class="main">)</span>
        <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹infinite <span class="skolem">C</span>›</span></span> C<span class="main">[</span><span class="operator">THEN</span> spec<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">C</span></span><span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="main">∞</span> <span class="main">∈</span> <span class="skolem">A</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">C</span> <span class="main">∩</span> <span class="skolem">A</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> <span class="keyword1"><span class="command">}</span></span>
      <span class="keyword1"><span class="command">note</span></span> inf_C <span class="main">=</span> this

      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="main">{</span>enat <span class="bound">x</span><span class="main">&lt;..}</span> <span class="main">⊆</span> <span class="skolem">A</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="main">{</span>enat <span class="bound">x</span><span class="main">&lt;..}</span> <span class="main">⊆</span> <span class="skolem">A</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">∞</span> <span class="main">∈</span> <span class="skolem">A</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="main">∃</span><span class="bound"><span class="bound">y</span></span><span class="main">&gt;</span><span class="bound">x</span><span class="main">.</span> enat <span class="bound">y</span> <span class="main">∉</span> <span class="skolem">A</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> subset_eq Bex_def<span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> enat.exhaust enat_ord_simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"infinite <span class="main">{</span><span class="bound">n</span><span class="main">.</span> enat <span class="bound">n</span> <span class="main">∉</span> <span class="skolem">A</span><span class="main">}</span>"</span></span>
          <span class="keyword1"><span class="command">unfolding</span></span> infinite_nat_iff_unbounded <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"infinite <span class="main">(</span>enat <span class="main">`</span> <span class="main">{</span><span class="bound">n</span><span class="main">.</span> enat <span class="bound">n</span> <span class="main">∉</span> <span class="skolem">A</span><span class="main">}</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> finite_imageD<span class="main">)</span>
        <span class="keyword1"><span class="command">from</span></span> inf_C<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> tendsto_inf2<span class="main">[</span><span class="operator">THEN</span> tendsto_compose<span class="main">,</span> <span class="operator">tendsto_intros</span><span class="main">]</span> <span class="main">=</span>
  tendsto_mcont<span class="main">[</span><span class="operator">OF</span> mcont_inf2<span class="main">]</span>

<span class="keyword1" id="CCPO_Topology-isCont_inf2"><span class="command">lemma</span></span> isCont_inf2<span class="main">[</span><span class="operator">THEN</span> isCont_o2<span class="main"><span class="main"><span class="main"><span class="main">[</span></span></span></span><span class="operator"><span class="operator"><span class="operator">rotated</span></span></span><span class="main"><span class="main"><span class="main"><span class="main">]</span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"isCont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">⊓</span> <span class="free">y</span><span class="main">)</span> <span class="main">(</span><span class="free">z</span> <span class="main">::</span> <span class="main">_</span> <span class="main">::</span> <span class="main">{</span>ccpo_topology<span class="main">,</span> complete_distrib_lattice<span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> isCont_def tendsto_inf2 tendsto_ident_at<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> tendsto_sup1<span class="main">[</span><span class="operator">THEN</span> tendsto_compose<span class="main">,</span> <span class="operator">tendsto_intros</span><span class="main">]</span> <span class="main">=</span>
  tendsto_mcont<span class="main">[</span><span class="operator">OF</span> mcont_sup1<span class="main">]</span>

<span class="keyword1" id="CCPO_Topology-isCont_If"><span class="command">lemma</span></span> isCont_If<span class="main">:</span> <span class="quoted"><span class="quoted">"isCont <span class="free">f</span> <span class="free">x</span> <span class="main">⟹</span> isCont <span class="free">g</span> <span class="free">x</span> <span class="main">⟹</span> isCont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="free">Q</span> <span class="keyword1">then</span> <span class="free">f</span> <span class="bound">x</span> <span class="keyword1">else</span> <span class="free">g</span> <span class="bound">x</span><span class="main">)</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">Q</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="CCPO_Topology-isCont_enat_case"><span class="command">lemma</span></span> isCont_enat_case<span class="main">:</span> <span class="quoted"><span class="quoted">"isCont <span class="main">(</span><span class="free">f</span> <span class="main">(</span>epred <span class="free">n</span><span class="main">)</span><span class="main">)</span> <span class="free">x</span> <span class="main">⟹</span> isCont <span class="free">g</span> <span class="free">x</span> <span class="main">⟹</span> isCont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> co.case_enat <span class="main">(</span><span class="free">g</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="free">f</span> <span class="bound">n</span> <span class="bound">x</span><span class="main">)</span> <span class="free">n</span><span class="main">)</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_coexhaust<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="LList_CCPO_Topology">
<div class="head">
<h1>Theory LList_CCPO_Topology</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       LList_CCPO_Topology.thy
    Author:      Johannes Hölzl, TU Munich
    Author:      Andreas Lochbihler, ETH Zurich
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹A CCPO topology on lazy lists with examples›</span></span>

<span class="keyword1"><span class="command">theory</span></span> LList_CCPO_Topology <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="#CCPO_Topology">CCPO_Topology</a>
  <span class="quoted">"<a href="#Coinductive_List_Prefix">../Coinductive_List_Prefix</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="LList_CCPO_Topology-closed_Collect_eq_isCont"><span class="command">lemma</span></span> closed_Collect_eq_isCont<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="free">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> t2_space <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>t2_space"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> f<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> isCont <span class="free">f</span> <span class="bound">x</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> g<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> isCont <span class="free">g</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"closed <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">g</span> <span class="bound">x</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> closed_Collect_eq continuous_at_imp_continuous_on ballI assms<span class="main">)</span>

<span class="keyword1"><span class="command">instantiation</span></span> llist <span class="main">::</span> <span class="main">(</span><span class="quoted">type</span><span class="main">)</span> <span class="quoted">ccpo_topology</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity"><span class="class_parameter">open_llist</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist set <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">open_llist</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">C</span><span class="main">.</span> chain <span class="bound">C</span> <span class="main">⟶</span> <span class="bound">C</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">⟶</span> Sup <span class="bound">C</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">⟶</span> <span class="bound">C</span> <span class="main">∩</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">≠</span> <span class="main">{}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> open_llist_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Continuity and closedness of predefined constants›</span></span>

<span class="keyword1" id="LList_CCPO_Topology-tendsto_mcont_llist"><span class="command">lemma</span></span> tendsto_mcont_llist<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont lSup lprefix lSup lprefix <span class="free">f</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">─</span><span class="free">l</span><span class="main">→</span> <span class="free">f</span> <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Sup_llist_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> tendsto_mcont<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-tendsto_ltl"><span class="command">lemma</span></span> tendsto_ltl<span class="main">[</span><span class="operator">THEN</span> tendsto_compose<span class="main">,</span> <span class="operator">tendsto_intros</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ltl <span class="main">─</span><span class="free">l</span><span class="main">→</span> ltl <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> tendsto_mcont_llist mcont_ltl<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-tendsto_lappend2"><span class="command">lemma</span></span> tendsto_lappend2<span class="main">[</span><span class="operator">THEN</span> tendsto_compose<span class="main">,</span> <span class="operator">tendsto_intros</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lappend <span class="free">l</span> <span class="main">─</span><span class="free">l'</span><span class="main">→</span> lappend <span class="free">l</span> <span class="free">l'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> tendsto_mcont_llist mcont_lappend2<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-tendsto_LCons"><span class="command">lemma</span></span> tendsto_LCons<span class="main">[</span><span class="operator">THEN</span> tendsto_compose<span class="main">,</span> <span class="operator">tendsto_intros</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"LCons <span class="free">x</span> <span class="main">─</span><span class="free">l</span><span class="main">→</span> LCons <span class="free">x</span> <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> tendsto_mcont_llist mcont_LCons<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-tendsto_lmap"><span class="command">lemma</span></span> tendsto_lmap<span class="main">[</span><span class="operator">THEN</span> tendsto_compose<span class="main">,</span> <span class="operator">tendsto_intros</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lmap <span class="free">f</span> <span class="main">─</span><span class="free">l</span><span class="main">→</span> lmap <span class="free">f</span> <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> tendsto_mcont_llist mcont_lmap<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-tendsto_llength"><span class="command">lemma</span></span> tendsto_llength<span class="main">[</span><span class="operator">THEN</span> tendsto_compose<span class="main">,</span> <span class="operator">tendsto_intros</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"llength <span class="main">─</span><span class="free">l</span><span class="main">→</span> llength <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> tendsto_mcont<span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Sup_llist_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-tendsto_lset"><span class="command">lemma</span></span> tendsto_lset<span class="main">[</span><span class="operator">THEN</span> tendsto_compose<span class="main">,</span> <span class="operator">tendsto_intros</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lset <span class="main">─</span><span class="free">l</span><span class="main">→</span> lset <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> tendsto_mcont<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Sup_llist_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-open_lhd"><span class="command">lemma</span></span> open_lhd<span class="main">:</span> <span class="quoted"><span class="quoted">"open <span class="main">{</span><span class="bound">l</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">l</span> <span class="main">∧</span> lhd <span class="bound">l</span> <span class="main">=</span> <span class="free">x</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> open_ccpo set_eq_iff
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> imp_conjL Sup_llist_def <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> lhd_lSup<span class="main"><span class="keyword3">,</span></span> <span class="operator">intro</span> allI impI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">C</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"Complete_Partial_Order.chain lprefix <span class="skolem">C</span>"</span></span> <span class="quoted"><span class="quoted">"lhd <span class="main">(</span>lSup <span class="skolem">C</span><span class="main">)</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">c</span><span class="main">∈</span><span class="skolem">C</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">c</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">c</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">∈</span> <span class="skolem">C</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lnull <span class="skolem">c</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">c</span><span class="main">.</span> <span class="bound">c</span> <span class="main">∈</span> <span class="skolem">C</span> <span class="main">∧</span> <span class="main">¬</span> lnull <span class="bound">c</span> <span class="main">∧</span> lhd <span class="bound">c</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> lhd_lSup_eq<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="LList_CCPO_Topology-open_LCons'"><span class="command">lemma</span></span> open_LCons'<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"open <span class="free">A</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"open <span class="main">(</span>LCons <span class="free">x</span> <span class="main">`</span> <span class="free">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"open <span class="main">(</span>ltl <span class="main">-`</span> <span class="free">A</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">l</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">l</span> <span class="main">∧</span> lhd <span class="bound">l</span> <span class="main">=</span> <span class="free">x</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> open_Int open_vimageI open_lhd A <span class="dynamic"><span class="dynamic">tendsto_intros</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>ltl <span class="main">-`</span> <span class="free">A</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">l</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">l</span> <span class="main">∧</span> lhd <span class="bound">l</span> <span class="main">=</span> <span class="free">x</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> LCons <span class="free">x</span> <span class="main">`</span> <span class="free">A</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="LList_CCPO_Topology-open_Ici"><span class="command">lemma</span></span> open_Ici<span class="main">:</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span> <span class="main">⟹</span> open <span class="main">{</span><span class="free">xs</span> <span class="main">..}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lfinite.induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> lfinite_LNil <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> atLeast_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>lfinite_LConsI <span class="skolem">xs</span> <span class="skolem">x</span><span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span>LCons <span class="skolem">x</span> <span class="skolem">xs</span> <span class="main">..}</span> <span class="main">=</span> LCons <span class="skolem">x</span> <span class="main">`</span> <span class="main">{</span><span class="skolem">xs</span> <span class="main">..}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> LCons_lprefix_conv<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> open_LCons'<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="LList_CCPO_Topology-open_lfinite"><span class="command">lemma</span></span> open_lfinite<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">x</span> <span class="main">⟹</span> open <span class="main">{</span><span class="free">x</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lfinite.induct<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"open <span class="main">{</span>LNil<span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> open_ccpo_Iic<span class="main">[</span><span class="operator">of</span> <span class="quoted">LNil</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> atMost_def lnull_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> open_LCons'<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-open_singleton_iff_lfinite"><span class="command">lemma</span></span> open_singleton_iff_lfinite<span class="main">:</span> <span class="quoted"><span class="quoted">"open <span class="main">{</span><span class="free">x</span><span class="main">}</span> <span class="main">⟷</span> lfinite <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"open <span class="main">{</span><span class="free">x</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> compact_eq_lfinite<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> Sup_llist_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">,</span> <span class="operator">symmetric</span><span class="main">]</span> less_eq_llist_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">,</span> <span class="operator">symmetric</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> open_singletonI_compact<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"open <span class="main">{</span><span class="free">x</span><span class="main">}</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?C</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">ys</span><span class="main">.</span> lprefix <span class="bound">ys</span> <span class="free">x</span> <span class="main">∧</span> <span class="bound">ys</span> <span class="main">≠</span> <span class="free">x</span><span class="main">}</span>"</span></span>
    <span class="keyword3"><span class="command">assume</span></span> inf<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lfinite <span class="free">x</span>"</span></span>
    <span class="keyword1"><span class="command">note</span></span> lSup_strict_prefixes<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="quoted"><span class="quoted">‹open <span class="main">{</span><span class="free">x</span><span class="main">}</span>›</span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"chain <span class="var">?C</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> lprefixes_chain<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">x</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> chain_compr<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?C</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> inf <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> open_ccpo Sup_llist_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="LList_CCPO_Topology-closure_eq_lfinite"><span class="command">lemma</span></span> closure_eq_lfinite<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> closed_Q<span class="main">:</span> <span class="quoted"><span class="quoted">"closed <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">xs</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> downwards_Q<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span> <span class="bound">ys</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">xs</span> <span class="main">⟹</span> lprefix <span class="bound">ys</span> <span class="bound">xs</span> <span class="main">⟹</span> <span class="free">Q</span> <span class="bound">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">xs</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">xs</span><span class="main">}</span> <span class="main">=</span> closure <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> lfinite <span class="bound">xs</span> <span class="main">∧</span> <span class="free">Q</span> <span class="bound">xs</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> closure_unique<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">T</span> <span class="keyword3"><span class="command">assume</span></span> T<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">xs</span><span class="main">.</span> lfinite <span class="bound">xs</span> <span class="main">∧</span> <span class="free">Q</span> <span class="bound">xs</span><span class="main">}</span> <span class="main">⊆</span> <span class="skolem">T</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"closed <span class="skolem">T</span>"</span></span>

  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">xs</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">xs</span><span class="main">}</span> <span class="main">⊆</span> <span class="skolem">T</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">clarify</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?F</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">ys</span><span class="main">.</span> lprefix <span class="bound">ys</span> <span class="skolem">xs</span> <span class="main">∧</span> lfinite <span class="bound">ys</span><span class="main">}</span>"</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="skolem">xs</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> T downwards_Q <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?F</span> <span class="main">⊆</span> <span class="skolem">T</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"chain <span class="var">?F</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="var">?F</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> lprefixes_chain chain_subset<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lSup <span class="var">?F</span> <span class="main">=</span> <span class="skolem">xs</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> lSup_finite_prefixes<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">∈</span> <span class="skolem">T</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹closed <span class="skolem">T</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> closed_ccpo Sup_llist_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> closed_Q<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-closure_lfinite"><span class="command">lemma</span></span> closure_lfinite<span class="main">:</span> <span class="quoted"><span class="quoted">"closure <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> lfinite <span class="bound">xs</span><span class="main">}</span> <span class="main">=</span> UNIV"</span></span>
  <span class="keyword1"><span class="command">using</span></span> closure_eq_lfinite<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="LList_CCPO_Topology-closed_ldistinct"><span class="command">lemma</span></span> closed_ldistinct<span class="main">:</span> <span class="quoted"><span class="quoted">"closed <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> ldistinct <span class="bound">xs</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> closed_ccpo <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ldistinct_lSup Sup_llist_def subset_eq<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-ldistinct_closure"><span class="command">lemma</span></span> ldistinct_closure<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">xs</span><span class="main">.</span> ldistinct <span class="bound">xs</span><span class="main">}</span> <span class="main">=</span> closure <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> lfinite <span class="bound">xs</span> <span class="main">∧</span> ldistinct <span class="bound">xs</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> closure_eq_lfinite<span class="main"><span class="main">[</span></span><span class="operator">OF</span> closed_ldistinct ldistinct_lprefix<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-closed_ldistinct'"><span class="command">lemma</span></span> closed_ldistinct'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> isCont <span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⟹</span> closed <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> ldistinct <span class="main">(</span><span class="free">f</span> <span class="bound">xs</span><span class="main">)</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> continuous_closed_vimage<span class="main">[</span><span class="operator">of</span> <span class="main">_</span> <span class="quoted"><span class="free">f</span></span><span class="main">,</span> <span class="operator">OF</span> closed_ldistinct<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="LList_CCPO_Topology-closed_lsorted"><span class="command">lemma</span></span> closed_lsorted<span class="main">:</span> <span class="quoted"><span class="quoted">"closed <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> lsorted <span class="bound">xs</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> closed_ccpo <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> lsorted_lSup Sup_llist_def subset_eq<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-lsorted_closure"><span class="command">lemma</span></span> lsorted_closure<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">xs</span><span class="main">.</span> lsorted <span class="bound">xs</span><span class="main">}</span> <span class="main">=</span> closure <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> lfinite <span class="bound">xs</span> <span class="main">∧</span> lsorted <span class="bound">xs</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> closure_eq_lfinite<span class="main"><span class="main">[</span></span><span class="operator">OF</span> closed_lsorted lsorted_lprefixD<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-closed_lsorted'"><span class="command">lemma</span></span> closed_lsorted'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> isCont <span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⟹</span> closed <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> lsorted <span class="main">(</span><span class="free">f</span> <span class="bound">xs</span><span class="main">)</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> continuous_closed_vimage<span class="main">[</span><span class="operator">of</span> <span class="main">_</span> <span class="quoted"><span class="free">f</span></span><span class="main">,</span> <span class="operator">OF</span> closed_lsorted<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="LList_CCPO_Topology-closed_in_lset"><span class="command">lemma</span></span> closed_in_lset<span class="main">:</span> <span class="quoted"><span class="quoted">"closed <span class="main">{</span><span class="bound">l</span><span class="main">.</span> <span class="free">x</span> <span class="main">∈</span> lset <span class="bound">l</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> closed_ccpo <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> subset_eq lset_lSup Sup_llist_def<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-closed_llist_all2"><span class="command">lemma</span></span> closed_llist_all2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"closed <span class="main">{</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> llist_all2 <span class="free">R</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="keyword3"><span class="command">assume</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">A</span> <span class="bound">B</span><span class="main">.</span> open <span class="bound">A</span> <span class="main">⟹</span> open <span class="bound">B</span> <span class="main">⟹</span> <span class="skolem">a</span> <span class="main">∈</span> <span class="bound">A</span> <span class="main">⟹</span> <span class="skolem">b</span> <span class="main">∈</span> <span class="bound">B</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">∈</span><span class="bound">A</span><span class="main">.</span> <span class="main">∃</span><span class="bound">y</span><span class="main">∈</span><span class="bound">B</span><span class="main">.</span> llist_all2 <span class="free">R</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"llist_all2 <span class="free">R</span> <span class="skolem">a</span> <span class="skolem">b</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">a</span></span> <span class="quoted"><span class="skolem">b</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> LNil
      <span class="keyword1"><span class="command">from</span></span> LNil<span class="main">[</span><span class="operator">rule_format</span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">{</span>LNil<span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">-</span> <span class="main">{</span>LNil<span class="main">}</span>"</span></span><span class="main">]</span> LNil<span class="main">[</span><span class="operator">rule_format</span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">-</span> <span class="main">{</span>LNil<span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span>LNil<span class="main">}</span>"</span></span><span class="main">]</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> closed_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> lnull_def<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> LCons
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span>
        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?lhd</span></span></span>
          <span class="keyword1"><span class="command">using</span></span> LCons<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">rule_format</span><span class="main">,</span> <span class="operator">OF</span> open_lhd open_lhd<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="quoted">"lhd <span class="skolem">a</span>"</span></span> <span class="quoted"><span class="quoted">"lhd <span class="skolem">b</span>"</span></span><span class="main">]</span> LCons<span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> llist_all2_lhdD<span class="main">)</span>
        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?ltl</span></span></span>
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">safe</span><span class="main">)</span>
          <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">A</span> <span class="skolem">B</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"open <span class="skolem">A</span>"</span></span> <span class="quoted"><span class="quoted">"open <span class="skolem">B</span>"</span></span> <span class="quoted"><span class="quoted">"ltl <span class="skolem">a</span> <span class="main">∈</span> <span class="skolem">A</span>"</span></span> <span class="quoted"><span class="quoted">"ltl <span class="skolem">b</span> <span class="main">∈</span> <span class="skolem">B</span>"</span></span>
          <span class="keyword1"><span class="command">with</span></span> LCons<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">rule_format</span><span class="main">,</span> <span class="operator">OF</span> open_LCons' open_LCons'<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">A</span></span> <span class="quoted"><span class="skolem">B</span></span> <span class="quoted"><span class="quoted">"lhd <span class="skolem">a</span>"</span></span> <span class="quoted"><span class="quoted">"lhd <span class="skolem">b</span>"</span></span><span class="main">]</span> LCons<span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span>
          <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">a'</span><span class="main">∈</span><span class="skolem">A</span><span class="main">.</span> <span class="main">∃</span><span class="bound">b'</span><span class="main">∈</span><span class="skolem">B</span><span class="main">.</span> llist_all2 <span class="free">R</span> <span class="bound">a'</span> <span class="bound">b'</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> not_lnull_conv<span class="main">)</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> closed_def open_prod_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> subset_eq<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="LList_CCPO_Topology-closed_list_all2"><span class="command">lemma</span></span> closed_list_all2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="free">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span><span class="main">::</span>t2_space <span class="main">⇒</span> <span class="tfree">'a</span> llist"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> f<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> isCont <span class="free">f</span> <span class="bound">x</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> g<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> isCont <span class="free">g</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"closed <span class="main">{</span><span class="bound">x</span><span class="main">.</span> llist_all2 <span class="free">R</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">g</span> <span class="bound">x</span><span class="main">)</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span>  continuous_closed_vimage<span class="main">[</span><span class="operator">OF</span> closed_llist_all2  isCont_Pair<span class="main"><span class="main">[</span></span><span class="operator">OF</span> f g<span class="main"><span class="main">]</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="LList_CCPO_Topology-at_botI_lfinite"><span class="command">lemma</span></span> at_botI_lfinite<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">l</span> <span class="main">⟹</span> <span class="keyword1">at</span> <span class="free">l</span> <span class="main">=</span> bot"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> at_eq_bot_iff<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-at_eq_lfinite"><span class="command">lemma</span></span> at_eq_lfinite<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">at</span> <span class="free">l</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> lfinite <span class="free">l</span> <span class="keyword1">then</span> bot <span class="keyword1">else</span> at' <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> at'_def open_singleton_iff_lfinite<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-eventually_lfinite"><span class="command">lemma</span></span> eventually_lfinite<span class="main">:</span> <span class="quoted"><span class="quoted">"eventually lfinite <span class="main">(</span>at' <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> at'_def open_singleton_iff_lfinite eventually_principal eventually_at_topological<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> exI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">{..</span></span> <span class="free"><span class="free">x</span></span><span class="main"><span class="main">}</span></span>"</span></span></span><span class="main"><span class="main">]</span></span> impI conjI open_ccpo_Iic<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> lstrict_prefix_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> lstrict_prefix_lfinite1<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="LList_CCPO_Topology-eventually_nhds_llist"><span class="command">lemma</span></span> eventually_nhds_llist<span class="main">:</span>
  <span class="quoted"><span class="quoted">"eventually <span class="free">P</span> <span class="main">(</span>nhds <span class="free">l</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound"><span class="bound">xs</span></span><span class="main">≤</span><span class="free">l</span><span class="main">.</span> lfinite <span class="bound">xs</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">ys</span></span><span class="main">≥</span><span class="bound">xs</span><span class="main">.</span> <span class="bound">ys</span> <span class="main">≤</span> <span class="free">l</span> <span class="main">⟶</span> <span class="free">P</span> <span class="bound">ys</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> eventually_nhds
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?F</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">l'</span><span class="main">.</span> lprefix <span class="bound">l'</span> <span class="free">l</span> <span class="main">∧</span> lfinite <span class="bound">l'</span><span class="main">}</span>"</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">A</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"open <span class="skolem">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="main">∈</span> <span class="skolem">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">l</span><span class="main">∈</span><span class="skolem">A</span><span class="main">.</span> <span class="free">P</span> <span class="bound">l</span>"</span></span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"chain <span class="var">?F</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="var">?F</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> chain_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lprefix_down_linear<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Sup <span class="var">?F</span> <span class="main">=</span> <span class="free">l</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> Sup_llist_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> lSup_finite_prefixes<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">xs</span><span class="main">.</span> <span class="bound">xs</span> <span class="main">∈</span> <span class="var">?F</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">ys</span></span><span class="main">≥</span><span class="bound">xs</span><span class="main">.</span> <span class="bound">ys</span> <span class="main">∈</span> <span class="var">?F</span> <span class="main">⟶</span> <span class="free">P</span> <span class="bound">ys</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> open_ccpoD<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">A</span></span> <span class="var"><span class="quoted"><span class="var">?F</span></span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound"><span class="bound">xs</span></span><span class="main">≤</span><span class="free">l</span><span class="main">.</span> lfinite <span class="bound">xs</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">ys</span></span><span class="main">≥</span><span class="bound">xs</span><span class="main">.</span> <span class="bound">ys</span> <span class="main">≤</span> <span class="free">l</span> <span class="main">⟶</span> <span class="free">P</span> <span class="bound">ys</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>lifting<span class="main"><span class="main">)</span></span> <span class="quoted"><span class="quoted">‹<span class="free">l</span> <span class="main">∈</span> <span class="skolem">A</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">∀</span><span class="bound">l</span><span class="main">∈</span><span class="skolem">A</span><span class="main">.</span> <span class="free">P</span> <span class="bound">l</span>›</span></span> le_llist_conv_lprefix mem_Collect_eq not_lfinite_lprefix_conv_eq<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">≤</span> <span class="free">l</span>"</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound"><span class="bound">ys</span></span><span class="main">≥</span><span class="skolem">xs</span><span class="main">.</span> <span class="bound">ys</span> <span class="main">≤</span> <span class="free">l</span> <span class="main">⟶</span> <span class="free">P</span> <span class="bound">ys</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">S</span><span class="main">.</span> open <span class="bound">S</span> <span class="main">∧</span> <span class="free">l</span> <span class="main">∈</span> <span class="bound">S</span> <span class="main">∧</span> Ball <span class="bound">S</span> <span class="free">P</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> exI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">{</span></span></span><span class="skolem"><span class="skolem"><span class="skolem">xs</span></span></span> <span class="main"><span class="main"><span class="main">..}</span></span></span> <span class="main"><span class="main"><span class="main">∩</span></span></span> <span class="main"><span class="main"><span class="main">{..</span></span></span> <span class="free"><span class="free"><span class="free">l</span></span></span><span class="main"><span class="main"><span class="main">}</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span> conjI open_Int open_Ici open_ccpo_Iic<span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="LList_CCPO_Topology-nhds_lfinite"><span class="command">lemma</span></span> nhds_lfinite<span class="main">:</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">l</span> <span class="main">⟹</span> nhds <span class="free">l</span> <span class="main">=</span> principal <span class="main">{</span><span class="free">l</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> filter_eq_iff eventually_principal eventually_nhds_llist
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> le_llist_conv_lprefix<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-eventually_at'_llist"><span class="command">lemma</span></span> eventually_at'_llist<span class="main">:</span>
  <span class="quoted"><span class="quoted">"eventually <span class="free">P</span> <span class="main">(</span>at' <span class="free">l</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound"><span class="bound">xs</span></span><span class="main">≤</span><span class="free">l</span><span class="main">.</span> lfinite <span class="bound">xs</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">ys</span></span><span class="main">≥</span><span class="bound">xs</span><span class="main">.</span> lfinite <span class="bound">ys</span> <span class="main">⟶</span> <span class="bound">ys</span> <span class="main">≤</span> <span class="free">l</span> <span class="main">⟶</span> <span class="free">P</span> <span class="bound">ys</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eventually_filtermap at'_def open_singleton_iff_lfinite
                       eventually_principal lfinite_eq_range_llist_of<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lfinite <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> eventually_filtermap at'_def open_singleton_iff_lfinite
                   eventually_at_filter eventually_nhds_llist<span class="main">)</span>
       <span class="main">(</span><span class="operator">metis</span> not_lfinite_lprefix_conv_eq<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="LList_CCPO_Topology-eventually_at'_llistI"><span class="command">lemma</span></span> eventually_at'_llistI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">xs</span><span class="main">.</span> lfinite <span class="bound">xs</span> <span class="main">⟹</span> <span class="bound">xs</span> <span class="main">≤</span> <span class="free">l</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">xs</span><span class="main">)</span> <span class="main">⟹</span> eventually <span class="free">P</span> <span class="main">(</span>at' <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> eventually_at'_llist<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-Lim_at'_lfinite"><span class="command">lemma</span></span> Lim_at'_lfinite<span class="main">:</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span> <span class="main">⟹</span> Lim <span class="main">(</span>at' <span class="free">xs</span><span class="main">)</span> <span class="free">f</span> <span class="main">=</span> <span class="free">f</span> <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> tendsto_Lim<span class="main"><span class="main">[</span></span><span class="operator">OF</span> at'_bot<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> at'_def topological_tendstoI eventually_principal<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-filterlim_at'_list"><span class="command">lemma</span></span> filterlim_at'_list<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">⤏</span> <span class="free">y</span><span class="main">)</span> <span class="main">(</span>at' <span class="main">(</span><span class="free">x</span><span class="main">::</span><span class="tfree">'a</span> llist<span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">─</span><span class="free">x</span><span class="main">→</span> <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> at'_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> open_singleton_iff_lfinite<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-tendsto_mcont_llist'"><span class="command">lemma</span></span> tendsto_mcont_llist'<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont lSup lprefix lSup lprefix <span class="free">f</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">f</span> <span class="main">⤏</span> <span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span>at' <span class="main">(</span><span class="free">x</span> <span class="main">::</span> <span class="tfree">'a</span> llist<span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> at'_def nhds_lfinite<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> open_singleton_iff_lfinite tendsto_at_iff_tendsto_nhds<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> tendsto_mcont_llist<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-tendsto_closed"><span class="command">lemma</span></span> tendsto_closed<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> eq<span class="main">:</span> <span class="quoted"><span class="quoted">"closed <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ev<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">ys</span><span class="main">.</span> lfinite <span class="bound">ys</span> <span class="main">⟹</span> <span class="bound">ys</span> <span class="main">≤</span> <span class="free">x</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> Lim_in_closed_set<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"eventually <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span>at' <span class="free">x</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> eq <span class="keyword1"><span class="command">using</span></span> ev
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> eventually_at'_llistI<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">rule</span> assms tendsto_id_at' at'_bot<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1" id="LList_CCPO_Topology-tendsto_Sup_at'"><span class="command">lemma</span></span> tendsto_Sup_at'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>ccpo_topology"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> f<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">y</span> <span class="main">⟹</span> lfinite <span class="bound">x</span> <span class="main">⟹</span> lfinite <span class="bound">y</span> <span class="main">⟹</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">≤</span> <span class="free">f</span> <span class="bound">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">⤏</span> <span class="main">(</span>Sup <span class="main">(</span><span class="free">f</span><span class="main">`</span><span class="main">{</span><span class="bound">xs</span><span class="main">.</span> lfinite <span class="bound">xs</span> <span class="main">∧</span> <span class="bound">xs</span> <span class="main">≤</span> <span class="free">l</span><span class="main">}</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>at' <span class="free">l</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> topological_tendstoI<span class="main">)</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?F</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">xs</span><span class="main">.</span> lfinite <span class="bound">xs</span> <span class="main">∧</span> <span class="bound">xs</span> <span class="main">≤</span> <span class="free">l</span><span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">have</span></span> ch_F<span class="main">:</span> <span class="quoted"><span class="quoted">"chain <span class="main">(</span><span class="free">f</span><span class="main">`</span><span class="var">?F</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span><span class="main">`</span><span class="var">?F</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> chain_imageI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> chain_subset<span class="main"><span class="main">,</span></span> <span class="operator">OF</span> lprefixes_chain<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> f<span class="main">)</span>

  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">A</span> <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"open <span class="skolem">A</span>"</span></span> <span class="quoted"><span class="quoted">"Sup <span class="main">(</span><span class="free">f</span><span class="main">`</span><span class="var">?F</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">A</span>"</span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"eventually <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">∈</span> <span class="skolem">A</span><span class="main">)</span> <span class="main">(</span>at' <span class="free">l</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> open_ccpoD<span class="main">[</span><span class="operator">OF</span> _ ch_F<span class="main">,</span> <span class="operator">OF</span> A<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> eventually_at'_llist f <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> le_llist_conv_lprefix<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="LList_CCPO_Topology-tendsto_Lim_at'"><span class="command">lemma</span></span> tendsto_Lim_at'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>ccpo_topology"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> f<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">l</span><span class="main">.</span> <span class="free">f</span> <span class="bound">l</span> <span class="main">=</span> Lim <span class="main">(</span>at' <span class="bound">l</span><span class="main">)</span> <span class="free">f'</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">y</span> <span class="main">⟹</span> lfinite <span class="bound">x</span> <span class="main">⟹</span> lfinite <span class="bound">y</span> <span class="main">⟹</span> <span class="free">f'</span> <span class="bound">x</span> <span class="main">≤</span> <span class="free">f'</span> <span class="bound">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">⤏</span> <span class="free">f</span> <span class="free">l</span><span class="main">)</span> <span class="main">(</span>at' <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> f<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> filterlim_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl refl eventually_mono<span class="main"><span class="main">[</span></span><span class="operator">OF</span> eventually_lfinite Lim_at'_lfinite<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> tendsto_LimI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> tendsto_Sup_at'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mono<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1" id="LList_CCPO_Topology-isCont_LCons"><span class="command">lemma</span></span> isCont_LCons<span class="main">[</span><span class="operator">THEN</span> isCont_o2<span class="main"><span class="main"><span class="main"><span class="main">[</span></span></span></span><span class="operator"><span class="operator"><span class="operator">rotated</span></span></span><span class="main"><span class="main"><span class="main"><span class="main">]</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"isCont <span class="main">(</span>LCons <span class="free">x</span><span class="main">)</span> <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> isCont_def tendsto_LCons tendsto_ident_at<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-isCont_lmap"><span class="command">lemma</span></span> isCont_lmap<span class="main">[</span><span class="operator">THEN</span> isCont_o2<span class="main"><span class="main"><span class="main"><span class="main">[</span></span></span></span><span class="operator"><span class="operator"><span class="operator">rotated</span></span></span><span class="main"><span class="main"><span class="main"><span class="main">]</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"isCont <span class="main">(</span>lmap <span class="free">f</span><span class="main">)</span> <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> isCont_def tendsto_lmap tendsto_ident_at<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-isCont_lappend"><span class="command">lemma</span></span> isCont_lappend<span class="main">[</span><span class="operator">THEN</span> isCont_o2<span class="main"><span class="main"><span class="main"><span class="main">[</span></span></span></span><span class="operator"><span class="operator"><span class="operator">rotated</span></span></span><span class="main"><span class="main"><span class="main"><span class="main">]</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"isCont <span class="main">(</span>lappend <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> isCont_def tendsto_lappend2 tendsto_ident_at<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-isCont_lset"><span class="command">lemma</span></span> isCont_lset<span class="main">[</span><span class="operator">THEN</span> isCont_o2<span class="main"><span class="main"><span class="main"><span class="main">[</span></span></span></span><span class="operator"><span class="operator"><span class="operator">rotated</span></span></span><span class="main"><span class="main"><span class="main"><span class="main">]</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"isCont lset <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> isCont_def tendsto_lset tendsto_ident_at<span class="main">)</span>



<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Define <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">lfilter</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> as continuous extension›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">lfilter'</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> Lim <span class="main">(</span>at' <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> llist_of <span class="main">(</span>filter <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">(</span>list_of <span class="bound">xs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="LList_CCPO_Topology-tendsto_lfilter"><span class="command">lemma</span></span> tendsto_lfilter<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>lfilter' <span class="free">P</span> <span class="main">⤏</span> lfilter' <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>at' <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> tendsto_Lim_at'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lfilter'_def<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lfinite_eq_range_llist_of less_eq_list_def prefix_def<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-isCont_lfilter"><span class="command">lemma</span></span> isCont_lfilter<span class="main">[</span><span class="operator">THEN</span> isCont_o2<span class="main"><span class="main"><span class="main"><span class="main">[</span></span></span></span><span class="operator"><span class="operator"><span class="operator">rotated</span></span></span><span class="main"><span class="main"><span class="main"><span class="main">]</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"isCont <span class="main">(</span>lfilter' <span class="free">P</span><span class="main">)</span> <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> isCont_def filterlim_at'_list tendsto_lfilter<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-lfilter'_lfinite"><span class="command">lemma</span></span> lfilter'_lfinite<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span> <span class="main">⟹</span> lfilter' <span class="free">P</span> <span class="free">xs</span> <span class="main">=</span> llist_of <span class="main">(</span>filter <span class="free">P</span> <span class="main">(</span>list_of <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lfilter'_def Lim_at'_lfinite<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-lfilter'_LNil"><span class="command">lemma</span></span> lfilter'_LNil<span class="main">:</span> <span class="quoted"><span class="quoted">"lfilter' <span class="free">P</span> LNil <span class="main">=</span> LNil"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="LList_CCPO_Topology-lfilter'_LCons"><span class="command">lemma</span></span> lfilter'_LCons <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lfilter' <span class="free">P</span> <span class="main">(</span>LCons <span class="free">a</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">P</span> <span class="free">a</span> <span class="keyword1">then</span> LCons <span class="free">a</span> <span class="main">(</span>lfilter' <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="keyword1">else</span> lfilter' <span class="free">P</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> tendsto_closed<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">xs</span></span></span></span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">OF</span> closed_Collect_eq_isCont<span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> isCont_lfilter isCont_LCons isCont_If<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-ldistinct_lfilter'"><span class="command">lemma</span></span> ldistinct_lfilter'<span class="main">:</span> <span class="quoted"><span class="quoted">"ldistinct <span class="free">l</span> <span class="main">⟹</span> ldistinct <span class="main">(</span>lfilter' <span class="free">P</span> <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> tendsto_closed<span class="main"><span class="main">[</span></span><span class="operator">OF</span> closed_ldistinct'<span class="main"><span class="main">,</span></span> <span class="operator">OF</span> isCont_lfilter<span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> distinct_filter <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> ldistinct_lprefix <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> lfinite_eq_range_llist_of<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-lfilter'_lmap"><span class="command">lemma</span></span> lfilter'_lmap<span class="main">:</span> <span class="quoted"><span class="quoted">"lfilter' <span class="free">P</span> <span class="main">(</span>lmap <span class="free">f</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lmap <span class="free">f</span> <span class="main">(</span>lfilter' <span class="main">(</span><span class="free">P</span> <span class="main">∘</span> <span class="free">f</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> tendsto_closed<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">xs</span></span></span></span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">OF</span> closed_Collect_eq_isCont<span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> filter_map comp_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> isCont_lmap isCont_lfilter<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-lfilter'_lfilter'"><span class="command">lemma</span></span> lfilter'_lfilter'<span class="main">:</span> <span class="quoted"><span class="quoted">"lfilter' <span class="free">P</span> <span class="main">(</span>lfilter' <span class="free">Q</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lfilter' <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">x</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span> <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> tendsto_closed<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">xs</span></span></span></span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">OF</span> closed_Collect_eq_isCont<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> isCont_lfilter<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-lfilter'_LNil_I"><span class="command">lemma</span></span> lfilter'_LNil_I<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> lset <span class="free">xs</span><span class="main">.</span> <span class="main">¬</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⟹</span> lfilter' <span class="free">P</span> <span class="free">xs</span> <span class="main">=</span> LNil"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> tendsto_closed<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">xs</span></span></span></span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">OF</span> closed_Collect_eq_isCont<span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lfinite_eq_range_llist_of llist_of_eq_LNil_conv filter_empty_conv <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> isCont_lfilter <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> lprefix_lsetD<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-lset_lfilter'"><span class="command">lemma</span></span> lset_lfilter'<span class="main">:</span> <span class="quoted"><span class="quoted">"lset <span class="main">(</span>lfilter' <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lset <span class="free">xs</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> tendsto_closed<span class="main"><span class="main">[</span></span><span class="operator">OF</span> closed_Collect_eq_isCont<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> isCont_lset isCont_lfilter isCont_inf2<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-lfilter'_eq_LNil_iff"><span class="command">lemma</span></span> lfilter'_eq_LNil_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"lfilter' <span class="free">P</span> <span class="free">xs</span> <span class="main">=</span> LNil <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">∈</span>lset <span class="free">xs</span><span class="main">.</span> <span class="main">¬</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> lset_lfilter'<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">P</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="LList_CCPO_Topology-lfilter'_eq_lfilter"><span class="command">lemma</span></span> lfilter'_eq_lfilter<span class="main">:</span> <span class="quoted"><span class="quoted">"lfilter' <span class="free">P</span> <span class="free">xs</span> <span class="main">=</span> lfilter <span class="free">P</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> isCont_lfilter
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> tendsto_closed<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">xs</span></span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">OF</span> closed_Collect_eq_isCont<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">ys</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="skolem">ys</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"lfilter' <span class="free">P</span> <span class="skolem">ys</span> <span class="main">=</span> lfilter <span class="free">P</span> <span class="skolem">ys</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">induction</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> isCont_def tendsto_mcont_llist mcont_lfilter<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Define <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">lconcat</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> as continuous extension›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">lconcat'</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> Lim <span class="main">(</span>at' <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> foldr lappend <span class="main">(</span>list_of <span class="bound">xs</span><span class="main">)</span> LNil<span class="main">)</span>"</span></span>

<span class="keyword1" id="LList_CCPO_Topology-tendsto_lconcat'"><span class="command">lemma</span></span> tendsto_lconcat'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>lconcat' <span class="main">⤏</span> lconcat' <span class="free">xss</span><span class="main">)</span> <span class="main">(</span>at' <span class="free">xss</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> tendsto_Lim_at'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lconcat'_def<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lfinite_eq_range_llist_of less_eq_list_def prefix_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="improper"><span class="quoted"><span class="improper">xa</span></span></span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="LList_CCPO_Topology-isCont_lconcat'"><span class="command">lemma</span></span> isCont_lconcat'<span class="main">[</span><span class="operator">THEN</span> isCont_o2<span class="main"><span class="main"><span class="main"><span class="main">[</span></span></span></span><span class="operator"><span class="operator"><span class="operator">rotated</span></span></span><span class="main"><span class="main"><span class="main"><span class="main">]</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"isCont lconcat' <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> isCont_def filterlim_at'_list tendsto_lconcat'<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-lconcat'_lfinite"><span class="command">lemma</span></span> lconcat'_lfinite<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span> <span class="main">⟹</span> lconcat' <span class="free">xs</span> <span class="main">=</span> foldr lappend <span class="main">(</span>list_of <span class="free">xs</span><span class="main">)</span> LNil"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lconcat'_def Lim_at'_lfinite<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-lconcat'_LNil"><span class="command">lemma</span></span> lconcat'_LNil<span class="main">:</span> <span class="quoted"><span class="quoted">"lconcat' LNil <span class="main">=</span> LNil"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="LList_CCPO_Topology-lconcat'_LCons"><span class="command">lemma</span></span> lconcat'_LCons <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lconcat' <span class="main">(</span>LCons <span class="free">l</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lappend <span class="free">l</span> <span class="main">(</span>lconcat' <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> tendsto_closed<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">xs</span></span></span></span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">OF</span> closed_Collect_eq_isCont<span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> isCont_lconcat' isCont_lappend isCont_LCons<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-lmap_lconcat"><span class="command">lemma</span></span> lmap_lconcat<span class="main">:</span> <span class="quoted"><span class="quoted">"lmap <span class="free">f</span> <span class="main">(</span>lconcat' <span class="free">xss</span><span class="main">)</span> <span class="main">=</span> lconcat' <span class="main">(</span>lmap <span class="main">(</span>lmap <span class="free">f</span><span class="main">)</span> <span class="main">(</span><span class="free">xss</span><span class="main">::</span><span class="tfree">'a</span> llist llist<span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> tendsto_closed<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">xss</span></span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">OF</span> closed_Collect_eq_isCont<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist llist"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="skolem">xs</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"lmap <span class="free">f</span> <span class="main">(</span>lconcat' <span class="skolem">xs</span><span class="main">)</span> <span class="main">=</span> lconcat' <span class="main">(</span>lmap <span class="main">(</span>lmap <span class="free">f</span><span class="main">)</span> <span class="skolem">xs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lfinite.induct<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> lmap_lappend_distrib<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">intro</span> isCont_lconcat' isCont_lappend isCont_LCons continuous_ident isCont_lmap<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> tendsto_Sup<span class="main">[</span><span class="operator">THEN</span> tendsto_compose<span class="main">,</span> <span class="operator">tendsto_intros</span><span class="main">]</span> <span class="main">=</span>
  mcont_SUP<span class="main">[</span><span class="operator">OF</span> mcont_id' mcont_const<span class="main">,</span> <span class="operator">THEN</span> tendsto_mcont<span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> fin<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">xs</span><span class="main">∈</span>lset <span class="free">xss</span><span class="main">.</span> lfinite <span class="bound">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lset <span class="main">(</span>lconcat' <span class="free">xss</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">xs</span><span class="main">∈</span>lset <span class="free">xss</span><span class="main">.</span> lset <span class="bound">xs</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> tendsto_unique_eventually<span class="main"><span class="main">[</span></span><span class="operator">OF</span> at'_bot<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"eventually <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> lset <span class="main">(</span>lconcat' <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">y</span><span class="main">∈</span>lset <span class="bound">x</span><span class="main">.</span> lset <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>at' <span class="free">xss</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> eventually_at'_llistI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xss'</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="skolem">xss'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xss'</span> <span class="main">≤</span> <span class="free">xss</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">xs</span><span class="main">∈</span>lset <span class="skolem">xss'</span><span class="main">.</span> lfinite <span class="bound">xs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fin <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> lprefix_lsetD<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹lfinite <span class="skolem">xss'</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"lset <span class="main">(</span>lconcat' <span class="skolem">xss'</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">xs</span><span class="main">∈</span>lset <span class="skolem">xss'</span><span class="main">.</span> lset <span class="bound">xs</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xss'</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">rule</span> <span class="dynamic"><span class="dynamic">tendsto_intros</span></span> tendsto_lconcat' tendsto_id_at'<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Define <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">ldropWhile</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> as continuous extension›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">ldropWhile'</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> Lim <span class="main">(</span>at' <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> llist_of <span class="main">(</span>dropWhile <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">(</span>list_of <span class="bound">xs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="LList_CCPO_Topology-tendsto_ldropWhile'"><span class="command">lemma</span></span> tendsto_ldropWhile'<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>ldropWhile' <span class="free">P</span> <span class="main">⤏</span> ldropWhile' <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>at' <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> tendsto_Lim_at'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ldropWhile'_def<span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lfinite_eq_range_llist_of less_eq_list_def prefix_def dropWhile_append dropWhile_False<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-isCont_ldropWhile'"><span class="command">lemma</span></span> isCont_ldropWhile'<span class="main">[</span><span class="operator">THEN</span> isCont_o2<span class="main"><span class="main"><span class="main"><span class="main">[</span></span></span></span><span class="operator"><span class="operator"><span class="operator">rotated</span></span></span><span class="main"><span class="main"><span class="main"><span class="main">]</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"isCont <span class="main">(</span>ldropWhile' <span class="free">P</span><span class="main">)</span> <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> isCont_def filterlim_at'_list tendsto_ldropWhile'<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-ldropWhile'_lfinite"><span class="command">lemma</span></span> ldropWhile'_lfinite<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span> <span class="main">⟹</span> ldropWhile' <span class="free">P</span> <span class="free">xs</span> <span class="main">=</span> llist_of <span class="main">(</span>dropWhile <span class="free">P</span> <span class="main">(</span>list_of <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldropWhile'_def Lim_at'_lfinite<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-ldropWhile'_LNil"><span class="command">lemma</span></span> ldropWhile'_LNil<span class="main">:</span> <span class="quoted"><span class="quoted">"ldropWhile' <span class="free">P</span> LNil <span class="main">=</span> LNil"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="LList_CCPO_Topology-ldropWhile'_LCons"><span class="command">lemma</span></span> ldropWhile'_LCons <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ldropWhile' <span class="free">P</span> <span class="main">(</span>LCons <span class="free">l</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">P</span> <span class="free">l</span> <span class="keyword1">then</span> ldropWhile' <span class="free">P</span> <span class="free">xs</span> <span class="keyword1">else</span> LCons <span class="free">l</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> tendsto_closed<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">xs</span></span></span></span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">OF</span> closed_Collect_eq_isCont<span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> isCont_ldropWhile' isCont_If isCont_LCons<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"ldropWhile' <span class="free">P</span> <span class="main">(</span>lmap <span class="free">f</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lmap <span class="free">f</span> <span class="main">(</span>ldropWhile' <span class="main">(</span><span class="free">P</span> <span class="main">∘</span> <span class="free">f</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> tendsto_closed<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">xs</span></span></span></span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">OF</span> closed_Collect_eq_isCont<span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dropWhile_map comp_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> isCont_lmap isCont_ldropWhile'<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-ldropWhile'_LNil_I"><span class="command">lemma</span></span> ldropWhile'_LNil_I<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> lset <span class="free">xs</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="main">⟹</span> ldropWhile' <span class="free">P</span> <span class="free">xs</span> <span class="main">=</span> LNil"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> tendsto_closed<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">xs</span></span></span></span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">OF</span> closed_Collect_eq_isCont<span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_of_eq_LNil_conv <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> isCont_lmap isCont_ldropWhile' <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> lprefix_lsetD<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-lnull_ldropWhile'"><span class="command">lemma</span></span> lnull_ldropWhile'<span class="main">:</span> <span class="quoted"><span class="quoted">"lnull <span class="main">(</span>ldropWhile' <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> lset <span class="free">xs</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="main">_</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> iffI ballI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> lset <span class="free">xs</span>"</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1" id="LList_CCPO_Topology-lhd_lfilter'"><span class="command">lemma</span></span> lhd_lfilter'<span class="main">:</span> <span class="quoted"><span class="quoted">"lhd <span class="main">(</span>lfilter' <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lhd <span class="main">(</span>ldropWhile' <span class="main">(</span>Not <span class="main">∘</span> <span class="free">P</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span><span class="main">∈</span>lset <span class="free">xs</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> lset <span class="free">xs</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> lset <span class="free">xs</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">‹<span class="free">P</span> <span class="skolem">x</span>›</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Define <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>ldrop›</span></span></span></span> as continuous extension›</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">edrop</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">edrop</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">[]</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">edrop</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">of</span> eSuc <span class="bound">n</span> <span class="main">⇒</span> <span class="free">edrop</span> <span class="bound">n</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">|</span> <span class="main">0</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="LList_CCPO_Topology-mono_edrop"><span class="command">lemma</span></span> mono_edrop<span class="main">:</span> <span class="quoted"><span class="quoted">"edrop <span class="free">n</span> <span class="free">xs</span> <span class="main">≤</span> edrop <span class="free">n</span> <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> enat_cosplit<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-edrop_mono"><span class="command">lemma</span></span> edrop_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≤</span> <span class="free">ys</span> <span class="main">⟹</span> edrop <span class="free">n</span> <span class="free">xs</span> <span class="main">≤</span> edrop <span class="free">n</span> <span class="free">ys</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> mono_edrop<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_eq_list_def prefix_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">ldrop'</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> Lim <span class="main">(</span>at' <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">(</span>llist_of <span class="main">∘</span> edrop <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">∘</span> list_of<span class="main">)</span>"</span></span>

<span class="keyword1" id="LList_CCPO_Topology-ldrop'_lfinite"><span class="command">lemma</span></span> ldrop'_lfinite<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span> <span class="main">⟹</span> ldrop' <span class="free">n</span> <span class="free">xs</span> <span class="main">=</span> llist_of <span class="main">(</span>edrop <span class="free">n</span> <span class="main">(</span>list_of <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldrop'_def Lim_at'_lfinite<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-tendsto_ldrop'"><span class="command">lemma</span></span> tendsto_ldrop'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>ldrop' <span class="free">n</span> <span class="main">⤏</span> ldrop' <span class="free">n</span> <span class="free">l</span><span class="main">)</span> <span class="main">(</span>at' <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> tendsto_Lim_at'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ldrop'_def<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lfinite_eq_range_llist_of <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> edrop_mono<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-isCont_ldrop'"><span class="command">lemma</span></span> isCont_ldrop'<span class="main">[</span><span class="operator">THEN</span> isCont_o2<span class="main"><span class="main"><span class="main"><span class="main">[</span></span></span></span><span class="operator"><span class="operator"><span class="operator">rotated</span></span></span><span class="main"><span class="main"><span class="main"><span class="main">]</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"isCont <span class="main">(</span>ldrop' <span class="free">n</span><span class="main">)</span> <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> isCont_def filterlim_at'_list tendsto_ldrop'<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"ldrop' <span class="free">n</span> LNil <span class="main">=</span> LNil"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"ldrop' <span class="free">n</span> <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">n</span> <span class="keyword1">of</span> <span class="main">0</span> <span class="main">⇒</span> LCons <span class="free">x</span> <span class="free">xs</span> <span class="main">|</span> eSuc <span class="bound">n</span> <span class="main">⇒</span> ldrop' <span class="bound">n</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> tendsto_closed<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">xs</span></span></span></span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">OF</span> closed_Collect_eq_isCont<span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> isCont_ldrop' isCont_enat_case isCont_LCons <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> enat_cosplit<span class="main">)</span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">up</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> order <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">up</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">[]</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">up</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free">up</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">else</span> <span class="free">up</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="LList_CCPO_Topology-set_upD"><span class="command">lemma</span></span> set_upD<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> set <span class="main">(</span>up <span class="free">y</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">∈</span> set <span class="free">xs</span> <span class="main">∧</span> <span class="free">y</span> <span class="main">&lt;</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">y</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> less_trans<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-prefix_up"><span class="command">lemma</span></span> prefix_up<span class="main">:</span> <span class="quoted"><span class="quoted">"prefix <span class="main">(</span>up <span class="free">a</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>up <span class="free">a</span> <span class="main">(</span><span class="free">xs</span> <span class="main">@</span>  <span class="free">ys</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">a</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="LList_CCPO_Topology-mono_up"><span class="command">lemma</span></span> mono_up<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≤</span> <span class="free">ys</span> <span class="main">⟹</span> up <span class="free">a</span> <span class="free">xs</span> <span class="main">≤</span> up <span class="free">a</span> <span class="free">ys</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> less_eq_list_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> prefix_def<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> prefix_up<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-sorted_up"><span class="command">lemma</span></span> sorted_up<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted <span class="main">(</span>up <span class="free">a</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">a</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> set_upD <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> less_imp_le<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Define more functions on lazy lists as continuous extensions›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">lup</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> Lim <span class="main">(</span>at' <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> llist_of <span class="main">(</span>up <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">(</span>list_of <span class="bound">xs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="LList_CCPO_Topology-tendsto_lup"><span class="command">lemma</span></span> tendsto_lup<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>lup <span class="free">a</span> <span class="main">⤏</span> lup <span class="free">a</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>at' <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> tendsto_Lim_at'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lup_def<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> lfinite_eq_range_llist_of mono_up<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-isCont_lup"><span class="command">lemma</span></span> isCont_lup<span class="main">[</span><span class="operator">THEN</span> isCont_o2<span class="main"><span class="main"><span class="main"><span class="main">[</span></span></span></span><span class="operator"><span class="operator"><span class="operator">rotated</span></span></span><span class="main"><span class="main"><span class="main"><span class="main">]</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"isCont <span class="main">(</span>lup <span class="free">a</span><span class="main">)</span> <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> isCont_def filterlim_at'_list tendsto_lup<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-lup_lfinite"><span class="command">lemma</span></span> lup_lfinite<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span> <span class="main">⟹</span> lup <span class="free">a</span> <span class="free">xs</span> <span class="main">=</span> llist_of <span class="main">(</span>up <span class="free">a</span> <span class="main">(</span>list_of <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lup_def Lim_at'_lfinite<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-lup_LNil"><span class="command">lemma</span></span> lup_LNil<span class="main">:</span> <span class="quoted"><span class="quoted">"lup <span class="free">a</span> LNil <span class="main">=</span> LNil"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="LList_CCPO_Topology-lup_LCons"><span class="command">lemma</span></span> lup_LCons <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lup <span class="free">a</span> <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">a</span> <span class="main">&lt;</span> <span class="free">x</span> <span class="keyword1">then</span> LCons <span class="free">x</span> <span class="main">(</span>lup <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="keyword1">else</span> lup <span class="free">a</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> tendsto_closed<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">xs</span></span></span></span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">OF</span> closed_Collect_eq_isCont<span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> isCont_lup isCont_If isCont_LCons<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-lset_lup"><span class="command">lemma</span></span> lset_lup<span class="main">:</span> <span class="quoted"><span class="quoted">"lset <span class="main">(</span>lup <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⊆</span> lset <span class="free">xs</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">y</span><span class="main">.</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="bound">y</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> tendsto_le_ccpo<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> g<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">λ</span></span></span><span class="bound"><span class="bound"><span class="bound">xs</span></span></span><span class="main"><span class="main"><span class="main">.</span></span></span> lset <span class="main"><span class="main"><span class="main">(</span></span></span>lup <span class="free"><span class="free"><span class="free">x</span></span></span> <span class="bound"><span class="bound"><span class="bound">xs</span></span></span><span class="main"><span class="main"><span class="main">)</span></span></span>"</span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">λ</span></span></span><span class="bound"><span class="bound"><span class="bound">xs</span></span></span><span class="main"><span class="main"><span class="main">.</span></span></span> lset <span class="bound"><span class="bound"><span class="bound">xs</span></span></span> <span class="main"><span class="main"><span class="main">∩</span></span></span> <span class="main"><span class="main"><span class="main">{</span></span></span><span class="bound"><span class="bound"><span class="bound">y</span></span></span><span class="main"><span class="main"><span class="main">.</span></span></span> <span class="free"><span class="free"><span class="free">x</span></span></span> <span class="main"><span class="main"><span class="main">&lt;</span></span></span> <span class="bound"><span class="bound"><span class="bound">y</span></span></span><span class="main"><span class="main"><span class="main">}</span></span></span>"</span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> F<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"at' <span class="free"><span class="free"><span class="free">xs</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> lprefix_lsetD set_upD <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span>  <span class="dynamic"><span class="dynamic">tendsto_intros</span></span> at'_bot tendsto_lup eventually_at'_llistI<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-lsorted_lup"><span class="command">lemma</span></span> lsorted_lup<span class="main">:</span> <span class="quoted"><span class="quoted">"lsorted <span class="main">(</span>lup <span class="main">(</span><span class="free">a</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>linorder<span class="main">)</span> <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> tendsto_closed<span class="main"><span class="main">[</span></span><span class="operator">OF</span> closed_lsorted'<span class="main"><span class="main">,</span></span> <span class="operator">OF</span> isCont_lup<span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> sorted_up <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> lprefix_conv_lappend<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">function_internals</span><span class="main">]</span><span class="main">]</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">partial_function</span></span> <span class="main">(</span>llist<span class="main">)</span> <span class="entity">lup'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ord <span class="main">⇒</span> <span class="tfree">'a</span> llist <span class="main">⇒</span> <span class="tfree">'a</span> llist"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lup'</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">of</span> LNil <span class="main">⇒</span> LNil <span class="main">|</span> LCons <span class="bound">x</span> <span class="bound">xs</span> <span class="main">⇒</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">&lt;</span> <span class="bound">x</span> <span class="keyword1">then</span> LCons <span class="bound">x</span> <span class="main">(</span><span class="free">lup'</span> <span class="bound">x</span> <span class="bound">xs</span><span class="main">)</span> <span class="keyword1">else</span> <span class="free">lup'</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="bound">xs</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">declare</span></span> lup'.mono<span class="main">[</span><span class="operator">cont_intro</span><span class="main">]</span>

<span class="keyword1" id="LList_CCPO_Topology-monotone_lup'"><span class="command">lemma</span></span> monotone_lup'<span class="main">:</span> <span class="quoted"><span class="quoted">"monotone <span class="main">(</span>rel_prod <span class="main">(=)</span> lprefix<span class="main">)</span> lprefix <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">xs</span><span class="main">)</span><span class="main">.</span> lup' <span class="bound">a</span> <span class="bound">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> llist.fixp_preserves_mono2<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lup'.mono lup'_def<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1" id="LList_CCPO_Topology-mono2mono_lup'2"><span class="command">lemma</span></span> mono2mono_lup'2<span class="main">[</span><span class="operator">THEN</span> llist.mono2mono<span class="main">,</span> <span class="operator">simp</span><span class="main">,</span> <span class="operator">cont_intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> monotone_lup'2<span class="main">:</span> <span class="quoted"><span class="quoted">"monotone lprefix lprefix <span class="main">(</span>lup' <span class="free">a</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> monotone_lup' <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="LList_CCPO_Topology-mcont_lup'"><span class="command">lemma</span></span> mcont_lup'<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont <span class="main">(</span>prod_lub the_Sup lSup<span class="main">)</span> <span class="main">(</span>rel_prod <span class="main">(=)</span> lprefix<span class="main">)</span> lSup lprefix <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">xs</span><span class="main">)</span><span class="main">.</span> lup' <span class="bound">a</span> <span class="bound">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> llist.fixp_preserves_mcont2<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lup'.mono lup'_def<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1" id="LList_CCPO_Topology-mcont2mcont_lup'2"><span class="command">lemma</span></span> mcont2mcont_lup'2<span class="main">[</span><span class="operator">THEN</span> llist.mcont2mcont<span class="main">,</span> <span class="operator">simp</span><span class="main">,</span> <span class="operator">cont_intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> mcont_lup'2<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont lSup lprefix lSup lprefix <span class="main">(</span>lup' <span class="free">a</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> mcont_lup' <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">simps_of_case</span></span> lup'_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> lup'.simps

<span class="keyword1" id="LList_CCPO_Topology-lset_lup'_subset"><span class="command">lemma</span></span> lset_lup'_subset<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">::</span> preorder"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lset <span class="main">(</span>lup' <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⊆</span> lset <span class="free">xs</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">y</span><span class="main">.</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="bound">y</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> less_trans<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-in_lset_lup'D"><span class="command">lemma</span></span> in_lset_lup'D<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">::</span> preorder"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> lset <span class="main">(</span>lup' <span class="free">x</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> lset <span class="free">xs</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> lset_lup'_subset<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">]</span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="LList_CCPO_Topology-lsorted_lup'"><span class="command">lemma</span></span> lsorted_lup'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">::</span> preorder"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lsorted <span class="main">(</span>lup' <span class="free">x</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lsorted_LCons <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> in_lset_lup'D <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> less_imp_le<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-ldistinct_lup'"><span class="command">lemma</span></span> ldistinct_lup'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">::</span> preorder"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ldistinct <span class="main">(</span>lup' <span class="free">x</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> in_lset_lup'D<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">partial_function</span></span> <span class="main">(</span>llist<span class="main">)</span> <span class="entity">iterate</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> llist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">iterate</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> LCons <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="free">iterate</span> <span class="main">(</span><span class="free">f</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="LList_CCPO_Topology-lmap_iterate"><span class="command">lemma</span></span> lmap_iterate<span class="main">:</span> <span class="quoted"><span class="quoted">"lmap <span class="free">f</span> <span class="main">(</span>iterate <span class="free">x</span><span class="main">)</span> <span class="main">=</span> iterate <span class="main">(</span><span class="free">f</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> iterate.fixp_induct<span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">extup</span> <span class="entity">extdown</span>  <span class="main">::</span> <span class="quoted"><span class="quoted">"int <span class="main">⇒</span> int list <span class="main">⇒</span> int list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">extup</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">[]</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">extup</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">then</span> <span class="free">extup</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">#</span> <span class="free">extdown</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">extdown</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">[]</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">extdown</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">≥</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">then</span> <span class="free">extdown</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">#</span> <span class="free">extup</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="LList_CCPO_Topology-prefix_ext"><span class="command">lemma</span></span> prefix_ext<span class="main">:</span>
  <span class="quoted"><span class="quoted">"prefix <span class="main">(</span>extup <span class="free">a</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>extup <span class="free">a</span> <span class="main">(</span><span class="free">xs</span> <span class="main">@</span>  <span class="free">ys</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"prefix <span class="main">(</span>extdown <span class="free">a</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>extdown <span class="free">a</span> <span class="main">(</span><span class="free">xs</span> <span class="main">@</span>  <span class="free">ys</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">a</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="LList_CCPO_Topology-mono_ext"><span class="command">lemma</span></span> mono_ext<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≤</span> <span class="free">ys</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"extup <span class="free">a</span> <span class="free">xs</span> <span class="main">≤</span> extup <span class="free">a</span> <span class="free">ys</span>"</span></span> <span class="quoted"><span class="quoted">"extdown <span class="free">a</span> <span class="free">xs</span> <span class="main">≤</span> extdown <span class="free">a</span> <span class="free">ys</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms<span class="main">[</span><span class="operator">unfolded</span> less_eq_list_def prefix_def<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> less_eq_list_def prefix_ext<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-set_ext"><span class="command">lemma</span></span> set_ext<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>extup <span class="free">a</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="free">a</span><span class="main">}</span> <span class="main">∪</span> set <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>extdown <span class="free">a</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="free">a</span><span class="main">}</span> <span class="main">∪</span> set <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">a</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">lextup</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> Lim <span class="main">(</span>at' <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="main">(</span>llist_of <span class="main">∘</span> extup <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">∘</span> list_of<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">lextdown</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> Lim <span class="main">(</span>at' <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="main">(</span>llist_of <span class="main">∘</span> extdown <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">∘</span> list_of<span class="main">)</span>"</span></span>

<span class="keyword1" id="LList_CCPO_Topology-tendsto_lextup"><span class="command">lemma</span></span> tendsto_lextup<span class="main">[</span><span class="operator">tendsto_intros</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>lextup <span class="free">i</span> <span class="main">⤏</span> lextup <span class="free">i</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>at' <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> tendsto_Lim_at'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lextup_def<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> lfinite_eq_range_llist_of mono_ext<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-tendsto_lextdown"><span class="command">lemma</span></span> tendsto_lextdown<span class="main">[</span><span class="operator">tendsto_intros</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>lextdown <span class="free">i</span> <span class="main">⤏</span> lextdown <span class="free">i</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>at' <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> tendsto_Lim_at'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lextdown_def<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> lfinite_eq_range_llist_of mono_ext<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-isCont_lextup"><span class="command">lemma</span></span> isCont_lextup<span class="main">[</span><span class="operator">THEN</span> isCont_o2<span class="main"><span class="main"><span class="main"><span class="main">[</span></span></span></span><span class="operator"><span class="operator"><span class="operator">rotated</span></span></span><span class="main"><span class="main"><span class="main"><span class="main">]</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"isCont <span class="main">(</span>lextup <span class="free">a</span><span class="main">)</span> <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> isCont_def filterlim_at'_list tendsto_lextup<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-isCont_lextdown"><span class="command">lemma</span></span> isCont_lextdown<span class="main">[</span><span class="operator">THEN</span> isCont_o2<span class="main"><span class="main"><span class="main"><span class="main">[</span></span></span></span><span class="operator"><span class="operator"><span class="operator">rotated</span></span></span><span class="main"><span class="main"><span class="main"><span class="main">]</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"isCont <span class="main">(</span>lextdown <span class="free">a</span><span class="main">)</span> <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> isCont_def filterlim_at'_list tendsto_lextdown<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-lextup_lfinite"><span class="command">lemma</span></span> lextup_lfinite<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span> <span class="main">⟹</span> lextup <span class="free">i</span> <span class="free">xs</span> <span class="main">=</span> llist_of <span class="main">(</span>extup <span class="free">i</span> <span class="main">(</span>list_of <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lextup_def Lim_at'_lfinite<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-lextdown_lfinite"><span class="command">lemma</span></span> lextdown_lfinite<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span> <span class="main">⟹</span> lextdown <span class="free">i</span> <span class="free">xs</span> <span class="main">=</span> llist_of <span class="main">(</span>extdown <span class="free">i</span> <span class="main">(</span>list_of <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lextdown_def Lim_at'_lfinite<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"lextup <span class="free">i</span> LNil <span class="main">=</span> LNil"</span></span> <span class="quoted"><span class="quoted">"lextdown <span class="free">i</span> LNil <span class="main">=</span> LNil"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"lextup <span class="free">i</span> <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">i</span> <span class="main">≤</span> <span class="free">x</span> <span class="keyword1">then</span> lextup <span class="free">x</span> <span class="free">xs</span> <span class="keyword1">else</span> LCons <span class="free">i</span> <span class="main">(</span>lextdown <span class="free">x</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> tendsto_closed<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">xs</span></span></span></span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">OF</span> closed_Collect_eq_isCont<span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> isCont_lextdown isCont_lextup isCont_If isCont_LCons<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"lextdown <span class="free">i</span> <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span> <span class="main">≤</span> <span class="free">i</span> <span class="keyword1">then</span> lextdown <span class="free">x</span> <span class="free">xs</span> <span class="keyword1">else</span> LCons <span class="free">i</span> <span class="main">(</span>lextup <span class="free">x</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> tendsto_closed<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">xs</span></span></span></span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">OF</span> closed_Collect_eq_isCont<span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> isCont_lextdown isCont_lextup isCont_If isCont_LCons<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"lset <span class="main">(</span>lextup <span class="free">a</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="free">a</span><span class="main">}</span> <span class="main">∪</span> lset <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> tendsto_le_ccpo<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> g<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">xs</span></span><span class="main"><span class="main">.</span></span> lset <span class="main"><span class="main">(</span></span>lextup <span class="free"><span class="free">a</span></span> <span class="bound"><span class="bound">xs</span></span><span class="main"><span class="main">)</span></span>"</span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">xs</span></span><span class="main"><span class="main">.</span></span> <span class="main"><span class="main">{</span></span><span class="free"><span class="free">a</span></span><span class="main"><span class="main">}</span></span> <span class="main"><span class="main">∪</span></span> lset <span class="bound"><span class="bound">xs</span></span>"</span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> F<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"at' <span class="free"><span class="free">xs</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> <span class="dynamic"><span class="dynamic">tendsto_intros</span></span> at'_bot tendsto_lup eventually_at'_llistI tendsto_id_at'<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> lprefix_lsetD set_ext<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"lset <span class="main">(</span>lextdown <span class="free">a</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="free">a</span><span class="main">}</span> <span class="main">∪</span> lset <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> tendsto_le_ccpo<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> g<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">xs</span></span><span class="main"><span class="main">.</span></span> lset <span class="main"><span class="main">(</span></span>lextdown <span class="free"><span class="free">a</span></span> <span class="bound"><span class="bound">xs</span></span><span class="main"><span class="main">)</span></span>"</span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">xs</span></span><span class="main"><span class="main">.</span></span> <span class="main"><span class="main">{</span></span><span class="free"><span class="free">a</span></span><span class="main"><span class="main">}</span></span> <span class="main"><span class="main">∪</span></span> lset <span class="bound"><span class="bound">xs</span></span>"</span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> F<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"at' <span class="free"><span class="free">xs</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> <span class="dynamic"><span class="dynamic">tendsto_intros</span></span> at'_bot tendsto_lup eventually_at'_llistI tendsto_id_at'<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> lprefix_lsetD set_ext<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="LList_CCPO_Topology-distinct_ext"><span class="command">lemma</span></span> distinct_ext<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">∉</span> set <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>extup <span class="free">a</span> <span class="free">xs</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>extdown <span class="free">a</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms set_ext
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">a</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> eq_iff insert_iff subset_iff<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"ldistinct <span class="free">xs</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">∉</span> lset <span class="free">xs</span> <span class="main">⟹</span> ldistinct <span class="main">(</span>lextup <span class="free">a</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule_tac</span> tendsto_closed<span class="main"><span class="main">[</span></span><span class="operator">OF</span> closed_ldistinct'<span class="main"><span class="main">,</span></span> <span class="operator">OF</span> isCont_lextup<span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> lfinite_eq_range_llist_of <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> distinct_ext <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> ldistinct_lprefix <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lprefix_lsetD<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">esum_list</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"ereal llist <span class="main">⇒</span> ereal"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">esum_list</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> Lim <span class="main">(</span>at' <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">(</span>sum_list <span class="main">∘</span> list_of<span class="main">)</span>"</span></span>

<span class="keyword1" id="LList_CCPO_Topology-esum_list_lfinite"><span class="command">lemma</span></span> esum_list_lfinite<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span> <span class="main">⟹</span> esum_list <span class="free">xs</span> <span class="main">=</span> sum_list <span class="main">(</span>list_of <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> esum_list_def Lim_at'_lfinite<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-esum_list_LNil"><span class="command">lemma</span></span> esum_list_LNil<span class="main">:</span> <span class="quoted"><span class="quoted">"esum_list LNil <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"ereal llist"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> lset <span class="free">xs</span> <span class="main">⟹</span> <span class="main">0</span> <span class="main">≤</span> <span class="bound">x</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="LList_CCPO_Topology-esum_list_tendsto_SUP"><span class="command">lemma</span></span> esum_list_tendsto_SUP<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>sum_list<span class="main">∘</span>list_of<span class="main">)</span> <span class="main">⤏</span> <span class="main">(</span><span class="keyword1">SUP</span> <span class="bound">ys</span> <span class="main">∈</span> <span class="main">{</span><span class="bound">ys</span><span class="main">.</span> lfinite <span class="bound">ys</span> <span class="main">∧</span> <span class="bound">ys</span> <span class="main">≤</span> <span class="free">xs</span><span class="main">}</span><span class="main">.</span> esum_list <span class="bound">ys</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>at' <span class="free">xs</span><span class="main">)</span>"</span></span>
    <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">_</span> <span class="main">⤏</span> <span class="var">?y</span><span class="main">)</span> <span class="main">_</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> order_tendstoI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">&lt;</span> <span class="var">?y</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">ys</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"llist_of <span class="skolem">ys</span> <span class="main">≤</span> <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">&lt;</span> sum_list <span class="skolem">ys</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> less_SUP_iff lfinite_eq_range_llist_of<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">zs</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ys</span> <span class="main">≤</span> <span class="skolem">zs</span>"</span></span> <span class="quoted"><span class="quoted">"llist_of <span class="skolem">zs</span> <span class="main">≤</span> <span class="free">xs</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">ys'</span></span> <span class="keyword2"><span class="keyword">where</span></span> zs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">zs</span> <span class="main">=</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="skolem">ys'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> prefix_def less_eq_list_def<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹llist_of <span class="skolem">zs</span> <span class="main">≤</span> <span class="free">xs</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> nonneg<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">≤</span> sum_list <span class="skolem">ys'</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> xs <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> lprefix_conv_lappend sum_list_sum_nth <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> sum_nonneg<span class="main">)</span>
    <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">a</span> <span class="main">&lt;</span> sum_list <span class="skolem">ys</span>›</span></span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"sum_list <span class="skolem">ys</span> <span class="main">≤</span> sum_list <span class="skolem">zs</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> zs add_mono<span class="main">[</span><span class="operator">OF</span> order_refl nonneg<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">&lt;</span> sum_list <span class="skolem">zs</span>"</span></span> <span class="keyword1"><span class="command">.</span></span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"eventually <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">a</span> <span class="main">&lt;</span> <span class="main">(</span>sum_list<span class="main">∘</span>list_of<span class="main">)</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span>at' <span class="free">xs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> eventually_at'_llist <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> lfinite_eq_range_llist_of<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="var">?y</span> <span class="main">&lt;</span> <span class="skolem">a</span>"</span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"eventually <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span>sum_list<span class="main">∘</span>list_of<span class="main">)</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">(</span>at' <span class="free">xs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> eventually_at'_llistI <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> SUP_lessD<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="LList_CCPO_Topology-tendsto_esum_list"><span class="command">lemma</span></span> tendsto_esum_list<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>esum_list <span class="main">⤏</span> esum_list <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>at' <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> filterlim_cong<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> g<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"sum_list <span class="main"><span class="main">∘</span></span> list_of"</span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> iffD2<span class="main"><span class="main">,</span></span> <span class="operator">OF</span> refl refl<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> eventually_mono<span class="main"><span class="main">[</span></span><span class="operator">OF</span> eventually_lfinite<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">unfolding</span></span> esum_list_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> tendsto_LimI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> esum_list_tendsto_SUP<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="LList_CCPO_Topology-isCont_esum_list"><span class="command">lemma</span></span> isCont_esum_list<span class="main">:</span> <span class="quoted"><span class="quoted">"isCont esum_list <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> isCont_def filterlim_at'_list tendsto_esum_list<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="LList_CCPO_Topology-esum_list_nonneg"><span class="command">lemma</span></span> esum_list_nonneg<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> lset <span class="free">xs</span> <span class="main">⟹</span> <span class="main">0</span> <span class="main">≤</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">0</span> <span class="main">≤</span> esum_list <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> tendsto_le<span class="main"><span class="main">[</span></span><span class="operator">OF</span> at'_bot tendsto_esum_list tendsto_const<span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> eventually_at'_llistI sum_nonneg
           <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> lprefix_conv_lappend sum_list_sum_nth lfinite_eq_range_llist_of<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-esum_list_LCons"><span class="command">lemma</span></span> esum_list_LCons<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">≤</span> <span class="free">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> lset <span class="free">xs</span> <span class="main">⟹</span> <span class="main">0</span> <span class="main">≤</span> <span class="bound">x</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"esum_list <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">x</span> <span class="main">+</span> esum_list <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> tendsto_unique_eventually<span class="main"><span class="main">[</span></span><span class="operator">OF</span> at'_bot<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> x <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> esum_list <span class="main">(</span>LCons <span class="free">x</span> <span class="bound">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">⤏</span> esum_list <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>at' <span class="free">xs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> tendsto_compose<span class="main"><span class="main">[</span></span><span class="operator">OF</span> filterlim_at'_list<span class="main"><span class="main">[</span></span><span class="operator">OF</span> tendsto_esum_list<span class="main"><span class="main">]</span></span> tendsto_LCons<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"eventually <span class="main">(</span><span class="main">λ</span><span class="bound">xa</span><span class="main">.</span> esum_list <span class="main">(</span>LCons <span class="free">x</span> <span class="bound">xa</span><span class="main">)</span> <span class="main">=</span> <span class="free">x</span> <span class="main">+</span> esum_list <span class="bound">xa</span><span class="main">)</span> <span class="main">(</span>at' <span class="free">xs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> eventually_lfinite <span class="keyword1"><span class="command">by</span></span> <span class="operator">eventually_elim</span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">from</span></span> x <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">xa</span><span class="main">.</span> <span class="free">x</span> <span class="main">+</span> esum_list <span class="bound">xa</span><span class="main">)</span> <span class="main">⤏</span> <span class="free">x</span> <span class="main">+</span> esum_list <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>at' <span class="free">xs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> esum_list_nonneg tendsto_esum_list tendsto_add_ereal<span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="LList_CCPO_Topology-esum_list_lfilter'"><span class="command">lemma</span></span> esum_list_lfilter'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> nn<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> lset <span class="free">xs</span> <span class="main">⟹</span> <span class="main">0</span> <span class="main">≤</span> <span class="bound">x</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"esum_list <span class="main">(</span>lfilter' <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> esum_list <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> tendsto_unique_eventually<span class="main"><span class="main">[</span></span><span class="operator">OF</span> at'_bot<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>esum_list <span class="main">⤏</span> esum_list <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>at' <span class="free">xs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> nn <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> tendsto_esum_list<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> nn <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> esum_list <span class="main">(</span>lfilter' <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span> <span class="bound">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">⤏</span> esum_list <span class="main">(</span>lfilter' <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>at' <span class="free">xs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> tendsto_compose<span class="main"><span class="main">[</span></span><span class="operator">OF</span> filterlim_at'_list<span class="main"><span class="main">[</span></span><span class="operator">OF</span> tendsto_esum_list<span class="main"><span class="main">]</span></span> tendsto_lfilter<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> lset_lfilter'<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"eventually <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> esum_list <span class="main">(</span>lfilter' <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span> <span class="bound">xs</span><span class="main">)</span> <span class="main">=</span> esum_list <span class="bound">xs</span><span class="main">)</span> <span class="main">(</span>at' <span class="free">xs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> eventually_lfinite
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">eventually_elim</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sum_list_map_filter<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> P<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≠</span> <span class="main">0</span>"</span></span><span class="main"><span class="main">,</span></span> <span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">function</span></span> <span class="entity">f</span><span class="main">::</span> <span class="quoted"><span class="quoted">"nat list <span class="main">⇒</span> nat list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">[]</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">*</span> <span class="numeral">2</span><span class="main">)</span> <span class="main">#</span> <span class="free">f</span> <span class="main">(</span><span class="free">f</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> <span class="operator">pat_completeness</span>

<span class="keyword1"><span class="command">termination</span></span> <span class="quoted">f</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">relation</span> <span class="quoted"><span class="quoted">"inv_image natLess length"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">xs</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"f_dom <span class="skolem">xs</span>"</span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>f <span class="skolem">xs</span><span class="main">,</span> <span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∈</span> inv_image natLess length"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> f.psimps natLess_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> wf_less <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> natLess_def<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-length_f"><span class="command">lemma</span></span> length_f<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>f <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> length <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> f.induct<span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="LList_CCPO_Topology-f_mono'"><span class="command">lemma</span></span> f_mono'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">ys'</span><span class="main">.</span> f <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> f <span class="free">xs</span> <span class="main">@</span> <span class="bound">ys'</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"length <span class="free">xs</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> less_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> less <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> length_f lessI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="LList_CCPO_Topology-f_mono"><span class="command">lemma</span></span> f_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≤</span> <span class="free">ys</span> <span class="main">⟹</span> f <span class="free">xs</span> <span class="main">≤</span> f <span class="free">ys</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> less_eq_list_def prefix_def f_mono'<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">f'</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> Lim <span class="main">(</span>at' <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">l</span><span class="main">.</span> llist_of <span class="main">(</span>f <span class="main">(</span>list_of <span class="bound">l</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="LList_CCPO_Topology-f'_lfinite"><span class="command">lemma</span></span> f'_lfinite<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span> <span class="main">⟹</span> f' <span class="free">xs</span> <span class="main">=</span> llist_of <span class="main">(</span>f <span class="main">(</span>list_of <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> f'_def Lim_at'_lfinite<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-tendsto_f'"><span class="command">lemma</span></span> tendsto_f'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>f' <span class="main">⤏</span> f' <span class="free">l</span><span class="main">)</span> <span class="main">(</span>at' <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> tendsto_Lim_at'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> f'_def<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lfinite_eq_range_llist_of <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> f_mono<span class="main">)</span>

<span class="keyword1" id="LList_CCPO_Topology-isCont_f'"><span class="command">lemma</span></span> isCont_f'<span class="main">[</span><span class="operator">THEN</span> isCont_o2<span class="main"><span class="main"><span class="main"><span class="main">[</span></span></span></span><span class="operator"><span class="operator"><span class="operator">rotated</span></span></span><span class="main"><span class="main"><span class="main"><span class="main">]</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"isCont f' <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> isCont_def filterlim_at'_list tendsto_f'<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"f' LNil <span class="main">=</span> LNil"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"f' <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> LCons <span class="main">(</span><span class="free">x</span> <span class="main">*</span> <span class="numeral">2</span><span class="main">)</span> <span class="main">(</span>f' <span class="main">(</span>f' <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> tendsto_closed<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">xs</span></span></span></span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">OF</span> closed_Collect_eq_isCont<span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> isCont_f' isCont_LCons<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="TLList_CCPO">
<div class="head">
<h1>Theory TLList_CCPO</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       TLList_CCPO.thy
    Author:      Andreas Lochbihler, ETH Zurich
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Ccpo structure for terminated lazy lists›</span></span>

<span class="keyword1"><span class="command">theory</span></span> TLList_CCPO <span class="keyword2"><span class="keyword">imports</span></span> <a href="#TLList">TLList</a> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="TLList_CCPO-Set_is_empty_parametric"><span class="command">lemma</span></span> Set_is_empty_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_set <span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> Set.is_empty Set.is_empty"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def Set.is_empty_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> rel_setD1 rel_setD2<span class="main">)</span>

<span class="keyword1" id="TLList_CCPO-monotone_comp"><span class="command">lemma</span></span> monotone_comp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> monotone <span class="free">orda</span> <span class="free">ordb</span> <span class="free">g</span><span class="main">;</span> monotone <span class="free">ordb</span> <span class="free">ordc</span> <span class="free">f</span> <span class="main">⟧</span> <span class="main">⟹</span> monotone <span class="free">orda</span> <span class="free">ordc</span> <span class="main">(</span><span class="free">f</span> <span class="main">∘</span> <span class="free">g</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monotoneI<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> monotoneD<span class="main">)</span>

<span class="keyword1" id="TLList_CCPO-cont_comp"><span class="command">lemma</span></span> cont_comp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> mcont <span class="free">luba</span> <span class="free">orda</span> <span class="free">lubb</span> <span class="free">ordb</span> <span class="free">g</span><span class="main">;</span> cont <span class="free">lubb</span> <span class="free">ordb</span> <span class="free">lubc</span> <span class="free">ordc</span> <span class="free">f</span> <span class="main">⟧</span> <span class="main">⟹</span> cont <span class="free">luba</span> <span class="free">orda</span> <span class="free">lubc</span> <span class="free">ordc</span> <span class="main">(</span><span class="free">f</span> <span class="main">∘</span> <span class="free">g</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> contI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">frule</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> mcont_contD<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> contD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ chain_imageI<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> mcont_monoD<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> image_image o_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="TLList_CCPO-mcont_comp"><span class="command">lemma</span></span> mcont_comp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> mcont <span class="free">luba</span> <span class="free">orda</span> <span class="free">lubb</span> <span class="free">ordb</span> <span class="free">g</span><span class="main">;</span> mcont <span class="free">lubb</span> <span class="free">ordb</span> <span class="free">lubc</span> <span class="free">ordc</span> <span class="free">f</span> <span class="main">⟧</span> <span class="main">⟹</span> mcont <span class="free">luba</span> <span class="free">orda</span> <span class="free">lubc</span> <span class="free">ordc</span> <span class="main">(</span><span class="free">f</span> <span class="main">∘</span> <span class="free">g</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mcont_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> cont_comp monotone_comp<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="TLList_CCPO-monotone_parametric"><span class="command">lemma</span></span> monotone_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bi_total <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">B</span> <span class="main">===&gt;</span> <span class="free">B</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">B</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> monotone monotone"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> monotone_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="TLList_CCPO-cont_parametric"><span class="command">lemma</span></span> cont_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bi_total <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"bi_unique <span class="free">B</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>rel_set <span class="free">A</span> <span class="main">===&gt;</span> <span class="free">A</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span>rel_set <span class="free">B</span> <span class="main">===&gt;</span> <span class="free">B</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">B</span> <span class="main">===&gt;</span> <span class="free">B</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">B</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> cont cont"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> cont_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> Set.is_empty_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="TLList_CCPO-mcont_parametric"><span class="command">lemma</span></span> mcont_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bi_total <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"bi_unique <span class="free">B</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>rel_set <span class="free">A</span> <span class="main">===&gt;</span> <span class="free">A</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span>rel_set <span class="free">B</span> <span class="main">===&gt;</span> <span class="free">B</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">B</span> <span class="main">===&gt;</span> <span class="free">B</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">B</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> mcont mcont"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> mcont_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> ccpo<span class="main">)</span> Sup_Un_less<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> chain<span class="main">:</span> <span class="quoted"><span class="quoted">"Complete_Partial_Order.chain <span class="main">(≤)</span> <span class="main">(</span><span class="free">A</span> <span class="main">∪</span> <span class="free">B</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> AB<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> <span class="main">∃</span><span class="bound">y</span><span class="main">∈</span><span class="free">B</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Sup <span class="main">(</span><span class="free">A</span> <span class="main">∪</span> <span class="free">B</span><span class="main">)</span> <span class="main">=</span> Sup <span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> order.antisym<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> chain <span class="keyword1"><span class="command">have</span></span> chain'<span class="main">:</span> <span class="quoted"><span class="quoted">"Complete_Partial_Order.chain <span class="main">(≤)</span> <span class="free">B</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> chain_subset<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Sup <span class="main">(</span><span class="free">A</span> <span class="main">∪</span> <span class="free">B</span><span class="main">)</span> <span class="main">≤</span> Sup <span class="free">B</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> chain
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ccpo_Sup_least<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">A</span> <span class="main">∪</span> <span class="free">B</span>"</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≤</span> Sup <span class="free">B</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">A</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">y</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="free">B</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> AB <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">y</span>›</span></span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> chain' <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> <span class="free">B</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">≤</span> Sup <span class="free">B</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> ccpo_Sup_upper<span class="main">)</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">rule</span> ccpo_Sup_upper<span class="main"><span class="main">[</span></span><span class="operator">OF</span> chain'<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Sup <span class="free">B</span> <span class="main">≤</span> Sup <span class="main">(</span><span class="free">A</span> <span class="main">∪</span> <span class="free">B</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> chain chain' <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> ccpo_Sup_least ccpo_Sup_upper<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The ccpo structure›</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> tllist.lifting <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">b</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'b</span></span></span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> tllist_ord <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">xs1</span><span class="main">,</span> <span class="bound">b1</span><span class="main">)</span> <span class="main">(</span><span class="bound">xs2</span><span class="main">,</span> <span class="bound">b2</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">if</span> lfinite <span class="bound">xs1</span> <span class="keyword1">then</span> <span class="bound">b1</span> <span class="main">=</span> <span class="free">b</span> <span class="main">∧</span> lprefix <span class="bound">xs1</span> <span class="bound">xs2</span> <span class="main">∨</span> <span class="bound">xs1</span> <span class="main">=</span> <span class="bound">xs2</span> <span class="main">∧</span> flat_ord <span class="free">b</span> <span class="bound">b1</span> <span class="bound">b2</span> <span class="keyword1">else</span> <span class="bound">xs1</span> <span class="main">=</span> <span class="bound">xs2</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lift_definition</span></span> tSup <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist"</span></span>
<span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">A</span><span class="main">.</span> <span class="main">(</span>lSup <span class="main">(</span>fst <span class="main">`</span> <span class="bound">A</span><span class="main">)</span><span class="main">,</span> flat_lub <span class="free">b</span> <span class="main">(</span>snd <span class="main">`</span> <span class="main">(</span><span class="bound">A</span> <span class="main">∩</span> <span class="main">{</span><span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> lfinite <span class="bound">xs</span><span class="main">}</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">goal_cases</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">A1</span> <span class="skolem">A2</span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"fst <span class="main">`</span> <span class="skolem">A1</span> <span class="main">=</span> fst <span class="main">`</span> <span class="skolem">A2</span>"</span></span> <span class="quoted"><span class="quoted">"snd <span class="main">`</span> <span class="main">(</span><span class="skolem">A1</span> <span class="main">∩</span> <span class="main">{</span><span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> lfinite <span class="bound">xs</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> snd <span class="main">`</span> <span class="main">(</span><span class="skolem">A2</span> <span class="main">∩</span> <span class="main">{</span><span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> lfinite <span class="bound">xs</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_set_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_image_eqI<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="TLList_CCPO-tllist_ord_simps"><span class="command">lemma</span></span> tllist_ord_simps <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="comment1">(* FIXME: does not work with transfer *)</span>
  <span class="keyword2"><span class="keyword">shows</span></span> tllist_ord_TNil_TNil<span class="main">:</span> <span class="quoted"><span class="quoted">"tllist_ord <span class="main">(</span>TNil <span class="free">b1</span><span class="main">)</span> <span class="main">(</span>TNil <span class="free">b2</span><span class="main">)</span> <span class="main">⟷</span> flat_ord <span class="free">b</span> <span class="free">b1</span> <span class="free">b2</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> tllist_ord_TNil_TCons<span class="main">:</span> <span class="quoted"><span class="quoted">"tllist_ord <span class="main">(</span>TNil <span class="free">b1</span><span class="main">)</span> <span class="main">(</span>TCons <span class="free">y</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">b1</span> <span class="main">=</span> <span class="free">b</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> tllist_ord_TCons_TNil<span class="main">:</span> <span class="quoted"><span class="quoted">"tllist_ord <span class="main">(</span>TCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>TNil <span class="free">b2</span><span class="main">)</span> <span class="main">⟷</span> False"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> tllist_ord_TCons_TCons<span class="main">:</span> <span class="quoted"><span class="quoted">"tllist_ord <span class="main">(</span>TCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>TCons <span class="free">y</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span> <span class="main">∧</span> tllist_ord <span class="free">xs</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tllist_ord.rep_eq flat_ord_def<span class="main">)</span>

<span class="keyword1" id="TLList_CCPO-tllist_ord_refl"><span class="command">lemma</span></span> tllist_ord_refl <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"tllist_ord <span class="free">xs</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> flat_ord_def<span class="main">)</span>

<span class="keyword1" id="TLList_CCPO-tllist_ord_antisym"><span class="command">lemma</span></span> tllist_ord_antisym<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> tllist_ord <span class="free">xs</span> <span class="free">ys</span><span class="main">;</span> tllist_ord <span class="free">ys</span> <span class="free">xs</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">xs</span> <span class="main">=</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> flat_ord_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> lprefix_antisym<span class="main">)</span>

<span class="keyword1" id="TLList_CCPO-tllist_ord_trans"><span class="command">lemma</span></span> tllist_ord_trans <span class="main">[</span><span class="operator">trans</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> tllist_ord <span class="free">xs</span> <span class="free">ys</span><span class="main">;</span> tllist_ord <span class="free">ys</span> <span class="free">zs</span> <span class="main">⟧</span> <span class="main">⟹</span> tllist_ord <span class="free">xs</span> <span class="free">zs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> flat_ord_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> lprefix_trans<span class="main">)</span>

<span class="keyword1" id="TLList_CCPO-chain_tllist_llist_of_tllist"><span class="command">lemma</span></span> chain_tllist_llist_of_tllist<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Complete_Partial_Order.chain tllist_ord <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Complete_Partial_Order.chain lprefix <span class="main">(</span>llist_of_tllist <span class="main">`</span> <span class="free">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> chainI<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tllist_ord.rep_eq <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> chainD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="TLList_CCPO-chain_tllist_terminal"><span class="command">lemma</span></span> chain_tllist_terminal<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Complete_Partial_Order.chain tllist_ord <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Complete_Partial_Order.chain <span class="main">(</span>flat_ord <span class="free">b</span><span class="main">)</span> <span class="main">{</span>terminal <span class="bound">xs</span><span class="main">|</span><span class="bound">xs</span><span class="main">.</span> <span class="bound">xs</span> <span class="main">∈</span> <span class="free">A</span> <span class="main">∧</span> tfinite <span class="bound">xs</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> chainI<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tllist_ord.rep_eq flat_ord_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> chainD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="TLList_CCPO-flat_ord_chain_finite"><span class="command">lemma</span></span> flat_ord_chain_finite<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Complete_Partial_Order.chain <span class="main">(</span>flat_ord <span class="free">b</span><span class="main">)</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">z</span><span class="main">.</span> <span class="main">∀</span><span class="bound">x</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">b</span> <span class="main">∨</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">z</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> chain_def flat_ord_def<span class="main">)</span> <span class="operator">metis</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">z</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">A</span> <span class="main">⟹</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">b</span> <span class="main">∨</span> <span class="bound">x</span> <span class="main">=</span> <span class="skolem">z</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊆</span> <span class="main">{</span><span class="free">b</span><span class="main">,</span> <span class="skolem">z</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main">)</span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="TLList_CCPO-tSup_empty"><span class="command">lemma</span></span> tSup_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"tSup <span class="main">{}</span> <span class="main">=</span> TNil <span class="free">b</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> flat_lub_def<span class="main">)</span>

<span class="keyword1" id="TLList_CCPO-is_TNil_tSup"><span class="command">lemma</span></span> is_TNil_tSup <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"is_TNil <span class="main">(</span>tSup <span class="free">A</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> is_TNil <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta<span class="main">)</span>

<span class="keyword1" id="TLList_CCPO-chain_tllist_ord_tSup"><span class="command">lemma</span></span> chain_tllist_ord_tSup<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> chain<span class="main">:</span> <span class="quoted"><span class="quoted">"Complete_Partial_Order.chain tllist_ord <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">∈</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"tllist_ord <span class="free">xs</span> <span class="main">(</span>tSup <span class="free">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"tfinite <span class="free">xs</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"llist_of_tllist <span class="free">xs</span> <span class="main">=</span> llist_of_tllist <span class="main">(</span>tSup <span class="free">A</span><span class="main">)</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹tfinite <span class="free">xs</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>lSup <span class="main">(</span>llist_of_tllist <span class="main">`</span> <span class="free">A</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tSup_def image_image<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"terminal <span class="main">(</span>tSup <span class="free">A</span><span class="main">)</span> <span class="main">=</span> flat_lub <span class="free">b</span> <span class="main">{</span>terminal <span class="bound">xs</span><span class="main">|</span><span class="bound">xs</span><span class="main">.</span> <span class="bound">xs</span> <span class="main">∈</span> <span class="free">A</span> <span class="main">∧</span> tfinite <span class="bound">xs</span><span class="main">}</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=</span> flat_lub <span class="main">_</span> <span class="var">?A</span>"</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tSup_def terminal_tllist_of_llist image_image<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_image_eqI <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> arg_cong<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"flat_lub <span class="free">b</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"flat_ord <span class="free">b</span> <span class="main">(</span>terminal <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>flat_lub <span class="free">b</span> <span class="var">?A</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> ccpo.ccpo_Sup_upper<span class="main"><span class="main">[</span></span><span class="operator">OF</span> Partial_Function.ccpo<span class="main"><span class="main">[</span></span><span class="operator">OF</span> flat_interpretation<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> chain_tllist_terminal<span class="main"><span class="main">[</span></span><span class="operator">OF</span> chain<span class="main"><span class="main">]</span></span> A <span class="quoted"><span class="quoted">‹tfinite <span class="free">xs</span>›</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> True <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tllist_ord.rep_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">ys</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> <span class="main">¬</span> tllist_ord <span class="bound">ys</span> <span class="free">xs</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> contrapos_np<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> lprefix_antisym chain_lSup_lprefix chain_lprefix_lSup <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tSup_def image_image A chain_tllist_llist_of_tllist<span class="main"><span class="main">[</span></span><span class="operator">OF</span> chain<span class="main"><span class="main">]</span></span> tllist_ord.rep_eq <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">ys</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ys</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> tllist_ord <span class="skolem">ys</span> <span class="free">xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">with</span></span> A <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"tllist_ord <span class="free">xs</span> <span class="skolem">ys</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="skolem">ys</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> chainD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> chain<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> True <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"terminal <span class="free">xs</span> <span class="main">=</span> <span class="free">b</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> flat_ord_def<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> True False <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tllist_ord.rep_eq tSup_def image_image chain_lprefix_lSup chain_tllist_llist_of_tllist chain A<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tllist_ord.rep_eq tSup_def image_image chain_lprefix_lSup chain_tllist_llist_of_tllist not_lfinite_lprefix_conv_eq<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> iffD1<span class="main"><span class="main">]</span></span> terminal_tllist_of_llist <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="TLList_CCPO-chain_tSup_tllist_ord"><span class="command">lemma</span></span> chain_tSup_tllist_ord<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> chain<span class="main">:</span> <span class="quoted"><span class="quoted">"Complete_Partial_Order.chain tllist_ord <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> lub<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs'</span><span class="main">.</span> <span class="bound">xs'</span> <span class="main">∈</span> <span class="free">A</span> <span class="main">⟹</span> tllist_ord <span class="bound">xs'</span> <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"tllist_ord <span class="main">(</span>tSup <span class="free">A</span><span class="main">)</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs'</span><span class="main">.</span> <span class="bound">xs'</span> <span class="main">∈</span> llist_of_tllist <span class="main">`</span> <span class="free">A</span> <span class="main">⟹</span> lprefix <span class="bound">xs'</span> <span class="main">(</span>llist_of_tllist <span class="free">xs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> lub <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tllist_ord.rep_eq <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> chain_tllist_llist_of_tllist<span class="main">[</span><span class="operator">OF</span> chain<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> prefix<span class="main">:</span> <span class="quoted"><span class="quoted">"lprefix <span class="main">(</span>lSup <span class="main">(</span>llist_of_tllist <span class="main">`</span> <span class="free">A</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>llist_of_tllist <span class="free">xs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> chain_lSup_lprefix<span class="main">)</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"tfinite <span class="main">(</span>tSup <span class="free">A</span><span class="main">)</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> False <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> prefix
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tllist_ord.rep_eq tSup_def image_image not_lfinite_lprefix_conv_eq<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> iffD1<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">from</span></span> True <span class="keyword1"><span class="command">have</span></span> fin<span class="main">:</span> <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>lSup <span class="main">(</span>llist_of_tllist <span class="main">`</span> <span class="free">A</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tSup_def image_image<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> eq<span class="main">:</span> <span class="quoted"><span class="quoted">"terminal <span class="main">(</span>tSup <span class="free">A</span><span class="main">)</span> <span class="main">=</span> flat_lub <span class="free">b</span> <span class="main">{</span>terminal <span class="bound">xs</span><span class="main">|</span><span class="bound">xs</span><span class="main">.</span> <span class="bound">xs</span> <span class="main">∈</span> <span class="free">A</span> <span class="main">∧</span> tfinite <span class="bound">xs</span><span class="main">}</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=</span> flat_lub <span class="main">_</span> <span class="var">?A</span>"</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tSup_def terminal_tllist_of_llist image_image fin<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_image_eqI <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> arg_cong<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"flat_lub <span class="free">b</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"lprefix <span class="main">(</span>llist_of_tllist <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>lSup <span class="main">(</span>llist_of_tllist <span class="main">`</span> <span class="free">A</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">with</span></span> prefix <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lSup <span class="main">(</span>llist_of_tllist <span class="main">`</span> <span class="free">A</span><span class="main">)</span> <span class="main">=</span> llist_of_tllist <span class="free">xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> lprefix_antisym<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"flat_ord <span class="free">b</span> <span class="main">(</span>flat_lub <span class="free">b</span> <span class="var">?A</span><span class="main">)</span> <span class="main">(</span>terminal <span class="free">xs</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> ccpo.ccpo_Sup_least<span class="main"><span class="main">[</span></span><span class="operator">OF</span> Partial_Function.ccpo<span class="main"><span class="main">[</span></span><span class="operator">OF</span> flat_interpretation<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> chain_tllist_terminal<span class="main"><span class="main">[</span></span><span class="operator">OF</span> chain<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lub <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tllist_ord.rep_eq flat_ord_def<span class="main">)</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> eq <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tllist_ord.rep_eq tSup_def image_image<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs'</span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs'</span> <span class="main">∈</span> <span class="free">A</span>"</span></span>
        <span class="keyword1"><span class="command">with</span></span> False <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lprefix <span class="main">(</span>llist_of_tllist <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>llist_of_tllist <span class="skolem">xs'</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span><span class="operator">-</span><span class="main">(</span><span class="operator">erule</span> contrapos_nn<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> 4 4 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> lprefix_trans chain_lprefix_lSup chain_tllist_llist_of_tllist chain<span class="main">)</span>
        <span class="keyword1"><span class="command">with</span></span> lub<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="skolem">xs'</span> <span class="main">∈</span> <span class="free">A</span>›</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"terminal <span class="skolem">xs'</span> <span class="main">=</span> <span class="free">b</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tllist_ord.rep_eq <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
      <span class="keyword1"><span class="command">with</span></span> chain_tllist_terminal<span class="main">[</span><span class="operator">OF</span> chain<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"flat_ord <span class="free">b</span> <span class="main">(</span>flat_lub <span class="free">b</span> <span class="var">?A</span><span class="main">)</span> <span class="free">b</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span><span class="main">(</span><span class="operator">rule</span> ccpo.ccpo_Sup_least<span class="main"><span class="main">[</span></span><span class="operator">OF</span> Partial_Function.ccpo<span class="main"><span class="main">[</span></span><span class="operator">OF</span> flat_interpretation<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> flat_ord_def<span class="main">)</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"flat_lub <span class="free">b</span> <span class="var">?A</span> <span class="main">=</span> <span class="free">b</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> flat_ord_def<span class="main">)</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> True eq prefix
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tSup_def terminal_tllist_of_llist tllist_ord.rep_eq image_image<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="TLList_CCPO-tllist_ord_ccpo"><span class="command">lemma</span></span> tllist_ord_ccpo <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">cont_intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"class.ccpo tSup tllist_ord <span class="main">(</span>mk_less tllist_ord<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mk_less_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> tllist_ord_antisym tllist_ord_trans chain_tllist_ord_tSup chain_tSup_tllist_ord<span class="main">)</span>

<span class="keyword1" id="TLList_CCPO-tllist_ord_partial_function_definitions"><span class="command">lemma</span></span> tllist_ord_partial_function_definitions<span class="main">:</span> <span class="quoted"><span class="quoted">"partial_function_definitions tllist_ord tSup"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mk_less_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> tllist_ord_antisym tllist_ord_trans chain_tllist_ord_tSup chain_tSup_tllist_ord<span class="main">)</span>

<span class="keyword1"><span class="command">interpretation</span></span> tllist<span class="main">:</span> partial_function_definitions <span class="quoted"><span class="quoted">"tllist_ord"</span></span> <span class="quoted"><span class="quoted">"tSup"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> tllist_ord_partial_function_definitions<span class="main">)</span>

<span class="keyword1" id="TLList_CCPO-admissible_mcont_is_TNil"><span class="command">lemma</span></span> admissible_mcont_is_TNil <span class="main">[</span><span class="operator">THEN</span> admissible_subst<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> admissible_is_TNil<span class="main">:</span> <span class="quoted"><span class="quoted">"ccpo.admissible tSup tllist_ord is_TNil"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> ccpo.admissibleI<span class="main">)</span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="TLList_CCPO-terminal_tSup"><span class="command">lemma</span></span> terminal_tSup<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">xs</span><span class="main">∈</span><span class="free">Y</span><span class="main">.</span> is_TNil <span class="bound">xs</span> <span class="main">⟹</span> terminal <span class="main">(</span>tSup <span class="free">Y</span><span class="main">)</span> <span class="main">=</span> flat_lub <span class="free">b</span> <span class="main">(</span>terminal <span class="main">`</span> <span class="free">Y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> tllist.lifting <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> arg_cong <span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted">"flat_lub <span class="free"><span class="free">b</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="TLList_CCPO-thd_tSup"><span class="command">lemma</span></span> thd_tSup<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">xs</span> <span class="main">∈</span> <span class="free">Y</span><span class="main">.</span> <span class="main">¬</span> is_TNil <span class="bound">xs</span>
  <span class="main">⟹</span> thd <span class="main">(</span>tSup <span class="free">Y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">THE</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> thd <span class="main">`</span> <span class="main">(</span><span class="free">Y</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> is_TNil <span class="bound">xs</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tSup_def image_image<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> arg_cong<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">The</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_image_eqI <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ext<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="TLList_CCPO-ex_TCons_raw_parametric"><span class="command">lemma</span></span> ex_TCons_raw_parametric<span class="main">:</span>
  <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_set <span class="main">(</span>rel_prod <span class="main">(</span>llist_all2 <span class="free">A</span><span class="main">)</span> <span class="free">B</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">Y</span><span class="main">.</span> <span class="main">∃</span><span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∈</span> <span class="bound">Y</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">Y</span><span class="main">.</span> <span class="main">∃</span><span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∈</span> <span class="bound">Y</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 4 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> rel_setD1 rel_setD2 llist_all2_lnullD <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_bexI<span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> ex_TCons <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist set <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">Y</span><span class="main">.</span> <span class="main">∃</span><span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∈</span> <span class="bound">Y</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span>"</span></span> <span class="keyword2"><span class="keyword">parametric</span></span> ex_TCons_raw_parametric
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> rel_setD1 rel_setD2<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="TLList_CCPO-ex_TCons_iff"><span class="command">lemma</span></span> ex_TCons_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"ex_TCons <span class="free">Y</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">xs</span> <span class="main">∈</span> <span class="free">Y</span><span class="main">.</span> <span class="main">¬</span> is_TNil <span class="bound">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>

<span class="keyword1" id="TLList_CCPO-retain_TCons_raw_parametric"><span class="command">lemma</span></span> retain_TCons_raw_parametric<span class="main">:</span>
  <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_set <span class="main">(</span>rel_prod <span class="main">(</span>llist_all2 <span class="free">A</span><span class="main">)</span> <span class="free">B</span><span class="main">)</span> <span class="main">===&gt;</span> rel_set <span class="main">(</span>rel_prod <span class="main">(</span>llist_all2 <span class="free">A</span><span class="main">)</span> <span class="free">B</span><span class="main">)</span><span class="main">)</span>
    <span class="main">(</span><span class="main">λ</span><span class="bound">A</span><span class="main">.</span> <span class="bound">A</span> <span class="main">∩</span> <span class="main">{</span><span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">A</span><span class="main">.</span> <span class="bound">A</span> <span class="main">∩</span> <span class="main">{</span><span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> rel_funI rel_setI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span><span class="main">(</span><span class="operator">auto</span> 4 4 <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> llist_all2_lnullD rel_setD2 rel_setD1 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_bexI<span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> retain_TCons <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist set"</span></span>
<span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">A</span><span class="main">.</span> <span class="bound">A</span> <span class="main">∩</span> <span class="main">{</span><span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">parametric</span></span> retain_TCons_raw_parametric
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> rel_setI<span class="main">)</span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> rel_setD1 rel_setD2<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="TLList_CCPO-retain_TCons_conv"><span class="command">lemma</span></span> retain_TCons_conv<span class="main">:</span> <span class="quoted"><span class="quoted">"retain_TCons <span class="free">A</span> <span class="main">=</span> <span class="free">A</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> is_TNil <span class="bound">xs</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> retain_TCons_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_image_eqI<span class="main">)</span>

<span class="keyword1" id="TLList_CCPO-ttl_tSup"><span class="command">lemma</span></span> ttl_tSup<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> Complete_Partial_Order.chain tllist_ord <span class="free">Y</span><span class="main">;</span> <span class="main">∃</span><span class="bound">xs</span> <span class="main">∈</span> <span class="free">Y</span><span class="main">.</span> <span class="main">¬</span> is_TNil <span class="bound">xs</span> <span class="main">⟧</span>
  <span class="main">⟹</span> ttl <span class="main">(</span>tSup <span class="free">Y</span><span class="main">)</span> <span class="main">=</span> tSup <span class="main">(</span>ttl <span class="main">`</span> <span class="main">(</span><span class="free">Y</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> is_TNil <span class="bound">xs</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> ex_TCons_iff<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> retain_TCons_conv<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> prems<span class="main">:</span> <span class="main">(</span>1 <span class="skolem">Y</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xs</span></span> <span class="skolem"><span class="skolem">b'</span></span> <span class="keyword2"><span class="keyword">where</span></span> xsb<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">xs</span><span class="main">,</span> <span class="skolem">b'</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">Y</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lnull <span class="skolem">xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">note</span></span> chain <span class="main">=</span> prems<span class="main">(</span>1<span class="main">)</span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"flat_lub <span class="free">b</span> <span class="main">(</span>snd <span class="main">`</span> <span class="main">(</span><span class="skolem">Y</span> <span class="main">∩</span> <span class="main">{</span><span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> lfinite <span class="bound">xs</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> flat_lub <span class="free">b</span> <span class="main">(</span>insert <span class="free">b</span> <span class="main">(</span>snd <span class="main">`</span> <span class="main">(</span><span class="skolem">Y</span> <span class="main">∩</span> <span class="main">{</span><span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> lfinite <span class="bound">xs</span><span class="main">}</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> flat_lub_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"insert <span class="free">b</span> <span class="main">(</span>snd <span class="main">`</span> <span class="main">(</span><span class="skolem">Y</span> <span class="main">∩</span> <span class="main">{</span><span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> lfinite <span class="bound">xs</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> insert <span class="free">b</span> <span class="main">(</span>snd <span class="main">`</span> <span class="main">(</span>apfst ltl <span class="main">`</span> <span class="main">(</span><span class="skolem">Y</span> <span class="main">∩</span> <span class="main">{</span><span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">}</span><span class="main">)</span> <span class="main">∩</span> <span class="main">{</span><span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> lfinite <span class="bound">xs</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_image_eqI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule</span> contrapos_np<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">frule</span> chainD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> chain <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">xs</span><span class="main">,</span> <span class="skolem">b'</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">Y</span>›</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> lnull <span class="skolem">xs</span>›</span></span> xsb
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lprefix_lnull <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rev_image_eqI<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"flat_lub <span class="free">b</span> <span class="main">…</span> <span class="main">=</span> flat_lub <span class="free">b</span> <span class="main">(</span>snd <span class="main">`</span> <span class="main">(</span>apfst ltl <span class="main">`</span> <span class="main">(</span><span class="skolem">Y</span> <span class="main">∩</span> <span class="main">{</span><span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">}</span><span class="main">)</span> <span class="main">∩</span> <span class="main">{</span><span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> lfinite <span class="bound">xs</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> flat_lub_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ltl <span class="main">`</span> <span class="main">(</span>fst <span class="main">`</span> <span class="skolem">Y</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> fst <span class="main">`</span> apfst ltl <span class="main">`</span> <span class="main">(</span><span class="skolem">Y</span> <span class="main">∩</span> <span class="main">{</span><span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">.</span> <span class="main">¬</span> lnull <span class="bound">xs</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> image_image<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> prems <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="TLList_CCPO-tSup_TCons"><span class="command">lemma</span></span> tSup_TCons<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">⟹</span> tSup <span class="main">(</span>TCons <span class="free">x</span> <span class="main">`</span> <span class="free">A</span><span class="main">)</span> <span class="main">=</span> TCons <span class="free">x</span> <span class="main">(</span>tSup <span class="free">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Set.is_empty_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer</span>
<span class="keyword1"><span class="command">unfolding</span></span> Set.is_empty_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> image_image lSup_LCons<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> arg_cong<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"flat_lub <span class="free"><span class="free">b</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_image_eqI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="TLList_CCPO-tllist_ord_terminalD"><span class="command">lemma</span></span> tllist_ord_terminalD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> tllist_ord <span class="free">xs</span> <span class="free">ys</span><span class="main">;</span> is_TNil <span class="free">ys</span> <span class="main">⟧</span> <span class="main">⟹</span> flat_ord <span class="free">b</span> <span class="main">(</span>terminal <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>terminal <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> is_TNil_def<span class="main">)</span>

<span class="keyword1" id="TLList_CCPO-tllist_ord_bot"><span class="command">lemma</span></span> tllist_ord_bot <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"tllist_ord <span class="main">(</span>TNil <span class="free">b</span><span class="main">)</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> flat_ord_def<span class="main">)</span>

<span class="keyword1" id="TLList_CCPO-tllist_ord_ttlI"><span class="command">lemma</span></span> tllist_ord_ttlI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"tllist_ord <span class="free">xs</span> <span class="free">ys</span> <span class="main">⟹</span> tllist_ord <span class="main">(</span>ttl <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>ttl <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> tllist.exhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> tllist.exhaust<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1" id="TLList_CCPO-not_is_TNil_conv"><span class="command">lemma</span></span> not_is_TNil_conv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> is_TNil <span class="free">xs</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span> <span class="bound">xs'</span><span class="main">.</span> <span class="free">xs</span> <span class="main">=</span> TCons <span class="bound">x</span> <span class="bound">xs'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Continuity of predefined constants›</span></span>

<span class="keyword1" id="TLList_CCPO-mono_tllist_ord_case"><span class="command">lemma</span></span> mono_tllist_ord_case<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">bot</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> monotone tllist_ord <span class="free">ord</span> <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="bound">xs</span> <span class="main">(</span>TCons <span class="bound">x</span> <span class="bound">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> ord<span class="main">:</span> <span class="quoted"><span class="quoted">"class.preorder <span class="free">ord</span> <span class="main">(</span>mk_less <span class="free">ord</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> bot<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">ord</span> <span class="main">(</span><span class="free">bot</span> <span class="free">b</span><span class="main">)</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monotone tllist_ord <span class="free">ord</span> <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">xs</span> <span class="keyword1">of</span> TNil <span class="bound">b</span> <span class="main">⇒</span> <span class="free">bot</span> <span class="bound">b</span> <span class="main">|</span> TCons <span class="bound">x</span> <span class="bound">xs'</span> <span class="main">⇒</span> <span class="free">f</span> <span class="bound">x</span> <span class="bound">xs'</span> <span class="bound">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> preorder <span class="quoted"><span class="free">ord</span></span> <span class="quoted"><span class="quoted">"mk_less <span class="free">ord</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fact</span> ord<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monotoneI<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> tllist.split <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> monotoneD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mono<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> flat_ord_def bot<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="TLList_CCPO-mcont_lprefix_case_aux"><span class="command">lemma</span></span> mcont_lprefix_case_aux<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="free">bot</span> <span class="free">ord</span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span>thd <span class="bound">xs</span><span class="main">)</span> <span class="main">(</span>ttl <span class="bound">xs</span><span class="main">)</span> <span class="main">(</span>TCons <span class="main">(</span>thd <span class="bound">xs</span><span class="main">)</span> <span class="main">(</span>ttl <span class="bound">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> mcont<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> mcont tSup tllist_ord <span class="free">lub</span> <span class="free">ord</span> <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="bound">xs</span> <span class="main">(</span>TCons <span class="bound">x</span> <span class="bound">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> ccpo<span class="main">:</span> <span class="quoted"><span class="quoted">"class.ccpo <span class="free">lub</span> <span class="free">ord</span> <span class="main">(</span>mk_less <span class="free">ord</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> bot<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">ord</span> <span class="main">(</span><span class="free">bot</span> <span class="free">b</span><span class="main">)</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> cont_bot<span class="main">:</span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span>flat_lub <span class="free">b</span><span class="main">)</span> <span class="main">(</span>flat_ord <span class="free">b</span><span class="main">)</span> <span class="free">lub</span> <span class="free">ord</span> <span class="free">bot</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mcont tSup tllist_ord <span class="free">lub</span> <span class="free">ord</span> <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">xs</span> <span class="keyword1">of</span> TNil <span class="bound">b</span> <span class="main">⇒</span> <span class="free">bot</span> <span class="bound">b</span> <span class="main">|</span> TCons <span class="bound">x</span> <span class="bound">xs'</span> <span class="main">⇒</span> <span class="free">f</span> <span class="bound">x</span> <span class="bound">xs'</span> <span class="bound">xs</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"mcont <span class="main">_</span> <span class="main">_</span> <span class="main">_</span> <span class="main">_</span> <span class="var">?f</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> mcontI<span class="main">)</span>
  <span class="keyword1"><span class="command">interpret</span></span> b<span class="main">:</span> ccpo <span class="quoted"><span class="free">lub</span></span> <span class="quoted"><span class="free">ord</span></span> <span class="quoted"><span class="quoted">"mk_less <span class="free">ord</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> ccpo<span class="main">)</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"cont tSup tllist_ord <span class="free">lub</span> <span class="free">ord</span> <span class="var">?f</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> contI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">Y</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist set"</span></span>
    <span class="keyword3"><span class="command">assume</span></span> chain<span class="main">:</span> <span class="quoted"><span class="quoted">"Complete_Partial_Order.chain tllist_ord <span class="skolem">Y</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> Y<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">Y</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> chain <span class="keyword1"><span class="command">have</span></span> chain'<span class="main">:</span> <span class="quoted"><span class="quoted">"Complete_Partial_Order.chain <span class="free">ord</span> <span class="main">(</span><span class="var">?f</span> <span class="main">`</span> <span class="skolem">Y</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> chain_imageI<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> tllist.split <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> flat_ord_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> bot mcont_monoD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mcont<span class="main"><span class="main">]</span></span><span class="main">)</span>

    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?f</span> <span class="main">(</span>tSup <span class="skolem">Y</span><span class="main">)</span> <span class="main">=</span> <span class="free">lub</span> <span class="main">(</span><span class="var">?f</span> <span class="main">`</span> <span class="skolem">Y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"is_TNil <span class="main">(</span>tSup <span class="skolem">Y</span><span class="main">)</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="var">?f</span> <span class="main">`</span> <span class="skolem">Y</span> <span class="main">=</span> <span class="free">bot</span> <span class="main">`</span> terminal <span class="main">`</span> <span class="skolem">Y</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> tllist.split <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_image_eqI <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> imageI<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> True <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"tSup <span class="skolem">Y</span> <span class="main">=</span> TNil <span class="main">(</span>flat_lub <span class="free">b</span> <span class="main">(</span>terminal <span class="main">`</span> <span class="skolem">Y</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span><span class="main">(</span><span class="operator">rule</span> tllist.expand<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> terminal_tSup<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Complete_Partial_Order.chain <span class="main">(</span>flat_ord <span class="free">b</span><span class="main">)</span> <span class="main">(</span>terminal <span class="main">`</span> <span class="skolem">Y</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> chain True <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> chain_imageI tllist_ord_terminalD<span class="main">)</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> Y
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> contD <span class="main"><span class="main">[</span></span><span class="operator">OF</span> cont_bot<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">cong</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> b.SUP_cong_simp<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">hence</span></span> eq<span class="main">:</span> <span class="quoted"><span class="quoted">"tSup <span class="skolem">Y</span> <span class="main">=</span> TCons <span class="main">(</span>thd <span class="main">(</span>tSup <span class="skolem">Y</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>ttl <span class="main">(</span>tSup <span class="skolem">Y</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">have</span></span> eq'<span class="main">:</span> 
        <span class="quoted"><span class="quoted">"<span class="var">?f</span> <span class="main">`</span> <span class="skolem">Y</span> <span class="main">=</span>
         <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">bot</span> <span class="main">(</span>terminal <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">`</span> <span class="main">(</span><span class="skolem">Y</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> is_TNil <span class="bound">xs</span><span class="main">}</span><span class="main">)</span> <span class="main">∪</span>
         <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span>thd <span class="bound">xs</span><span class="main">)</span> <span class="main">(</span>ttl <span class="bound">xs</span><span class="main">)</span> <span class="bound">xs</span><span class="main">)</span> <span class="main">`</span> <span class="main">(</span><span class="skolem">Y</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> is_TNil <span class="bound">xs</span><span class="main">}</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> tllist.splits <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_image_eqI<span class="main">)</span>
      
      <span class="keyword1"><span class="command">from</span></span> False <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xs</span></span> <span class="keyword2"><span class="keyword">where</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">∈</span> <span class="skolem">Y</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> is_TNil <span class="skolem">xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">ys</span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ys</span> <span class="main">∈</span> <span class="skolem">Y</span>"</span></span> <span class="quoted"><span class="quoted">"is_TNil <span class="skolem">ys</span>"</span></span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"terminal <span class="skolem">ys</span> <span class="main">=</span> <span class="free">b</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> xs
          <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quoted"><span class="skolem">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> tllist.exhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> tllist.exhaust<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> chainD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> chain<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> lub<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">lub</span> <span class="main">(</span><span class="var">?f</span> <span class="main">`</span> <span class="skolem">Y</span><span class="main">)</span> <span class="main">=</span> <span class="free">lub</span> <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span>thd <span class="bound">xs</span><span class="main">)</span> <span class="main">(</span>ttl <span class="bound">xs</span><span class="main">)</span> <span class="bound">xs</span><span class="main">)</span> <span class="main">`</span> <span class="main">(</span><span class="skolem">Y</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> is_TNil <span class="bound">xs</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> xs chain' <span class="keyword1"><span class="command">unfolding</span></span> eq'
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span><span class="main">(</span><span class="operator">erule</span> ccpo.Sup_Un_less<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ccpo<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> bot<span class="main">)</span>
      <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span>
        <span class="keyword3"><span class="command">assume</span></span> xs<span class="main">:</span>  <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">∈</span> <span class="skolem">Y</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> is_TNil <span class="bound">xs</span><span class="main">}</span>"</span></span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">THE</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> thd <span class="main">`</span> <span class="main">(</span><span class="skolem">Y</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> is_TNil <span class="bound">xs</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> thd <span class="skolem">xs</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> chainD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> chain<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_is_TNil_conv <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> the_equality<span class="main">)</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span><span class="keyword1">THE</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> thd <span class="main">`</span> <span class="main">(</span><span class="skolem">Y</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> is_TNil <span class="bound">xs</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>ttl <span class="skolem">xs</span><span class="main">)</span> <span class="main">(</span>TCons <span class="main">(</span><span class="keyword1">THE</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> thd <span class="main">`</span> <span class="main">(</span><span class="skolem">Y</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> is_TNil <span class="bound">xs</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>ttl <span class="skolem">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span>thd <span class="skolem">xs</span><span class="main">)</span> <span class="main">(</span>ttl <span class="skolem">xs</span><span class="main">)</span> <span class="skolem">xs</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> xs <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="keyword1"><span class="command">}</span></span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Complete_Partial_Order.chain tllist_ord <span class="main">(</span>ttl <span class="main">`</span> <span class="main">(</span><span class="skolem">Y</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> is_TNil <span class="bound">xs</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> chain <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> chain_imageI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> chain_subset<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tllist_ord_ttlI<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> False <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">Y</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> <span class="main">¬</span> is_TNil <span class="bound">xs</span><span class="main">}</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2<span class="main"><span class="main">)</span></span> eq<span class="main">)</span>
        <span class="keyword1"><span class="command">using</span></span> False
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> thd_tSup ttl_tSup<span class="main"><span class="main">[</span></span><span class="operator">OF</span> chain<span class="main"><span class="main">]</span></span> mcont_contD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mcont<span class="main"><span class="main">]</span></span> image_image lub<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">from</span></span> mcont_mono<span class="main">[</span><span class="operator">OF</span> mcont<span class="main">]</span> _ bot
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"monotone tllist_ord <span class="free">ord</span> <span class="var">?f</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> mono_tllist_ord_case<span class="main">)</span><span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="TLList_CCPO-cont_TNil"><span class="command">lemma</span></span> cont_TNil <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">cont_intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span>flat_lub <span class="free">b</span><span class="main">)</span> <span class="main">(</span>flat_ord <span class="free">b</span><span class="main">)</span> tSup tllist_ord TNil"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> contI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> image_image image_constant_conv<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> arg_cong<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"flat_lub <span class="free"><span class="free">b</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_image_eqI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="TLList_CCPO-monotone_TCons"><span class="command">lemma</span></span> monotone_TCons<span class="main">:</span> <span class="quoted"><span class="quoted">"monotone tllist_ord tllist_ord <span class="main">(</span>TCons <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monotoneI<span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemmas</span></span> mono2mono_TCons<span class="main">[</span><span class="operator">cont_intro</span><span class="main">]</span> <span class="main">=</span> monotone_TCons<span class="main">[</span><span class="operator">THEN</span> tllist.mono2mono<span class="main">]</span>

<span class="keyword1" id="TLList_CCPO-mcont_TCons"><span class="command">lemma</span></span> mcont_TCons<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont tSup tllist_ord tSup tllist_ord <span class="main">(</span>TCons <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> mcontI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> monotone_TCons<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> contI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tSup_TCons<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemmas</span></span> mcont2mcont_TCons<span class="main">[</span><span class="operator">cont_intro</span><span class="main">]</span> <span class="main">=</span> mcont_TCons<span class="main">[</span><span class="operator">THEN</span> tllist.mcont2mcont<span class="main">]</span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">transfer_rule</span> <span class="quasi_keyword"><span class="quasi_keyword">del</span></span><span class="main">]</span> <span class="main">=</span> tllist_ord.transfer tSup.transfer

<span class="keyword1"><span class="command">lifting_update</span></span> tllist.lifting
<span class="keyword1"><span class="command">lifting_forget</span></span> tllist.lifting

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span> <span class="main">=</span> tllist_ord.transfer tSup.transfer

<span class="keyword1" id="TLList_CCPO-mono2mono_tset"><span class="command">lemma</span></span> mono2mono_tset<span class="main">[</span><span class="operator">THEN</span> lfp.mono2mono<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> smonotone_tset<span class="main">:</span> <span class="quoted"><span class="quoted">"monotone tllist_ord <span class="main">(⊆)</span> tset"</span></span>
<span class="keyword1"><span class="command">including</span></span> tllist.lifting
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">rule</span> monotone_comp<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ monotone_lset<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> monotoneI<span class="main">)</span>

<span class="keyword1" id="TLList_CCPO-mcont2mcont_tset"><span class="command">lemma</span></span> mcont2mcont_tset <span class="main">[</span><span class="operator">THEN</span> lfp.mcont2mcont<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> mcont_tset<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont tSup tllist_ord Union <span class="main">(⊆)</span> tset"</span></span>
<span class="keyword1"><span class="command">including</span></span> tllist.lifting
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> mcont_comp<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ mcont_lset<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">unfolding</span></span> mcont_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> monotoneI contI <span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="TLList_CCPO-rel_fun_lift"><span class="command">lemma</span></span> rel_fun_lift<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">A</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">g</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> <span class="free">A</span><span class="main">)</span> <span class="free">f</span> <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def<span class="main">)</span>

<span class="keyword1" id="TLList_CCPO-tllist_ord_transfer"><span class="command">lemma</span></span> tllist_ord_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> pcr_tllist <span class="main">(=)</span> <span class="main">(=)</span> <span class="main">===&gt;</span> pcr_tllist <span class="main">(=)</span> <span class="main">(=)</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span>
     <span class="main">(</span><span class="main">λ</span><span class="bound">b</span> <span class="main">(</span><span class="bound">xs1</span><span class="main">,</span> <span class="bound">b1</span><span class="main">)</span> <span class="main">(</span><span class="bound">xs2</span><span class="main">,</span> <span class="bound">b2</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">if</span> lfinite <span class="bound">xs1</span> <span class="keyword1">then</span> <span class="bound">b1</span> <span class="main">=</span> <span class="bound">b</span> <span class="main">∧</span> lprefix <span class="bound">xs1</span> <span class="bound">xs2</span> <span class="main">∨</span> <span class="bound">xs1</span> <span class="main">=</span> <span class="bound">xs2</span> <span class="main">∧</span> flat_ord <span class="bound">b</span> <span class="bound">b1</span> <span class="bound">b2</span> <span class="keyword1">else</span> <span class="bound">xs1</span> <span class="main">=</span> <span class="bound">xs2</span><span class="main">)</span>
     tllist_ord"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> rel_fun_lift<span class="main">)</span><span class="main">(</span><span class="operator">rule</span> tllist_ord.transfer<span class="main">)</span>

<span class="keyword1" id="TLList_CCPO-tSup_transfer"><span class="command">lemma</span></span> tSup_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> rel_set <span class="main">(</span>pcr_tllist <span class="main">(=)</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span> pcr_tllist <span class="main">(=)</span> <span class="main">(=)</span><span class="main">)</span>
     <span class="main">(</span><span class="main">λ</span><span class="bound">b</span> <span class="bound">A</span><span class="main">.</span> <span class="main">(</span>lSup <span class="main">(</span>fst <span class="main">`</span> <span class="bound">A</span><span class="main">)</span><span class="main">,</span> flat_lub <span class="bound">b</span> <span class="main">(</span>snd <span class="main">`</span> <span class="main">(</span><span class="bound">A</span> <span class="main">∩</span> <span class="main">{</span><span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> lfinite <span class="bound">xs</span><span class="main">}</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
     tSup"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> rel_fun_lift<span class="main">)</span><span class="main">(</span><span class="operator">rule</span> tSup.transfer<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lifting_update</span></span> tllist.lifting
<span class="keyword1"><span class="command">lifting_forget</span></span> tllist.lifting

<span class="keyword1"><span class="command">interpretation</span></span> tllist<span class="main">:</span> partial_function_definitions <span class="quoted"><span class="quoted">"tllist_ord <span class="free">b</span>"</span></span> <span class="quoted"><span class="quoted">"tSup <span class="free">b</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">b</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> tllist_ord_partial_function_definitions<span class="main">)</span>

<span class="keyword1" id="TLList_CCPO-tllist_case_mono"><span class="command">lemma</span></span> tllist_case_mono <span class="main">[</span><span class="operator">partial_function_mono</span><span class="main">,</span> <span class="operator">cont_intro</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> tnil<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">b</span><span class="main">.</span> monotone <span class="free">orda</span> <span class="free">ordb</span> <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="free">tnil</span> <span class="bound">f</span> <span class="bound">b</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> tcons<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">xs</span><span class="main">.</span> monotone <span class="free">orda</span> <span class="free">ordb</span> <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="free">tcons</span> <span class="bound">f</span> <span class="bound">x</span> <span class="bound">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monotone <span class="free">orda</span> <span class="free">ordb</span> <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> case_tllist <span class="main">(</span><span class="free">tnil</span> <span class="bound">f</span><span class="main">)</span> <span class="main">(</span><span class="free">tcons</span> <span class="bound">f</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monotoneI<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> tllist.split <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> monotoneD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> tnil<span class="main"><span class="main">]</span></span> monotoneD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> tcons<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Definition of recursive functions›</span></span>

<span class="keyword1"><span class="command">locale</span></span> tllist_pf <span class="main">=</span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">b</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'b</span></span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">declaration</span></span> <span class="quoted">‹<span class="entity">Partial_Function.init</span> <span class="inner_quoted">"tllist"</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"tllist.fixp_fun <span class="free">b</span>"</span><span class="antiquote">}</span></span>
  <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"tllist.mono_body <span class="free">b</span>"</span><span class="antiquote">}</span></span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> tllist.fixp_rule_uc<span class="main">[</span><span class="operator">where</span> b<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">b</span></span><span class="main">]</span><span class="antiquote">}</span></span></span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> tllist.fixp_induct_uc<span class="main">[</span><span class="operator">where</span> b<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">b</span></span><span class="main">]</span><span class="antiquote">}</span></span></span> NONE›</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">mono_tllist</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">mono_tllist</span> <span class="main">≡</span> monotone <span class="main">(</span>fun_ord <span class="main">(</span>tllist_ord <span class="free">b</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>tllist_ord <span class="free">b</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="TLList_CCPO-LCons_mono"><span class="command">lemma</span></span> LCons_mono <span class="main">[</span><span class="operator">partial_function_mono</span><span class="main">,</span> <span class="operator">cont_intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"mono_tllist <span class="free">A</span> <span class="main">⟹</span> mono_tllist <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> TCons <span class="free">x</span> <span class="main">(</span><span class="free">A</span> <span class="bound">f</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monotoneI<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> monotoneD<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="TLList_CCPO-mono_tllist_lappendt2"><span class="command">lemma</span></span> mono_tllist_lappendt2 <span class="main">[</span><span class="operator">partial_function_mono</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"tllist_pf.mono_tllist <span class="free">b</span> <span class="free">A</span> <span class="main">⟹</span> tllist_pf.mono_tllist <span class="free">b</span> <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> lappendt <span class="free">xs</span> <span class="main">(</span><span class="free">A</span> <span class="bound">f</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> monotoneI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> monotoneD<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tllist_ord.rep_eq <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lappend_inf<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="TLList_CCPO-mono_tllist_tappend2"><span class="command">lemma</span></span> mono_tllist_tappend2 <span class="main">[</span><span class="operator">partial_function_mono</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">y</span><span class="main">.</span> tllist_pf.mono_tllist <span class="free">b</span> <span class="main">(</span><span class="free">C</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"tllist_pf.mono_tllist <span class="free">b</span> <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> tappend <span class="free">xs</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="free">C</span> <span class="bound">y</span> <span class="bound">f</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"tfinite <span class="free">xs</span>"</span></span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> monotoneI<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule</span> monotoneD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main"><span class="main">[</span></span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> y<span class="main"><span class="main"><span class="main"><span class="main">=</span></span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"terminal <span class="free"><span class="free">xs</span></span>"</span></span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
 <span class="keyword1"><span class="command">including</span></span> tllist.lifting
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tappend_inf<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="TLList_CCPO_Examples">
<div class="head">
<h1>Theory TLList_CCPO_Examples</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       TLList_CCPO_Examples.thy
    Author:      Andreas Lochbihler, ETH Zurich
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Example definitions using the CCPO structure on terminated lazy lists›</span></span>

<span class="keyword1"><span class="command">theory</span></span> TLList_CCPO_Examples <span class="keyword2"><span class="keyword">imports</span></span>
   <span class="quoted">"<a href="#TLList_CCPO">../TLList_CCPO</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">b</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'b</span></span></span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">interpretation</span></span> tllist_pf <span class="quoted"><span class="free">b</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">P</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">function_internals</span><span class="main">]</span><span class="main">]</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">partial_function</span></span> <span class="main">(</span>tllist<span class="main">)</span> <span class="entity">tfilter</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">tfilter</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">of</span> TNil <span class="bound">b'</span> <span class="main">⇒</span> TNil <span class="bound">b'</span> <span class="main">|</span> TCons <span class="bound">x</span> <span class="bound">xs'</span> <span class="main">⇒</span> <span class="keyword1">if</span> <span class="free">P</span> <span class="bound">x</span> <span class="keyword1">then</span> TCons <span class="bound">x</span> <span class="main">(</span><span class="free">tfilter</span> <span class="bound">xs'</span><span class="main">)</span> <span class="keyword1">else</span> <span class="free">tfilter</span> <span class="bound">xs'</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">simps_of_case</span></span> tfilter_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> tfilter.simps

<span class="keyword1" id="TLList_CCPO_Examples-is_TNil_tfilter"><span class="command">lemma</span></span> is_TNil_tfilter<span class="main">:</span> <span class="quoted"><span class="quoted">"is_TNil <span class="main">(</span>tfilter <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> tset <span class="free">xs</span><span class="main">.</span> <span class="main">¬</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> iffI ballI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> tset <span class="free">xs</span>"</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">P</span> <span class="skolem">x</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> tllist_set_induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>find <span class="skolem">xs</span><span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">xs</span> <span class="skolem">x</span><span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> tfilter.fixp_induct<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> tllist.split<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="TLList_CCPO_Examples-mcont2mcont_tfilter"><span class="command">lemma</span></span> mcont2mcont_tfilter<span class="main">[</span><span class="operator">THEN</span> tllist.mcont2mcont<span class="main">,</span> <span class="operator">simp</span><span class="main">,</span> <span class="operator">cont_intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> mcont_tfilter<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont <span class="main">(</span>tSup <span class="free">b</span><span class="main">)</span> <span class="main">(</span>tllist_ord <span class="free">b</span><span class="main">)</span> <span class="main">(</span>tSup <span class="free">b</span><span class="main">)</span> <span class="main">(</span>tllist_ord <span class="free">b</span><span class="main">)</span> <span class="main">(</span>tfilter <span class="free">b</span> <span class="free">P</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> tllist.fixp_preserves_mcont1<span class="main"><span class="main">[</span></span><span class="operator">OF</span> tfilter.mono tfilter_def<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> mcont_lprefix_case_aux<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="TLList_CCPO_Examples-tfilter_tfilter"><span class="command">lemma</span></span> tfilter_tfilter<span class="main">:</span>
  <span class="quoted"><span class="quoted">"tfilter <span class="free">b</span> <span class="free">P</span> <span class="main">(</span>tfilter <span class="free">b</span> <span class="free">Q</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> tfilter <span class="free">b</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="main">∧</span> <span class="free">Q</span> <span class="bound">x</span><span class="main">)</span> <span class="free">xs</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="free">xs</span> <span class="main">=</span> <span class="var">?rhs</span> <span class="free">xs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> tllist.leq_antisym<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">xs</span><span class="main">.</span> tllist_ord <span class="free">b</span> <span class="main">(</span><span class="var">?lhs</span> <span class="bound">xs</span><span class="main">)</span> <span class="main">(</span><span class="var">?rhs</span> <span class="bound">xs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> tfilter.fixp_induct<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> Pa<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">λ</span></span></span><span class="bound"><span class="bound"><span class="bound">f</span></span></span><span class="main"><span class="main"><span class="main">.</span></span></span> <span class="main"><span class="main"><span class="main">∀</span></span></span><span class="bound"><span class="bound"><span class="bound">xs</span></span></span><span class="main"><span class="main"><span class="main">.</span></span></span> tllist_ord <span class="free"><span class="free"><span class="free">b</span></span></span> <span class="main"><span class="main"><span class="main">(</span></span></span>tfilter <span class="free"><span class="free"><span class="free">b</span></span></span> <span class="free"><span class="free"><span class="free">P</span></span></span> <span class="main"><span class="main"><span class="main">(</span></span></span><span class="bound"><span class="bound"><span class="bound">f</span></span></span> <span class="bound"><span class="bound"><span class="bound">xs</span></span></span><span class="main"><span class="main"><span class="main">)</span></span></span><span class="main"><span class="main"><span class="main">)</span></span></span> <span class="main"><span class="main"><span class="main">(</span></span></span><span class="var"><span class="var"><span class="var">?rhs</span></span></span> <span class="bound"><span class="bound"><span class="bound">xs</span></span></span><span class="main"><span class="main"><span class="main">)</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> tllist.split<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"tllist_ord <span class="free">b</span> <span class="main">(</span><span class="var">?lhs</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span><span class="var">?rhs</span> <span class="free">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">xs</span><span class="main">.</span> tllist_ord <span class="free">b</span> <span class="main">(</span><span class="var">?rhs</span> <span class="bound">xs</span><span class="main">)</span> <span class="main">(</span><span class="var">?lhs</span> <span class="bound">xs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> tfilter.fixp_induct<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> Pa<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">λ</span></span></span><span class="bound"><span class="bound"><span class="bound">f</span></span></span><span class="main"><span class="main"><span class="main">.</span></span></span> <span class="main"><span class="main"><span class="main">∀</span></span></span><span class="bound"><span class="bound"><span class="bound">xs</span></span></span><span class="main"><span class="main"><span class="main">.</span></span></span> tllist_ord <span class="free"><span class="free"><span class="free">b</span></span></span> <span class="main"><span class="main"><span class="main">(</span></span></span><span class="bound"><span class="bound"><span class="bound">f</span></span></span> <span class="bound"><span class="bound"><span class="bound">xs</span></span></span><span class="main"><span class="main"><span class="main">)</span></span></span> <span class="main"><span class="main"><span class="main">(</span></span></span><span class="var"><span class="var"><span class="var">?lhs</span></span></span> <span class="bound"><span class="bound"><span class="bound">xs</span></span></span><span class="main"><span class="main"><span class="main">)</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> tllist.split<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"tllist_ord <span class="free">b</span> <span class="main">(</span><span class="var">?rhs</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span><span class="var">?lhs</span> <span class="free">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">declare</span></span> ccpo.admissible_leI<span class="main">[</span><span class="operator">OF</span> complete_lattice_ccpo<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span>

<span class="keyword1" id="TLList_CCPO_Examples-tset_tfilter"><span class="command">lemma</span></span> tset_tfilter<span class="main">:</span> <span class="quoted"><span class="quoted">"tset <span class="main">(</span>tfilter <span class="free">b</span> <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">x</span></span><span class="main">∈</span>tset <span class="free">xs</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> equalityI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ subsetI<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"tset <span class="main">(</span>tfilter <span class="free">b</span> <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound"><span class="bound">x</span></span> <span class="main">∈</span> tset <span class="free">xs</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> tfilter.fixp_induct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> tllist.split<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="main">{</span><span class="bound"><span class="bound">x</span></span> <span class="main">∈</span> tset <span class="free">xs</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> tset <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> tset <span class="main">(</span>tfilter <span class="free">b</span> <span class="free">P</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> tset_induct<span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">b</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'b</span></span></span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">interpretation</span></span> tllist_pf <span class="quoted"><span class="free">b</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">partial_function</span></span> <span class="main">(</span>tllist<span class="main">)</span> <span class="entity">tconcat</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> llist<span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> tllist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">tconcat</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">of</span> TNil <span class="bound">b</span> <span class="main">⇒</span> TNil <span class="bound">b</span> <span class="main">|</span> TCons <span class="bound">x</span> <span class="bound">xs'</span> <span class="main">⇒</span> lappendt <span class="bound">x</span> <span class="main">(</span><span class="free">tconcat</span> <span class="bound">xs'</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">simps_of_case</span></span> tconcat2_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> tconcat.simps

<span class="keyword2"><span class="keyword">end</span></span>

</pre>
</div><div id="Koenigslemma">
<div class="head">
<h1>Theory Koenigslemma</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Koenig's lemma with paths modelled as coinductive lists
    Author:      Andreas Lochbihler
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Example: Koenig's lemma›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Koenigslemma <span class="keyword2"><span class="keyword">imports</span></span> 
  <span class="quoted">"<a href="#Coinductive_List">../Coinductive_List</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'node</span> graph <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'node</span> <span class="main">⇒</span> <span class="tfree">'node</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'node</span> path <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'node</span> llist"</span></span>

<span class="keyword1"><span class="command">coinductive_set</span></span> <span class="entity">paths</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'node</span> graph <span class="main">⇒</span> <span class="tfree">'node</span> path set"</span></span>
<span class="keyword2"><span class="keyword">for</span></span> <span class="entity">graph</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'node</span> graph"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  Empty<span class="main">:</span> <span class="quoted"><span class="quoted">"LNil <span class="main">∈</span> <span class="free">paths</span> <span class="free">graph</span>"</span></span>
<span class="main">|</span> Single<span class="main">:</span> <span class="quoted"><span class="quoted">"LCons <span class="free"><span class="bound"><span class="entity">x</span></span></span> LNil <span class="main">∈</span> <span class="free">paths</span> <span class="free">graph</span>"</span></span>
<span class="main">|</span> LCons<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">graph</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">;</span> LCons <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">∈</span> <span class="free">paths</span> <span class="free">graph</span> <span class="main">⟧</span> <span class="main">⟹</span> LCons <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>LCons <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">∈</span> <span class="free">paths</span> <span class="free">graph</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">connected</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'node</span> graph <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">connected</span> <span class="free"><span class="bound"><span class="entity">graph</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">n</span> <span class="bound">n'</span><span class="main">.</span> <span class="main">∃</span><span class="bound">xs</span><span class="main">.</span> llist_of <span class="main">(</span><span class="bound">n</span> <span class="main">#</span> <span class="bound">xs</span> <span class="main">@</span> <span class="main">[</span><span class="bound">n'</span><span class="main">]</span><span class="main">)</span> <span class="main">∈</span> paths <span class="free"><span class="bound"><span class="entity">graph</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">inductive_set</span></span> <span class="entity">reachable_via</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'node</span> graph <span class="main">⇒</span> <span class="tfree">'node</span> set <span class="main">⇒</span> <span class="tfree">'node</span> <span class="main">⇒</span> <span class="tfree">'node</span> set"</span></span>
<span class="keyword2"><span class="keyword">for</span></span> <span class="entity">graph</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'node</span> graph"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="entity">ns</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'node</span> set"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="entity">n</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'node</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> LCons <span class="free">n</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">∈</span> paths <span class="free">graph</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">n'</span></span></span> <span class="main">∈</span> lset <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">;</span> lset <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">⊆</span> <span class="free">ns</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free"><span class="bound"><span class="entity">n'</span></span></span> <span class="main">∈</span> <span class="free">reachable_via</span> <span class="free">graph</span> <span class="free">ns</span> <span class="free">n</span>"</span></span>


<span class="keyword1" id="Koenigslemma-connectedD"><span class="command">lemma</span></span> connectedD<span class="main">:</span> <span class="quoted"><span class="quoted">"connected <span class="free">graph</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">xs</span><span class="main">.</span> llist_of <span class="main">(</span><span class="free">n</span> <span class="main">#</span> <span class="bound">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">n'</span><span class="main">]</span><span class="main">)</span> <span class="main">∈</span> paths <span class="free">graph</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> connected_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="Koenigslemma-paths_LConsD"><span class="command">lemma</span></span> paths_LConsD<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"LCons <span class="free">x</span> <span class="free">xs</span> <span class="main">∈</span> paths <span class="free">graph</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">∈</span> paths <span class="free">graph</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduct</span><span class="main">)</span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> paths.cases <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> disjCI<span class="main">)</span>

<span class="keyword1" id="Koenigslemma-paths_lappendD1"><span class="command">lemma</span></span> paths_lappendD1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"lappend <span class="free">xs</span> <span class="free">ys</span> <span class="main">∈</span> paths <span class="free">graph</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">∈</span> paths <span class="free">graph</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">coinduct</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule</span> paths.cases<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lappend_eq_LNil_iff<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lappend_eq_LNil_iff<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x22</span></span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Koenigslemma-paths_lappendD2"><span class="command">lemma</span></span> paths_lappendD2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"lappend <span class="free">xs</span> <span class="free">ys</span> <span class="main">∈</span> paths <span class="free">graph</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">∈</span> paths <span class="free">graph</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> paths.cases <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> paths.intros<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Koenigslemma-path_avoid_node"><span class="command">lemma</span></span> path_avoid_node<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> path<span class="main">:</span> <span class="quoted"><span class="quoted">"LCons <span class="free">n</span> <span class="free">xs</span> <span class="main">∈</span> paths <span class="free">graph</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> set<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> lset <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> n_neq_x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≠</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">xs'</span><span class="main">.</span> LCons <span class="free">n</span> <span class="bound">xs'</span> <span class="main">∈</span> paths <span class="free">graph</span> <span class="main">∧</span> lset <span class="bound">xs'</span> <span class="main">⊆</span> lset <span class="free">xs</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">∈</span> lset <span class="bound">xs'</span> <span class="main">∧</span> <span class="free">n</span> <span class="main">∉</span> lset <span class="bound">xs'</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> set <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xs'</span></span> <span class="skolem"><span class="skolem">xs''</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="skolem">xs'</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> lappend <span class="skolem">xs'</span> <span class="main">(</span>LCons <span class="free">x</span> <span class="skolem">xs''</span><span class="main">)</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∉</span> lset <span class="skolem">xs'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> split_llist_first<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">∈</span> lset <span class="skolem">xs'</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?xs'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"lappend <span class="skolem">xs'</span> <span class="main">(</span>LCons <span class="free">x</span> LNil<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> xs path <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lappend <span class="main">(</span>LCons <span class="free">n</span> <span class="main">(</span>lappend <span class="skolem">xs'</span> <span class="main">(</span>LCons <span class="free">x</span> LNil<span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="skolem">xs''</span> <span class="main">∈</span> paths <span class="free">graph</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lappend_assoc<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"LCons <span class="free">n</span> <span class="var">?xs'</span> <span class="main">∈</span> paths <span class="free">graph</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> paths_lappendD1<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> lset <span class="var">?xs'</span>"</span></span> <span class="quoted"><span class="quoted">"lset <span class="var">?xs'</span> <span class="main">⊆</span> lset <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">∉</span> lset <span class="var">?xs'</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> xs False <span class="quoted"><span class="quoted">‹lfinite <span class="skolem">xs'</span>›</span></span> n_neq_x <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹lfinite <span class="skolem">xs'</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">XS'</span></span> <span class="keyword2"><span class="keyword">where</span></span> xs'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xs'</span> <span class="main">=</span> llist_of <span class="skolem">XS'</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> lfinite_eq_range_llist_of <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">with</span></span> True <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">∈</span> set <span class="skolem">XS'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> split_list_last<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">ys</span></span> <span class="skolem"><span class="skolem">zs</span></span> <span class="keyword2"><span class="keyword">where</span></span> XS'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">XS'</span> <span class="main">=</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="free">n</span> <span class="main">#</span> <span class="skolem">zs</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">∉</span> set <span class="skolem">zs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?xs'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"lappend <span class="main">(</span>llist_of <span class="skolem">zs</span><span class="main">)</span> <span class="main">(</span>LCons <span class="free">x</span> LNil<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>LCons <span class="free">n</span> <span class="main">(</span>llist_of <span class="skolem">ys</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> xs xs' XS' path
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lappend <span class="main">(</span>LCons <span class="free">n</span> <span class="main">(</span>llist_of <span class="skolem">ys</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>lappend <span class="main">(</span>LCons <span class="free">n</span> <span class="var">?xs'</span><span class="main">)</span> <span class="skolem">xs''</span><span class="main">)</span> <span class="main">∈</span> paths <span class="free">graph</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lappend_assoc<span class="main">)</span><span class="main">(</span><span class="operator">metis</span> lappend_assoc lappend_llist_of_LCons lappend_llist_of_llist_of llist_of.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lappend <span class="main">(</span>LCons <span class="free">n</span> <span class="var">?xs'</span><span class="main">)</span> <span class="skolem">xs''</span> <span class="main">∈</span> paths <span class="free">graph</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> paths_lappendD2<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"LCons <span class="free">n</span> <span class="var">?xs'</span> <span class="main">∈</span> paths <span class="free">graph</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> paths_lappendD1<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> lset <span class="var">?xs'</span>"</span></span> <span class="quoted"><span class="quoted">"lset <span class="var">?xs'</span> <span class="main">⊆</span> lset <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">∉</span> lset <span class="var">?xs'</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> xs xs' XS' <span class="quoted"><span class="quoted">‹lfinite <span class="skolem">xs'</span>›</span></span> n_neq_x <span class="quoted"><span class="quoted">‹<span class="free">n</span> <span class="main">∉</span> set <span class="skolem">zs</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Koenigslemma-reachable_via_subset_unfold"><span class="command">lemma</span></span> reachable_via_subset_unfold<span class="main">:</span>
  <span class="quoted"><span class="quoted">"reachable_via <span class="free">graph</span> <span class="free">ns</span> <span class="free">n</span> <span class="main">⊆</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">n'</span> <span class="main">∈</span> <span class="main">{</span><span class="bound">n'</span><span class="main">.</span> <span class="free">graph</span> <span class="free">n</span> <span class="bound">n'</span><span class="main">}</span> <span class="main">∩</span> <span class="free">ns</span><span class="main">.</span> insert <span class="bound">n'</span> <span class="main">(</span>reachable_via <span class="free">graph</span> <span class="main">(</span><span class="free">ns</span> <span class="main">-</span> <span class="main">{</span><span class="bound">n'</span><span class="main">}</span><span class="main">)</span> <span class="bound">n'</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⊆</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> subsetI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="var">?lhs</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xs</span></span> <span class="keyword2"><span class="keyword">where</span></span> path<span class="main">:</span> <span class="quoted"><span class="quoted">"LCons <span class="free">n</span> <span class="skolem">xs</span> <span class="main">∈</span> paths <span class="free">graph</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> lset <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="quoted">"lset <span class="skolem">xs</span> <span class="main">⊆</span> <span class="free">ns</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">cases</span>

  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> lset <span class="skolem">xs</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">n'</span></span> <span class="skolem"><span class="skolem">xs'</span></span> <span class="keyword2"><span class="keyword">where</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> LCons <span class="skolem">n'</span> <span class="skolem">xs'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> path <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">graph</span> <span class="free">n</span> <span class="skolem">n'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">cases</span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹lset <span class="skolem">xs</span> <span class="main">⊆</span> <span class="free">ns</span>›</span></span> xs <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n'</span> <span class="main">∈</span> <span class="free">ns</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n'</span> <span class="main">∈</span> <span class="main">{</span><span class="bound">n'</span><span class="main">.</span> <span class="free">graph</span> <span class="free">n</span> <span class="bound">n'</span><span class="main">}</span> <span class="main">∩</span> <span class="free">ns</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="var">?rhs</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> UN_I<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> insert <span class="skolem">n'</span> <span class="main">(</span>reachable_via <span class="free">graph</span> <span class="main">(</span><span class="free">ns</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">n'</span><span class="main">}</span><span class="main">)</span> <span class="skolem">n'</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">n'</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">with</span></span> xs <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> lset <span class="skolem">xs</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> lset <span class="skolem">xs'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">with</span></span> path xs <span class="keyword1"><span class="command">have</span></span> path'<span class="main">:</span> <span class="quoted"><span class="quoted">"LCons <span class="skolem">n'</span> <span class="skolem">xs'</span> <span class="main">∈</span> paths <span class="free">graph</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">cases</span> <span class="operator">simp_all</span>
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹lset <span class="skolem">xs</span> <span class="main">⊆</span> <span class="free">ns</span>›</span></span> xs <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lset <span class="skolem">xs'</span> <span class="main">⊆</span> <span class="free">ns</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      
      <span class="keyword1"><span class="command">from</span></span> path_avoid_node<span class="main">[</span><span class="operator">OF</span> path' <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> lset <span class="skolem">xs'</span>›</span></span><span class="main">]</span> False
      <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xs''</span></span> <span class="keyword2"><span class="keyword">where</span></span> path''<span class="main">:</span> <span class="quoted"><span class="quoted">"LCons <span class="skolem">n'</span> <span class="skolem">xs''</span> <span class="main">∈</span> paths <span class="free">graph</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"lset <span class="skolem">xs''</span> <span class="main">⊆</span> lset <span class="skolem">xs'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> lset <span class="skolem">xs''</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n'</span> <span class="main">∉</span> lset <span class="skolem">xs''</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">with</span></span> False <span class="quoted"><span class="quoted">‹lset <span class="skolem">xs</span> <span class="main">⊆</span> <span class="free">ns</span>›</span></span> xs <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> reachable_via.intros<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> koenigslemma<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">graph</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'node</span> graph"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">n</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'node</span></span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> connected<span class="main">:</span> <span class="quoted"><span class="quoted">"connected <span class="free">graph</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> infinite<span class="main">:</span> <span class="quoted"><span class="quoted">"infinite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'node</span> set<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> finite_branching<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">n</span><span class="main">.</span> finite <span class="main">{</span><span class="bound">n'</span><span class="main">.</span> <span class="free">graph</span> <span class="bound">n</span> <span class="bound">n'</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">xs</span> <span class="main">∈</span> paths <span class="free">graph</span><span class="main">.</span> <span class="free">n</span> <span class="main">∈</span> lset <span class="bound">xs</span> <span class="main">∧</span> <span class="main">¬</span> lfinite <span class="bound">xs</span> <span class="main">∧</span> ldistinct <span class="bound">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">intro</span> bexI conjI<span class="main">)</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?P</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">n</span><span class="main">,</span> <span class="bound">ns</span><span class="main">)</span> <span class="bound">n'</span><span class="main">.</span> <span class="free">graph</span> <span class="bound">n</span> <span class="bound">n'</span> <span class="main">∧</span> infinite <span class="main">(</span>reachable_via <span class="free">graph</span> <span class="main">(</span><span class="main">-</span> insert <span class="bound">n</span> <span class="main">(</span>insert <span class="bound">n'</span> <span class="bound">ns</span><span class="main">)</span><span class="main">)</span> <span class="bound">n'</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">n'</span> <span class="main">∉</span> insert <span class="bound">n</span> <span class="bound">ns</span>"</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">LTL</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">LTL</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">n</span><span class="main">,</span> <span class="bound">ns</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">let</span> <span class="bound">n'</span> <span class="main">=</span> <span class="keyword1">SOME</span> <span class="bound">n'</span><span class="main">.</span> <span class="var">?P</span> <span class="main">(</span><span class="bound">n</span><span class="main">,</span> <span class="bound">ns</span><span class="main">)</span> <span class="bound">n'</span> <span class="keyword1">in</span> <span class="main">(</span><span class="bound">n'</span><span class="main">,</span> insert <span class="bound">n</span> <span class="bound">ns</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">f</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">=</span> unfold_llist <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> False<span class="main">)</span> fst <span class="skolem">LTL</span>"</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">ns</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'node</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ns</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>

  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">n</span> <span class="skolem">ns</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"infinite <span class="main">(</span>reachable_via <span class="free">graph</span> <span class="main">(</span><span class="main">-</span> insert <span class="skolem">n</span> <span class="skolem">ns</span><span class="main">)</span> <span class="skolem">n</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">n'</span><span class="main">.</span> <span class="var">?P</span> <span class="main">(</span><span class="skolem">n</span><span class="main">,</span> <span class="skolem">ns</span><span class="main">)</span> <span class="bound">n'</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> contrapos_np<span class="main">)</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="var">?thesis</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> fin<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">n'</span><span class="main">.</span> <span class="main">⟦</span> <span class="free">graph</span> <span class="skolem">n</span> <span class="bound">n'</span><span class="main">;</span> <span class="bound">n'</span> <span class="main">∉</span> insert <span class="skolem">n</span> <span class="skolem">ns</span> <span class="main">⟧</span> <span class="main">⟹</span> finite <span class="main">(</span>reachable_via <span class="free">graph</span> <span class="main">(</span><span class="main">-</span> insert <span class="skolem">n</span> <span class="main">(</span>insert <span class="bound">n'</span> <span class="skolem">ns</span><span class="main">)</span><span class="main">)</span> <span class="bound">n'</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        
      <span class="keyword1"><span class="command">from</span></span> reachable_via_subset_unfold<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">graph</span></span> <span class="quoted"><span class="quoted">"<span class="main">-</span> insert <span class="skolem">n</span> <span class="skolem">ns</span>"</span></span> <span class="quoted"><span class="skolem">n</span></span><span class="main">]</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>reachable_via <span class="free">graph</span> <span class="main">(</span><span class="main">-</span> insert <span class="skolem">n</span> <span class="skolem">ns</span><span class="main">)</span> <span class="skolem">n</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ finite_UN_I<span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">from</span></span> finite_branching<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">n</span></span><span class="main">]</span>
        <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="main">{</span><span class="bound">n'</span><span class="main">.</span> <span class="free">graph</span> <span class="skolem">n</span> <span class="bound">n'</span><span class="main">}</span> <span class="main">∩</span> <span class="main">-</span> insert <span class="skolem">n</span> <span class="skolem">ns</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">n'</span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n'</span> <span class="main">∈</span> <span class="main">{</span><span class="bound">n'</span><span class="main">.</span> <span class="free">graph</span> <span class="skolem">n</span> <span class="bound">n'</span><span class="main">}</span> <span class="main">∩</span> <span class="main">-</span> insert <span class="skolem">n</span> <span class="skolem">ns</span>"</span></span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">graph</span> <span class="skolem">n</span> <span class="skolem">n'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n'</span> <span class="main">∉</span> insert <span class="skolem">n</span> <span class="skolem">ns</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
        <span class="keyword1"><span class="command">from</span></span> fin<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>reachable_via <span class="free">graph</span> <span class="main">(</span><span class="main">-</span> insert <span class="skolem">n</span> <span class="main">(</span>insert <span class="skolem">n'</span> <span class="skolem">ns</span><span class="main">)</span><span class="main">)</span> <span class="skolem">n'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">-</span> insert <span class="skolem">n</span> <span class="main">(</span>insert <span class="skolem">n'</span> <span class="skolem">ns</span><span class="main">)</span> <span class="main">=</span> <span class="main">-</span> insert <span class="skolem">n</span> <span class="skolem">ns</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">n'</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>insert <span class="skolem">n'</span> <span class="main">(</span>reachable_via <span class="free">graph</span> <span class="main">(</span><span class="main">-</span> insert <span class="skolem">n</span> <span class="skolem">ns</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">n'</span><span class="main">}</span><span class="main">)</span> <span class="skolem">n'</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">note</span></span> ex_P_I <span class="main">=</span> this

  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">n</span> <span class="skolem">ns</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lnull <span class="main">(</span><span class="skolem">f</span> <span class="main">(</span><span class="skolem">n</span><span class="main">,</span> <span class="skolem">ns</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="quoted"><span class="quoted">"lhd <span class="main">(</span><span class="skolem">f</span> <span class="main">(</span><span class="skolem">n</span><span class="main">,</span> <span class="skolem">ns</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">n</span>"</span></span>
      <span class="quoted"><span class="quoted">"ltl <span class="main">(</span><span class="skolem">f</span> <span class="main">(</span><span class="skolem">n</span><span class="main">,</span> <span class="skolem">ns</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">n'</span> <span class="main">=</span> <span class="keyword1">SOME</span> <span class="bound">n'</span><span class="main">.</span> <span class="var">?P</span> <span class="main">(</span><span class="skolem">n</span><span class="main">,</span> <span class="skolem">ns</span><span class="main">)</span> <span class="bound">n'</span> <span class="keyword1">in</span> <span class="skolem">f</span> <span class="main">(</span><span class="bound">n'</span><span class="main">,</span> insert <span class="skolem">n</span> <span class="skolem">ns</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> f_def LTL_def<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">note</span></span> f_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> this

  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">n</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'node</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">ns</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'node</span> set"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'node</span></span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> lset <span class="main">(</span><span class="skolem">f</span> <span class="main">(</span><span class="skolem">n</span><span class="main">,</span> <span class="skolem">ns</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">∉</span> <span class="skolem">ns</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"finite <span class="skolem">ns</span>"</span></span> <span class="quoted"><span class="quoted">"infinite <span class="main">(</span>reachable_via <span class="free">graph</span> <span class="main">(</span><span class="main">-</span> insert <span class="skolem">n</span> <span class="skolem">ns</span><span class="main">)</span> <span class="skolem">n</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∉</span> <span class="skolem">ns</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">(</span><span class="skolem">n</span><span class="main">,</span> <span class="skolem">ns</span><span class="main">)</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">n</span></span> <span class="quoted"><span class="skolem">ns</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lset_induct<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> find
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 4 <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> sym eq_LConsD<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">x'</span> <span class="skolem">xs</span><span class="main">)</span>
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?n'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"Eps <span class="main">(</span><span class="var">?P</span> <span class="main">(</span><span class="skolem">n</span><span class="main">,</span> <span class="skolem">ns</span><span class="main">)</span><span class="main">)</span>"</span></span> 
        <span class="keyword2"><span class="keyword">and</span></span> <span class="var"><span class="quoted"><span class="var">?ns'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"insert <span class="skolem">n</span> <span class="skolem">ns</span>"</span></span>
      <span class="keyword1"><span class="command">from</span></span> eq_LConsD<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹LCons <span class="skolem">x'</span> <span class="skolem">xs</span> <span class="main">=</span> <span class="skolem">f</span> <span class="main">(</span><span class="skolem">n</span><span class="main">,</span> <span class="skolem">ns</span><span class="main">)</span>›</span></span><span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x'</span> <span class="main">=</span> <span class="skolem">n</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> <span class="skolem">f</span> <span class="main">(</span><span class="var">?n'</span><span class="main">,</span> <span class="var">?ns'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹infinite <span class="main">(</span>reachable_via <span class="free">graph</span> <span class="main">(</span><span class="main">-</span> insert <span class="skolem">n</span> <span class="skolem">ns</span><span class="main">)</span> <span class="skolem">n</span><span class="main">)</span>›</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">n'</span><span class="main">.</span> <span class="var">?P</span> <span class="main">(</span><span class="skolem">n</span><span class="main">,</span> <span class="skolem">ns</span><span class="main">)</span> <span class="bound">n'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> ex_P_I<span class="main">)</span>
      <span class="keyword1"><span class="command">hence</span></span> P<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?P</span> <span class="main">(</span><span class="skolem">n</span><span class="main">,</span> <span class="skolem">ns</span><span class="main">)</span> <span class="var">?n'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> someI_ex<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"insert <span class="var">?n'</span> <span class="var">?ns'</span> <span class="main">=</span> insert <span class="skolem">n</span> <span class="main">(</span>insert <span class="var">?n'</span> <span class="skolem">ns</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?n'</span> <span class="main">∉</span> <span class="var">?ns'</span>"</span></span> <span class="quoted"><span class="quoted">"finite <span class="var">?ns'</span>"</span></span> 
        <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"infinite <span class="main">(</span>reachable_via <span class="free">graph</span> <span class="main">(</span><span class="main">-</span> insert <span class="var">?n'</span> <span class="var">?ns'</span><span class="main">)</span> <span class="var">?n'</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹finite <span class="skolem">ns</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> xs <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∉</span> <span class="var">?ns'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> step<span class="main">)</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">note</span></span> lset <span class="main">=</span> this

  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">∈</span> lset <span class="main">(</span><span class="skolem">f</span> <span class="main">(</span><span class="free">n</span><span class="main">,</span> <span class="skolem">ns</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> llist.set_sel<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> f_simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="skolem">ns</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> llist.set_sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lfinite <span class="main">(</span><span class="skolem">f</span> <span class="main">(</span><span class="free">n</span><span class="main">,</span> <span class="skolem">ns</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span><span class="skolem">f</span> <span class="main">(</span><span class="free">n</span><span class="main">,</span> <span class="skolem">ns</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">(</span><span class="free">n</span><span class="main">,</span> <span class="skolem">ns</span><span class="main">)</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="skolem">ns</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lfinite_induct<span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?X</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="main">∃</span><span class="bound">n</span> <span class="bound">ns</span><span class="main">.</span> <span class="bound">xs</span> <span class="main">=</span> <span class="skolem">f</span> <span class="main">(</span><span class="bound">n</span><span class="main">,</span> <span class="bound">ns</span><span class="main">)</span> <span class="main">∧</span> finite <span class="bound">ns</span> <span class="main">∧</span> infinite <span class="main">(</span>reachable_via <span class="free">graph</span> <span class="main">(</span><span class="main">-</span> insert <span class="bound">n</span> <span class="bound">ns</span><span class="main">)</span> <span class="bound">n</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"reachable_via <span class="free">graph</span> <span class="main">(</span><span class="main">-</span> <span class="main">{</span><span class="free">n</span><span class="main">}</span><span class="main">)</span> <span class="free">n</span> <span class="main">⊇</span> <span class="main">-</span> <span class="main">{</span><span class="free">n</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> subsetI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">n'</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'node</span></span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n'</span> <span class="main">∈</span> <span class="main">-</span> <span class="main">{</span><span class="free">n</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≠</span> <span class="skolem">n'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> connected <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xs</span></span>
      <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"llist_of <span class="main">(</span><span class="free">n</span> <span class="main">#</span> <span class="skolem">xs</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">n'</span><span class="main">]</span><span class="main">)</span> <span class="main">∈</span> paths <span class="free">graph</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> connectedD<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"LCons <span class="free">n</span> <span class="main">(</span>llist_of <span class="main">(</span><span class="skolem">xs</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">n'</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> paths <span class="free">graph</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n'</span> <span class="main">∈</span> lset <span class="main">(</span>llist_of <span class="main">(</span><span class="skolem">xs</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">n'</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command">from</span></span> path_avoid_node<span class="main">[</span><span class="operator">OF</span> this <span class="quoted"><span class="quoted">‹<span class="free">n</span> <span class="main">≠</span> <span class="skolem">n'</span>›</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n'</span> <span class="main">∈</span> reachable_via <span class="free">graph</span> <span class="main">(</span><span class="main">-</span> <span class="main">{</span><span class="free">n</span><span class="main">}</span><span class="main">)</span> <span class="free">n</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> reachable_via.intros<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"infinite <span class="main">(</span>reachable_via <span class="free">graph</span> <span class="main">(</span><span class="main">-</span> <span class="main">{</span><span class="free">n</span><span class="main">}</span><span class="main">)</span> <span class="free">n</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> infinite <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> finite_subset<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> X<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?X</span> <span class="main">(</span><span class="skolem">f</span> <span class="main">(</span><span class="free">n</span><span class="main">,</span> <span class="main">{}</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">(</span><span class="free">n</span><span class="main">,</span> <span class="main">{}</span><span class="main">)</span> <span class="main">∈</span> paths <span class="free">graph</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduct</span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>paths <span class="skolem">xs</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="skolem"><span class="skolem">ns</span></span> <span class="keyword2"><span class="keyword">where</span></span> xs_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> <span class="skolem">f</span> <span class="main">(</span><span class="skolem">n</span><span class="main">,</span> <span class="skolem">ns</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"finite <span class="skolem">ns</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"infinite <span class="main">(</span>reachable_via <span class="free">graph</span> <span class="main">(</span><span class="main">-</span> insert <span class="skolem">n</span> <span class="skolem">ns</span><span class="main">)</span> <span class="skolem">n</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹infinite <span class="main">(</span>reachable_via <span class="free">graph</span> <span class="main">(</span><span class="main">-</span> insert <span class="skolem">n</span> <span class="skolem">ns</span><span class="main">)</span> <span class="skolem">n</span><span class="main">)</span>›</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">n'</span><span class="main">.</span> <span class="var">?P</span> <span class="main">(</span><span class="skolem">n</span><span class="main">,</span> <span class="skolem">ns</span><span class="main">)</span> <span class="bound">n'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> ex_P_I<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> P<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?P</span> <span class="main">(</span><span class="skolem">n</span><span class="main">,</span> <span class="skolem">ns</span><span class="main">)</span> <span class="main">(</span>Eps <span class="main">(</span><span class="var">?P</span> <span class="main">(</span><span class="skolem">n</span><span class="main">,</span> <span class="skolem">ns</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> someI_ex<span class="main">)</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?n'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"Eps <span class="main">(</span><span class="var">?P</span> <span class="main">(</span><span class="skolem">n</span><span class="main">,</span> <span class="skolem">ns</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?ns'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"insert <span class="skolem">n</span> <span class="skolem">ns</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?n''</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"Eps <span class="main">(</span><span class="var">?P</span> <span class="main">(</span><span class="var">?n'</span><span class="main">,</span> <span class="var">?ns'</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?ns''</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"insert <span class="var">?n'</span> <span class="var">?ns'</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> LCons <span class="skolem">n</span> <span class="main">(</span>LCons <span class="var">?n'</span> <span class="main">(</span><span class="skolem">f</span> <span class="main">(</span><span class="var">?n''</span><span class="main">,</span> <span class="var">?ns''</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> xs_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> llist.expand<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> P <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">graph</span> <span class="skolem">n</span> <span class="var">?n'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"LCons <span class="var">?n'</span> <span class="main">(</span><span class="skolem">f</span> <span class="main">(</span><span class="var">?n''</span><span class="main">,</span> <span class="var">?ns''</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">f</span> <span class="main">(</span><span class="var">?n'</span><span class="main">,</span> <span class="var">?ns'</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> llist.expand<span class="main">)</span> <span class="operator">simp_all</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="var">?ns'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹finite <span class="skolem">ns</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"insert <span class="var">?n'</span> <span class="var">?ns'</span> <span class="main">=</span> insert <span class="skolem">n</span> <span class="main">(</span>insert <span class="var">?n'</span> <span class="skolem">ns</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"infinite <span class="main">(</span>reachable_via <span class="free">graph</span> <span class="main">(</span><span class="main">-</span> insert <span class="var">?n'</span> <span class="var">?ns'</span><span class="main">)</span> <span class="var">?n'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> P <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?X</span> <span class="main">(</span>LCons <span class="var">?n'</span> <span class="main">(</span><span class="skolem">f</span> <span class="main">(</span><span class="var">?n''</span><span class="main">,</span> <span class="var">?ns''</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?LCons</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹infinite <span class="main">(</span>reachable_via <span class="free">graph</span> <span class="main">(</span><span class="main">-</span> <span class="main">{</span><span class="free">n</span><span class="main">}</span><span class="main">)</span> <span class="free">n</span><span class="main">)</span>›</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"infinite <span class="main">(</span>reachable_via <span class="free">graph</span> <span class="main">(</span><span class="main">-</span> insert <span class="free">n</span> <span class="skolem">ns</span><span class="main">)</span> <span class="free">n</span><span class="main">)</span> <span class="main">∧</span> finite <span class="skolem">ns</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ns_def<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"ldistinct <span class="main">(</span><span class="skolem">f</span> <span class="main">(</span><span class="free">n</span><span class="main">,</span> <span class="skolem">ns</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="skolem">ns</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>ldistinct <span class="skolem">n</span> <span class="skolem">ns</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="quoted"><span class="quoted">"finite <span class="skolem">ns</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"infinite <span class="main">(</span>reachable_via <span class="free">graph</span> <span class="main">(</span><span class="main">-</span> insert <span class="skolem">n</span> <span class="skolem">ns</span><span class="main">)</span> <span class="skolem">n</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹infinite <span class="main">(</span>reachable_via <span class="free">graph</span> <span class="main">(</span><span class="main">-</span> insert <span class="skolem">n</span> <span class="skolem">ns</span><span class="main">)</span> <span class="skolem">n</span><span class="main">)</span>›</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">n'</span><span class="main">.</span> <span class="var">?P</span> <span class="main">(</span><span class="skolem">n</span><span class="main">,</span> <span class="skolem">ns</span><span class="main">)</span> <span class="bound">n'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> ex_P_I<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> P<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?P</span> <span class="main">(</span><span class="skolem">n</span><span class="main">,</span> <span class="skolem">ns</span><span class="main">)</span> <span class="main">(</span>Eps <span class="main">(</span><span class="var">?P</span> <span class="main">(</span><span class="skolem">n</span><span class="main">,</span> <span class="skolem">ns</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> someI_ex<span class="main">)</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?n'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"Eps <span class="main">(</span><span class="var">?P</span> <span class="main">(</span><span class="skolem">n</span><span class="main">,</span> <span class="skolem">ns</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?ns'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"insert <span class="skolem">n</span> <span class="skolem">ns</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> eq<span class="main">:</span> <span class="quoted"><span class="quoted">"insert <span class="var">?n'</span> <span class="var">?ns'</span> <span class="main">=</span> insert <span class="skolem">n</span> <span class="main">(</span>insert <span class="var">?n'</span> <span class="skolem">ns</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">∉</span> lset <span class="main">(</span><span class="skolem">f</span> <span class="main">(</span><span class="var">?n'</span><span class="main">,</span> <span class="var">?ns'</span><span class="main">)</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> P <span class="quoted"><span class="quoted">‹finite <span class="skolem">ns</span>›</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lset<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹finite <span class="skolem">ns</span>›</span></span> P eq
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"infinite <span class="main">(</span>reachable_via <span class="free">graph</span> <span class="main">(</span><span class="main">-</span> insert <span class="var">?n'</span> <span class="var">?ns'</span><span class="main">)</span> <span class="var">?n'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹finite <span class="skolem">ns</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

</pre>
</div><div id="LMirror">
<div class="head">
<h1>Theory LMirror</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       LMirror
    Author:      Andreas Lochbihler, ETH Zurich
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Definition of the function lmirror›</span></span>

<span class="keyword1"><span class="command">theory</span></span> LMirror <span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="#Coinductive_List">../Coinductive_List</a>"</span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This theory defines a function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>lmirror›</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">primcorec</span></span> <span class="entity">lmirror_aux</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">⇒</span> <span class="tfree">'a</span> llist <span class="main">⇒</span> <span class="tfree">'a</span> llist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lmirror_aux</span> <span class="free"><span class="bound"><span class="entity">acc</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">of</span> LNil <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">acc</span></span></span> <span class="main">|</span> LCons <span class="bound">x</span> <span class="bound">xs'</span> <span class="main">⇒</span> LCons <span class="bound">x</span> <span class="main">(</span><span class="free">lmirror_aux</span> <span class="main">(</span>LCons <span class="bound">x</span> <span class="free"><span class="bound"><span class="entity">acc</span></span></span><span class="main">)</span> <span class="bound">xs'</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">lmirror</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">⇒</span> <span class="tfree">'a</span> llist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">lmirror</span> <span class="main">=</span> lmirror_aux LNil"</span></span>


<span class="keyword1"><span class="command">simps_of_case</span></span> lmirror_aux_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> lmirror_aux.code

<span class="keyword1" id="LMirror-lnull_lmirror_aux"><span class="command">lemma</span></span> lnull_lmirror_aux <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lnull <span class="main">(</span>lmirror_aux <span class="free">acc</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>lnull <span class="free">xs</span> <span class="main">∧</span> lnull <span class="free">acc</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> lmirror_aux.simps<span class="main">)</span>

<span class="keyword1" id="LMirror-ltl_lmirror_aux"><span class="command">lemma</span></span> ltl_lmirror_aux<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ltl <span class="main">(</span>lmirror_aux <span class="free">acc</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> lnull <span class="free">xs</span> <span class="keyword1">then</span> ltl <span class="free">acc</span> <span class="keyword1">else</span> lmirror_aux <span class="main">(</span>LCons <span class="main">(</span>lhd <span class="free">xs</span><span class="main">)</span> <span class="free">acc</span><span class="main">)</span> <span class="main">(</span>ltl <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">acc</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split<span class="main">)</span>

<span class="keyword1" id="LMirror-lhd_lmirror_aux"><span class="command">lemma</span></span> lhd_lmirror_aux<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lhd <span class="main">(</span>lmirror_aux <span class="free">acc</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> lnull <span class="free">xs</span> <span class="keyword1">then</span> lhd <span class="free">acc</span> <span class="keyword1">else</span> lhd <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">acc</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> lmirror_aux.sel<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword">del</span></span><span class="main">]</span>

<span class="keyword1" id="LMirror-lfinite_lmirror_aux"><span class="command">lemma</span></span> lfinite_lmirror_aux <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>lmirror_aux <span class="free">acc</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟷</span> lfinite <span class="free">xs</span> <span class="main">∧</span> lfinite <span class="free">acc</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="skolem">zs</span><span class="main"><span class="main">≡</span></span><span class="quoted"><span class="quoted">"lmirror_aux <span class="free">acc</span> <span class="free">xs</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">acc</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lfinite_induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> LCons
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"lnull <span class="skolem">xs</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">with</span></span> LCons.hyps<span class="main">(</span>3<span class="main">)</span><span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"ltl <span class="skolem">acc</span>"</span></span> <span class="quoted">LNil</span><span class="main">]</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltl_lmirror_aux<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltl_lmirror_aux<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">acc</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">acc</span></span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="LMirror-lmirror_aux_inf"><span class="command">lemma</span></span> lmirror_aux_inf<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">¬</span> lfinite <span class="free">xs</span> <span class="main">⟹</span> lmirror_aux <span class="free">acc</span> <span class="free">xs</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">acc</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lhd_lmirror_aux ltl_lmirror_aux<span class="main">)</span>

<span class="keyword1" id="LMirror-lmirror_aux_acc"><span class="command">lemma</span></span> lmirror_aux_acc<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lmirror_aux <span class="main">(</span>lappend <span class="free">ys</span> <span class="free">zs</span><span class="main">)</span> <span class="free">xs</span> <span class="main">=</span> lappend <span class="main">(</span>lmirror_aux <span class="free">ys</span> <span class="free">xs</span><span class="main">)</span> <span class="free">zs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lmirror_aux_inf lappend_inf<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lappend_code<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> lappend_code<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="LMirror-lmirror_aux_LCons"><span class="command">lemma</span></span> lmirror_aux_LCons<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lmirror_aux <span class="free">acc</span> <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> LCons <span class="free">x</span> <span class="main">(</span>lappend <span class="main">(</span>lmirror_aux LNil <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>LCons <span class="free">x</span> <span class="free">acc</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> lappend_code<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> lmirror_aux_acc lmirror_aux_simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>

<span class="keyword1" id="LMirror-llength_lmirror_aux"><span class="command">lemma</span></span> llength_lmirror_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"llength <span class="main">(</span>lmirror_aux <span class="free">acc</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="numeral">2</span> <span class="main">*</span> llength <span class="free">xs</span> <span class="main">+</span> llength <span class="free">acc</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">acc</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat_coinduct<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> iadd_is_0 epred_iadd1 mult_2 epred_llength ltl_lmirror_aux iadd_Suc_right<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> exI conjI refl<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> iadd_Suc_right llength_ltl<span class="main">)</span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>hide_lams<span class="main"><span class="main">,</span></span> no_types<span class="main"><span class="main">)</span></span> add.commute epred_llength iadd_Suc_right lhd_LCons_ltl llength_LCons<span class="main">)</span>

<span class="keyword1" id="LMirror-lnull_lmirror"><span class="command">lemma</span></span> lnull_lmirror <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lnull <span class="main">(</span>lmirror <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lnull <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lmirror_def<span class="main">)</span>

<span class="keyword1" id="LMirror-lmirror_LNil"><span class="command">lemma</span></span> lmirror_LNil <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lmirror LNil <span class="main">=</span> LNil"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lmirror_def<span class="main">)</span>

<span class="keyword1" id="LMirror-lmirror_LCons"><span class="command">lemma</span></span> lmirror_LCons <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lmirror <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> LCons <span class="free">x</span> <span class="main">(</span>lappend <span class="main">(</span>lmirror <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>LCons <span class="free">x</span> LNil<span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> lmirror_aux_LCons lmirror_def<span class="main">)</span>

<span class="keyword1" id="LMirror-ltl_lmirror"><span class="command">lemma</span></span> ltl_lmirror <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">¬</span> lnull <span class="free">xs</span> <span class="main">⟹</span> ltl <span class="main">(</span>lmirror <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lappend <span class="main">(</span>lmirror <span class="main">(</span>ltl <span class="free">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>LCons <span class="main">(</span>lhd <span class="free">xs</span><span class="main">)</span> LNil<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lnull_conv<span class="main">)</span>

<span class="keyword1" id="LMirror-lmap_lmirror_aux"><span class="command">lemma</span></span> lmap_lmirror_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"lmap <span class="free">f</span> <span class="main">(</span>lmirror_aux <span class="free">acc</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lmirror_aux <span class="main">(</span>lmap <span class="free">f</span> <span class="free">acc</span><span class="main">)</span> <span class="main">(</span>lmap <span class="free">f</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">acc</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> llist.coinduct_strong<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lhd_lmirror_aux ltl_lmirror_aux<span class="main">)</span>

<span class="keyword1" id="LMirror-lmap_lmirror"><span class="command">lemma</span></span> lmap_lmirror<span class="main">:</span> <span class="quoted"><span class="quoted">"lmap <span class="free">f</span> <span class="main">(</span>lmirror <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lmirror <span class="main">(</span>lmap <span class="free">f</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lmirror_def lmap_lmirror_aux<span class="main">)</span>

<span class="keyword1" id="LMirror-lset_lmirror_aux"><span class="command">lemma</span></span> lset_lmirror_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"lset <span class="main">(</span>lmirror_aux <span class="free">acc</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lset <span class="main">(</span>lappend <span class="free">xs</span> <span class="free">acc</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">acc</span></span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lmirror_aux_inf lappend_inf<span class="main">)</span>

<span class="keyword1" id="LMirror-lset_lmirror"><span class="command">lemma</span></span> lset_lmirror <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lset <span class="main">(</span>lmirror <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lset <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lmirror_def lset_lmirror_aux<span class="main">)</span>

<span class="keyword1" id="LMirror-llength_lmirror"><span class="command">lemma</span></span> llength_lmirror <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"llength <span class="main">(</span>lmirror <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="numeral">2</span> <span class="main">*</span> llength <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lmirror_def llength_lmirror_aux<span class="main">)</span>

<span class="keyword1" id="LMirror-lmirror_llist_of"><span class="command">lemma</span></span> lmirror_llist_of <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lmirror <span class="main">(</span>llist_of <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> llist_of <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> rev <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lappend_llist_of_LCons<span class="main">)</span>

<span class="keyword1" id="LMirror-list_of_lmirror"><span class="command">lemma</span></span> list_of_lmirror <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span> <span class="main">⟹</span> list_of <span class="main">(</span>lmirror <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> list_of <span class="free">xs</span> <span class="main">@</span> rev <span class="main">(</span>list_of <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> list_of_llist_of llist_of_list_of lmirror_llist_of<span class="main">)</span>

<span class="keyword1" id="LMirror-llist_all2_lmirror_aux"><span class="command">lemma</span></span> llist_all2_lmirror_aux<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> llist_all2 <span class="free">P</span> <span class="free">acc</span> <span class="free">acc'</span><span class="main">;</span> llist_all2 <span class="free">P</span> <span class="free">xs</span> <span class="free">xs'</span> <span class="main">⟧</span>
  <span class="main">⟹</span> llist_all2 <span class="free">P</span> <span class="main">(</span>lmirror_aux <span class="free">acc</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>lmirror_aux <span class="free">acc'</span> <span class="free">xs'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">acc</span></span> <span class="quoted"><span class="free">acc'</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">xs'</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lhd_lmirror_aux ltl_lmirror_aux <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> llist_all2_lhdD <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> llist_all2_ltlI exI <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> llist_all2_lnullD<span class="main">)</span>

<span class="keyword1" id="LMirror-enat_mult_cancel1"><span class="command">lemma</span></span> enat_mult_cancel1 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">*</span> <span class="free">m</span> <span class="main">=</span> <span class="free">k</span> <span class="main">*</span> <span class="free">n</span> <span class="main">⟷</span> <span class="free">m</span> <span class="main">=</span> <span class="free">n</span> <span class="main">∨</span> <span class="free">k</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∨</span> <span class="free">k</span> <span class="main">=</span> <span class="main">(</span><span class="main">∞</span> <span class="main">::</span> enat<span class="main">)</span> <span class="main">∧</span> <span class="free">n</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">∧</span> <span class="free">m</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">k</span></span> <span class="quoted"><span class="free">m</span></span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> enat.exhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> enat.exhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> enat.exhaust<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def<span class="main">)</span>

<span class="keyword1" id="LMirror-llist_all2_lmirror_auxD"><span class="command">lemma</span></span> llist_all2_lmirror_auxD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> llist_all2 <span class="free">P</span> <span class="main">(</span>lmirror_aux <span class="free">acc</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>lmirror_aux <span class="free">acc'</span> <span class="free">xs'</span><span class="main">)</span><span class="main">;</span> llist_all2 <span class="free">P</span> <span class="free">acc</span> <span class="free">acc'</span><span class="main">;</span> lfinite <span class="free">acc</span> <span class="main">⟧</span>
  <span class="main">⟹</span> llist_all2 <span class="free">P</span> <span class="free">xs</span> <span class="free">xs'</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">xs'</span></span> <span class="quoted"><span class="free">acc</span></span> <span class="quoted"><span class="free">acc'</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>LNil <span class="skolem">xs</span> <span class="skolem">xs'</span> <span class="skolem">acc</span> <span class="skolem">acc'</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹llist_all2 <span class="free">P</span> <span class="main">(</span>lmirror_aux <span class="skolem">acc</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">(</span>lmirror_aux <span class="skolem">acc'</span> <span class="skolem">xs'</span><span class="main">)</span>›</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"llength <span class="main">(</span>lmirror_aux <span class="skolem">acc</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">=</span> llength <span class="main">(</span>lmirror_aux <span class="skolem">acc'</span> <span class="skolem">xs'</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> llist_all2_llengthD<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹llist_all2 <span class="free">P</span> <span class="skolem">acc</span> <span class="skolem">acc'</span>›</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"llength <span class="skolem">acc</span> <span class="main">=</span> llength <span class="skolem">acc'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> llist_all2_llengthD<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"llength <span class="skolem">xs</span> <span class="main">=</span> llength <span class="skolem">xs'</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹lfinite <span class="skolem">acc</span>›</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llength_lmirror_aux <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lfinite_llength_enat<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>LCons <span class="skolem">xs</span> <span class="skolem">xs'</span> <span class="skolem">acc</span> <span class="skolem">acc'</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹llist_all2 <span class="free">P</span> <span class="main">(</span>lmirror_aux <span class="skolem">acc</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">(</span>lmirror_aux <span class="skolem">acc'</span> <span class="skolem">xs'</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> lnull <span class="skolem">xs</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> lnull <span class="skolem">xs'</span>›</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?lhd</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> llist_all2_lhdD <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lhd_lmirror_aux<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> LCons <span class="quoted"><span class="quoted">‹llist_all2 <span class="free">P</span> <span class="main">(</span>lmirror_aux <span class="skolem">acc</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">(</span>lmirror_aux <span class="skolem">acc'</span> <span class="skolem">xs'</span><span class="main">)</span>›</span></span><span class="main">[</span><span class="operator">THEN</span> llist_all2_ltlI<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltl_lmirror_aux<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="LMirror-llist_all2_lmirrorI"><span class="command">lemma</span></span> llist_all2_lmirrorI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"llist_all2 <span class="free">P</span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">⟹</span> llist_all2 <span class="free">P</span> <span class="main">(</span>lmirror <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>lmirror <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lmirror_def llist_all2_lmirror_aux<span class="main">)</span>

<span class="keyword1" id="LMirror-llist_all2_lmirrorD"><span class="command">lemma</span></span> llist_all2_lmirrorD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"llist_all2 <span class="free">P</span> <span class="main">(</span>lmirror <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>lmirror <span class="free">ys</span><span class="main">)</span> <span class="main">⟹</span> llist_all2 <span class="free">P</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> lmirror_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">erule</span> llist_all2_lmirror_auxD<span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="LMirror-llist_all2_lmirror"><span class="command">lemma</span></span> llist_all2_lmirror <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"llist_all2 <span class="free">P</span> <span class="main">(</span>lmirror <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>lmirror <span class="free">ys</span><span class="main">)</span> <span class="main">⟷</span> llist_all2 <span class="free">P</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> llist_all2_lmirrorI llist_all2_lmirrorD<span class="main">)</span>

<span class="keyword1" id="LMirror-lmirror_parametric"><span class="command">lemma</span></span> lmirror_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>llist_all2 <span class="free">A</span> <span class="main">===&gt;</span> llist_all2 <span class="free">A</span><span class="main">)</span> lmirror lmirror"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> rel_funI<span class="main">)</span><span class="main">(</span><span class="operator">rule</span> llist_all2_lmirrorI<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Hamming_Stream">
<div class="head">
<h1>Theory Hamming_Stream</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Hamming_Stream.thy
    Author:      Andreas Lochbihler, ETH Zurich
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹The Hamming stream defined as a least fixpoint›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Hamming_Stream <span class="keyword2"><span class="keyword">imports</span></span>
  <span class="quoted">"<a href="#Coinductive_List">../Coinductive_List</a>"</span>
  <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Computational_Algebra/Primes.html">HOL-Computational_Algebra.Primes</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Hamming_Stream-infinity_inf_enat"><span class="command">lemma</span></span> infinity_inf_enat <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">n</span> <span class="main">::</span> <span class="quoted">enat</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∞</span> <span class="main">⊓</span> <span class="free">n</span> <span class="main">=</span> <span class="free">n</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">⊓</span> <span class="main">∞</span> <span class="main">=</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inf_enat_def<span class="main">)</span>

<span class="keyword1" id="Hamming_Stream-eSuc_inf_eSuc"><span class="command">lemma</span></span> eSuc_inf_eSuc <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"eSuc <span class="free">n</span> <span class="main">⊓</span> eSuc <span class="free">m</span> <span class="main">=</span> eSuc <span class="main">(</span><span class="free">n</span> <span class="main">⊓</span> <span class="free">m</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inf_enat_def<span class="main">)</span>


<span class="keyword1" id="Hamming_Stream-if_pull2"><span class="command">lemma</span></span> if_pull2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">if</span> <span class="free">b</span> <span class="keyword1">then</span> <span class="free">f</span> <span class="free">x</span> <span class="free">x'</span> <span class="keyword1">else</span> <span class="free">f</span> <span class="free">y</span> <span class="free">y'</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">b</span> <span class="keyword1">then</span> <span class="free">x</span> <span class="keyword1">else</span> <span class="free">y</span><span class="main">)</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">b</span> <span class="keyword1">then</span> <span class="free">x'</span> <span class="keyword1">else</span> <span class="free">y'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">context</span></span> ord <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">primcorec</span></span> <span class="entity">lmerge</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">⇒</span> <span class="tfree">'a</span> llist <span class="main">⇒</span> <span class="tfree">'a</span> llist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">lmerge</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">of</span> LNil <span class="main">⇒</span> LNil <span class="main">|</span> LCons <span class="bound">x</span> <span class="bound">xs'</span> <span class="main">⇒</span>
    <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="keyword1">of</span> LNil <span class="main">⇒</span> LNil <span class="main">|</span> LCons <span class="bound">y</span> <span class="bound">ys'</span> <span class="main">⇒</span>
    <span class="keyword1">if</span> lhd <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">&lt;</span> lhd <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="keyword1">then</span> LCons <span class="bound">x</span> <span class="main">(</span><span class="free">lmerge</span> <span class="bound">xs'</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span>
    <span class="keyword1">else</span> LCons <span class="bound">y</span> <span class="main">(</span><span class="keyword1">if</span> lhd <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">&lt;</span> lhd <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">then</span> <span class="free">lmerge</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="bound">ys'</span> <span class="keyword1">else</span> <span class="free">lmerge</span> <span class="bound">xs'</span> <span class="bound">ys'</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Hamming_Stream-lnull_lmerge"><span class="command">lemma</span></span> lnull_lmerge <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lnull <span class="main">(</span>lmerge <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span>lnull <span class="free">xs</span> <span class="main">∨</span> lnull <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lmerge_def<span class="main">)</span>

<span class="keyword1" id="Hamming_Stream-lmerge_eq_LNil_iff"><span class="command">lemma</span></span> lmerge_eq_LNil_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"lmerge <span class="free">xs</span> <span class="free">ys</span> <span class="main">=</span> LNil <span class="main">⟷</span> <span class="main">(</span><span class="free">xs</span> <span class="main">=</span> LNil <span class="main">∨</span> <span class="free">ys</span> <span class="main">=</span> LNil<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> lnull_lmerge <span class="keyword1"><span class="command">unfolding</span></span> lnull_def <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1" id="Hamming_Stream-lhd_lmerge"><span class="command">lemma</span></span> lhd_lmerge<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">¬</span> lnull <span class="free">xs</span><span class="main">;</span> <span class="main">¬</span> lnull <span class="free">ys</span> <span class="main">⟧</span> <span class="main">⟹</span> lhd <span class="main">(</span>lmerge <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> lhd <span class="free">xs</span> <span class="main">&lt;</span> lhd <span class="free">ys</span> <span class="keyword1">then</span> lhd <span class="free">xs</span> <span class="keyword1">else</span> lhd <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split<span class="main">)</span>

<span class="keyword1" id="Hamming_Stream-ltl_lmerge"><span class="command">lemma</span></span> ltl_lmerge<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">¬</span> lnull <span class="free">xs</span><span class="main">;</span> <span class="main">¬</span> lnull <span class="free">ys</span> <span class="main">⟧</span> <span class="main">⟹</span> 
  ltl <span class="main">(</span>lmerge <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">if</span> lhd <span class="free">xs</span> <span class="main">&lt;</span> lhd <span class="free">ys</span> <span class="keyword1">then</span> lmerge <span class="main">(</span>ltl <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span> 
   <span class="keyword1">else</span> <span class="keyword1">if</span> lhd <span class="free">ys</span> <span class="main">&lt;</span> lhd <span class="free">xs</span> <span class="keyword1">then</span> lmerge <span class="free">xs</span> <span class="main">(</span>ltl <span class="free">ys</span><span class="main">)</span> 
   <span class="keyword1">else</span> lmerge <span class="main">(</span>ltl <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>ltl <span class="free">ys</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> lmerge.sel <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword">del</span></span><span class="main">]</span>

<span class="keyword1" id="Hamming_Stream-lmerge_simps"><span class="command">lemma</span></span> lmerge_simps<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lmerge <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>LCons <span class="free">y</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="free">y</span> <span class="keyword1">then</span> LCons <span class="free">x</span> <span class="main">(</span>lmerge <span class="free">xs</span> <span class="main">(</span>LCons <span class="free">y</span> <span class="free">ys</span><span class="main">)</span><span class="main">)</span>
   <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free">y</span> <span class="main">&lt;</span> <span class="free">x</span> <span class="keyword1">then</span> LCons <span class="free">y</span> <span class="main">(</span>lmerge <span class="main">(</span>LCons <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span>
   <span class="keyword1">else</span> LCons <span class="free">y</span> <span class="main">(</span>lmerge <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> llist.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lhd_lmerge ltl_lmerge<span class="main">)</span>

<span class="keyword1" id="Hamming_Stream-lmerge_LNil"><span class="command">lemma</span></span> lmerge_LNil <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lmerge LNil <span class="free">ys</span> <span class="main">=</span> LNil"</span></span>
  <span class="quoted"><span class="quoted">"lmerge <span class="free">xs</span> LNil <span class="main">=</span> LNil"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Hamming_Stream-lprefix_lmergeI"><span class="command">lemma</span></span> lprefix_lmergeI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> lprefix <span class="free">xs</span> <span class="free">xs'</span><span class="main">;</span> lprefix <span class="free">ys</span> <span class="free">ys'</span> <span class="main">⟧</span>
  <span class="main">⟹</span> lprefix <span class="main">(</span>lmerge <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">(</span>lmerge <span class="free">xs'</span> <span class="free">ys'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">xs'</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quoted"><span class="free">ys'</span></span><span class="main">)</span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lhd_lmerge ltl_lmerge <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lprefix_lhdD lprefix_lnullD <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lnull_conv <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">partial_function_mono</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> F<span class="main">:</span> <span class="quoted"><span class="quoted">"mono_llist <span class="free">F</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> G<span class="main">:</span> <span class="quoted"><span class="quoted">"mono_llist <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mono_llist <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> lmerge <span class="main">(</span><span class="free">F</span> <span class="bound">f</span><span class="main">)</span> <span class="main">(</span><span class="free">G</span> <span class="bound">f</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> monotoneI lprefix_lmergeI monotoneD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> F<span class="main"><span class="main">]</span></span> monotoneD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> G<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Hamming_Stream-in_lset_lmergeD"><span class="command">lemma</span></span> in_lset_lmergeD<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> lset <span class="main">(</span>lmerge <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">∈</span> lset <span class="free">xs</span> <span class="main">∨</span> <span class="free">x</span> <span class="main">∈</span> lset <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="skolem">zs</span><span class="main"><span class="main">≡</span></span><span class="quoted"><span class="quoted">"lmerge <span class="free">xs</span> <span class="free">ys</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> llist_set_induct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lhd_lmerge ltl_lmerge <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> in_lset_ltlD<span class="main">)</span>

<span class="keyword1" id="Hamming_Stream-lset_lmerge"><span class="command">lemma</span></span> lset_lmerge<span class="main">:</span> <span class="quoted"><span class="quoted">"lset <span class="main">(</span>lmerge <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⊆</span> lset <span class="free">xs</span> <span class="main">∪</span> lset <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> in_lset_lmergeD<span class="main">)</span>

<span class="keyword1" id="Hamming_Stream-lfinite_lmergeD"><span class="command">lemma</span></span> lfinite_lmergeD<span class="main">:</span> <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>lmerge <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟹</span> lfinite <span class="free">xs</span> <span class="main">∨</span> lfinite <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="skolem">zs</span><span class="main"><span class="main">≡</span></span><span class="quoted"><span class="quoted">"lmerge <span class="free">xs</span> <span class="free">ys</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lfinite_induct<span class="main">)</span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltl_lmerge if_pull2 <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">F</span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">F</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">lmerge</span> <span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="bound">ys</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">xs</span> <span class="keyword1">of</span> LNil <span class="main">⇒</span> LNil <span class="main">|</span> LCons <span class="bound">x</span> <span class="bound">xs'</span> <span class="main">⇒</span> <span class="keyword1">case</span> <span class="bound">ys</span> <span class="keyword1">of</span> LNil <span class="main">⇒</span> LNil <span class="main">|</span> LCons <span class="bound">y</span> <span class="bound">ys'</span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="bound">y</span> <span class="keyword1">then</span> LCons <span class="bound">x</span> <span class="main">(</span>curry <span class="bound">lmerge</span> <span class="bound">xs'</span> <span class="bound">ys</span><span class="main">)</span> <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="bound">x</span> <span class="keyword1">then</span> LCons <span class="bound">y</span> <span class="main">(</span>curry <span class="bound">lmerge</span> <span class="bound">xs</span> <span class="bound">ys'</span><span class="main">)</span> <span class="keyword1">else</span> LCons <span class="bound">y</span> <span class="main">(</span>curry <span class="bound">lmerge</span> <span class="bound">xs'</span> <span class="bound">ys'</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> lmerge_conv_fixp<span class="main">:</span> <span class="quoted"><span class="quoted">"lmerge <span class="main">≡</span> curry <span class="main">(</span>ccpo.fixp <span class="main">(</span>fun_lub lSup<span class="main">)</span> <span class="main">(</span>fun_ord lprefix<span class="main">)</span> <span class="free">F</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">≡</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> lmerge_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"mono_llist <span class="main">(</span><span class="main">λ</span><span class="bound">lmerge</span><span class="main">.</span> <span class="free">F</span> <span class="bound">lmerge</span> <span class="free">xs</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?mono</span> <span class="free">xs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">intro</span> eq_reflection ext<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span><span class="main">.</span> <span class="var">?mono</span> <span class="bound">xs</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> F_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">tactic</span> <span class="quoted">‹<span class="entity">Partial_Function.mono_tac</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span>›</span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="skolem">ys</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"lmerge <span class="skolem">xs</span> <span class="skolem">ys</span> <span class="main">=</span> <span class="var">?rhs</span> <span class="skolem">xs</span> <span class="skolem">ys</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quoted"><span class="skolem">ys</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> Eq_llist <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 3 4<span class="main"><span class="main">)</span></span> llist.mono_body_fixp<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mono<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> F_def lmerge_simps <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> llist.split<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Hamming_Stream-monotone_lmerge"><span class="command">lemma</span></span> monotone_lmerge<span class="main">:</span> <span class="quoted"><span class="quoted">"monotone <span class="main">(</span>rel_prod lprefix lprefix<span class="main">)</span> lprefix <span class="main">(</span>case_prod lmerge<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> llist.fixp_preserves_mono2<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lmerge_mono lmerge_conv_fixp<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule</span> conjE<span class="main"><span class="keyword3">|</span></span><span class="operator">rule</span> allI conjI <span class="dynamic"><span class="dynamic">cont_intro</span></span><span class="main"><span class="keyword3">|</span></span><span class="operator">simp</span><span class="main"><span class="keyword3">|</span></span><span class="operator">erule</span> allE<span class="main"><span class="keyword3">,</span></span> <span class="operator">erule</span> llist.mono2mono<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Hamming_Stream-mono2mono_lmerge1"><span class="command">lemma</span></span> mono2mono_lmerge1 <span class="main">[</span><span class="operator">THEN</span> llist.mono2mono<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> monotone_lmerge1<span class="main">:</span> <span class="quoted"><span class="quoted">"monotone lprefix lprefix <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> lmerge <span class="bound">xs</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> monotone_lmerge<span class="main"><span class="main">[</span></span><span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Hamming_Stream-mono2mono_lmerge2"><span class="command">lemma</span></span> mono2mono_lmerge2 <span class="main">[</span><span class="operator">THEN</span> llist.mono2mono<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> monotone_lmerge2<span class="main">:</span> <span class="quoted"><span class="quoted">"monotone lprefix lprefix <span class="main">(</span><span class="main">λ</span><span class="bound">ys</span><span class="main">.</span> lmerge <span class="free">xs</span> <span class="bound">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> monotone_lmerge<span class="main"><span class="main">[</span></span><span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Hamming_Stream-mcont_lmerge"><span class="command">lemma</span></span> mcont_lmerge<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont <span class="main">(</span>prod_lub lSup lSup<span class="main">)</span> <span class="main">(</span>rel_prod lprefix lprefix<span class="main">)</span> lSup lprefix <span class="main">(</span>case_prod lmerge<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> llist.fixp_preserves_mcont2<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lmerge_mono lmerge_conv_fixp<span class="main"><span class="main">]</span></span><span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule</span> conjE<span class="main"><span class="keyword3">|</span></span><span class="operator">rule</span> allI conjI <span class="dynamic"><span class="dynamic">cont_intro</span></span><span class="main"><span class="keyword3">|</span></span><span class="operator">simp</span><span class="main"><span class="keyword3">|</span></span><span class="operator">erule</span> allE<span class="main"><span class="keyword3">,</span></span> <span class="operator">erule</span> llist.mcont2mcont<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Hamming_Stream-mcont2mcont_lmerge1"><span class="command">lemma</span></span> mcont2mcont_lmerge1 <span class="main">[</span><span class="operator">THEN</span> llist.mcont2mcont<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> mcont_lmerge1<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont lSup lprefix lSup lprefix <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> lmerge <span class="bound">xs</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mcont_lmerge<span class="main"><span class="main">[</span></span><span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Hamming_Stream-mcont2mcont_lmerge2"><span class="command">lemma</span></span> mcont2mcont_lmerge2 <span class="main">[</span><span class="operator">THEN</span> llist.mcont2mcont<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> mcont_lmerge2<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont lSup lprefix lSup lprefix <span class="main">(</span><span class="main">λ</span><span class="bound">ys</span><span class="main">.</span> lmerge <span class="free">xs</span> <span class="bound">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mcont_lmerge<span class="main"><span class="main">[</span></span><span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Hamming_Stream-lfinite_lmergeI"><span class="command">lemma</span></span> lfinite_lmergeI <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> lfinite <span class="free">xs</span><span class="main">;</span> lfinite <span class="free">ys</span> <span class="main">⟧</span> <span class="main">⟹</span> lfinite <span class="main">(</span>lmerge <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lfinite_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>LCons <span class="skolem">xs</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> LCons.prems LCons.hyps LCons.IH
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lnull_conv lmerge_simps<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Hamming_Stream-linfinite_lmerge"><span class="command">lemma</span></span> linfinite_lmerge <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">¬</span> lfinite <span class="free">xs</span><span class="main">;</span> <span class="main">¬</span> lfinite <span class="free">ys</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">¬</span> lfinite <span class="main">(</span>lmerge <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lfinite_lmergeD<span class="main">)</span>

<span class="keyword1" id="Hamming_Stream-llength_lmerge_above"><span class="command">lemma</span></span> llength_lmerge_above<span class="main">:</span> <span class="quoted"><span class="quoted">"llength <span class="free">xs</span> <span class="main">⊓</span> llength <span class="free">ys</span> <span class="main">≤</span> llength <span class="main">(</span>lmerge <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>LCons <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> LCons <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> LCons.IH
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bot_enat_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> lmerge_simps le_infI1 le_infI2 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bot_enat_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bot_enat_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> linorder <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Hamming_Stream-in_lset_lmergeI1"><span class="command">lemma</span></span> in_lset_lmergeI1<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">x</span> <span class="main">∈</span> lset <span class="free">xs</span><span class="main">;</span> lsorted <span class="free">xs</span><span class="main">;</span> <span class="main">¬</span> lfinite <span class="free">ys</span><span class="main">;</span> <span class="main">∃</span><span class="bound">y</span><span class="main">∈</span>lset <span class="free">ys</span><span class="main">.</span> <span class="free">x</span> <span class="main">≤</span> <span class="bound">y</span> <span class="main">⟧</span>
  <span class="main">⟹</span> <span class="free">x</span> <span class="main">∈</span> lset <span class="main">(</span>lmerge <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lset_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>find <span class="skolem">xs</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> lset <span class="skolem">ys</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≤</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lmerge_simps not_less<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">x'</span> <span class="skolem">xs</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> lset <span class="skolem">ys</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≤</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹lsorted <span class="main">(</span>LCons <span class="skolem">x'</span> <span class="skolem">xs</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">x</span> <span class="main">∈</span> lset <span class="skolem">xs</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">x</span> <span class="main">≠</span> <span class="skolem">x'</span>›</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x'</span> <span class="main">&lt;</span> <span class="free">x</span>"</span></span> <span class="quoted"><span class="quoted">"lsorted <span class="skolem">xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lsorted_LCons<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> lfinite <span class="skolem">ys</span>›</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lmerge_simps <span class="quoted"><span class="quoted">‹<span class="free">x</span> <span class="main">≠</span> <span class="skolem">x'</span>›</span></span> not_less <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> step.IH <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> in_lset_lmergeD<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Hamming_Stream-in_lset_lmergeI2"><span class="command">lemma</span></span> in_lset_lmergeI2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">x</span> <span class="main">∈</span> lset <span class="free">ys</span><span class="main">;</span> lsorted <span class="free">ys</span><span class="main">;</span> <span class="main">¬</span> lfinite <span class="free">xs</span><span class="main">;</span> <span class="main">∃</span><span class="bound">y</span><span class="main">∈</span>lset <span class="free">xs</span><span class="main">.</span> <span class="free">x</span> <span class="main">≤</span> <span class="bound">y</span> <span class="main">⟧</span>
  <span class="main">⟹</span> <span class="free">x</span> <span class="main">∈</span> lset <span class="main">(</span>lmerge <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lset_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>find <span class="skolem">ys</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> lset <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≤</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lmerge_simps not_less<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">x'</span> <span class="skolem">ys</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> lset <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≤</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹lsorted <span class="main">(</span>LCons <span class="skolem">x'</span> <span class="skolem">ys</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">x</span> <span class="main">∈</span> lset <span class="skolem">ys</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">x</span> <span class="main">≠</span> <span class="skolem">x'</span>›</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x'</span> <span class="main">&lt;</span> <span class="free">x</span>"</span></span> <span class="quoted"><span class="quoted">"lsorted <span class="skolem">ys</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lsorted_LCons<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> lfinite <span class="skolem">xs</span>›</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lmerge_simps <span class="quoted"><span class="quoted">‹<span class="free">x</span> <span class="main">≠</span> <span class="skolem">x'</span>›</span></span> not_less <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> step.IH <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> in_lset_lmergeD<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Hamming_Stream-lsorted_lmerge"><span class="command">lemma</span></span> lsorted_lmerge<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> lsorted <span class="free">xs</span><span class="main">;</span> lsorted <span class="free">ys</span> <span class="main">⟧</span> <span class="main">⟹</span> lsorted <span class="main">(</span>lmerge <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>lsorted <span class="skolem">xs</span> <span class="skolem">ys</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?lhd</span></span></span> <span class="keyword1"><span class="command">using</span></span> lsorted
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_lnull_conv lsorted_LCons lhd_lmerge ltl_lmerge <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> in_lset_lmergeD<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?ltl</span></span></span> <span class="keyword1"><span class="command">using</span></span> lsorted <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltl_lmerge <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> lsorted_ltlI<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Hamming_Stream-ldistinct_lmerge"><span class="command">lemma</span></span> ldistinct_lmerge<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> lsorted <span class="free">xs</span><span class="main">;</span> lsorted <span class="free">ys</span><span class="main">;</span> ldistinct <span class="free">xs</span><span class="main">;</span> ldistinct <span class="free">ys</span> <span class="main">⟧</span>
  <span class="main">⟹</span> ldistinct <span class="main">(</span>lmerge <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lhd_lmerge ltl_lmerge not_lnull_conv lsorted_LCons not_less <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> in_lset_lmergeD <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> order.antisym<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">partial_function</span></span> <span class="main">(</span>llist<span class="main">)</span> <span class="entity">hamming'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"unit <span class="main">⇒</span> nat llist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">hamming'</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> 
   LCons <span class="main">1</span> <span class="main">(</span>lmerge <span class="main">(</span>lmap <span class="main">(</span><span class="main">(*)</span> <span class="numeral">2</span><span class="main">)</span> <span class="main">(</span><span class="free">hamming'</span> <span class="main">()</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>lmerge <span class="main">(</span>lmap <span class="main">(</span><span class="main">(*)</span> <span class="numeral">3</span><span class="main">)</span> <span class="main">(</span><span class="free">hamming'</span> <span class="main">()</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>lmap <span class="main">(</span><span class="main">(*)</span> <span class="numeral">5</span><span class="main">)</span> <span class="main">(</span><span class="free">hamming'</span> <span class="main">()</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">hamming</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat llist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">hamming</span> <span class="main">=</span> hamming' <span class="main">()</span>"</span></span>

<span class="keyword1" id="Hamming_Stream-lnull_hamming"><span class="command">lemma</span></span> lnull_hamming <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lnull hamming"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> hamming_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> hamming'.simps<span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1" id="Hamming_Stream-hamming_eq_LNil_iff"><span class="command">lemma</span></span> hamming_eq_LNil_iff <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hamming <span class="main">=</span> LNil <span class="main">⟷</span> False"</span></span>
<span class="keyword1"><span class="command">using</span></span> lnull_hamming <span class="keyword1"><span class="command">unfolding</span></span> lnull_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Hamming_Stream-lhd_hamming"><span class="command">lemma</span></span> lhd_hamming <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lhd hamming <span class="main">=</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> hamming_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> hamming'.simps<span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1" id="Hamming_Stream-ltl_hamming"><span class="command">lemma</span></span> ltl_hamming <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"ltl hamming <span class="main">=</span> lmerge <span class="main">(</span>lmap <span class="main">(</span><span class="main">(*)</span> <span class="numeral">2</span><span class="main">)</span> hamming<span class="main">)</span> <span class="main">(</span>lmerge <span class="main">(</span>lmap <span class="main">(</span><span class="main">(*)</span> <span class="numeral">3</span><span class="main">)</span> hamming<span class="main">)</span> <span class="main">(</span>lmap <span class="main">(</span><span class="main">(*)</span> <span class="numeral">5</span><span class="main">)</span> hamming<span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> hamming_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> hamming'.simps<span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1" id="Hamming_Stream-hamming_unfold"><span class="command">lemma</span></span> hamming_unfold<span class="main">:</span>
  <span class="quoted"><span class="quoted">"hamming <span class="main">=</span> LCons <span class="main">1</span> <span class="main">(</span>lmerge <span class="main">(</span>lmap <span class="main">(</span><span class="main">(*)</span> <span class="numeral">2</span><span class="main">)</span> hamming<span class="main">)</span> <span class="main">(</span>lmerge <span class="main">(</span>lmap <span class="main">(</span><span class="main">(*)</span> <span class="numeral">3</span><span class="main">)</span> hamming<span class="main">)</span> <span class="main">(</span>lmap <span class="main">(</span><span class="main">(*)</span> <span class="numeral">5</span><span class="main">)</span> hamming<span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> llist.expand<span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">smooth</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">smooth</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">p</span><span class="main">.</span> prime <span class="bound">p</span> <span class="main">⟶</span> <span class="bound">p</span> <span class="keyword1">dvd</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">⟶</span> <span class="bound">p</span> <span class="main">≤</span> <span class="numeral">5</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Hamming_Stream-smooth_0"><span class="command">lemma</span></span> smooth_0 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> smooth <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> smooth_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="numeral">7</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Hamming_Stream-smooth_Suc0"><span class="command">lemma</span></span> smooth_Suc0 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"smooth <span class="main">(</span>Suc <span class="main">0</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> smooth_def<span class="main">)</span>

<span class="keyword1" id="Hamming_Stream-smooth_gt0"><span class="command">lemma</span></span> smooth_gt0<span class="main">:</span> <span class="quoted"><span class="quoted">"smooth <span class="free">n</span> <span class="main">⟹</span> <span class="free">n</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Hamming_Stream-smooth_ge_Suc0"><span class="command">lemma</span></span> smooth_ge_Suc0<span class="main">:</span> <span class="quoted"><span class="quoted">"smooth <span class="free">n</span> <span class="main">⟹</span> <span class="free">n</span> <span class="main">≥</span> Suc <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Hamming_Stream-prime_nat_dvdD"><span class="command">lemma</span></span> prime_nat_dvdD<span class="main">:</span> <span class="quoted"><span class="quoted">"prime <span class="free">p</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">n</span> <span class="main">::</span> nat<span class="main">)</span> <span class="keyword1">dvd</span> <span class="free">p</span> <span class="main">⟹</span> <span class="free">n</span> <span class="main">=</span> <span class="main">1</span> <span class="main">∨</span> <span class="free">n</span> <span class="main">=</span> <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> prime_nat_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Hamming_Stream-smooth_times"><span class="command">lemma</span></span> smooth_times <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"smooth <span class="main">(</span><span class="free">x</span> <span class="main">*</span> <span class="free">y</span><span class="main">)</span> <span class="main">⟷</span> smooth <span class="free">x</span> <span class="main">∧</span> smooth <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> smooth_def prime_dvd_mult_iff<span class="main">)</span>

<span class="keyword1" id="Hamming_Stream-smooth2"><span class="command">lemma</span></span> smooth2 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"smooth <span class="numeral">2</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> smooth_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> prime_nat_dvdD<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="numeral">2</span></span><span class="main"><span class="main">,</span></span> <span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Hamming_Stream-smooth3"><span class="command">lemma</span></span> smooth3 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"smooth <span class="numeral">3</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> smooth_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> prime_nat_dvdD<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="numeral">3</span></span><span class="main"><span class="main">,</span></span> <span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Hamming_Stream-smooth5"><span class="command">lemma</span></span> smooth5 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"smooth <span class="numeral">5</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> smooth_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> prime_nat_dvdD<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="numeral">5</span></span><span class="main"><span class="main">,</span></span> <span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Hamming_Stream-hamming_in_smooth"><span class="command">lemma</span></span> hamming_in_smooth<span class="main">:</span> <span class="quoted"><span class="quoted">"lset hamming <span class="main">⊆</span> <span class="main">{</span><span class="bound">n</span><span class="main">.</span> smooth <span class="bound">n</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> hamming_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> hamming'.fixp_induct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 6 6 <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> in_lset_lmergeD<span class="main">)</span>

<span class="keyword1" id="Hamming_Stream-lfinite_hamming"><span class="command">lemma</span></span> lfinite_hamming <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lfinite hamming"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"lfinite hamming"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="keyword2"><span class="keyword">where</span></span> n<span class="main">:</span> <span class="quoted"><span class="quoted">"llength hamming <span class="main">=</span> enat <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> lfinite_conv_llength_enat <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"llength <span class="main">(</span>lmap <span class="main">(</span><span class="main">(*)</span> <span class="numeral">3</span><span class="main">)</span> hamming<span class="main">)</span> <span class="main">⊓</span> llength <span class="main">(</span>lmap <span class="main">(</span><span class="main">(*)</span> <span class="numeral">5</span><span class="main">)</span> hamming<span class="main">)</span> <span class="main">≤</span> llength <span class="main">(</span>lmerge <span class="main">(</span>lmap <span class="main">(</span><span class="main">(*)</span> <span class="numeral">3</span><span class="main">)</span> hamming<span class="main">)</span> <span class="main">(</span>lmap <span class="main">(</span><span class="main">(*)</span> <span class="numeral">5</span><span class="main">)</span> hamming<span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> llength_lmerge_above<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"llength hamming <span class="main">≤</span> <span class="main">…</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"llength <span class="main">(</span>lmap <span class="main">(</span><span class="main">(*)</span> <span class="numeral">2</span><span class="main">)</span> hamming<span class="main">)</span> <span class="main">⊓</span> <span class="main">…</span> <span class="main">≤</span>
    llength <span class="main">(</span>lmerge <span class="main">(</span>lmap <span class="main">(</span><span class="main">(*)</span> <span class="numeral">2</span><span class="main">)</span> hamming<span class="main">)</span> <span class="main">(</span>lmerge <span class="main">(</span>lmap <span class="main">(</span><span class="main">(*)</span> <span class="numeral">3</span><span class="main">)</span> hamming<span class="main">)</span> <span class="main">(</span>lmap <span class="main">(</span><span class="main">(*)</span> <span class="numeral">5</span><span class="main">)</span> hamming<span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> llength_lmerge_above<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"llength hamming <span class="main">≤</span> <span class="main">…</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inf.absorb1<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> n <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">&lt;</span> enat <span class="skolem">n</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> hamming_unfold<span class="main">)</span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">n</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> eSuc_enat<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">unfolding</span></span> n <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Hamming_Stream-lsorted_hamming"><span class="command">lemma</span></span> lsorted_hamming <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lsorted hamming"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> ldistinct_hamming <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ldistinct hamming"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lsorted hamming <span class="main">∧</span> ldistinct hamming <span class="main">∧</span> lset hamming <span class="main">⊆</span> <span class="main">{</span><span class="main">1</span><span class="main">..}</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> hamming_def
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> hamming'.fixp_induct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 6 6 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lsorted_LCons <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> in_lset_lmergeD <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> smooth_ge_Suc0 lsorted_lmerge lsorted_lmap monotoneI ldistinct_lmerge inj_onI<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"lsorted hamming"</span></span> <span class="quoted"><span class="quoted">"ldistinct hamming"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Hamming_Stream-smooth_hamming"><span class="command">lemma</span></span> smooth_hamming<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"smooth <span class="free">n</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">∈</span> lset hamming"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> less_induct<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"monotone <span class="main">(≤)</span> <span class="main">(≤)</span> <span class="main">(</span><span class="main">(*)</span> <span class="numeral">2</span> <span class="main">::</span> nat <span class="main">⇒</span> nat<span class="main">)</span>"</span></span> 
    <span class="quoted"><span class="quoted">"monotone <span class="main">(≤)</span> <span class="main">(≤)</span> <span class="main">(</span><span class="main">(*)</span> <span class="numeral">3</span> <span class="main">::</span> nat <span class="main">⇒</span> nat<span class="main">)</span>"</span></span> 
    <span class="quoted"><span class="quoted">"monotone <span class="main">(≤)</span> <span class="main">(≤)</span> <span class="main">(</span><span class="main">(*)</span> <span class="numeral">5</span> <span class="main">::</span> nat <span class="main">⇒</span> nat<span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> monotone_def<span class="main">)</span>

  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>less <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">&gt;</span> <span class="main">1</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹smooth <span class="skolem">n</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> contrapos_pn<span class="main">)</span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">=</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> hamming_unfold<span class="main">)</span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">p</span><span class="main">.</span> prime <span class="bound">p</span> <span class="main">∧</span> <span class="bound">p</span> <span class="keyword1">dvd</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">metis</span> less_numeral_extra<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span> prime_factor_nat<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹smooth <span class="skolem">n</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"prime <span class="skolem">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="keyword1">dvd</span> <span class="skolem">n</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">≤</span> <span class="numeral">5</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> smooth_def<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">p</span> <span class="keyword1">dvd</span> <span class="skolem">n</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">n'</span></span> <span class="keyword2"><span class="keyword">where</span></span> n<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">=</span> <span class="skolem">p</span> <span class="main">*</span> <span class="skolem">n'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dvd_def<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹smooth <span class="skolem">n</span>›</span></span> <span class="quoted"><span class="quoted">‹prime <span class="skolem">p</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"smooth <span class="skolem">n'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> smooth_def<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹prime <span class="skolem">p</span>›</span></span> n <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n'</span> <span class="main">&lt;</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> smooth_gt0 prime_gt_Suc_0_nat<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> n'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">n'</span> <span class="main">∈</span> lset hamming"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹smooth <span class="skolem">n'</span>›</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> less.IH<span class="main">)</span>

    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">p</span> <span class="main">≤</span> <span class="numeral">5</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∨</span> <span class="skolem">p</span> <span class="main">=</span> <span class="main">1</span> <span class="main">∨</span> <span class="skolem">p</span> <span class="main">=</span> <span class="numeral">2</span> <span class="main">∨</span> <span class="skolem">p</span> <span class="main">=</span> <span class="numeral">3</span> <span class="main">∨</span> <span class="skolem">p</span> <span class="main">=</span> <span class="numeral">4</span> <span class="main">∨</span> <span class="skolem">p</span> <span class="main">=</span> <span class="numeral">5</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">presburger</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹prime <span class="skolem">p</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">=</span> <span class="numeral">2</span> <span class="main">∨</span> <span class="skolem">p</span> <span class="main">=</span> <span class="numeral">3</span> <span class="main">∨</span> <span class="skolem">p</span> <span class="main">=</span> <span class="numeral">5</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">elim</span> disjE<span class="main">)</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">=</span> <span class="numeral">2</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> n n' <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> hamming_unfold<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> in_lset_lmergeI1 not_less lsorted_lmap bexI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="skolem">n'</span>"</span></span><span class="main"><span class="main">]</span></span> bexI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="numeral">3</span><span class="main">*</span><span class="skolem">n'</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">=</span> <span class="numeral">3</span>"</span></span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">with</span></span></span> n <span class="quoted"><span class="quoted">‹smooth <span class="skolem">n'</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span> <span class="main">*</span> <span class="skolem">n'</span> <span class="main">&lt;</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> smooth_gt0<span class="main">)</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span> <span class="main">*</span> <span class="skolem">n'</span> <span class="main">∈</span> lset hamming"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> less.IH<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">‹smooth <span class="skolem">n'</span>›</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> n n'
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> hamming_unfold<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 4 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_less lsorted_lmap lsorted_lmerge <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> in_lset_lmergeI1 in_lset_lmergeI2 bexI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="numeral">4</span><span class="main">*</span><span class="skolem">n'</span>"</span></span><span class="main"><span class="main">]</span></span> bexI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="numeral">5</span><span class="main">*</span><span class="skolem">n'</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">=</span> <span class="numeral">5</span>"</span></span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">with</span></span></span> n <span class="quoted"><span class="quoted">‹smooth <span class="skolem">n'</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span> <span class="main">*</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="skolem">n'</span><span class="main">)</span> <span class="main">&lt;</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> smooth_gt0<span class="main">)</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span> <span class="main">*</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="skolem">n'</span><span class="main">)</span> <span class="main">∈</span> lset hamming"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> less.IH<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> smooth_times smooth2 <span class="quoted"><span class="quoted">‹smooth <span class="skolem">n'</span>›</span></span> simp_thms<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">p</span> <span class="main">=</span> <span class="numeral">5</span>›</span></span> n <span class="quoted"><span class="quoted">‹smooth <span class="skolem">n'</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="numeral">3</span> <span class="main">*</span> <span class="skolem">n'</span> <span class="main">&lt;</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> smooth_gt0<span class="main">)</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="numeral">3</span> <span class="main">*</span> <span class="skolem">n'</span> <span class="main">∈</span> lset hamming"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> less.IH<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">‹smooth <span class="skolem">n'</span>›</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> n n'
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> hamming_unfold<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 4 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lsorted_lmap lsorted_lmerge <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> in_lset_lmergeI2 bexI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="numeral">9</span><span class="main">*</span><span class="skolem">n'</span>"</span></span><span class="main"><span class="main">]</span></span> bexI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="numeral">8</span> <span class="main">*</span> <span class="skolem">n'</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">corollary</span></span> hamming_smooth<span class="main">:</span> <span class="quoted"><span class="quoted">"lset hamming <span class="main">=</span> <span class="main">{</span><span class="bound">n</span><span class="main">.</span> smooth <span class="bound">n</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> hamming_in_smooth <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> smooth_hamming<span class="main">)</span>

<span class="keyword1" id="Hamming_Stream-hamming_THE"><span class="command">lemma</span></span> hamming_THE<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">THE</span> <span class="bound">xs</span><span class="main">.</span> lsorted <span class="bound">xs</span> <span class="main">∧</span> ldistinct <span class="bound">xs</span> <span class="main">∧</span> lset <span class="bound">xs</span> <span class="main">=</span> <span class="main">{</span><span class="bound">n</span><span class="main">.</span> smooth <span class="bound">n</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> hamming"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> the_equality<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hamming_smooth lsorted_ldistinct_lset_unique<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Resumption">
<div class="head">
<h1>Theory Resumption</h1>
</div>
<pre class="source"><span class="comment1">(*  Author:      Andreas Lochbihler
    Maintainer:  Andreas Lochbihler
*)</span>
<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Manual construction of a resumption codatatype›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Resumption <span class="keyword2"><span class="keyword">imports</span></span> 
  <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/Old_Datatype.html">HOL-Library.Old_Datatype</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  This theory defines the following codatatype:

\begin{verbatim}
codatatype ('a,'b,'c,'d) resumption =
    Terminal 'a
  | Linear 'b "('a,'b,'c,'d) resumption"
  | Branch 'c "'d =&gt; ('a,'b,'c,'d) resumption"
\end{verbatim}

›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Auxiliary definitions and lemmata similar to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> "<a href="../../HOL/HOL-Library/Old_Datatype.html"></a><a href="../../HOL/HOL-Library/Old_Datatype.html">HOL-Library.Old_Datatype</a>"<span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1" id="Resumption-Lim_mono"><span class="command">lemma</span></span> Lim_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">d</span><span class="main">.</span> <span class="free">rs</span> <span class="bound">d</span> <span class="main">⊆</span> <span class="free">rs'</span> <span class="bound">d</span><span class="main">)</span> <span class="main">⟹</span> Old_Datatype.Lim <span class="free">rs</span> <span class="main">⊆</span> Old_Datatype.Lim <span class="free">rs'</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Lim_def<span class="main">)</span> <span class="operator">blast</span>

<span class="keyword1" id="Resumption-Lim_UN1"><span class="command">lemma</span></span> Lim_UN1<span class="main">:</span>  <span class="quoted"><span class="quoted">"Old_Datatype.Lim <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">⋃</span><span class="bound">y</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">y</span><span class="main">.</span> Old_Datatype.Lim <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Old_Datatype.Lim_def<span class="main">)</span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Inverse for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"Old_Datatype.Lim"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> like <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"Old_Datatype.Split"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"Old_Datatype.Case"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
  for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"Old_Datatype.Scons"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"In0"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>/<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"In1"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">DTBranch</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> Old_Datatype.dtree<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> Old_Datatype.dtree <span class="main">⇒</span> <span class="tfree">'c</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">DTBranch</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">THE</span> <span class="bound">u</span><span class="main">.</span> <span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="main">=</span> Old_Datatype.Lim <span class="bound">x</span> <span class="main">∧</span> <span class="bound">u</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">x</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Resumption-DTBranch_Lim"><span class="command">lemma</span></span> DTBranch_Lim <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"DTBranch <span class="free">f</span> <span class="main">(</span>Old_Datatype.Lim <span class="free">M</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="free">M</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> DTBranch_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Lim_inject<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Lemmas for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Old_Datatype.ntrunc</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"Old_Datatype.Lim"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1" id="Resumption-ndepth_Push_Node_Inl_aux"><span class="command">lemma</span></span> ndepth_Push_Node_Inl_aux<span class="main">:</span>
     <span class="quoted"><span class="quoted">"case_nat <span class="main">(</span>Inl <span class="free">n</span><span class="main">)</span> <span class="free">f</span> <span class="free">k</span> <span class="main">=</span> Inr <span class="main">0</span> <span class="main">⟹</span> Suc <span class="main">(</span><span class="keyword1">LEAST</span> <span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">=</span> Inr <span class="main">0</span><span class="main">)</span> <span class="main">&lt;=</span> <span class="free">k</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"<span class="free">k</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> Least_le<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Resumption-ndepth_Push_Node_Inl"><span class="command">lemma</span></span> ndepth_Push_Node_Inl<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ndepth <span class="main">(</span>Push_Node <span class="main">(</span>Inl <span class="free">a</span><span class="main">)</span> <span class="free">n</span><span class="main">)</span> <span class="main">=</span> Suc <span class="main">(</span>ndepth <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> Rep_Node<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">n</span></span><span class="main">,</span> <span class="operator">unfolded</span> Node_def<span class="main">]</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ndepth_def Push_Node_def Abs_Node_inverse<span class="main"><span class="main">[</span></span><span class="operator">OF</span> Node_Push_I<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> Rep_Node<span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Push_def split_beta<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> Least_equality<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> LeastI <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> ndepth_Push_Node_Inl_aux<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Resumption-ntrunc_Lim"><span class="command">lemma</span></span> ntrunc_Lim <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ntrunc <span class="main">(</span>Suc <span class="free">k</span><span class="main">)</span> <span class="main">(</span>Old_Datatype.Lim <span class="free">rs</span><span class="main">)</span> <span class="main">=</span> Old_Datatype.Lim <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> ntrunc <span class="free">k</span> <span class="main">(</span><span class="free">rs</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Lim_def ntrunc_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> equalityI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarify</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ndepth_Push_Node_Inl<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Definition for the codatatype universe›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Constructors›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">TERMINAL</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'c</span> <span class="main">+</span> <span class="tfree">'b</span> <span class="main">+</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'d</span><span class="main">)</span> Old_Datatype.dtree"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">TERMINAL</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">=</span> In0 <span class="main">(</span>Old_Datatype.Leaf <span class="main">(</span>Inr <span class="main">(</span>Inr <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">LINEAR</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'c</span> <span class="main">+</span> <span class="tfree">'b</span> <span class="main">+</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'d</span><span class="main">)</span> Old_Datatype.dtree <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'c</span> <span class="main">+</span> <span class="tfree">'b</span> <span class="main">+</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'d</span><span class="main">)</span> Old_Datatype.dtree"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">LINEAR</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">=</span> In1 <span class="main">(</span>In0 <span class="main">(</span>Scons <span class="main">(</span>Old_Datatype.Leaf <span class="main">(</span>Inr <span class="main">(</span>Inl <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">BRANCH</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'d</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'c</span> <span class="main">+</span> <span class="tfree">'b</span> <span class="main">+</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'d</span><span class="main">)</span> Old_Datatype.dtree<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'c</span> <span class="main">+</span> <span class="tfree">'b</span> <span class="main">+</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'d</span><span class="main">)</span> Old_Datatype.dtree"</span></span>
 <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">BRANCH</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="free"><span class="bound"><span class="entity">rs</span></span></span> <span class="main">=</span> In1 <span class="main">(</span>In1 <span class="main">(</span>Scons <span class="main">(</span>Old_Datatype.Leaf <span class="main">(</span>Inl <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Old_Datatype.Lim <span class="free"><span class="bound"><span class="entity">rs</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹case operator›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">case_RESUMPTION</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'e</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'c</span> <span class="main">+</span> <span class="tfree">'b</span> <span class="main">+</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'d</span><span class="main">)</span> Old_Datatype.dtree<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'e</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'c</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'d</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'c</span> <span class="main">+</span> <span class="tfree">'b</span> <span class="main">+</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'d</span><span class="main">)</span> Old_Datatype.dtree<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'e</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'c</span> <span class="main">+</span> <span class="tfree">'b</span> <span class="main">+</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'d</span><span class="main">)</span> Old_Datatype.dtree <span class="main">⇒</span> <span class="tfree">'e</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">case_RESUMPTION</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">br</span></span></span> <span class="main">=</span>
   Old_Datatype.Case <span class="main">(</span><span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="keyword1">o</span> inv <span class="main">(</span>Old_Datatype.Leaf <span class="keyword1">o</span> Inr <span class="keyword1">o</span> Inr<span class="main">)</span><span class="main">)</span>
                 <span class="main">(</span>Old_Datatype.Case <span class="main">(</span>Old_Datatype.Split <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">(</span>inv <span class="main">(</span>Old_Datatype.Leaf <span class="keyword1">o</span> Inr <span class="keyword1">o</span> Inl<span class="main">)</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                                <span class="main">(</span>Old_Datatype.Split <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> DTBranch <span class="main">(</span><span class="free"><span class="bound"><span class="entity">br</span></span></span> <span class="main">(</span>inv <span class="main">(</span>Old_Datatype.Leaf <span class="keyword1">o</span> Inl<span class="main">)</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> TERMINAL_not_LINEAR<span class="main">:</span> <span class="quoted"><span class="quoted">"TERMINAL <span class="free">a</span> <span class="main">≠</span> LINEAR <span class="free">b</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> LINEAR_not_TERMINAL<span class="main">:</span> <span class="quoted"><span class="quoted">"LINEAR <span class="free">b</span> <span class="free">R</span> <span class="main">≠</span> TERMINAL <span class="free">a</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> TERMINAL_not_BRANCH<span class="main">:</span> <span class="quoted"><span class="quoted">"TERMINAL <span class="free">a</span> <span class="main">≠</span> BRANCH <span class="free">c</span> <span class="free">rs</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> BRANCH_not_TERMINAL<span class="main">:</span> <span class="quoted"><span class="quoted">"BRANCH <span class="free">c</span> <span class="free">rs</span> <span class="main">≠</span> TERMINAL <span class="free">a</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> LINEAR_not_BRANCH<span class="main">:</span> <span class="quoted"><span class="quoted">"LINEAR <span class="free">b</span> <span class="free">r</span> <span class="main">≠</span> BRANCH <span class="free">c</span> <span class="free">rs</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> BRANCH_not_LINEAR<span class="main">:</span> <span class="quoted"><span class="quoted">"BRANCH <span class="free">c</span> <span class="free">rs</span> <span class="main">≠</span> LINEAR <span class="free">b</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> TERMINAL_inject<span class="main">:</span> <span class="quoted"><span class="quoted">"TERMINAL <span class="free">a</span> <span class="main">=</span> TERMINAL <span class="free">a'</span> <span class="main">⟷</span> <span class="free">a</span> <span class="main">=</span> <span class="free">a'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> LINEAR_inject<span class="main">:</span> <span class="quoted"><span class="quoted">"LINEAR <span class="free">b</span> <span class="free">r</span> <span class="main">=</span> LINEAR <span class="free">b'</span> <span class="free">r'</span> <span class="main">⟷</span> <span class="free">b</span> <span class="main">=</span> <span class="free">b'</span> <span class="main">∧</span> <span class="free">r</span> <span class="main">=</span> <span class="free">r'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> BRANCH_inject<span class="main">:</span> <span class="quoted"><span class="quoted">"BRANCH <span class="free">c</span> <span class="free">rs</span> <span class="main">=</span> BRANCH <span class="free">c'</span> <span class="free">rs'</span> <span class="main">⟷</span> <span class="free">c</span> <span class="main">=</span> <span class="free">c'</span> <span class="main">∧</span> <span class="free">rs</span> <span class="main">=</span> <span class="free">rs'</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> TERMINAL_def LINEAR_def BRANCH_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Lim_inject<span class="main">)</span>

<span class="keyword1" id="Resumption-case_RESUMPTION_simps"><span class="command">lemma</span></span> case_RESUMPTION_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> case_RESUMPTION_TERMINAL<span class="main">:</span> <span class="quoted"><span class="quoted">"case_RESUMPTION <span class="free">t</span> <span class="free">l</span> <span class="free">br</span> <span class="main">(</span>TERMINAL <span class="free">a</span><span class="main">)</span> <span class="main">=</span> <span class="free">t</span> <span class="free">a</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> case_RESUMPTION_LINEAR<span class="main">:</span> <span class="quoted"><span class="quoted">"case_RESUMPTION <span class="free">t</span> <span class="free">l</span> <span class="free">br</span> <span class="main">(</span>LINEAR <span class="free">b</span> <span class="free">r</span><span class="main">)</span> <span class="main">=</span> <span class="free">l</span> <span class="free">b</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> case_RESUMPTION_BRANCH<span class="main">:</span> <span class="quoted"><span class="quoted">"case_RESUMPTION <span class="free">t</span> <span class="free">l</span> <span class="free">br</span> <span class="main">(</span>BRANCH <span class="free">c</span> <span class="free">rs</span><span class="main">)</span> <span class="main">=</span> <span class="free">br</span> <span class="free">c</span> <span class="free">rs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> case_RESUMPTION_def TERMINAL_def LINEAR_def BRANCH_def o_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> arg_cong<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">back</span></span></span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> injI inv_f_f<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> arg_cong<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">back</span></span></span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> injI inv_f_f<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> arg_cong<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">back</span></span></span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> injI inv_f_f<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Resumption-LINEAR_mono"><span class="command">lemma</span></span> LINEAR_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">⊆</span> <span class="free">r'</span> <span class="main">⟹</span> LINEAR <span class="free">b</span> <span class="free">r</span> <span class="main">⊆</span> LINEAR <span class="free">b</span> <span class="free">r'</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> LINEAR_def In1_mono In0_mono Scons_mono<span class="main">)</span>

<span class="keyword1" id="Resumption-BRANCH_mono"><span class="command">lemma</span></span> BRANCH_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">d</span><span class="main">.</span> <span class="free">rs</span> <span class="bound">d</span> <span class="main">⊆</span> <span class="free">rs'</span> <span class="bound">d</span><span class="main">)</span> <span class="main">⟹</span> BRANCH <span class="free">c</span> <span class="free">rs</span> <span class="main">⊆</span> BRANCH <span class="free">c</span> <span class="free">rs'</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> BRANCH_def In1_mono Scons_mono Lim_mono<span class="main">)</span>

<span class="keyword1" id="Resumption-LINEAR_UN"><span class="command">lemma</span></span> LINEAR_UN<span class="main">:</span> <span class="quoted"><span class="quoted">"LINEAR <span class="free">b</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">x</span><span class="main">.</span> LINEAR <span class="free">b</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> LINEAR_def In1_UN1 In0_UN1 Scons_UN1_y<span class="main">)</span>

<span class="keyword1" id="Resumption-BRANCH_UN"><span class="command">lemma</span></span> BRANCH_UN<span class="main">:</span> <span class="quoted"><span class="quoted">"BRANCH <span class="free">b</span> <span class="main">(</span><span class="main">λ</span><span class="bound">d</span><span class="main">.</span> <span class="main">⋃</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">d</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">x</span><span class="main">.</span> BRANCH <span class="free">b</span> <span class="main">(</span><span class="main">λ</span><span class="bound">d</span><span class="main">.</span> <span class="free">f</span> <span class="bound">d</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> BRANCH_def Lim_UN1 In1_UN1 In0_UN1 Scons_UN1_y<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The codatatype universe›</span></span>

<span class="keyword1"><span class="command">coinductive_set</span></span> <span class="entity">resumption</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c</span> <span class="main">+</span> <span class="tfree">'b</span> <span class="main">+</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'d</span><span class="main">)</span> Old_Datatype.dtree set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
resumption_TERMINAL<span class="main">:</span>
  <span class="quoted"><span class="quoted">"TERMINAL <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">∈</span> <span class="free">resumption</span>"</span></span>
<span class="main">|</span> resumption_LINEAR<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">∈</span> <span class="free">resumption</span> <span class="main">⟹</span> LINEAR <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">∈</span> <span class="free">resumption</span>"</span></span>
<span class="main">|</span> resumption_BRANCH<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">d</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">rs</span></span></span> <span class="bound">d</span> <span class="main">∈</span> <span class="free">resumption</span><span class="main">)</span> <span class="main">⟹</span> BRANCH <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="free"><span class="bound"><span class="entity">rs</span></span></span> <span class="main">∈</span> <span class="free">resumption</span>"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Definition of the codatatype as a type›</span></span>

<span class="keyword1"><span class="command">typedef</span></span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">,</span><span class="tfree">'c</span><span class="main">,</span><span class="tfree">'d</span><span class="main">)</span> resumption <span class="main">=</span> <span class="quoted"><span class="quoted">"resumption <span class="main">::</span> <span class="main">(</span><span class="tfree">'c</span> <span class="main">+</span> <span class="tfree">'b</span> <span class="main">+</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'d</span><span class="main">)</span> Old_Datatype.dtree set"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"TERMINAL undefined <span class="main">∈</span> <span class="var">?resumption</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> resumption.intros<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Constructors›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Terminal</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">,</span><span class="tfree">'c</span><span class="main">,</span><span class="tfree">'d</span><span class="main">)</span> resumption"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">Terminal</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">=</span> Abs_resumption <span class="main">(</span>TERMINAL <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Linear</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">,</span><span class="tfree">'c</span><span class="main">,</span><span class="tfree">'d</span><span class="main">)</span> resumption <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">,</span><span class="tfree">'c</span><span class="main">,</span><span class="tfree">'d</span><span class="main">)</span> resumption"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">Linear</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">=</span> Abs_resumption <span class="main">(</span>LINEAR <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">(</span>Rep_resumption <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Branch</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'d</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">,</span><span class="tfree">'c</span><span class="main">,</span><span class="tfree">'d</span><span class="main">)</span> resumption<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">,</span><span class="tfree">'c</span><span class="main">,</span><span class="tfree">'d</span><span class="main">)</span> resumption"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">Branch</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="free"><span class="bound"><span class="entity">rs</span></span></span> <span class="main">=</span> Abs_resumption <span class="main">(</span>BRANCH <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="bound">d</span><span class="main">.</span> Rep_resumption <span class="main">(</span><span class="free"><span class="bound"><span class="entity">rs</span></span></span> <span class="bound">d</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> Terminal_not_Linear<span class="main">:</span> <span class="quoted"><span class="quoted">"Terminal <span class="free">a</span> <span class="main">≠</span> Linear <span class="free">b</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> Linear_not_Terminal<span class="main">:</span> <span class="quoted"><span class="quoted">"Linear <span class="free">b</span> <span class="free">R</span> <span class="main">≠</span> Terminal <span class="free">a</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> Termina_not_Branch<span class="main">:</span> <span class="quoted"><span class="quoted">"Terminal <span class="free">a</span> <span class="main">≠</span> Branch <span class="free">c</span> <span class="free">rs</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> Branch_not_Terminal<span class="main">:</span> <span class="quoted"><span class="quoted">"Branch <span class="free">c</span> <span class="free">rs</span> <span class="main">≠</span> Terminal <span class="free">a</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> Linear_not_Branch<span class="main">:</span> <span class="quoted"><span class="quoted">"Linear <span class="free">b</span> <span class="free">r</span> <span class="main">≠</span> Branch <span class="free">c</span> <span class="free">rs</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> Branch_not_Linear<span class="main">:</span> <span class="quoted"><span class="quoted">"Branch <span class="free">c</span> <span class="free">rs</span> <span class="main">≠</span> Linear <span class="free">b</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> Terminal_inject<span class="main">:</span> <span class="quoted"><span class="quoted">"Terminal <span class="free">a</span> <span class="main">=</span> Terminal <span class="free">a'</span> <span class="main">⟷</span> <span class="free">a</span> <span class="main">=</span> <span class="free">a'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> Linear_inject<span class="main">:</span> <span class="quoted"><span class="quoted">"Linear <span class="free">b</span> <span class="free">r</span> <span class="main">=</span> Linear <span class="free">b'</span> <span class="free">r'</span> <span class="main">⟷</span> <span class="free">b</span> <span class="main">=</span> <span class="free">b'</span> <span class="main">∧</span> <span class="free">r</span> <span class="main">=</span> <span class="free">r'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> Branch_inject<span class="main">:</span> <span class="quoted"><span class="quoted">"Branch <span class="free">c</span> <span class="free">rs</span> <span class="main">=</span> Branch <span class="free">c'</span> <span class="free">rs'</span> <span class="main">⟷</span> <span class="free">c</span> <span class="main">=</span> <span class="free">c'</span> <span class="main">∧</span> <span class="free">rs</span> <span class="main">=</span> <span class="free">rs'</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Terminal_def Linear_def Branch_def <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Rep_resumption resumption.intros Abs_resumption_inject Rep_resumption_inject<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> fun_eq_iff<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Rep_resumption_inject<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Resumption-Rep_resumption_constructors"><span class="command">lemma</span></span> Rep_resumption_constructors<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> Rep_resumption_Terminal<span class="main">:</span> <span class="quoted"><span class="quoted">"Rep_resumption <span class="main">(</span>Terminal <span class="free">a</span><span class="main">)</span> <span class="main">=</span> TERMINAL <span class="free">a</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> Rep_resumption_Linear<span class="main">:</span> <span class="quoted"><span class="quoted">"Rep_resumption <span class="main">(</span>Linear <span class="free">b</span> <span class="free">r</span><span class="main">)</span> <span class="main">=</span> LINEAR <span class="free">b</span> <span class="main">(</span>Rep_resumption <span class="free">r</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> Rep_resumption_Branch<span class="main">:</span> <span class="quoted"><span class="quoted">"Rep_resumption <span class="main">(</span>Branch <span class="free">c</span> <span class="free">rs</span><span class="main">)</span> <span class="main">=</span> BRANCH <span class="free">c</span> <span class="main">(</span><span class="main">λ</span><span class="bound">d</span><span class="main">.</span> Rep_resumption <span class="main">(</span><span class="free">rs</span> <span class="bound">d</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Terminal_def Linear_def Branch_def Abs_resumption_inverse resumption.intros Rep_resumption<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Case operator›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">case_resumption</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'e</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">,</span><span class="tfree">'c</span><span class="main">,</span><span class="tfree">'d</span><span class="main">)</span> resumption <span class="main">⇒</span> <span class="tfree">'e</span><span class="main">)</span> <span class="main">⇒</span>
                            <span class="main">(</span><span class="tfree">'c</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'d</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">,</span><span class="tfree">'c</span><span class="main">,</span><span class="tfree">'d</span><span class="main">)</span> resumption<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'e</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">,</span><span class="tfree">'c</span><span class="main">,</span><span class="tfree">'d</span><span class="main">)</span> resumption <span class="main">⇒</span> <span class="tfree">'e</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">case_resumption</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">br</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">=</span>
   case_RESUMPTION <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="bound">b</span> <span class="bound">r</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">b</span> <span class="main">(</span>Abs_resumption <span class="bound">r</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">c</span> <span class="bound">rs</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">br</span></span></span> <span class="bound">c</span> <span class="main">(</span><span class="main">λ</span><span class="bound">d</span><span class="main">.</span> Abs_resumption <span class="main">(</span><span class="bound">rs</span> <span class="bound">d</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Rep_resumption <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Resumption-case_resumption_simps"><span class="command">lemma</span></span> case_resumption_simps <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> case_resumption_Terminal<span class="main">:</span> <span class="quoted"><span class="quoted">"case_resumption <span class="free">t</span> <span class="free">l</span> <span class="free">br</span> <span class="main">(</span>Terminal <span class="free">a</span><span class="main">)</span> <span class="main">=</span> <span class="free">t</span> <span class="free">a</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> case_resumption_Linear<span class="main">:</span> <span class="quoted"><span class="quoted">"case_resumption <span class="free">t</span> <span class="free">l</span> <span class="free">br</span> <span class="main">(</span>Linear <span class="free">b</span> <span class="free">r</span><span class="main">)</span> <span class="main">=</span> <span class="free">l</span> <span class="free">b</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> case_resumption_Branch<span class="main">:</span> <span class="quoted"><span class="quoted">"case_resumption <span class="free">t</span> <span class="free">l</span> <span class="free">br</span> <span class="main">(</span>Branch <span class="free">c</span> <span class="free">rs</span><span class="main">)</span> <span class="main">=</span> <span class="free">br</span> <span class="free">c</span> <span class="free">rs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Terminal_def Linear_def Branch_def case_resumption_def Abs_resumption_inverse resumption.intros Rep_resumption Rep_resumption_inverse<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">case_translation</span> <span class="quoted">case_resumption</span> <span class="quoted">Terminal</span> <span class="quoted">Linear</span> <span class="quoted">Branch</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Resumption-case_resumption_cert"><span class="command">lemma</span></span> case_resumption_cert<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">CASE</span> <span class="main">≡</span> case_resumption <span class="free">t</span> <span class="free">l</span> <span class="free">br</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">CASE</span> <span class="main">(</span>Terminal <span class="free">a</span><span class="main">)</span> <span class="main">≡</span> <span class="free">t</span> <span class="free">a</span><span class="main">)</span> <span class="main">&amp;&amp;&amp;</span> <span class="main">(</span><span class="free">CASE</span> <span class="main">(</span>Linear <span class="free">b</span> <span class="free">r</span><span class="main">)</span> <span class="main">≡</span> <span class="free">l</span> <span class="free">b</span> <span class="free">r</span><span class="main">)</span> <span class="main">&amp;&amp;&amp;</span> <span class="main">(</span><span class="free">CASE</span> <span class="main">(</span>Branch <span class="free">c</span> <span class="free">rs</span><span class="main">)</span> <span class="main">≡</span> <span class="free">br</span> <span class="free">c</span> <span class="free">rs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">code_datatype</span></span> <span class="quoted">Terminal</span> <span class="quoted">Linear</span> <span class="quoted">Branch</span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">Code.declare_case_global</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> case_resumption_cert<span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹
  <span class="entity">Nitpick.register_codatatype</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">,</span><span class="tfree">'c</span><span class="main">,</span><span class="tfree">'d</span><span class="main">)</span> resumption"</span><span class="antiquote">}</span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> case_resumption<span class="antiquote">}</span></span>
                              <span class="main">(</span>map dest_Const <span class="main">[</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">Terminal</span><span class="antiquote">}</span></span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">Linear</span><span class="antiquote">}</span></span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">Branch</span><span class="antiquote">}</span></span><span class="main">]</span><span class="main">)</span>
›</span>

<span class="keyword1" id="Resumption-resumption_exhaust"><span class="command">lemma</span></span> resumption_exhaust <span class="main">[</span><span class="operator">cases</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">type</span></span></span><span class="main"><span class="main"><span class="main"><span class="main">:</span></span></span></span> resumption<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="main">(</span>Terminal<span class="main">)</span> <span class="free">a</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> Terminal <span class="free">a</span>"</span></span>
  <span class="main">|</span> <span class="main">(</span>Linear<span class="main">)</span> <span class="free">b</span> <span class="free">r</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> Linear <span class="free">b</span> <span class="free">r</span>"</span></span>
  <span class="main">|</span> <span class="main">(</span>Branch<span class="main">)</span> <span class="free">c</span> <span class="free">rs</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> Branch <span class="free">c</span> <span class="free">rs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Abs_resumption <span class="skolem">y</span><span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> <span class="quoted"><span class="quoted">‹<span class="free">x</span> <span class="main">=</span> Abs_resumption <span class="skolem">y</span>›</span></span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> resumption›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="free">thesis</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> resumption.cases<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> resumption_TERMINAL <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span><span class="main">(</span><span class="operator">rule</span> Terminal<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Terminal_def<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>resumption_LINEAR <span class="skolem">r</span> <span class="skolem">b</span><span class="main">)</span> 
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">r</span> <span class="main">∈</span> resumption›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Rep_resumption <span class="main">(</span>Abs_resumption <span class="skolem">r</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">r</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_resumption_inverse<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">=</span> LINEAR <span class="skolem">b</span> <span class="main">(</span>Rep_resumption <span class="main">(</span>Abs_resumption <span class="skolem">r</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">=</span> LINEAR <span class="skolem">b</span> <span class="skolem">r</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span><span class="main">(</span><span class="operator">rule</span> Linear<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Linear_def<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>resumption_BRANCH <span class="skolem">rs</span> <span class="skolem">c</span><span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="main">⋀</span><span class="bound">d</span><span class="main">.</span> <span class="skolem">rs</span> <span class="bound">d</span> <span class="main">∈</span> resumption›</span></span>
    <span class="keyword1"><span class="command">have</span></span> eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">rs</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">d</span><span class="main">.</span> Rep_resumption <span class="main">(</span>Abs_resumption <span class="main">(</span><span class="skolem">rs</span> <span class="bound">d</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> Abs_resumption_inverse<span class="main">)</span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">=</span> BRANCH <span class="skolem">c</span> <span class="skolem">rs</span>›</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span><span class="main">(</span><span class="operator">rule</span> Branch<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Branch_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> eq<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Resumption-resumption_split"><span class="command">lemma</span></span> resumption_split<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span>case_resumption <span class="free">t</span> <span class="free">l</span> <span class="free">br</span> <span class="free">r</span><span class="main">)</span> <span class="main">⟷</span> 
  <span class="main">(</span><span class="main">∀</span><span class="bound">a</span><span class="main">.</span> <span class="free">r</span> <span class="main">=</span> Terminal <span class="bound">a</span> <span class="main">⟶</span> <span class="free">P</span> <span class="main">(</span><span class="free">t</span> <span class="bound">a</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
  <span class="main">(</span><span class="main">∀</span><span class="bound">b</span> <span class="bound">r'</span><span class="main">.</span> <span class="free">r</span> <span class="main">=</span> Linear <span class="bound">b</span> <span class="bound">r'</span> <span class="main">⟶</span> <span class="free">P</span> <span class="main">(</span><span class="free">l</span> <span class="bound">b</span> <span class="bound">r'</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
  <span class="main">(</span><span class="main">∀</span><span class="bound">c</span> <span class="bound">rs</span><span class="main">.</span> <span class="free">r</span> <span class="main">=</span> Branch <span class="bound">c</span> <span class="bound">rs</span> <span class="main">⟶</span> <span class="free">P</span> <span class="main">(</span><span class="free">br</span> <span class="bound">c</span> <span class="bound">rs</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">r</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Resumption-resumption_split_asm"><span class="command">lemma</span></span> resumption_split_asm<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span>case_resumption <span class="free">t</span> <span class="free">l</span> <span class="free">br</span> <span class="free">r</span><span class="main">)</span> <span class="main">⟷</span>
  <span class="main">¬</span> <span class="main">(</span><span class="main">(</span><span class="main">∃</span><span class="bound">a</span><span class="main">.</span> <span class="free">r</span> <span class="main">=</span> Terminal <span class="bound">a</span> <span class="main">∧</span> <span class="main">¬</span> <span class="free">P</span> <span class="main">(</span><span class="free">t</span> <span class="bound">a</span><span class="main">)</span><span class="main">)</span> <span class="main">∨</span>
     <span class="main">(</span><span class="main">∃</span><span class="bound">b</span> <span class="bound">r'</span><span class="main">.</span> <span class="free">r</span> <span class="main">=</span> Linear <span class="bound">b</span> <span class="bound">r'</span> <span class="main">∧</span> <span class="main">¬</span> <span class="free">P</span> <span class="main">(</span><span class="free">l</span> <span class="bound">b</span> <span class="bound">r'</span><span class="main">)</span><span class="main">)</span> <span class="main">∨</span>
     <span class="main">(</span><span class="main">∃</span><span class="bound">c</span> <span class="bound">rs</span><span class="main">.</span> <span class="free">r</span> <span class="main">=</span> Branch <span class="bound">c</span> <span class="bound">rs</span> <span class="main">∧</span> <span class="main">¬</span> <span class="free">P</span> <span class="main">(</span><span class="free">br</span> <span class="bound">c</span> <span class="bound">rs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">r</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemmas</span></span> resumption_splits <span class="main">=</span> resumption_split resumption_split_asm


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹corecursion operator›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="main">(</span>dead <span class="tfree">'a</span><span class="main">,</span> dead <span class="tfree">'b</span><span class="main">,</span> dead <span class="tfree">'c</span><span class="main">,</span> dead <span class="tfree">'d</span><span class="main">,</span> dead <span class="tfree">'e</span><span class="main">)</span> resumption_corec <span class="main">=</span>
    Terminal_corec <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span>
  <span class="main">|</span> Linear_corec <span class="tfree"><span class="quoted"><span class="tfree">'b</span></span></span> <span class="tfree"><span class="quoted"><span class="tfree">'e</span></span></span>
  <span class="main">|</span> Branch_corec <span class="tfree"><span class="quoted"><span class="tfree">'c</span></span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'d</span> <span class="main">⇒</span> <span class="tfree">'e</span>"</span></span>
  <span class="main">|</span> Resumption_corec <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'c</span><span class="main">,</span> <span class="tfree">'d</span><span class="main">)</span> resumption"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">RESUMPTION_corec_aux</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'e</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">,</span><span class="tfree">'c</span><span class="main">,</span><span class="tfree">'d</span><span class="main">,</span><span class="tfree">'e</span><span class="main">)</span> resumption_corec<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'e</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'c</span> <span class="main">+</span> <span class="tfree">'b</span> <span class="main">+</span> <span class="tfree">'a</span><span class="main">,</span><span class="tfree">'d</span><span class="main">)</span> Old_Datatype.dtree"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">RESUMPTION_corec_aux</span> <span class="main">0</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">RESUMPTION_corec_aux</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="keyword1">of</span> Terminal_corec <span class="bound">a</span> <span class="main">⇒</span> TERMINAL <span class="bound">a</span>
            <span class="main">|</span> Linear_corec <span class="bound">b</span> <span class="bound">e'</span> <span class="main">⇒</span> LINEAR <span class="bound">b</span> <span class="main">(</span><span class="free">RESUMPTION_corec_aux</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">e'</span><span class="main">)</span>
            <span class="main">|</span> Branch_corec <span class="bound">c</span> <span class="bound">es</span> <span class="main">⇒</span> BRANCH <span class="bound">c</span> <span class="main">(</span><span class="main">λ</span><span class="bound">d</span><span class="main">.</span> <span class="free">RESUMPTION_corec_aux</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="bound">es</span> <span class="bound">d</span><span class="main">)</span><span class="main">)</span>
            <span class="main">|</span> Resumption_corec <span class="bound">r</span> <span class="main">⇒</span> Rep_resumption <span class="bound">r</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">RESUMPTION_corec</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'e</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">,</span><span class="tfree">'c</span><span class="main">,</span><span class="tfree">'d</span><span class="main">,</span><span class="tfree">'e</span><span class="main">)</span> resumption_corec<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'e</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'c</span> <span class="main">+</span> <span class="tfree">'b</span> <span class="main">+</span> <span class="tfree">'a</span><span class="main">,</span><span class="tfree">'d</span><span class="main">)</span> Old_Datatype.dtree"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">RESUMPTION_corec</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">n</span><span class="main">.</span> RESUMPTION_corec_aux <span class="bound">n</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Resumption-RESUMPTION_corec"><span class="command">lemma</span></span> RESUMPTION_corec <span class="main">[</span><span class="operator">nitpick_simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"RESUMPTION_corec <span class="free">f</span> <span class="free">e</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> <span class="free">f</span> <span class="free">e</span> <span class="keyword1">of</span> Terminal_corec <span class="bound">a</span> <span class="main">⇒</span> TERMINAL <span class="bound">a</span>
            <span class="main">|</span> Linear_corec <span class="bound">b</span> <span class="bound">e'</span> <span class="main">⇒</span> LINEAR <span class="bound">b</span> <span class="main">(</span>RESUMPTION_corec <span class="free">f</span> <span class="bound">e'</span><span class="main">)</span>
            <span class="main">|</span> Branch_corec <span class="bound">c</span> <span class="bound">es</span> <span class="main">⇒</span> BRANCH <span class="bound">c</span> <span class="main">(</span><span class="main">λ</span><span class="bound">d</span><span class="main">.</span> RESUMPTION_corec <span class="free">f</span> <span class="main">(</span><span class="bound">es</span> <span class="bound">d</span><span class="main">)</span><span class="main">)</span>
            <span class="main">|</span> Resumption_corec <span class="bound">r</span> <span class="main">⇒</span> Rep_resumption <span class="bound">r</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⊆</span> <span class="var">?rhs</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> RESUMPTION_corec_def
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> UN_least<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">n</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"RESUMPTION_corec_aux <span class="skolem">n</span> <span class="free">f</span> <span class="free">e</span>
        <span class="main">⊆</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">f</span> <span class="free">e</span> <span class="keyword1">of</span> Terminal_corec <span class="bound">a</span> <span class="main">⇒</span> TERMINAL <span class="bound">a</span>
           <span class="main">|</span> Linear_corec <span class="bound">b</span> <span class="bound">e'</span> <span class="main">⇒</span> LINEAR <span class="bound">b</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">n</span><span class="main">.</span> RESUMPTION_corec_aux <span class="bound">n</span> <span class="free">f</span> <span class="bound">e'</span><span class="main">)</span>
           <span class="main">|</span> Branch_corec <span class="bound">c</span> <span class="bound">es</span> <span class="main">⇒</span> BRANCH <span class="bound">c</span> <span class="main">(</span><span class="main">λ</span><span class="bound">d</span><span class="main">.</span> <span class="main">⋃</span><span class="bound">n</span><span class="main">.</span> RESUMPTION_corec_aux <span class="bound">n</span> <span class="free">f</span> <span class="main">(</span><span class="bound">es</span> <span class="bound">d</span><span class="main">)</span><span class="main">)</span>
           <span class="main">|</span> Resumption_corec <span class="bound">r</span> <span class="main">⇒</span> Rep_resumption <span class="bound">r</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">n</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> resumption_corec.split<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> conjI strip LINEAR_mono<span class="main"><span class="main">[</span></span><span class="operator">OF</span> UN_upper<span class="main"><span class="main">]</span></span> BRANCH_mono<span class="main"><span class="main">[</span></span><span class="operator">OF</span> UN_upper<span class="main"><span class="main">]</span></span> UNIV_I<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rhs</span> <span class="main">⊆</span> <span class="var">?lhs</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> RESUMPTION_corec_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> resumption_corec.split <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> LINEAR_UN BRANCH_UN<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">safe</span><span class="main">(</span><span class="operator">rule_tac</span> a<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"Suc <span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem">n</span></span></span></span>"</span></span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">for</span></span></span> <span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem">n</span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> UN_I<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> UNIV_I<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Resumption-RESUMPTION_corec_type"><span class="command">lemma</span></span> RESUMPTION_corec_type<span class="main">:</span> <span class="quoted"><span class="quoted">"RESUMPTION_corec <span class="free">f</span> <span class="free">e</span> <span class="main">∈</span> resumption"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span><span class="main">.</span> RESUMPTION_corec <span class="free">f</span> <span class="free">e</span> <span class="main">=</span> RESUMPTION_corec <span class="free">f</span> <span class="bound">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">coinduct</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>resumption <span class="skolem">x</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">e</span></span> <span class="keyword2"><span class="keyword">where</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> RESUMPTION_corec <span class="free">f</span> <span class="skolem">e</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> 
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="skolem">e</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Resumption_corec <span class="skolem">r</span><span class="main">)</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> x
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">r</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RESUMPTION_corec Rep_resumption_constructors Rep_resumption<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RESUMPTION_corec<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹corecursion operator for the resumption type›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">resumption_corec</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'e</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">,</span><span class="tfree">'c</span><span class="main">,</span><span class="tfree">'d</span><span class="main">,</span><span class="tfree">'e</span><span class="main">)</span> resumption_corec<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'e</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">,</span><span class="tfree">'c</span><span class="main">,</span><span class="tfree">'d</span><span class="main">)</span> resumption"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">resumption_corec</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">=</span> Abs_resumption <span class="main">(</span>RESUMPTION_corec <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Resumption-resumption_corec"><span class="command">lemma</span></span> resumption_corec<span class="main">:</span>
  <span class="quoted"><span class="quoted">"resumption_corec <span class="free">f</span> <span class="free">e</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> <span class="free">f</span> <span class="free">e</span> <span class="keyword1">of</span> Terminal_corec <span class="bound">a</span> <span class="main">⇒</span> Terminal <span class="bound">a</span>
            <span class="main">|</span> Linear_corec <span class="bound">b</span> <span class="bound">e'</span> <span class="main">⇒</span> Linear <span class="bound">b</span> <span class="main">(</span>resumption_corec <span class="free">f</span> <span class="bound">e'</span><span class="main">)</span>
            <span class="main">|</span> Branch_corec <span class="bound">c</span> <span class="bound">es</span> <span class="main">⇒</span> Branch <span class="bound">c</span> <span class="main">(</span><span class="main">λ</span><span class="bound">d</span><span class="main">.</span> resumption_corec <span class="free">f</span> <span class="main">(</span><span class="bound">es</span> <span class="bound">d</span><span class="main">)</span><span class="main">)</span>
            <span class="main">|</span> Resumption_corec <span class="bound">r</span> <span class="main">⇒</span> <span class="bound">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> resumption_corec_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> RESUMPTION_corec<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> resumption_corec.splits <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Terminal_def Linear_def Branch_def RESUMPTION_corec_type Abs_resumption_inverse Rep_resumption_inverse<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Equality as greatest fixpoint›</span></span>

<span class="keyword1"><span class="command">coinductive</span></span> <span class="entity">Eq_RESUMPTION</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c</span><span class="main">+</span><span class="tfree">'b</span><span class="main">+</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'d</span><span class="main">)</span> Old_Datatype.dtree <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'c</span><span class="main">+</span><span class="tfree">'b</span><span class="main">+</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'d</span><span class="main">)</span> Old_Datatype.dtree <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  EqTERMINAL<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Eq_RESUMPTION</span> <span class="main">(</span>TERMINAL <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="main">(</span>TERMINAL <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> EqLINEAR<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Eq_RESUMPTION</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">r'</span></span></span> <span class="main">⟹</span> <span class="free">Eq_RESUMPTION</span> <span class="main">(</span>LINEAR <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">(</span>LINEAR <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="free"><span class="bound"><span class="entity">r'</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> EqBRANCH<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">d</span><span class="main">.</span> <span class="free">Eq_RESUMPTION</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">rs</span></span></span> <span class="bound">d</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">rs'</span></span></span> <span class="bound">d</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">Eq_RESUMPTION</span> <span class="main">(</span>BRANCH <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="free"><span class="bound"><span class="entity">rs</span></span></span><span class="main">)</span> <span class="main">(</span>BRANCH <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="free"><span class="bound"><span class="entity">rs'</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Resumption-Eq_RESUMPTION_implies_ntrunc_equality"><span class="command">lemma</span></span> Eq_RESUMPTION_implies_ntrunc_equality<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Eq_RESUMPTION <span class="free">r</span> <span class="free">r'</span> <span class="main">⟹</span> ntrunc <span class="free">k</span> <span class="free">r</span> <span class="main">=</span> ntrunc <span class="free">k</span> <span class="free">r'</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">k</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">r</span></span> <span class="quoted"><span class="free">r'</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> less_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>less <span class="skolem">k</span><span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> IH <span class="main">=</span> <span class="quoted"><span class="quoted">‹<span class="main">⋀</span><span class="bound">k'</span> <span class="bound">r</span> <span class="bound">r'</span><span class="main">.</span> <span class="main">⟦</span><span class="bound">k'</span> <span class="main">&lt;</span> <span class="skolem">k</span><span class="main">;</span> Eq_RESUMPTION <span class="bound">r</span> <span class="bound">r'</span><span class="main">⟧</span> <span class="main">⟹</span> ntrunc <span class="bound">k'</span> <span class="bound">r</span> <span class="main">=</span> ntrunc <span class="bound">k'</span> <span class="bound">r'</span>›</span></span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹Eq_RESUMPTION <span class="skolem">r</span> <span class="skolem">r'</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
    <span class="keyword3"><span class="command">case</span></span> EqTERMINAL
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>EqLINEAR <span class="skolem">R</span> <span class="skolem">R'</span> <span class="skolem">b</span><span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> LINEAR_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">k</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rename_tac</span> k'<span class="main"><span class="keyword3">,</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="improper">k'</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rename_tac</span> k''<span class="main"><span class="keyword3">,</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="improper">k''</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> IH<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>EqBRANCH <span class="skolem">rs</span> <span class="skolem">rs'</span> <span class="skolem">c</span><span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> BRANCH_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">k</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rename_tac</span> k'<span class="main"><span class="keyword3">,</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="improper">k'</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rename_tac</span> k''<span class="main"><span class="keyword3">,</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="improper">k''</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rename_tac</span> k'''<span class="main"><span class="keyword3">,</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="improper">k'''</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> arg_cong<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">Old_Datatype.Lim</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> IH<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Resumption-Eq_RESUMPTION_refl"><span class="command">lemma</span></span> Eq_RESUMPTION_refl<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∈</span> resumption"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Eq_RESUMPTION <span class="free">r</span> <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">r'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">r'</span> <span class="main">=</span> <span class="free">r</span>"</span></span>
  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">=</span> <span class="skolem">r'</span> <span class="main">∧</span> <span class="free">r</span> <span class="main">∈</span> resumption"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"Eq_RESUMPTION <span class="free">r</span> <span class="skolem">r'</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduct</span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Eq_RESUMPTION <span class="skolem">r</span> <span class="skolem">r'</span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span> <span class="main">=</span> <span class="skolem">r'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span> <span class="main">∈</span> resumption"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">r</span> <span class="main">∈</span> resumption›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> resumption.cases<span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Resumption-Eq_RESUMPTION_into_resumption"><span class="command">lemma</span></span> Eq_RESUMPTION_into_resumption<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Eq_RESUMPTION <span class="free">r</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∈</span> resumption"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduct</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> resumption <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">cases</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Resumption-Eq_RESUMPTION_eq"><span class="command">lemma</span></span> Eq_RESUMPTION_eq<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Eq_RESUMPTION <span class="free">r</span> <span class="free">r'</span> <span class="main">⟷</span> <span class="free">r</span> <span class="main">=</span> <span class="free">r'</span> <span class="main">∧</span> <span class="free">r</span> <span class="main">∈</span> resumption"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> iffI<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"Eq_RESUMPTION <span class="free">r</span> <span class="free">r'</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">k</span><span class="main">.</span> ntrunc <span class="bound">k</span> <span class="free">r</span> <span class="main">=</span> ntrunc <span class="bound">k</span> <span class="free">r'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> Eq_RESUMPTION_implies_ntrunc_equality<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">=</span> <span class="free">r'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> ntrunc_equality<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">with</span></span></span> <span class="quoted"><span class="quoted">‹Eq_RESUMPTION <span class="free">r</span> <span class="free">r'</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∈</span> resumption"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> Eq_RESUMPTION_into_resumption<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">=</span> <span class="free">r'</span> <span class="main">∧</span> <span class="free">r</span> <span class="main">∈</span> resumption"</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">=</span> <span class="free">r'</span> <span class="main">∧</span> <span class="free">r</span> <span class="main">∈</span> resumption"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"Eq_RESUMPTION <span class="free">r</span> <span class="free">r'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> Eq_RESUMPTION_refl<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Resumption-Eq_RESUMPTION_I"><span class="command">lemma</span></span> Eq_RESUMPTION_I <span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> Eq_RESUMPTION<span class="main">,</span> <span class="operator">case_conclusion</span> Eq_RESUMPTION EqTerminal EqLinear EqBranch<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="free">r</span> <span class="free">r'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> step<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">r</span> <span class="bound">r'</span><span class="main">.</span> <span class="free">X</span> <span class="bound">r</span> <span class="bound">r'</span> <span class="main">⟹</span>
             <span class="main">(</span><span class="main">∃</span><span class="bound">a</span><span class="main">.</span> <span class="bound">r</span> <span class="main">=</span> TERMINAL <span class="bound">a</span> <span class="main">∧</span> <span class="bound">r'</span> <span class="main">=</span> TERMINAL <span class="bound">a</span><span class="main">)</span> <span class="main">∨</span>
             <span class="main">(</span><span class="main">∃</span><span class="bound">R</span> <span class="bound">R'</span> <span class="bound">b</span><span class="main">.</span> <span class="bound">r</span> <span class="main">=</span> LINEAR <span class="bound">b</span> <span class="bound">R</span> <span class="main">∧</span> <span class="bound">r'</span> <span class="main">=</span> LINEAR <span class="bound">b</span> <span class="bound">R'</span> <span class="main">∧</span> <span class="main">(</span><span class="free">X</span> <span class="bound">R</span> <span class="bound">R'</span> <span class="main">∨</span> Eq_RESUMPTION <span class="bound">R</span> <span class="bound">R'</span><span class="main">)</span><span class="main">)</span> <span class="main">∨</span>
             <span class="main">(</span><span class="main">∃</span><span class="bound">rs</span> <span class="bound">rs'</span> <span class="bound">c</span><span class="main">.</span> <span class="bound">r</span> <span class="main">=</span> BRANCH <span class="bound">c</span> <span class="bound">rs</span> <span class="main">∧</span> <span class="bound">r'</span> <span class="main">=</span> BRANCH <span class="bound">c</span> <span class="bound">rs'</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">d</span><span class="main">.</span> <span class="free">X</span> <span class="main">(</span><span class="bound">rs</span> <span class="bound">d</span><span class="main">)</span> <span class="main">(</span><span class="bound">rs'</span> <span class="bound">d</span><span class="main">)</span> <span class="main">∨</span> Eq_RESUMPTION <span class="main">(</span><span class="bound">rs</span> <span class="bound">d</span><span class="main">)</span> <span class="main">(</span><span class="bound">rs'</span> <span class="bound">d</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">=</span> <span class="free">r'</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="free">X</span> <span class="free">r</span> <span class="free">r'</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Eq_RESUMPTION <span class="free">r</span> <span class="free">r'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduct</span><span class="main">)</span><span class="main">(</span><span class="operator">rule</span> step<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Eq_RESUMPTION_eq<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Resumption-resumption_equalityI"><span class="command">lemma</span></span> resumption_equalityI <span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> Eq_resumption<span class="main">,</span> <span class="operator">case_conclusion</span> Eq_resumption EqTerminal EqLinear EqBranch<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="free">r</span> <span class="free">r'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> step<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">r</span> <span class="bound">r'</span><span class="main">.</span> <span class="free">X</span> <span class="bound">r</span> <span class="bound">r'</span> <span class="main">⟹</span>
             <span class="main">(</span><span class="main">∃</span><span class="bound">a</span><span class="main">.</span> <span class="bound">r</span> <span class="main">=</span> Terminal <span class="bound">a</span> <span class="main">∧</span> <span class="bound">r'</span> <span class="main">=</span> Terminal <span class="bound">a</span><span class="main">)</span> <span class="main">∨</span>
             <span class="main">(</span><span class="main">∃</span><span class="bound">R</span> <span class="bound">R'</span> <span class="bound">b</span><span class="main">.</span> <span class="bound">r</span> <span class="main">=</span> Linear <span class="bound">b</span> <span class="bound">R</span> <span class="main">∧</span> <span class="bound">r'</span> <span class="main">=</span> Linear <span class="bound">b</span> <span class="bound">R'</span> <span class="main">∧</span> <span class="main">(</span><span class="free">X</span> <span class="bound">R</span> <span class="bound">R'</span> <span class="main">∨</span> <span class="bound">R</span> <span class="main">=</span> <span class="bound">R'</span><span class="main">)</span><span class="main">)</span> <span class="main">∨</span>
             <span class="main">(</span><span class="main">∃</span><span class="bound">rs</span> <span class="bound">rs'</span> <span class="bound">c</span><span class="main">.</span> <span class="bound">r</span> <span class="main">=</span> Branch <span class="bound">c</span> <span class="bound">rs</span> <span class="main">∧</span> <span class="bound">r'</span> <span class="main">=</span> Branch <span class="bound">c</span> <span class="bound">rs'</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">d</span><span class="main">.</span> <span class="free">X</span> <span class="main">(</span><span class="bound">rs</span> <span class="bound">d</span><span class="main">)</span> <span class="main">(</span><span class="bound">rs'</span> <span class="bound">d</span><span class="main">)</span> <span class="main">∨</span> <span class="bound">rs</span> <span class="bound">d</span> <span class="main">=</span> <span class="bound">rs'</span> <span class="bound">d</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">=</span> <span class="free">r'</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">M</span></span> <span class="skolem"><span class="skolem">N</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">M</span> <span class="main">=</span> Rep_resumption <span class="free">r</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">N</span> <span class="main">=</span> Rep_resumption <span class="free">r'</span>"</span></span>
  <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="free">X</span> <span class="free">r</span> <span class="free">r'</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">r</span> <span class="bound">r'</span><span class="main">.</span> <span class="skolem">M</span> <span class="main">=</span> Rep_resumption <span class="bound">r</span> <span class="main">∧</span> <span class="skolem">N</span> <span class="main">=</span> Rep_resumption <span class="bound">r'</span> <span class="main">∧</span> <span class="free">X</span> <span class="bound">r</span> <span class="bound">r'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">M</span> <span class="main">=</span> <span class="skolem">N</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> Eq_RESUMPTION_I<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Eq_RESUMPTION <span class="skolem">M</span> <span class="skolem">N</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">r</span></span> <span class="skolem"><span class="skolem">r'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">M</span> <span class="main">=</span> Rep_resumption <span class="skolem">r</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">N</span> <span class="main">=</span> Rep_resumption <span class="skolem">r'</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="skolem">r</span> <span class="skolem">r'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">a</span><span class="main">.</span> <span class="skolem">r</span> <span class="main">=</span> Terminal <span class="bound">a</span> <span class="main">∧</span> <span class="skolem">r'</span> <span class="main">=</span> Terminal <span class="bound">a</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="var"><span class="quoted"><span class="var">?EqTerminal</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Rep_resumption_constructors<span class="main">)</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">..</span></span> <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">R</span> <span class="bound">R'</span> <span class="bound">b</span><span class="main">.</span> <span class="skolem">r</span> <span class="main">=</span> Linear <span class="bound">b</span> <span class="bound">R</span> <span class="main">∧</span> <span class="skolem">r'</span> <span class="main">=</span> Linear <span class="bound">b</span> <span class="bound">R'</span> <span class="main">∧</span> <span class="main">(</span><span class="free">X</span> <span class="bound">R</span> <span class="bound">R'</span> <span class="main">∨</span> <span class="bound">R</span> <span class="main">=</span> <span class="bound">R'</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="var"><span class="quoted"><span class="var">?EqLinear</span></span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Rep_resumption_constructors Eq_RESUMPTION_eq Rep_resumption_inject Rep_resumption<span class="main">)</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">rs</span> <span class="bound">rs'</span> <span class="bound">c</span><span class="main">.</span> <span class="skolem">r</span> <span class="main">=</span> Branch <span class="bound">c</span> <span class="bound">rs</span> <span class="main">∧</span> <span class="skolem">r'</span> <span class="main">=</span> Branch <span class="bound">c</span> <span class="bound">rs'</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">d</span><span class="main">.</span> <span class="free">X</span> <span class="main">(</span><span class="bound">rs</span> <span class="bound">d</span><span class="main">)</span> <span class="main">(</span><span class="bound">rs'</span> <span class="bound">d</span><span class="main">)</span> <span class="main">∨</span> <span class="bound">rs</span> <span class="bound">d</span> <span class="main">=</span> <span class="bound">rs'</span> <span class="bound">d</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="var"><span class="quoted"><span class="var">?EqBranch</span></span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Rep_resumption_constructors Eq_RESUMPTION_eq Rep_resumption_inject Rep_resumption<span class="main">)</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> step<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="free">X</span> <span class="skolem">r</span> <span class="skolem">r'</span>›</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> M_def N_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Rep_resumption_inject<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Finality of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>resumption›</span></span></span></span>: Uniqueness of functions defined by corecursion.
›</span></span>

<span class="keyword1" id="Resumption-equals_RESUMPTION_corec"><span class="command">lemma</span></span> equals_RESUMPTION_corec<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> h<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">h</span> <span class="bound">x</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">f</span> <span class="bound">x</span> <span class="keyword1">of</span> Terminal_corec <span class="bound">a</span> <span class="main">⇒</span> TERMINAL <span class="bound">a</span>
                                   <span class="main">|</span> Linear_corec <span class="bound">b</span> <span class="bound">x'</span> <span class="main">⇒</span> LINEAR <span class="bound">b</span> <span class="main">(</span><span class="free">h</span> <span class="bound">x'</span><span class="main">)</span>
                                   <span class="main">|</span> Branch_corec <span class="bound">c</span> <span class="bound">xs</span> <span class="main">⇒</span> BRANCH <span class="bound">c</span> <span class="main">(</span><span class="main">λ</span><span class="bound">d</span><span class="main">.</span> <span class="free">h</span> <span class="main">(</span><span class="bound">xs</span> <span class="bound">d</span><span class="main">)</span><span class="main">)</span>
                                   <span class="main">|</span> Resumption_corec <span class="bound">r</span> <span class="main">⇒</span> Rep_resumption <span class="bound">r</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">=</span> RESUMPTION_corec <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">h'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">h'</span> <span class="main">=</span> RESUMPTION_corec <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> h'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">h'</span> <span class="bound">x</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">f</span> <span class="bound">x</span> <span class="keyword1">of</span> Terminal_corec <span class="bound">a</span> <span class="main">⇒</span> TERMINAL <span class="bound">a</span>
                                   <span class="main">|</span> Linear_corec <span class="bound">b</span> <span class="bound">x'</span> <span class="main">⇒</span> LINEAR <span class="bound">b</span> <span class="main">(</span><span class="skolem">h'</span> <span class="bound">x'</span><span class="main">)</span>
                                   <span class="main">|</span> Branch_corec <span class="bound">c</span> <span class="bound">xs</span> <span class="main">⇒</span> BRANCH <span class="bound">c</span> <span class="main">(</span><span class="main">λ</span><span class="bound">d</span><span class="main">.</span> <span class="skolem">h'</span> <span class="main">(</span><span class="bound">xs</span> <span class="bound">d</span><span class="main">)</span><span class="main">)</span>
                                   <span class="main">|</span> Resumption_corec <span class="bound">r</span> <span class="main">⇒</span> Rep_resumption <span class="bound">r</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> h'_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RESUMPTION_corec<span class="main">)</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">M</span></span> <span class="skolem"><span class="skolem">N</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">M</span> <span class="main">=</span> <span class="free">h</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">N</span> <span class="main">=</span> <span class="skolem">h'</span> <span class="skolem">x</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">M</span> <span class="main">=</span> <span class="free">h</span> <span class="bound">x</span> <span class="main">∧</span> <span class="skolem">N</span> <span class="main">=</span> <span class="skolem">h'</span> <span class="bound">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">M</span> <span class="main">=</span> <span class="skolem">N</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> Eq_RESUMPTION_I<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Eq_RESUMPTION <span class="skolem">M</span> <span class="skolem">N</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">M</span> <span class="main">=</span> <span class="free">h</span> <span class="skolem">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">N</span> <span class="main">=</span> <span class="skolem">h'</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="skolem">x</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Terminal_corec <span class="skolem">a</span><span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> h h' <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?EqTerminal</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Linear_corec <span class="skolem">b</span> <span class="skolem">x'</span><span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> h h' <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?EqLinear</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Branch_corec <span class="skolem">c</span> <span class="skolem">xs</span><span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> h h' <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?EqBranch</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Resumption_corec <span class="skolem">r</span><span class="main">)</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">r</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> h h' Rep_resumption_constructors Eq_RESUMPTION_refl Rep_resumption<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Resumption-equals_resumption_corec"><span class="command">lemma</span></span> equals_resumption_corec<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> h<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">h</span> <span class="bound">x</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">f</span> <span class="bound">x</span> <span class="keyword1">of</span> Terminal_corec <span class="bound">a</span> <span class="main">⇒</span> Terminal <span class="bound">a</span>
                                   <span class="main">|</span> Linear_corec <span class="bound">b</span> <span class="bound">x'</span> <span class="main">⇒</span> Linear <span class="bound">b</span> <span class="main">(</span><span class="free">h</span> <span class="bound">x'</span><span class="main">)</span>
                                   <span class="main">|</span> Branch_corec <span class="bound">c</span> <span class="bound">xs</span> <span class="main">⇒</span> Branch <span class="bound">c</span> <span class="main">(</span><span class="main">λ</span><span class="bound">d</span><span class="main">.</span> <span class="free">h</span> <span class="main">(</span><span class="bound">xs</span> <span class="bound">d</span><span class="main">)</span><span class="main">)</span>
                                   <span class="main">|</span> Resumption_corec <span class="bound">r</span> <span class="main">⇒</span> <span class="bound">r</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">=</span> resumption_corec <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
    <span class="keyword1"><span class="command">from</span></span> h<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Rep_resumption <span class="main">(</span><span class="free">h</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">=</span>
      <span class="main">(</span><span class="keyword1">case</span> <span class="free">f</span> <span class="skolem">x</span> <span class="keyword1">of</span> Terminal_corec <span class="bound">a</span> <span class="main">⇒</span> TERMINAL <span class="bound">a</span>
                <span class="main">|</span> Linear_corec <span class="bound">b</span> <span class="bound">x'</span> <span class="main">⇒</span> LINEAR <span class="bound">b</span> <span class="main">(</span>Rep_resumption <span class="main">(</span><span class="free">h</span> <span class="bound">x'</span><span class="main">)</span><span class="main">)</span>
                <span class="main">|</span> Branch_corec <span class="bound">c</span> <span class="bound">xs</span> <span class="main">⇒</span> BRANCH <span class="bound">c</span> <span class="main">(</span><span class="main">λ</span><span class="bound">d</span><span class="main">.</span> Rep_resumption <span class="main">(</span><span class="free">h</span> <span class="main">(</span><span class="bound">xs</span> <span class="bound">d</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                <span class="main">|</span> Resumption_corec <span class="bound">r</span> <span class="main">⇒</span> Rep_resumption <span class="bound">r</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> resumption_corec.split <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Rep_resumption_constructors<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">hence</span></span> eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> Rep_resumption <span class="main">(</span><span class="free">h</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> RESUMPTION_corec <span class="free">f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> equals_RESUMPTION_corec<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"Abs_resumption <span class="main">(</span>Rep_resumption <span class="main">(</span><span class="free">h</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Abs_resumption <span class="main">(</span>RESUMPTION_corec <span class="free">f</span> <span class="skolem">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> fun_eq_iff<span class="main">)</span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="skolem">x</span> <span class="main">=</span> resumption_corec <span class="free">f</span> <span class="skolem">x</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> resumption_corec_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Rep_resumption_inverse<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Coinductive_Examples">
<div class="head">
<h1>Theory Coinductive_Examples</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Coinductive_Examples.thy
    Author:     Andreas Lochbihler, ETH Zurich
*)</span>

<span class="keyword1"><span class="command">theory</span></span> Coinductive_Examples <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="#LList_CCPO_Topology">LList_CCPO_Topology</a>
  <a href="#TLList_CCPO_Examples">TLList_CCPO_Examples</a>
  <a href="#Koenigslemma">Koenigslemma</a>
  <a href="#LMirror">LMirror</a>
  <a href="#Hamming_Stream">Hamming_Stream</a>
  <a href="#Resumption">Resumption</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div>